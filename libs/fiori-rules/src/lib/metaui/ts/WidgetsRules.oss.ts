/**
 *  This is generated file. Do not edit !!
 *
 *  @formatter:off
 *
 */
/* tslint:disable */
export const WidgetsRulesRule = ' /**  * @license  * Copyright 2017 SAP Ariba  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  * Based on original work: MetaUI: Craig Federighi (2008)  *  */  field {     type  {        component:StringComponent;         bindings:{           value:$value;           id: ${properties.get("field")};           placeholder:${properties.get("label")};         };     }      type=(boolean, Boolean) {         editable {             component:CheckboxComponent;             bindings:{               ngModel: $value;               isBinary:true;               value:"Yes/No";             };         }          editable=false {            bindings:{               isBinary:true;               value: ${value ? "Yes" : "No"};            };         }     }      type=(Number) {         editable {           component:InputComponent;           canSetType:true;           bindings:{              ngModel: $value;           };         }     }      type=Date   {         editable {           component:DatePickerComponent;             bindings:{               ngModel:$value;           };         }          editable=false {             component:DatePickerComponent;               bindings:{                 value:$value;                 editable:false;                 placeholder:"MM/dd/yyyy";             };          }         fiveZoneLayout = true {}     }      type=(Array, Set) {         editable {            trait:asSelect;            bindings:{               noSelectionString:${properties.get("noSelectionString")};            };         }     }      type=(String, string) {         editable  {             component:InputComponent;             bindings:{                ngModel: $value;             };         }         @trait=longtext {             after:zBottom;             editable {               component:TextAreaComponent;             }             operation=(search, list)  { visible:false; }         }         trait=truncated { component:TruncateString; bindings:{size:10;}; }     }      type="Money" {         component: MoneyComponent;         bindings:{             ngModel:$value;             currencies:${properties.get("currencies")};         };     }      @trait=derived {         editable:false;         editing { after:zNone; }     }      @trait=required {         operation=(edit, create) {             required:true;             object {                 valid: ${( value == null || value.length  == 0) ? "Required field": true};             }         }     }      @trait=fluid {         fluid:true;     }      @trait=asSelect {         editable {             component:SelectComponent;             bindings:{                 ngModel:$value;                 required:${properties.get("required")};                 lookupKey:${properties.get("lookupKey")};                 displayKey:${ meta.displayLabel(type, properties.get("labelField"), true )};                 list:${properties.get("choices")};             };         }     }      @trait=asRadio {           editable {               component:RadioGroupComponent;               bindings:{                   ngModel:$value;                   required:${properties.get("required")};                   isInline:${properties.get("isInline")};                   label:${properties.get("label")};                   lookupKey:${properties.get("lookupKey")};                   displayKey:${ meta.displayLabel(type, properties.get("labelField"), true )};                   list:${properties.get("choices")};               };           }      }      @trait=asAutoComplete {          editable {              component:ComboBoxComponent;              bindings:{                  ngModel:$value;                  required:${properties.get("required")};                  entityClass:${properties.get("entityClass")};                  lookupKey:${properties.get("lookupKey")};                  displayKey:${ meta.displayLabel(type, properties.get("labelField"), true )};                  dataSource:${properties.get("choices")};              };          }     }      @trait=noCreate { operation=create { visible:false; } }     @trait=noSearch { operation=search { visible:false; } }       component=(StringComponent,LinkComponent) {         @trait=bold {             wrapperComponent:GenericContainerComponent;             wrapperBindings: { tagName:b; };         }         @trait=italic {             wrapperComponent:GenericContainerComponent;             wrapperBindings: { tagName:i; };         }         @trait=heading1 {             wrapperComponent:GenericContainerComponent;             wrapperBindings: { tagName:h1; };         }         @trait=heading2 {             wrapperComponent:GenericContainerComponent;             wrapperBindings: { tagName:h2; };         }         @trait=heading3 {             wrapperComponent:GenericContainerComponent;             wrapperBindings: { tagName:h3; };         }     } }  action {   @trait=messageResults {       actionResults:${           m = properties.get("mRef");           m(object);           matSnackBar.open(properties.get("message"))       };   } }   layout {     @trait=Form { visible:true; component:MetaForm; }  }  ~class layout=(Inspect, SearchForm) {component:StringComponent; bindings:{value:null; }; }   ';
/* tslint:disable */
/**
 *  @formatter:on
 *
 */
 
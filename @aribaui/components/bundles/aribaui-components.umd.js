(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@aribaui/core'), require('@angular/forms'), require('@angular/platform-browser'), require('@angular/common'), require('rxjs'), require('primeng/components/inputtext/inputtext'), require('rxjs/operators'), require('primeng/primeng'), require('primeng/dialog'), require('@angular/animations'), require('@angular/router'), require('primeng/components/utils/objectutils')) :
    typeof define === 'function' && define.amd ? define('@aribaui/components', ['exports', '@angular/core', '@aribaui/core', '@angular/forms', '@angular/platform-browser', '@angular/common', 'rxjs', 'primeng/components/inputtext/inputtext', 'rxjs/operators', 'primeng/primeng', 'primeng/dialog', '@angular/animations', '@angular/router', 'primeng/components/utils/objectutils'], factory) :
    (factory((global.aribaui = global.aribaui || {}, global.aribaui.components = {}),global.ng.core,global.core$1,global.ng.forms,global.ng.platformBrowser,global.ng.common,global.rxjs,global.inputtext,global.rxjs.operators,global.primeng,global.dialog,global.ng.animations,global.ng.router,global.objectutils));
}(this, (function (exports,core,core$1,forms,platformBrowser,common,rxjs,inputtext,operators,primeng,dialog,animations,router,objectutils) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * When we have a custom component like dropdown, radiobuttonlist and
     * many more we want to provide a custom content to it like so:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     *
     * ```
     * Who else would know how to render list of objects..
     *
     * But its not possible in current form. if I do not provide Angular some as they call it this
     * syntactic sugar *,
     *
     *
     * ```
     *  <aw-dropdown *mySugerDirective=.....>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     * ```
     *
     *
     * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
     * inside the component
     *
     * So the only way I found (expecting I do not want to change anything in terms of bindings and the
     * signature I use it. I have to use it like this:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      <ng-template let-item> {{item.userName}}</ng-template>
     *
     *   <aw-dropdown
     *
     * ```
     *
     *  This way it could work. Since I am inside ngFor I want to render the item into the correct
     * viewContainer of ngFor's current item.
     *
     *  This way I can also expose item outside using Angular's special local variable called:
     * $implicit.
     *
     * This gets even more complex if we try to pass this template 2 levels down, like in case of
     * RadioButtonList. But later on I might want to refactor this into custom NG FOR
     *
     * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
     *
     */
    var EmbeddedItemDirective = (function () {
        function EmbeddedItemDirective(_viewContainer) {
            this._viewContainer = _viewContainer;
        }
        Object.defineProperty(EmbeddedItemDirective.prototype, "item", {
            set: /**
             * @param {?} item
             * @return {?}
             */ function (item) {
                this._implicitValue = item;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        /**
         *
         * @param {?} changes
         * @return {?}
         */
        EmbeddedItemDirective.prototype.ngOnChanges = /**
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(this._viewRef)) {
                    this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
                }
                if (core$1.isPresent(this.embeddedItem)) {
                    /** @type {?} */
                    var context = new EmbededItem(this._implicitValue);
                    this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
                }
            };
        EmbeddedItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[embeddedItem]' },] }
        ];
        /** @nocollapse */
        EmbeddedItemDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef }
            ];
        };
        EmbeddedItemDirective.propDecorators = {
            embeddedItem: [{ type: core.Input }],
            item: [{ type: core.Input }]
        };
        return EmbeddedItemDirective;
    }());
    /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */
    var /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */ EmbededItem = (function () {
        function EmbededItem($implicit) {
            this.$implicit = $implicit;
        }
        return EmbededItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * GenericContainerComponent is used by include-component.directive to dynamically create an
     * HTMLElement and use this element to wrap a child component. This is very useful when we want to
     * modify a child by wrapping it with a border, a background, or bold its text.
     *
     * The wrapper element is dynamically created. It's element is specified by the tagName property in
     * the bindings \@Input.
     *
     *  ### Example.  Directly in html
     *
     *   app.html
     *      <aw-generic-container tagName="tagName" bindings="bindings">
     *          <my-component ..bindings..></my-component>
     *      </aw-generic-container>
     *
     *   app.component.ts
     *
     *       tagName = (bBold) ? 'h1' : 'span';
     *       bindings = {  style: 'background-color: red' }
     *
     */
    var GenericContainerComponent = (function () {
        /**
         * param renderer - Renderer is used to create 'tagName' element.
         */
        function GenericContainerComponent(renderer, element) {
            this.renderer = renderer;
            this.element = element;
            this.nativeElement = element.nativeElement;
        }
        /**
         * During the initialization, verify that at least one input has been set.
         */
        /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
        GenericContainerComponent.prototype.ngOnInit = /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
            function () {
                // If there's no input, this component wouldn't know what to do and throw exception.
                if (core$1.isBlank(this.bindings) && core$1.isBlank(this.tagName)) {
                    throw new Error('GenericContainerComponent input bindings or tagName ' +
                        'have not been set.');
                }
                // If the tagName is blank, the get it from bindings.
                if (core$1.isBlank(this.tagName)) {
                    this.tagName = this.bindings.get('tagName');
                    if (core$1.isBlank(this.tagName)) {
                        this.tagName = GenericContainerComponent.DefaultTagName;
                    }
                }
                // Save first added
                this.childElement = this.nativeElement.firstChild;
                this.doRender();
            };
        /**
         * @return {?}
         */
        GenericContainerComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.childElement) &&
                    this.childElement.parentNode !== this.nativeElement.firstChild) {
                    this.nativeElement.firstChild.appendChild(this.childElement);
                }
            };
        /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
        GenericContainerComponent.prototype.doRender = /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var el = this.renderer.createElement(this.tagName);
                if (core$1.isPresent(this.nativeElement)) {
                    this.renderer.appendChild(this.nativeElement, el);
                }
                // Loop through all the bindings and add them to the element.
                core$1.MapWrapper.iterable(this.bindings).forEach(function (v, k) {
                    _this.renderer.setStyle(el, k, v);
                });
                // Attach the component to this divElement.
                el.appendChild(this.childElement);
            };
        /**
         * Default tagName if none is specified inside bindings.
         *
         */
        GenericContainerComponent.DefaultTagName = 'div';
        GenericContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-container',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        /** @nocollapse */
        GenericContainerComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.ElementRef }
            ];
        };
        GenericContainerComponent.propDecorators = {
            bindings: [{ type: core.Input }],
            tagName: [{ type: core.Input }]
        };
        return GenericContainerComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *  Base component shares common functionality among all the components (layouts, widgets).
     *
     * @abstract
     */
    var BaseComponent = (function () {
        function BaseComponent(env) {
            this.env = env;
            /**
             * Adds disabled flag to the component
             *
             */
            this.disabled = false;
            /**
             * Weather this component is visible
             * Default is false;
             */
            this.visible = false;
            /**
             * Tell  the component if we are in editing mode.
             *
             */
            this.editable = true;
            /**
             * Removes padding from the component. Usually used when we are nesting other component with
             * its own grid.
             */
            this.omitPadding = false;
            /**
             * Prefix for the correct asset path
             */
            this.assetFolder = 'assets';
            this.extBindings = new Map();
            this.omitPadding = false;
        }
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.assetFolder = this.env.getValue(core$1.AppConfig.AssetFolder);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        BaseComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
            };
        BaseComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            visible: [{ type: core.Input }],
            editable: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            styleClass: [{ type: core.Input }],
            omitPadding: [{ type: core.Input }]
        };
        return BaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var WidgetSizeColumns = {
        xsmall: 1,
        small: 3,
        medium: 6,
        large: 9,
        xlarge: 12,
    };
    WidgetSizeColumns[WidgetSizeColumns.xsmall] = 'xsmall';
    WidgetSizeColumns[WidgetSizeColumns.small] = 'small';
    WidgetSizeColumns[WidgetSizeColumns.medium] = 'medium';
    WidgetSizeColumns[WidgetSizeColumns.large] = 'large';
    WidgetSizeColumns[WidgetSizeColumns.xlarge] = 'xlarge';
    /**
     *  BaseFormComponnet extends BaseComponent for add specific form behavior
     *
     * @abstract
     */
    var BaseFormComponent = (function (_super) {
        __extends(BaseFormComponent, _super);
        /**
         * Some of the BaseFormComponent can wrap other component and in these cases we want to
         * inherit some of the behavior from parent
         *
         * @Inject(Environment) public env: Environment : is tem a workaround as without inject
         * on this specific component it complains that Environment is unresolved symbol
         *
         */
        function BaseFormComponent(env, parentContainer) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Is current element visible
             */
            _this.hidden = false;
            /**
             * Renders required flex around the component
             *
             */
            _this.required = false;
            /**
             *  a text displayed when value is empty or NULL
             */
            _this.placeHolder = '';
            /**
             * Identify if this control is used directly or if its part of some other control
             * e.g. GenericChooser and managed by this control.
             * Meaning State is mananged outside of this component
             *
             */
            _this.isStandalone = true;
            _this.onModelChanged = core$1.noop;
            _this.onModelTouched = core$1.noop;
            return _this;
        }
        /**
         * @return {?}
         */
        BaseFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.parentContainer)) {
                    this.formGroup = this.parentContainer.formGroup;
                    this.editable = this.parentContainer.editable;
                }
                this.checkInitForm();
            };
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         */
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
        BaseFormComponent.prototype.checkInitForm = /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.env.currentForm)) {
                    this.env.currentForm = new forms.FormGroup({});
                }
                /**
                         * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                         * number basedon some semantics app.page.component if there are more component on the page
                         * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                         */
                if (core$1.isBlank(this.name)) {
                    this.name = core$1.uuid();
                }
                if (core$1.isBlank(this.id)) {
                    this.id = core$1.uuid();
                }
            };
        /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.doRegister = /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
            function (name, value) {
                /** @type {?} */
                var fControl;
                if (core$1.isBlank(this.formGroup.controls[name])) {
                    this.formGroup.registerControl(name, new forms.FormControl(value));
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                }
                else {
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                    /** @type {?} */
                    var updatedValue = core$1.isPresent(fControl.value) ? fControl.value : value;
                    fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
                }
                return fControl;
            };
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param value default value to be pre-set
         */
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
        BaseFormComponent.prototype.registerFormControl = /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
            function (value) {
                this.formControl = this.doRegister(this.name, value);
                if (this.disabled) {
                    this.formControl.disable();
                }
            };
        Object.defineProperty(BaseFormComponent.prototype, "formGroup", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._formGroup = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         */
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
        BaseFormComponent.prototype.canSetType = /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelChanged = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelTouched = fn;
            };
        /*
             *  Supported layout constants. It is expected there will be more options as we currently
             *  support only these two there will be other variations of it. e.g. for stacked it will not
             *  be 1 columns like it is now but multiple columns
             *
             */
        BaseFormComponent.LayoutStacked = 'stacked';
        BaseFormComponent.LayoutInline = 'inline';
        /** @nocollapse */
        BaseFormComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment, decorators: [{ type: core.Inject, args: [core$1.Environment,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        BaseFormComponent.propDecorators = {
            name: [{ type: core.Input }],
            id: [{ type: core.Input }],
            hidden: [{ type: core.Input }],
            required: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            isStandalone: [{ type: core.Input }],
            formGroup: [{ type: core.Input }]
        };
        return BaseFormComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Simple component rendering values in the read only mode. Just needed some component used
     * to render Strings in read only mode
     *
     *
     *  ### Example
     *
     * Using it inside form container along with label
     *
     *
     *  ```
     * \@Component({
     *              selector: 'userInfo' ,
     *              template: `
     *                      <aw-form-table [editable]="false" >
     *                          <aw-form-row [name]="fieldName"  [label]="label">
     *                                 <aw-string [value]="inputValue" ></aw-string>
     *                           </aw-form-row>
     *                      </aw-form-table>
     *
     *                  `
     *          })
     *          export class UserProfileComponent
     *          {
     *              inputValue: string = 'Some text';
     *              inputType: string = 'string';
     *              fieldName: string = 'firstName';
     *              label: string = 'My Name';
     *              required: boolean = true;
     *              editing: boolean = true;
     *              labelsOnTop: boolean = false;
     *
     *          }
     *
     *  ```
     *
     * You can also pass html tags.
     *
     */
    var StringComponent = (function (_super) {
        __extends(StringComponent, _super);
        function StringComponent(env, sanitizer, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.sanitizer = sanitizer;
            _this.parentContainer = parentContainer;
            /**
             *  Value to be interpolated
             *
             */
            _this._value = '';
            return _this;
        }
        Object.defineProperty(StringComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.sanitizer.bypassSecurityTrustHtml(this._value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        StringComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-string',
                        template: "\n        <span class=\"w-string-field\" [innerHTML]=\"value\"></span>\n    ",
                        styles: [".w-string-field{display:inline-block}"]
                    }] }
        ];
        /** @nocollapse */
        StringComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: platformBrowser.DomSanitizer },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        StringComponent.propDecorators = {
            value: [{ type: core.Input }]
        };
        return StringComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * A class holding a references to components. The methods are self-explanatory.
     *
     */
    var ComponentRegistry = (function () {
        function ComponentRegistry(env) {
            this.env = env;
            this._nameToType = new Map();
        }
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.initialize = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                this.registerTypes(references);
                /** @type {?} */
                var promise = new Promise(function (resolve) {
                    resolve(true);
                });
                return promise;
            };
        /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
        ComponentRegistry.prototype.registerType = /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
            function (name, type) {
                if (!this.nameToType.has(name)) {
                    this._nameToType.set(name, type);
                }
            };
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.registerTypes = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                var _this = this;
                if (!core$1.isStringMap(references)) {
                    return;
                }
                Object.keys(references).forEach(function (name) {
                    _this.registerType(name, references[name]);
                });
            };
        Object.defineProperty(ComponentRegistry.prototype, "nameToType", {
            get: /**
             * @return {?}
             */ function () {
                return this._nameToType;
            },
            enumerable: true,
            configurable: true
        });
        ComponentRegistry.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ComponentRegistry.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        return ComponentRegistry;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
     * based on the name. It can accepts bindings as well which will be automatically bound and applied
     * to the component
     *
     *  ### usage:
     *
     *  Instead of inserting component in the way:
     *
     *  ```
     *    <textfield value="some value">
     *
     *  ```
     *
     *  you can do so dynamically like this:
     *
     * ```
     *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
     * ```
     *
     * This is the main building block to dynamically generated UI.
     *
     *
     * Todo: Currently the way Angular API work and we use it to create programatically components
     * is too complext we need to create everything 3 different calls to place a component to the
     * container. What I want is is to create some kind of representation of ContainerElement and this
     * can be also parent for our BaseComponent with method add and remove content. Then we could have
     * some AWContent.
     *
     * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
     * component to the view.
     *
     * ```ts
     *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
     *  containerElement.add('Clck Me')
     * ```
     *
     * To assemble different components together - not only adding string content
     *
     * ```ts
     *  let content = new AWContent(ButtonComponent, bindingsMap)
     *  content.add('Click Me');
     *  containerElement.add(content)
     *
     * ```
     *
     * add more component hierarchy:
     *
     * ```ts
     *  let content = new AWContent(HoverCardComponnets, bindingsMap)
     *  content.add(createLayout();
     *  containerElement.add(content)
     *
     * ```
     *
     *
     *
     *
     */
    var IncludeComponentDirective = (function () {
        function IncludeComponentDirective(viewContainer, factoryResolver, cd, compRegistry) {
            this.viewContainer = viewContainer;
            this.factoryResolver = factoryResolver;
            this.cd = cd;
            this.compRegistry = compRegistry;
            /**
             * I use this flag to identify that component is rendering for first time or its updated during
             * change detection
             *
             */
            this.initRenderInProgress = false;
            /**
             * Not sure if we need this, but want to keep it here or maybe move it to some service so we
             * can cache created components and maybe reuse them.
             *
             */
            this.componentReferences = new Map();
            this.bindings = new Map();
        }
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = true;
                // todo: check if this the right lifecycle callback, this is called only once and you want
                // to probably listen for changes, and change dection decide there is some change and we
                // need to re-draw the view
                this.viewContainer.clear();
                this.doRenderComponent();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(changes['name']) &&
                    (changes['name'].currentValue !== changes['name'].previousValue)) {
                    this.viewContainer.clear();
                    this.doRenderComponent();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = false;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // check to see if we need to render and reposition DOM element both for wrapper and
                // content
                this.createWrapperElementIfAny();
                this.createContentElementIfAny();
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         */
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.createWrapperElementIfAny = /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
            function () {
            };
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         */
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
        IncludeComponentDirective.prototype.doRenderComponent = /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
            function () {
                var _this = this;
                this.placeTheComponent();
                // this.currentComponent.changeDetectorRef.detach();
                this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
                // this.currentComponent.changeDetectorRef.detectChanges();
                // Still not sure about this what all I should release here.
                this.currentComponent.onDestroy(function () {
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    _this.destroy();
                });
            };
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         */
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.placeTheComponent = /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var reference = this.componentReference();
                this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
            };
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return need to run detect changes ? default is false
         */
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
        IncludeComponentDirective.prototype.createContentElementIfAny = /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
            function () {
                /** @type {?} */
                var detectChanges = false;
                /** @type {?} */
                var ngContent = this.ngContent();
                /** @type {?} */
                var ngContentElement = this.ngContentElement();
                if (core$1.isPresent(ngContent)) {
                    /** @type {?} */
                    var awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
                    /** @type {?} */
                    var component = this.viewContainer.createComponent(awContentComponent, 0);
                    ((component.instance)).value = ngContent;
                    /** @type {?} */
                    var awContentContainer = this.currentComponent.location.nativeElement.firstChild;
                    awContentContainer.appendChild(component.location.nativeElement);
                    detectChanges = true;
                }
                else if (core$1.isPresent(ngContentElement)) ;
                return detectChanges;
            };
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         */
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContent = /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
                    this.bindings.delete(IncludeComponentDirective.NgContent);
                }
                return content;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContentElement = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
                    this.bindings.delete(IncludeComponentDirective.NgContentElement);
                }
                return content;
            };
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         */
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
        IncludeComponentDirective.prototype.componentReference = /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.resolvedComponentRef)) {
                    return this.resolvedComponentRef;
                }
                /** @type {?} */
                var currType = this.resolveComponentType();
                /** @type {?} */
                var componentFactory = this.factoryResolver
                    .resolveComponentFactory(currType);
                /** @type {?} */
                var componentMeta = this.resolveDirective(componentFactory);
                /** @type {?} */
                var compReference = {
                    metadata: componentMeta,
                    resolvedCompFactory: componentFactory,
                    componentType: currType,
                    componentName: this.name
                };
                this.resolvedComponentRef = compReference;
                return compReference;
            };
        /**
         * Iterates thru ComponentMetadata @Inputs() and check if we have available binding inside the
         * 'this.bindings'
         */
        /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
        IncludeComponentDirective.prototype.applyBindings = /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
            function (cRef, component, bindings) {
                /** @type {?} */
                var inputs = cRef.metadata.inputs;
                if (core$1.isBlank(inputs) || inputs.length === 0) {
                    return;
                }
                // should we do any type conversion?
                core$1.MapWrapper.iterable(bindings).forEach(function (v, k) {
                    if (core$1.isPresent(component.instance[k])) {
                        component.instance[k] = v;
                    }
                });
            };
        /**
         * Resolves a component Type based on the string literal
         *
         * @returns component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        IncludeComponentDirective.prototype.resolveComponentType = /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
            function () {
                /** @type {?} */
                var componentType = this.compRegistry.nameToType.get(this.name);
                if (core$1.isBlank(componentType)) {
                    core$1.assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                        ' of throwing this error');
                    return;
                }
                return componentType;
            };
        /**
         * @param {?} compFactory
         * @return {?}
         */
        IncludeComponentDirective.prototype.resolveDirective = /**
         * @param {?} compFactory
         * @return {?}
         */
            function (compFactory) {
                /** @type {?} */
                var compMeta = {
                    inputs: [],
                    outputs: []
                };
                if (core$1.isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
                    compFactory.inputs.forEach(function (input) {
                        compMeta.inputs.push(input.propName);
                    });
                }
                if (core$1.isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
                    compFactory.outputs.forEach(function (output) {
                        compMeta.outputs.push(output.propName);
                    });
                }
                return compMeta;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent.destroy();
                    this.currentComponent = undefined;
                }
                if (core$1.isPresent(this.viewContainer)) {
                    this.viewContainer.clear();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent = null;
                    this.resolvedComponentRef = null;
                }
            };
        IncludeComponentDirective.NgContent = 'ngcontent';
        IncludeComponentDirective.NgContentElement = 'ngcontentElement';
        IncludeComponentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'aw-include-component'
                    },] }
        ];
        /** @nocollapse */
        IncludeComponentDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver },
                { type: core.ChangeDetectorRef },
                { type: ComponentRegistry }
            ];
        };
        IncludeComponentDirective.propDecorators = {
            name: [{ type: core.Input }],
            bindings: [{ type: core.Input }]
        };
        return IncludeComponentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Error Manager is a service used by Forms components to map error codes into meaningful messages.
     * Currently it does not have much but once we plug in localization it will make more sense
     *
     *
     * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
     * externalize these messages into locale files.
     *
     */
    var ErrorManagerService = (function () {
        function ErrorManagerService() {
            this.messages = {
                'required': 'Required field',
                'minlength': 'Field does not meet minimum length',
                'maxlength': 'Field does not meet maximum length',
                'customMsg': '%s',
                'metavalid': '%s'
            };
        }
        /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
        ErrorManagerService.prototype.errorMessage = /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
            function (validatorName, validatorValue) {
                /** @type {?} */
                var message = this.messages[validatorName];
                if (core$1.StringWrapper.contains(message, '%s')) {
                    // todo: use ng-translate with proper message formatting
                    return core$1.StringWrapper.replace(message, '%s', validatorValue.msg);
                }
                return message;
            };
        ErrorManagerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ErrorManagerService.ctorParameters = function () { return []; };
        return ErrorManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
     * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
     *
     *
     *
     */
    var ErrorMessagesComponent = (function () {
        function ErrorMessagesComponent(errManager) {
            this.errManager = errManager;
        }
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.hasMessage = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var msg = this.errorMsg;
                return core$1.isPresent(msg);
            };
        Object.defineProperty(ErrorMessagesComponent.prototype, "errorMsg", {
            /**
             * Retrieve a messages if any registered by added validators
             *
             */
            get: /**
             * Retrieve a messages if any registered by added validators
             *
             * @return {?}
             */ function () {
                for (var propertyName in this.control.errors) {
                    if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                        return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         */
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
        ErrorMessagesComponent.prototype.showErrors = /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
            function () {
                return !this.control.valid && !this.control.pristine && this.control.touched;
            };
        ErrorMessagesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'a-error-messages',
                        template: "\n            <div class=\"ui-g\">\n                    <small *ngIf=\"hasMessage()\"\n                        class=\"ui-g-12 ui-message ui-messages-error ui-corner-all\">\n                        {{ errorMsg }}\n                    </small>\n            </div>\n    ",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        ErrorMessagesComponent.ctorParameters = function () {
            return [
                { type: ErrorManagerService }
            ];
        };
        ErrorMessagesComponent.propDecorators = {
            control: [{ type: core.Input }]
        };
        return ErrorMessagesComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
     * The service also keeps track of the created modal dialog and can close it by calling the
     * service's close()
     *
     * Modal service requires a ViewContainer to insert newly created modals. This is taken care
     * by the ModalComponent.
     *
     * Usage:
     *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
     *     page where a modal dialog will appear.
     *
     *    1.  Popup a dialog without creating your own component.
     *        Use the existing DialogComponent in widgets.
     *
     *             this.modalService.open<DialogComponent>(DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Creating your own Dialog Component to popup.
     *
     *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
     * {inputs});
     *
     * \@Component({
     *                selector: 'aw-mydialog' ,
     *                           template: `
     *                                         <aw-dialog (onClose)="closePopup()">
     *                                              <ng-template #titleTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Title </span>
     *                                              </ng-template>
     *                                              <ng-template #bodyTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Body </span>
     *                                              </ng-template>
     *                                        </aw-dialog>
     *                                     `
     *         })
     *         export class MyDialogComponent extends DialogComponent implements OnInit {
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     closePopup() {
     *                            this.modalService.close();
     *                      }
     *         }
     */
    var ModalService = (function () {
        /**
         * DI ComponentFactoryResolver to be used to create modal component.
         *
         * @param cfr
         */
        function ModalService(cfr) {
            this.cfr = cfr;
        }
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param vcRef
         */
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
        ModalService.prototype.registerViewContainerRef = /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
            function (vcRef) {
                this.vcRef = vcRef;
            };
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         */
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
        ModalService.prototype.open = /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
            function (component, parameters) {
                /** @type {?} */
                var cf = this.cfr.resolveComponentFactory(component);
                /** @type {?} */
                var componentRef = this.vcRef.createComponent(cf);
                // Auto set visiblity to true. So that the Dialog will display
                parameters = (parameters) ? parameters : {};
                parameters['visible'] = true;
                // Handle output parameters.
                ModalService.OUTPUT_PARAMETERS.forEach(function (param) {
                    if (parameters[param]) {
                        ((componentRef.instance))[param].subscribe(parameters[param]);
                        delete parameters[param];
                    }
                });
                Object.assign(componentRef.instance, parameters);
                // had to cast it in order to avoid any index Error
                // Attach a destroy method to the newly created component.
                ((componentRef.instance))['destroy'] = function () {
                    componentRef.destroy();
                };
                // Save the instance, so it can be destroyed later.
                this.instance = componentRef;
                return componentRef;
            };
        /**
         * Calling close() will remove the modal from view.
         */
        /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
        ModalService.prototype.close = /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
            function () {
                if (this.instance) {
                    this.instance.destroy();
                    this.instance = null;
                }
            };
        /**
         * This is a static list of output parameter from Dialog, Confirmation components
         * that needs to be handled.
         *
         */
        ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
        ModalService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ModalService.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver }
            ];
        };
        return ModalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Place holder for all modal dialogs. This component works with the modalService by providing
     * a place holder for it to inject Dialog component into.
     */
    var ModalComponent = (function () {
        function ModalComponent(modalService) {
            this.modalService = modalService;
        }
        /**
         * @return {?}
         */
        ModalComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.modalService.registerViewContainerRef(this.viewContainerRef);
            };
        ModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-modal',
                        template: "<div #modal></div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        ModalComponent.ctorParameters = function () {
            return [
                { type: ModalService }
            ];
        };
        ModalComponent.propDecorators = {
            viewContainerRef: [{ type: core.ViewChild, args: ['modal', { read: core.ViewContainerRef },] }]
        };
        return ModalComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This currency formatter will ignore null and empty string for value.
     * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
     */
    var CurrencyFormatPipe = (function () {
        function CurrencyFormatPipe(currencyPipe) {
            this.currencyPipe = currencyPipe;
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        CurrencyFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                /** @type {?} */
                var currencyCode = 'USD';
                /** @type {?} */
                var symbolDisplay = true;
                /** @type {?} */
                var digits = '1.0-2';
                if (!value || value.length === 0) {
                    return value;
                }
                if (args && args.length > 0) {
                    /** @type {?} */
                    var code = args[0];
                    if (code && code.length > 0) {
                        currencyCode = code;
                    }
                }
                return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
            };
        CurrencyFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'currencyFormat',
                        pure: false
                    },] }
        ];
        /** @nocollapse */
        CurrencyFormatPipe.ctorParameters = function () {
            return [
                { type: common.CurrencyPipe }
            ];
        };
        return CurrencyFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Simple utility directive that is used by NG For cycle in situation where we need to call a
     * or execute some logic after each iteration
     */
    var NgForSetDirective = (function () {
        function NgForSetDirective() {
            this.onItem = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        NgForSetDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.onItem.emit('--');
            };
        NgForSetDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngForSet]'
                    },] }
        ];
        /** @nocollapse */
        NgForSetDirective.ctorParameters = function () { return []; };
        NgForSetDirective.propDecorators = {
            onItem: [{ type: core.Output }]
        };
        return NgForSetDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
     * or traversal should be put into this service
     *
     */
    var DomUtilsService = (function () {
        function DomUtilsService() {
        }
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         */
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.hasParent = /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                return core$1.isPresent(this.closest(nativeElement, selector));
            };
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         */
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.closest = /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                /** @type {?} */
                var firstChar = selector.charAt(0);
                /** @type {?} */
                var parentNode = nativeElement;
                while (core$1.isPresent((parentNode = parentNode.parentNode))) {
                    if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                        return parentNode;
                    }
                    if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                        return parentNode;
                    }
                    // If selector is a tag
                    if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                        return parentNode;
                    }
                    if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                        return null;
                    }
                }
                return null;
            };
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         */
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
        DomUtilsService.prototype.insertIntoParentNgContent = /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
            function (parentNativeEl, childNativeEl) {
                /** @type {?} */
                var ngContentParent = parentNativeEl;
                /** @type {?} */
                var foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
                if (core$1.isPresent(foundNgContent)) {
                    // we don't cover a case where there could be multiple ngcontents
                    ngContentParent = foundNgContent;
                }
                ngContentParent.appendChild(childNativeEl);
            };
        /**
         *
         * Retrieves current browser window width and height
         *
         */
        /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
        DomUtilsService.prototype.browserDimentions = /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
            function () {
                return {
                    width: (window.innerWidth || document.documentElement.clientWidth
                        || document.body.clientWidth),
                    height: (window.innerHeight || document.documentElement.clientHeight
                        || document.body.clientHeight)
                };
            };
        /**
         *
         * Retrieves elemements dimensions
         *
         */
        /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
        DomUtilsService.prototype.elementDimensions = /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                if (core$1.isPresent(element.getBoundingClientRect)) {
                    return element.getBoundingClientRect();
                }
                return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
            };
        DomUtilsService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DomUtilsService.ctorParameters = function () { return []; };
        return DomUtilsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * The Infinite Scroll allows you to perform an action when the user
     * scrolls a specified distance from the bottom or top of the page.
     *
     * The expression assigned to the `infinite` event is called when
     * the user scrolls to the specified distance. When this expression
     * has finished its tasks, it should call the `complete()` method
     * on the infinite scroll instance.
     *
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
     *  </aw-infinite-scroll>
     *
     * ```
     *
     *
     * You can also set a threshold to change the distance when the lazy load kicks
     * in.
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
     *  </aw-infinite-scroll>
     *
     * ```
     */
    var InfiniteScrollComponent = (function () {
        function InfiniteScrollComponent(_render, _zone, domUtils, _cd) {
            this._render = _render;
            this._zone = _zone;
            this.domUtils = domUtils;
            this._cd = _cd;
            this._lastCheck = 0;
            this._lastScrollTop = 0;
            this._thr = '10%';
            this._thrPx = 0;
            this._thrPc = 0.10;
            this._init = false;
            /**
             * \@internal
             */
            this.state = STATE_ENABLED;
            /**
             * \@output {event} Emitted when the scroll reaches
             * the threshold distance. From within your infinite handler,
             * you must call the infinite scroll's `complete()` method when
             * your async operation has completed.
             */
            this.onLoad = new core.EventEmitter();
            /**
             *
             * Lazy load current numbers. tell the app starting point and what is the size of loaded
             * list
             *
             */
            this.fetchSize = 0;
            this.loadOffset = 0;
        }
        Object.defineProperty(InfiniteScrollComponent.prototype, "distance", {
            /**
             * @input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             */
            get: /**
             * \@input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             * @return {?}
             */ function () {
                return this._thr;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._thr = val;
                if (val.indexOf('%') > -1) {
                    this._thrPx = 0;
                    this._thrPc = (parseFloat(val) / 100);
                }
                else {
                    this._thrPx = parseFloat(val);
                    this._thrPc = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollComponent.prototype, "enabled", {
            /**
             * @input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             */
            set: /**
             * \@input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             * @param {?} shouldEnable
             * @return {?}
             */ function (shouldEnable) {
                this.enable(shouldEnable);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._render.addClass(document.body, 'has-infinite-scroll');
            };
        /**
         * @param {?} ev
         * @return {?}
         */
        InfiniteScrollComponent.prototype._onScroll = /**
         * @param {?} ev
         * @return {?}
         */
            function (ev) {
                if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
                    return;
                }
                // must throttle the class by 100ms
                if (this._lastCheck + 100 > ev.timeStamp) {
                    // no need to check less than every XXms
                    return;
                }
                this._lastCheck = ev.timeStamp;
                /** @type {?} */
                var scrollTop = this.scrollTop();
                /** @type {?} */
                var winHeight = this.domUtils.browserDimentions().height;
                /** @type {?} */
                var height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
                if (!height) {
                    // if there is no height of this element then do nothing
                    return;
                }
                /** @type {?} */
                var threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
                /** @type {?} */
                var distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
                // console.log('Document height (' + height + ') , Distance from bottom '
                // + distanceFromInfinite + ',  => threshold = ' +
                //     this.distance + ' (' + threshold + ')');
                if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
                    this.fireOnLazyLoad();
                }
                else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
                    && this.loadOffset !== this.fetchSize) {
                    this.fireOnLazyUnLoad();
                }
                this._lastScrollTop = scrollTop;
                return;
            };
        /**
         * Todo: refactor to one method
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyLoad = /**
         * Todo: refactor to one method
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        _this.onLoad.emit({
                            isLoad: true,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                        // start on the next record
                        // start on the next record
                        _this.loadOffset += _this.fetchSize;
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyUnLoad = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        // start on the next record
                        // start on the next record
                        _this.loadOffset = _this.fetchSize;
                        _this.onLoad.emit({
                            isLoad: false,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.scrollTop = /**
         * @return {?}
         */
            function () {
                return (window.pageYOffset || this._content.scrollTop);
            };
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         */
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.complete = /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state !== STATE_LOADING) {
                    return;
                }
                setTimeout(function () {
                    _this.state = STATE_ENABLED;
                    // need to trigger extra detect changes to rerender loading icon
                    // need to trigger extra detect changes to rerender loading icon
                    _this._cd.detectChanges();
                }, 100);
            };
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         */
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.enable = /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
            function (shouldEnable) {
                this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
                this._setListeners(shouldEnable);
            };
        /**
         * Subscribes to native windows scroll event
         */
        /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
        InfiniteScrollComponent.prototype._setListeners = /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
            function (shouldListen) {
                var _this = this;
                if (this._init) {
                    if (shouldListen) {
                        if (!this._scLsn) {
                            this._zone.runOutsideAngular(function () {
                                _this._scLsn = _this._onScroll.bind(_this);
                                window.addEventListener('scroll', _this._scLsn);
                            });
                        }
                    }
                    else {
                        if (core$1.isPresent(this._scLsn)) {
                            window.removeEventListener('scroll', this._scLsn);
                            this._scLsn = null;
                        }
                    }
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.isLoading = /**
         * @return {?}
         */
            function () {
                return this.state === STATE_LOADING;
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._init = true;
                this._docBody = document.body;
                this._content = document.documentElement;
                this._setListeners(this.state !== STATE_DISABLED);
                if (this.loadOffset === 0) {
                    this.fireOnLazyLoad();
                }
            };
        /**
         * @hidden
         */
        /**
         * @hidden
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnDestroy = /**
         * @hidden
         * @return {?}
         */
            function () {
                this._setListeners(false);
            };
        InfiniteScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-infinite-scroll',
                        template: "<div class=\"w-infinite-loader-panel\" *ngIf=\"isLoading()\">\n    <span class=\"sap-icon icon-synchronize u-spin-icon\"></span>\n</div>\n",
                        styles: [".w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}"]
                    }] }
        ];
        /** @nocollapse */
        InfiniteScrollComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.NgZone },
                { type: DomUtilsService },
                { type: core.ChangeDetectorRef }
            ];
        };
        InfiniteScrollComponent.propDecorators = {
            distance: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            onLoad: [{ type: core.Output }],
            loadPanel: [{ type: core.ViewChild, args: ['loadinPanel',] }],
            fetchSize: [{ type: core.Input }]
        };
        return InfiniteScrollComponent;
    }());
    /** @type {?} */
    var STATE_ENABLED = 'enabled';
    /** @type {?} */
    var STATE_DISABLED = 'disabled';
    /** @type {?} */
    var STATE_LOADING = 'loading';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AwNameStore = (function () {
        function AwNameStore() {
            this.store = new Map();
        }
        /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
        AwNameStore.prototype.add = /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
            function (name, el) {
                if (this.collides(name)) {
                    throw new Error('Name is not unique!');
                }
                return this.store.set(name, el);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.remove = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.delete(name);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.collides = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.has(name);
            };
        /**
         * @return {?}
         */
        AwNameStore.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.store.clear();
            };
        AwNameStore.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AwNameStore.ctorParameters = function () { return []; };
        return AwNameStore;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
     * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
     * and inherant immutable element attributes.
     *
     * **Generating the Base Name**
     *
     * The 'awName' directive generates a base name from element tag name and attributes which are
     * static by nature.
     *
     *     Example:
     *         <button name="order" awName>
     *
     *     Result:
     *         <button name="order" awname="button_order">
     *
     * If the element has an 'id', that value takes precedent and is used instead of a generated
     * name.
     *
     *     Example:
     *         <button name="order" id="myOrderButton" awName>
     *
     *     Result:
     *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
     *
     *
     * **Repeated Elements and the 'ext' Parameter**
     *
     * There are many cases where elements are generated dynamically in the code as lists or tables.
     * In such cases, it may not be easy to distinguish individual elements by standard HTML
     * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
     * using the 'ext' attribute.
     *
     *    Example:
     *        fruits = ['apple', 'banana', 'orange'];
     *
     *        <ul>
     *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
     *        </ul>
     *
     *   Result:
     *       <ul>
     *           <li awname="li_apple">apple</li>
     *           <li awname="li_banana">banana</li>
     *           <li awname="li_orane">orange</li>
     *       </ul>
     *
     * **Adding Context Through Ancestor Inspection**
     *
     * In order to provide context to the element naming, the 'awName' directive loops through the
     * parent ancestry and searches for any unique element 'id' to prepend to the base name.
     *
     *     Example:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *
     *     Result:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awname="applicant_input_firstName">
     *            <input type="text" name="lastName" awname="applicant_input_lastName">
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awname="spouse_input_firstName">
     *            <input type="text" name="lastName" awname="spouse_input_lastname">
     *         </form>
     *
     * **Uniqueness Check**
     *
     * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
     * creates a new name during the `ngOnInit` phase it checks it against the existing map,
     * and will throw an error if it encounters a duplicate. Moreover during the element destruction
     * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
     *
     *
     * **In Production**
     *
     * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
     * a production environment, 'awName' serves no functionality to the end user, but may have
     * a performance impact on the application. As such, 'awName' takes into account the
     * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
     * is `true`.
     *
     * In your application, you can turn on production mode by setting `devmode.enabled` to
     * `false` when configuring `AribaCoreModule`:
     *
     *     AribaCoreModule.forRoot({
     *         'devmode.enabled': false
     *     })
     *
     */
    var AwNameDirective = (function () {
        function AwNameDirective(el, store, config) {
            this.el = el;
            this.store = store;
            this.config = config;
            this.separator = '_';
        }
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.name = this.createName(this.el);
                this.addElementToStore(this.name, this.el);
                this.el.nativeElement.setAttribute('awname', this.name);
            };
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.store.remove(this.name);
            };
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         */
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
        AwNameDirective.prototype.addElementToStore = /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
            function (name, elem) {
                try {
                    this.store.add(name, elem);
                }
                catch (e) {
                    console.error(e.message + (". \"" + name + "\" is already in use."), elem.nativeElement);
                    return;
                }
            };
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @return String Name/ID
         */
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
        AwNameDirective.prototype.createName = /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
            function (elem) {
                /** @type {?} */
                var tagName = this.getTagName(elem);
                /** @type {?} */
                var parts = [];
                /** @type {?} */
                var parentID = this.getAncestorId(elem);
                if (parentID) {
                    parts.push(parentID);
                }
                // Check the tag type
                if (tagName === 'option') {
                    /** @type {?} */
                    var parentName = this.getParentName(elem);
                    if (parentName) {
                        parts.push(parentName);
                    }
                }
                // Get tagname
                parts.push(tagName);
                // Choose id property if it exists
                if (elem.nativeElement.id) {
                    parts.push(elem.nativeElement.id);
                    // Otherwise build extension from tag properties
                }
                else {
                    // check for a name attribute
                    if (elem.nativeElement.hasAttribute('name')) {
                        parts.push(elem.nativeElement.name);
                    }
                    // check for value attribute if 'option' tag
                    if (tagName === 'option') {
                        if (elem.nativeElement.hasAttribute('value')) {
                            parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                        }
                    }
                }
                // Add custom extension if it exists
                if (this.ext) {
                    parts.push(this.spacesToUnderscore(this.ext));
                }
                return parts.join(this.separator);
            };
        /**
         * Get tag name from element reference.
         * @param elem Reference to element
         */
        /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getTagName = /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                return elem.nativeElement.tagName.toLowerCase();
            };
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param elem Reference to element
         */
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getAncestorId = /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                /** @type {?} */
                var parent = elem.nativeElement.parentNode;
                /** @type {?} */
                var id = '';
                while (parent && !id) {
                    if (parent.id) {
                        id = parent.id;
                    }
                    parent = parent.parentNode;
                }
                return id;
            };
        /**
         * Get name attribute from parent if name attribute exists.
         * @param elem Reference to element
         */
        /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getParentName = /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                /** @type {?} */
                var parent = elem.nativeElement.parentNode;
                return (parent.name && !parent.id) ? parent.name : null;
            };
        /**
         * @param {?} str
         * @return {?}
         */
        AwNameDirective.prototype.spacesToUnderscore = /**
         * @param {?} str
         * @return {?}
         */
            function (str) {
                return str.replace(/\s+/g, '_');
            };
        AwNameDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[awName]',
                    },] }
        ];
        /** @nocollapse */
        AwNameDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: AwNameStore },
                { type: core$1.AppConfig }
            ];
        };
        AwNameDirective.propDecorators = {
            ext: [{ type: core.Input }]
        };
        return AwNameDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWCoreComponentModule = (function () {
        function AWCoreComponentModule() {
        }
        AWCoreComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            GenericContainerComponent,
                            ModalComponent
                        ],
                        exports: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ]
                    },] }
        ];
        return AWCoreComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */
    var /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */ ModalContainer = (function (_super) {
        __extends(ModalContainer, _super);
        function ModalContainer(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Override function.
             */
            _this.destroy = core$1.noop;
            return _this;
        }
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         */
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
        ModalContainer.prototype.closeModal = /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
            function () {
                this.destroy();
            };
        return ModalContainer;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * DataTypeProviderRegistry aggregates different DataProviders per type.
     */
    var DataTypeProviderRegistry = (function () {
        function DataTypeProviderRegistry() {
            this.registryByProvider = new Map();
            this.registryNameToClass = new Map();
        }
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         */
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.registerProvider = /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                if (core$1.isBlank(target) || (!core$1.isStringMap(target) && !core$1.isType(target))) {
                    throw new Error(' Cannot register non-object');
                }
                /** @type {?} */
                var name = core$1.isType(target) ? target.prototype.constructor.name : target.constructor.name;
                this.registryByProvider.set(name, provider);
                /** @type {?} */
                var prototype = Object.getPrototypeOf(target);
                this.registryNameToClass.set(name, prototype);
            };
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         */
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForClass = /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
            function (className) {
                /** @type {?} */
                var registeredClassName = className;
                /** @type {?} */
                var classProto = this.registryNameToClass.get(className);
                while (core$1.isPresent(registeredClassName)) {
                    /** @type {?} */
                    var provider = this.registryByProvider.get(registeredClassName);
                    if (core$1.isPresent(provider)) {
                        provider.type = className;
                        return provider;
                    }
                    // Go up to parent
                    if (core$1.isPresent(classProto)) {
                        classProto = Object.getPrototypeOf(classProto);
                        /** @type {?} */
                        var parentName = core$1.objectToName(classProto);
                        registeredClassName =
                            (core$1.isPresent(parentName) && parentName !== registeredClassName) ? parentName
                                : null;
                    }
                    else {
                        return null;
                    }
                }
                return null;
            };
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         */
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForType = /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
            function (type) {
                /** @type {?} */
                var name = core$1.objectToName(type);
                this.registryNameToClass.set(name, type);
                return this.bestMatchForClass(name);
            };
        DataTypeProviderRegistry.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DataTypeProviderRegistry.ctorParameters = function () { return []; };
        return DataTypeProviderRegistry;
    }());
    /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */
    var /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */ DataProvider = (function () {
        function DataProvider() {
            /**
             * Notifies all the listeners in case of data are available or if they changed due to some user
             * interaction  (search, adding or removing).
             *
             */
            this.dataChanges = new rxjs.BehaviorSubject([]);
        }
        /**
         *  Return size of the source
         *
         */
        /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
        DataProvider.prototype.expectedCount = /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return -1;
            };
        /**
         *
         * Returns non-async current state of data
         */
        /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
        DataProvider.prototype.data = /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
            function () {
                return this.dataChanges.getValue();
            };
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         */
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
        DataProvider.prototype.canCRUD = /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Tells if this DataProvider supports query capability
         *
         */
        /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
        DataProvider.prototype.canQuery = /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         */
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.insert = /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         */
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.remove = /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to provide access to low level searcg API.
         *
         */
        /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
        DataProvider.prototype.query = /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
            function (params) {
            };
        return DataProvider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Default implementation for Arrays.
     * @template T
     */
    var /**
     * Default implementation for Arrays.
     * @template T
     */ ArrayDataProvider = (function (_super) {
        __extends(ArrayDataProvider, _super);
        function ArrayDataProvider(values) {
            var _this = _super.call(this) || this;
            _this.values = values;
            _this.type = Array;
            _this.offScreenData = _this.values;
            _this.dataChanges.next(_this.values);
            return _this;
        }
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.expectedCount = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return this.offScreenData.length;
            };
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.dataForParams = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                if (core$1.isBlank(params)) {
                    return this.offScreenData;
                }
                /** @type {?} */
                var data = this.offScreenData;
                if (core$1.isPresent(params) && params.has('offset') && params.has('limit')) {
                    /** @type {?} */
                    var offset = params.get('offset');
                    /** @type {?} */
                    var limit = params.get('limit');
                    if (data.length > (offset + limit)) {
                        data = data.slice(offset, offset + limit);
                    }
                    else {
                        data = data.slice(offset, data.length);
                    }
                }
                if (params.has('orderby') && params.has('selector')) {
                    this.sort(data, params.get('orderby'), params.get('selector'));
                }
                return data;
            };
        /**
         * @param {?} params
         * @return {?}
         */
        ArrayDataProvider.prototype.fetch = /**
         * @param {?} params
         * @return {?}
         */
            function (params) {
                return rxjs.of(this.dataForParams(params));
            };
        /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        ArrayDataProvider.prototype.sort = /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (arrayToSort, key, sortOrder) {
                arrayToSort.sort(function (data1, data2) {
                    /** @type {?} */
                    var value1 = core$1.FieldPath.getFieldValue(data1, key);
                    /** @type {?} */
                    var value2 = core$1.FieldPath.getFieldValue(data2, key);
                    /** @type {?} */
                    var result = null;
                    if (value1 == null && value2 != null) {
                        result = -1;
                    }
                    else if (value1 != null && value2 == null) {
                        result = 1;
                    }
                    else if (value1 == null && value2 == null) {
                        result = 0;
                    }
                    else if (typeof value1 === 'string' && typeof value2 === 'string') {
                        result = value1.localeCompare(value2);
                    }
                    else {
                        result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                    }
                    return (sortOrder * result);
                });
            };
        return ArrayDataProvider;
    }(DataProvider));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
     * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
     * provider or instantiate our implicit provider for native types such as Array.
     *
     *
     */
    var DataProviders = (function () {
        function DataProviders(registry) {
            this.registry = registry;
        }
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         */
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
        DataProviders.prototype.find = /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (core$1.isArray(target)) {
                    return new ArrayDataProvider(target);
                }
                else if (core$1.isString(target)) {
                    return this.registry.bestMatchForClass(target);
                }
                return this.registry.bestMatchForType(target);
            };
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         */
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataProviders.prototype.register = /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                this.registry.registerProvider(target, provider);
            };
        DataProviders.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DataProviders.ctorParameters = function () {
            return [
                { type: DataTypeProviderRegistry }
            ];
        };
        return DataProviders;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Provides a registry of different data Finders used mostly by DataSources. All Finders are
     * registered by this class as we don't have any needs right now to expose this to developer.
     *
     */
    var DataFinders = (function () {
        function DataFinders() {
            this.findersByType = new Map();
            this.initFinders();
        }
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         */
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
        DataFinders.prototype.find = /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
            function (forProvider, forType) {
                /** @type {?} */
                var finderMatch;
                this.findersByType.forEach(function (v, k) {
                    if (k.accepts(forProvider, forType)) {
                        finderMatch = v;
                        return true;
                    }
                });
                if (core$1.isPresent(finderMatch)) {
                    /** @type {?} */
                    var copy = new finderMatch();
                    copy.forData(forProvider);
                    return copy;
                }
                return null;
            };
        /**
         * Registers new finder
         *
         */
        /**
         * Registers new finder
         *
         * @template T
         * @param {?} prototype
         * @param {?} type
         * @return {?}
         */
        DataFinders.prototype.register = /**
         * Registers new finder
         *
         * @template T
         * @param {?} prototype
         * @param {?} type
         * @return {?}
         */
            function (prototype, type) {
                this.findersByType.set(prototype, type);
            };
        /**
         * @return {?}
         */
        DataFinders.prototype.initFinders = /**
         * @return {?}
         */
            function () {
                // create a prototype for each
                this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
                this.findersByType.set(new OutlineFullTextArrayDataFinder(), OutlineFullTextArrayDataFinder);
            };
        DataFinders.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DataFinders.ctorParameters = function () { return []; };
        return DataFinders;
    }());
    /** @enum {number} */
    var QueryType = {
        FullText: 0,
        FullTextOutline: 1,
        Predicate: 2,
        FullTextAndPredicate: 3,
    };
    QueryType[QueryType.FullText] = 'FullText';
    QueryType[QueryType.FullTextOutline] = 'FullTextOutline';
    QueryType[QueryType.Predicate] = 'Predicate';
    QueryType[QueryType.FullTextAndPredicate] = 'FullTextAndPredicate';
    /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */
    var /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */ DataFinder = (function () {
        function DataFinder() {
        }
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         */
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        DataFinder.prototype.accepts = /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return false;
            };
        /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         */
        /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
        DataFinder.prototype.match = /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
            function (query, max) {
                if (max === void 0) {
                    max = -1;
                }
                return core$1.unimplemented();
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        DataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return core$1.unimplemented();
            };
        return DataFinder;
    }());
    /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     */
    var /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     */ FullTextArrayDataFinder = (function (_super) {
        __extends(FullTextArrayDataFinder, _super);
        function FullTextArrayDataFinder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(FullTextArrayDataFinder.prototype, "lookupKey", {
            set: /**
             * @param {?} key
             * @return {?}
             */ function (key) {
                this._keyPath = core$1.isPresent(key) ? new core$1.FieldPath(key) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.accepts = /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
            };
        /**
         * @param {?} provider
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.forData = /**
         * @param {?} provider
         * @return {?}
         */
            function (provider) {
                this._provider = provider;
                return this;
            };
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatch = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                /** @type {?} */
                var list = this._provider.dataForParams(new Map().set('limit', max));
                return this.instantMatchWithSelections(list, query, max);
            };
        /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selectionsForMatch, query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                if (core$1.isBlank(query)) {
                    return selectionsForMatch;
                }
                /** @type {?} */
                var result = [];
                /** @type {?} */
                var toLowerPattern = query.toLowerCase();
                for (var i = 0; i < selectionsForMatch.length; i++) {
                    /** @type {?} */
                    var item = selectionsForMatch[i];
                    if (this.matches(item, toLowerPattern)) {
                        result.push(item);
                        if (result.length >= max) {
                            break;
                        }
                    }
                }
                return result;
            };
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         */
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matches = /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
            function (item, pattern) {
                /** @type {?} */
                var val = (core$1.isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
                if (core$1.isFunction(val)) {
                    val = val.call(item);
                }
                else if (core$1.isJsObject(item)) {
                    return this.hasObjectValue(item, pattern);
                }
                else {
                    return core$1.isBlank(pattern) ||
                        core$1.isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
                }
            };
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.match = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                return rxjs.of(this.instantMatch(query, max));
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return rxjs.of(this.instantMatchWithSelections(selections, query, max));
            };
        /**
         * @param {?} obj
         * @param {?} pattern
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.hasObjectValue = /**
         * @param {?} obj
         * @param {?} pattern
         * @return {?}
         */
            function (obj, pattern) {
                var _this = this;
                /** @type {?} */
                var values = core$1.objectValues(obj);
                /** @type {?} */
                var parentObj = core$1.objectToName(obj);
                /** @type {?} */
                var length2 = values.filter(function (value) {
                    if (core$1.isBlank(value) || core$1.isArray(value)) {
                        return false;
                    }
                    else if (!core$1.isJsObject(value) && !core$1.isFunction(value)) {
                        return value.toString().toLowerCase().indexOf(pattern) !== -1;
                    }
                    else if (core$1.isJsObject(value) && core$1.objectToName(value) !== parentObj) {
                        return _this.hasObjectValue(value, pattern);
                    }
                    return false;
                }).length;
                return length2 > 0;
            };
        return FullTextArrayDataFinder;
    }(DataFinder));
    /**
     * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
     * children on lowest level and moving up to the root and marking nodes that can be removed.
     *
     *  For simple data structure which operates on local array this should be good enough we this
     *  can never match with real DB full text search.
     *
     */
    var /**
     * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
     * children on lowest level and moving up to the root and marking nodes that can be removed.
     *
     *  For simple data structure which operates on local array this should be good enough we this
     *  can never match with real DB full text search.
     *
     */ OutlineFullTextArrayDataFinder = (function (_super) {
        __extends(OutlineFullTextArrayDataFinder, _super);
        function OutlineFullTextArrayDataFinder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.accepts = /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return forData instanceof ArrayDataProvider && forType === QueryType.FullTextOutline;
            };
        /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selectionsForMatch, query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                if (core$1.isBlank(query)) {
                    return selectionsForMatch;
                }
                /** @type {?} */
                var toLowerPattern = query.toLowerCase();
                /** @type {?} */
                var sourceToSearch = selectionsForMatch.slice();
                this.rollup(sourceToSearch, toLowerPattern);
                return this.shake(sourceToSearch);
            };
        /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         */
        /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         * @param {?} nodes
         * @param {?} query
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.rollup = /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         * @param {?} nodes
         * @param {?} query
         * @return {?}
         */
            function (nodes, query) {
                var _this = this;
                nodes.forEach(function (item) {
                    /** @type {?} */
                    var hasChildrenMatch = false;
                    if (core$1.isPresent(item.children) && item.children.length > 0) {
                        hasChildrenMatch = _this.rollup(item.children, query);
                    }
                    item.visible = hasChildrenMatch || _this.matches(item, query);
                });
                return nodes.some(function (item) { return item.visible; });
            };
        /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         */
        /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         * @param {?} nodes
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.shake = /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         * @param {?} nodes
         * @return {?}
         */
            function (nodes) {
                var _this = this;
                return nodes
                    .filter(function (node) { return node.visible; })
                    .map(function (node) { return (__assign({}, node, { isExpanded: node.visible, children: node.children && _this.shake(node.children) })); });
            };
        return OutlineFullTextArrayDataFinder;
    }(FullTextArrayDataFinder));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DATA_SOURCE = new core.InjectionToken('DATA_SOURCE');
    /**
     * DataSource describes basic functionality for handling stream of data specific to component
     *
     * It is expected that DataSource will be defined as component provider using
     *
     * \@Components ({
     *      ...
     *      providers:[
     *
     *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
     * deps: [DataProviders, DataFinders]
     *      ]
     *
     * })
     *
     *
     * so all the dependencies (DataProviders, DataFinders) are properly injected.
     *
     * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
     * Or you can use instant() method to retrieve current state of this DataSource (sync)
     *
     * @abstract
     */
    var DataSource = (function () {
        /**
         *
         * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
         * implementation
         *
         */
        function DataSource(dataProviders, finders) {
            this.dataProviders = dataProviders;
            this.finders = finders;
        }
        /**
         * Returns a data instantly from the internal state of DataProvider
         */
        /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
        DataSource.prototype.instant = /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        DataSource.MaxLength = 10;
        DataSource.MaxRecentSelected = 5;
        return DataSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var TopZoneComponent = (function () {
        function TopZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad ';
        }
        TopZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-top',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        TopZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return TopZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var LeftZoneComponent = (function () {
        function LeftZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        LeftZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-left',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        LeftZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return LeftZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var MiddleZoneComponent = (function () {
        function MiddleZoneComponent() {
            this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
        }
        MiddleZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-middle',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        MiddleZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return MiddleZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var RightZoneComponent = (function () {
        function RightZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        RightZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-right',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        RightZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return RightZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var BottomZoneComponent = (function () {
        function BottomZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        BottomZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-bottom',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        BottomZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return BottomZoneComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
     * include actual component such is DropDown or InputField but mainly provides a enough context for
     * the component to specify the size, how it should layout, whether we need to show required flag,
     * to show/hide labels in case if we have no label layout and much more.
     *
     * FormRow component also registers angular validator for the current row/field. As already
     * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
     * information to/from user and let somebody else to figure out where it appear and how.
     *
     * todo: Move under FormTable
     */
    var FormRowComponent = (function (_super) {
        __extends(FormRowComponent, _super);
        function FormRowComponent(env, 
        // Event this creates CI depends. Need to have a reference to parent
        // I need to refactor more parent to not use this child and refactor layouting
        parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Hides the label
             *
             */
            _this.noLabelLayout = false;
            /**
             * Renders row with highlighted background
             *
             */
            _this.highlightRow = false;
            /**
             *
             *  Field label that should appear above or next to the control
             *
             */
            _this.label = '';
            /**
             * Tells the form row that we are rendering another nested form in this row. so we need
             * to go 100%
             */
            _this.isNestedLayout = false;
            /**
             *
             * For single column layout without zones we need to apply grid directly to the FormRow tag
             * so we don't need to introduce extra div level
             *
             */
            _this.classList = '';
            _this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
            return _this;
        }
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         */
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
        FormRowComponent.prototype.ngOnInit = /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, null);
                this.registerValidators();
                this.omitPadding = this.parentContainer.omitPadding;
                this.classList += core$1.isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
                this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
                this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
            };
        Object.defineProperty(FormRowComponent.prototype, "size", {
            /**
             * Just a size getter
             *
             */
            get: /**
             * Just a size getter
             *
             * @return {?}
             */ function () {
                return this._size;
            },
            /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             */
            set: /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var isDynVal = false;
                if (core$1.StringWrapper.startsWidth(value, 'd-')) {
                    isDynVal = true;
                    value = value.substr(2, value.length - 1);
                }
                if (core$1.isPresent(value) && !this.isNestedLayout) {
                    this._size = value;
                    /** @type {?} */
                    var dSize = this.dynSize(value, isDynVal);
                    this._size = 'ui-g-12 ui-md-' + dSize;
                }
                else if (this.isNestedLayout) {
                    this._size = 'ui-g-12 ui-md-12';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FormRowComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
                if (core$1.isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
                    this.editable = this.parentContainer.editable;
                }
            };
        /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
        FormRowComponent.prototype.registerValidators = /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
            function () {
                /** @type {?} */
                var validators = [];
                if (core$1.isPresent(this.maxLength)) {
                    validators.push(forms.Validators.maxLength(this.maxLength));
                }
                if (core$1.isPresent(this.minLength)) {
                    validators.push(forms.Validators.minLength(this.minLength));
                }
                if (core$1.isPresent(this.required) && this.required) {
                    validators.push(forms.Validators.required);
                }
                if (core$1.isPresent(this.pattern)) {
                    validators.push(forms.Validators.pattern(this.pattern));
                }
                if (core$1.isPresent(this.customValidators)) {
                    core$1.ListWrapper.addAll(validators, this.customValidators);
                }
                if (validators.length === 1) {
                    this.formControl.setValidators(validators[0]);
                }
                else if (validators.length > 1) {
                    this.formControl.setValidators(forms.Validators.compose(validators));
                }
                if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
                    this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
                }
                else if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
                    this.formControl.setAsyncValidators(forms.Validators.composeAsync(this.customAsyncValidators));
                }
            };
        Object.defineProperty(FormRowComponent.prototype, "labelsOnTop", {
            /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             */
            get: /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._labelsOnTop) && core$1.isPresent(this.parentContainer)) {
                    return ((this.parentContainer)).isLabelsOnTop();
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
        FormRowComponent.prototype.dynSize = /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
            function (value, isDynValue) {
                /** @type {?} */
                var normalizeSize = value.toLowerCase().replace('-', '');
                if (core$1.isPresent(this.parentContainer) &&
                    ((this.parentContainer)).hasTwoColumn && isDynValue) {
                    /** @type {?} */
                    var enumValues = Object.keys(WidgetSizeColumns);
                    normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
                }
                return ((WidgetSizeColumns))[normalizeSize];
            };
        FormRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-row',
                        template: "<div *ngIf=\"!hidden\"\n     class=\"w-form-row ui-g\"\n     [class.highlight-row]=\"highlightRow\"\n     [class.required]=\"required\"\n     [class.label-on-top]=\"labelsOnTop\"\n     [class.label-on-side]=\"!labelsOnTop\"\n     [class.has-danger]=\"!formControl.valid && !formControl.pristine \"\n     [ngClass]=\"styleClass\">\n\n    <div class=\"control-label ui-g-12 ui-g-nopad\"\n         *ngIf=\"!noLabelLayout\"\n         [class.ui-md-3]=\"!labelsOnTop\">\n        <label [class.sr-only]=\"noLabelLayout\">{{label}}</label>\n    </div>\n\n    <div class=\"control-value ui-g-nopad\" [ngClass]=\"size\"\n         [class.read-only]=\"!editable\">\n        <ng-content></ng-content>\n        <a-error-messages [control]=\"formControl\"></a-error-messages>\n    </div>\n</div>\n",
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormRowComponent; }) }
                        ],
                        styles: [".required label:after{content:\"*\";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.w-form-row .w-form-row{padding-top:.5em;padding-bottom:.5em}.control-label{color:#636363}.u-validation-error{border-color:red}"]
                    }] }
        ];
        /** @nocollapse */
        FormRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: FormTableComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormTableComponent; }),] }] }
            ];
        };
        FormRowComponent.propDecorators = {
            noLabelLayout: [{ type: core.Input }],
            highlightRow: [{ type: core.Input }],
            label: [{ type: core.Input }],
            maxLength: [{ type: core.Input }],
            minLength: [{ type: core.Input }],
            pattern: [{ type: core.Input }],
            customAsyncValidators: [{ type: core.Input }],
            customValidators: [{ type: core.Input }],
            isNestedLayout: [{ type: core.Input }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            size: [{ type: core.Input }]
        };
        return FormRowComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * FormTable is a specific layout component for rendering Labels and its controls in two columns
     * and 5 different zones.
     *
     * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
     * This
     * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
     * fields in the form I do not want controls to be aware of error validation, size, labels, and
     * some other things. Control such INPUT is just responsible for retrieve user value but not how it
     * appear on the page.
     *
     * This way we can be flexible how we treat widgets for different kinds of situation depending
     * where they appear
     * FormTable just like the rest of the components are using Model driven approach how to work with
     * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
     * otherwise its automatically created when the FormTable is instantiated.
     *
     * FormGroup is saved insode Environment where we are using this to pass this around the pages and
     * components.
     *
     * ### Example
     *
     * Simple Layout fields and its control
     *
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: `
     *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
     *  				<aw-form-row [label]="'name'" [name]="'name'">
     *  					<aw-input-field [type]="'string'"></aw-input-field>
     *  				</aw-form-row>
     *
     *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *  					<aw-checkbox-list [list]="checkBoxListValues"
     *  					                 [selections]="selectedValues"
     *  					                 [layout]="'inline'"
     *  					                 (onSelection)="onCBClick($event)">
     *  					</aw-checkbox-list>
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
     *
     *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *
     *  					</aw-radiobutton-list>
     *
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
     *
     *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
     *  					</aw-date-time>
     *  				</aw-form-row>
     *  			</aw-form-table>
     *    `
     *  })
     *  export class ShowUserInfoComponent
     *  {
     *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
     *     , 'black' , 'Green'
     *     , 'Gray' , 'Navy' ,
     *          'Olive' , 'Aqua' , 'Purple'];
     *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *      rbValues: string[] = ['male' , 'female' , 'other'];
     *      rbSelection: string = 'male';
     *      editable: boolean = true;
     *      showTime: boolean = true;
     *
     *      formGroup: FormGroup = new FormGroup({});
     *
     *
     *      onCBClick (event): void
     *      {
     *          console.log('onCBClick = ' + event);
     *      }
     *
     *      onSubmit (model: any): void
     *      {
     *         console.log(model)
     *
     *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
     *     male}
     *      }
     *
     *  }
     *
     *  ```
     *
     *  Or you can use zone to layout these fields into two columns:
     *
     *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
     *     specific pattern. In our case instead of creating extra wrapper custom component use simple
     *     CSS class
     *
     *
     *  ```
     *            <aw-form-table #metaFormTable [editable]="editing"
     *                          [useFiveZone]="isFiveZoneLayout"
     *                          (onSubmit)="onSaveAction($event)">
     *
     *                <aw-left  *ngIf="canShowZone('zLeft')">
     *
     *                        <aw-form-row [label]="'name'" [name]="'name'">
     *                            <aw-input-field [type]="'string'"></aw-input-field>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *                            <aw-checkbox-list [list]="checkBoxListValues"
     *                                             [selections]="selectedValues"
     *                                             [layout]="'inline'"
     *                                             (onSelection)="onCBClick($event)">
     *                            </aw-checkbox-list>
     *                        </aw-form-row>
     *                </aw-left>
     *
     *
     *                <aw-right  *ngIf="canShowZone('zRight')">
     *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
     *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *                                </aw-radiobutton-list>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
     *     [size]="'small'">
     *                            <aw-date-time [value]="date" [editable]="editable"
     *     [showTime]="showTime">
     *                            </aw-date-time>
     *                        </aw-form-row>
     *                </<aw-right>
     *            </aw-form-table>
     *
     *  ```
     *
     *  todo: remove my css selectors for zones and replace it with real component even just a tag
     *  todo: would work file
     *
     */
    var FormTableComponent = (function (_super) {
        __extends(FormTableComponent, _super);
        function FormTableComponent(env) {
            var _this = _super.call(this, env, null) || this;
            _this.env = env;
            /**
             * Used for the form layout to see if we need to render labels stacked  or side by side next to
             * the control
             *
             */
            _this.labelsOnTop = false;
            /**
             *
             * Is this a 4 zone layout
             *
             */
            _this.useFiveZone = false;
            /**
             * For certain usecase we dont want to set automatically this to all children
             */
            _this.editabilityCheck = true;
            /**
             *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
             *
             *
             */
            _this.onSubmit = new core.EventEmitter();
            /**
             * Cache calculated properties when init this component
             *
             */
            _this.hasOneColumn = false;
            _this.hasTwoColumn = false;
            _this.hasThreeColumn = false;
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        FormTableComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['editable']) &&
                    changes['editable'].previousValue !== changes['editable'].currentValue) {
                    this.updateFormFields();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FormTableComponent.prototype.onSubmitForm = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onSubmit.emit(event);
            };
        /**
         *
         * Are labels on top
         *
         */
        /**
         *
         * Are labels on top
         *
         * @return {?}
         */
        FormTableComponent.prototype.isLabelsOnTop = /**
         *
         * Are labels on top
         *
         * @return {?}
         */
            function () {
                return this.labelsOnTop;
            };
        /**
         *
         * Used by child component to inherit editability
         *
         */
        /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
        FormTableComponent.prototype.isFormEditable = /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
            function () {
                return this.editable;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.applyColumns = /**
         * @return {?}
         */
            function () {
                if (!this.useFiveZone && this.hasAnyZones()) {
                    throw new Error('Zones detected in the FormTable but useFiveZone option is false');
                }
                this.hasOneColumn = !core$1.isPresent(this.rightZone) && !core$1.isPresent(this.middleZone);
                this.hasTwoColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    !core$1.isPresent(this.middleZone);
                this.hasThreeColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    core$1.isPresent(this.middleZone);
                if (this.hasTwoColumn && !this.isTwoZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-6';
                    this.rightZone.classList += ' ui-md-6 ui-lg-6';
                }
                if (this.hasThreeColumn && !this.isThreeZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-4';
                    this.rightZone.classList += ' ui-md-6 ui-lg-4';
                }
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.hasAnyZones = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.leftZone) || core$1.isPresent(this.rightZone) || core$1.isPresent(this.middleZone)
                    || core$1.isPresent(this.topZone) || core$1.isPresent(this.bottomZone);
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isTwoZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-6') > 0;
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isThreeZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-4') > 0;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // problem since Angular 4.2, ngAfterContentInit
                // without this I get error that value was changed after view was checked
                // todo: refactor  - mainly our zones left, right middle
                setTimeout(function () {
                    _this.applyColumns();
                    _this.updateFormFields();
                    _this.adjustLayout();
                });
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.updateFormFields = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.editabilityCheck && core$1.isPresent(this.formFields) && this.formFields.length > 0) {
                    this.formFields.forEach(function (item) {
                        item.editable = _this.editable;
                        // item.formGroup = this.formGroup;
                    });
                }
            };
        /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
        FormTableComponent.prototype.adjustLayout = /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.rows) && this.rows.length > 0) {
                    if (this.hasThreeColumn) {
                        this.rows.forEach(function (item) { return item.size = 'large'; });
                    }
                }
            };
        FormTableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-table',
                        template: "<form class=\"w-form-table ui-g ui-fluid\" [formGroup]=\"formGroup\"\n      [ngClass]=\"styleClass\"\n      (ngSubmit)=\"onSubmitForm(formGroup.value)\" novalidate>\n\n    <div class=\"ui-g-12 ui-g-nopad\">\n\n        <div class=\"ui-g\">\n            <ng-content></ng-content>\n        </div>\n\n    </div>\n</form>\n\n",
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormTableComponent; }) }
                        ],
                        styles: [".page-container>form{margin-top:1em}.w-form-table button{float:right}"]
                    }] }
        ];
        /** @nocollapse */
        FormTableComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        FormTableComponent.propDecorators = {
            labelsOnTop: [{ type: core.Input }],
            useFiveZone: [{ type: core.Input }],
            editabilityCheck: [{ type: core.Input }],
            onSubmit: [{ type: core.Output }],
            leftZone: [{ type: core.ContentChild, args: [LeftZoneComponent,] }],
            middleZone: [{ type: core.ContentChild, args: [MiddleZoneComponent,] }],
            rightZone: [{ type: core.ContentChild, args: [RightZoneComponent,] }],
            topZone: [{ type: core.ContentChild, args: [TopZoneComponent,] }],
            bottomZone: [{ type: core.ContentChild, args: [BottomZoneComponent,] }],
            formFields: [{ type: core.ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
            rows: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return FormRowComponent; }), { descendants: true },] }]
        };
        return FormTableComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWFormTableModule = (function () {
        function AWFormTableModule() {
        }
        AWFormTableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        exports: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ]
                    },] }
        ];
        return AWFormTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * This component represent a Input field and it can  accept different types of values such as
     * text, number.
     *
     *
     *
     * ### Example
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *
     *
     * ### Example wher input field is initialized with ngModel
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
     *
      @type {?} */
    var INPUT_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return InputFieldComponent; }),
        multi: true
    };
    var InputFieldComponent = (function (_super) {
        __extends(InputFieldComponent, _super);
        function InputFieldComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to save and read  when rendering and updating a component
             *
             */
            _this.value = '';
            /**
             * The formatted decimal value. Uses angular decimalPipe to format based on locale.
             */
            _this.displayValue = '';
            /**
             * Input field type. Currently we support either Number or text
             */
            _this._type = 'string';
            _this.decimalPipe = new common.DecimalPipe(env.locale);
            return _this;
        }
        Object.defineProperty(InputFieldComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this._type;
            },
            /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             */
            set: /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
                    this._type = 'text';
                }
                else if (value.toLowerCase() === 'number') {
                    this._type = 'number';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.bigDecimal);
                this.vchSubscriber = this.formControl.valueChanges
                    .pipe(operators.distinctUntilChanged())
                    .subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
                if (this.bigDecimal) {
                    this.displayValue = this.formatNumber(this.bigDecimal.amount);
                }
                else {
                    this.displayValue = this.value;
                }
            };
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.canSetType = /**
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * @param {?} el
         * @return {?}
         */
        InputFieldComponent.prototype.onKeyDown = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._type === 'number') {
                    this.displayValue = el.value;
                    this.onModelChanged(this.displayValue);
                }
            };
        /**
         * @param {?} el
         * @return {?}
         */
        InputFieldComponent.prototype.onBlur = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._type === 'number') {
                    this.bigDecimal = new BigDecimal(Number(el.value));
                    this.displayValue = this.formatNumber(this.bigDecimal.amount);
                    this.onModelChanged(this.displayValue);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.displayValue) {
                    this.value = value;
                    this.displayValue = '';
                    if (this.value) {
                        this.displayValue = this.value;
                    }
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        /**
         * Format the number object according to its precision.
         *
         */
        /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.formatNumber = /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!value) {
                    return '';
                }
                // If precision is present, use it for format the bigDecimal value for display.
                if (core$1.isPresent(this.precision) &&
                    this._type === 'number') {
                    /** @type {?} */
                    var digits = '1.0-2';
                    digits = '1.0-' + this.precision;
                    return this.decimalPipe.transform(value, digits);
                }
                return value;
            };
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.vchSubscriber)) {
                    this.vchSubscriber.unsubscribe();
                }
            };
        InputFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-input-field',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\" class=\"w-input-wrapper\">\n\n    <input pInputText\n           #inputFieldValue\n           [attr.name]=\"name\"\n           [attr.type]=\"type\"\n           class=\"w-input-field\"\n           [ngClass]=\"styleClass\"\n           [class.has-icon]=\"icon\"\n           placeholder=\"{{placeHolder}}\"\n           [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n           formControlName=\"{{name}}\"\n           (keydown)=\"onKeyDown(inputFieldValue)\"\n           (blur)=\"onBlur(inputFieldValue)\"\n           [value]=\"displayValue\">\n    <span *ngIf=\"icon\" class=\"sap-icon\" [ngClass]=\"icon\"></span>\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"displayValue\"></aw-string>\n</ng-template>\n",
                        providers: [
                            INPUT_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return InputFieldComponent; }) }
                        ],
                        styles: [".w-input-wrapper{position:relative}.w-input-field{padding-right:35px}.w-input-field~span{top:13px;position:absolute;right:15px}"]
                    }] }
        ];
        /** @nocollapse */
        InputFieldComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        InputFieldComponent.propDecorators = {
            value: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            bigDecimal: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            type: [{ type: core.Input }]
        };
        return InputFieldComponent;
    }(BaseFormComponent));
    /**
     * BigDecimal object is represented as a value, locale, and currencyCode
     */
    var /**
     * BigDecimal object is represented as a value, locale, and currencyCode
     */ BigDecimal = (function () {
        function BigDecimal(amount, locale) {
            if (amount === void 0) {
                amount = 0;
            }
            if (locale === void 0) {
                locale = 'en_US';
            }
            this.amount = amount;
            this.locale = locale;
        }
        /**
         * @return {?}
         */
        BigDecimal.prototype.getTypes = /**
         * @return {?}
         */
            function () {
                return {
                    amount: Number,
                    locale: String
                };
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.className = /**
         * @return {?}
         */
            function () {
                return 'BigDecimal';
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.$proto = /**
         * @return {?}
         */
            function () {
                return new BigDecimal(1, 'en_US');
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.amount + ', locale: ' + this.locale;
            };
        /**
         * @param {?=} data
         * @return {?}
         */
        BigDecimal.prototype.clone = /**
         * @param {?=} data
         * @return {?}
         */
            function (data) {
                if (data === void 0) {
                    data = {};
                }
                return new BigDecimal(core$1.isPresent(data.amount) ? data.amount : this.amount, core$1.isPresent(data.locale) ? data.locale : this.locale);
            };
        return BigDecimal;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWStringFieldModule = (function () {
        function AWStringFieldModule() {
        }
        AWStringFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StringComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule
                        ],
                        entryComponents: [
                            StringComponent
                        ],
                        exports: [
                            StringComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWStringFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWInputFieldModule = (function () {
        function AWInputFieldModule() {
        }
        AWInputFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            InputFieldComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            InputFieldComponent
                        ],
                        exports: [
                            InputFieldComponent,
                            AWStringFieldModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWInputFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * basic navigation bar provide a main action buttons for its content (page level buttons).
     * This is not the Top level application navigation. This component provides by default action OK,
     * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
     * event. Or you can provide your own buttons template which will be used instead of this default
     * one.
     *
     *
     *
     *
     *
     * ### Example 1:
     *
     * In order to use navigation bar in its basic usage you can do following:
     * this will render buttons on the top as well as on the bottom around the content.
     *
     *
     *  ```html
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     *  if you do not want button on the top or bottom you can say thi using binding showTop or
     * showBottom.
     *
     *
     * ### Example 2:
     *  In this example we are providing custom buttons as well as brank section
     *
     *
     *  ```html
     *
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *            <ng-template #buttons>
     *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
     *                    <li class="nav-item ">
     *                        <button class="btn btn-secondary" type="button"
     * (click)="onSaveAction($evemt)">Cancel</button>
     *                    </li>
     *                    <li class="nav-item active">
     *                        <button class="btn btn-primary" type="button"
     * (click)="onCancelAction($event)"> Save
     *                        </button>
     *                    </li>
     *                </ul>
     *            </ng-template>
     *
     *            <ng-template #brand>
     *                <span class="brand-title">Ariba</span>
     *            </ng-template>
     *
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     */
    var BasicNavigatorComponent = (function (_super) {
        __extends(BasicNavigatorComponent, _super);
        function BasicNavigatorComponent(env, appConfig) {
            var _this = _super.call(this, env) || this;
            /**
             * Indicates that buttons will be rendered on the top
             *
             * Default value is TRUE
             *
             */
            _this.showTop = true;
            /**
             * Indicates that buttons will be rendered on the bottom
             *
             * Default value is TRUE
             *
             */
            _this.showBottom = true;
            /**
             * Indicates that brand section that is on the left side and only in the top bar is visible
             *
             * Default value is TRUE
             *
             */
            _this.showBrand = true;
            /**
             *
             * EventEmitter that is triggered when you click on default OK Action
             *
             */
            _this.onOKAction = new core.EventEmitter();
            /**
             *
             * EventEmitter that is triggered when you click on default CANCEL Action
             *
             */
            _this.onCancelAction = new core.EventEmitter();
            // todo: load this from resource file using ngTranslate service
            // todo: load this from resource file using ngTranslate service
            _this.okActionLabel = 'OK';
            _this.cancelActionLabel = 'Cancel';
            _this.brandImg = 'images/aribalogobal.png';
            return _this;
        }
        /**
         * @return {?}
         */
        BasicNavigatorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.showCancelButton)) {
                    this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                        && this.onOKAction.observers.length > 0);
                }
            };
        /**
         * Returns if buttonsTemplate is available
         *
         */
        /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasButtonTemplate = /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.buttonsTemplate);
            };
        /**
         * Returns if brandTemplate is available
         *
         */
        /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasBrandTemplate = /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.brandTemplate);
            };
        BasicNavigatorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-basic-navigator',
                        template: "<p-toolbar *ngIf=\"showTop\" [class]=\"'w-basic-navigator'\">\n    <div class=\"ui-toolbar-group-left\">\n\n        <a class=\"nav-brand\" href=\"#\" *ngIf=\"showBrand\">\n            <ng-template [ngIf]=\"!hasBrandTemplate()\">\n                <img src=\"{{assetFolder}}/{{brandImg}}\" height=\"30\" alt=\"\">\n                <span class=\"nav-brand-title\">Ariba</span>\n            </ng-template>\n\n            <ng-template [embeddedItem]=\"brandTemplate\" [item]=\"context\"\n                         *ngIf=\"hasBrandTemplate()\"></ng-template>\n        </a>\n\n    </div>\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n\n\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n<ng-content></ng-content>\n\n<p-toolbar *ngIf=\"showBottom\">\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n\n\n",
                        styles: ["a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}"]
                    }] }
        ];
        /** @nocollapse */
        BasicNavigatorComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core$1.AppConfig }
            ];
        };
        BasicNavigatorComponent.propDecorators = {
            showTop: [{ type: core.Input }],
            showBottom: [{ type: core.Input }],
            showBrand: [{ type: core.Input }],
            brandImg: [{ type: core.Input }],
            okActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            context: [{ type: core.Input }],
            showCancelButton: [{ type: core.Input }],
            onOKAction: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            buttonsTemplate: [{ type: core.ContentChild, args: ['buttons',] }],
            brandTemplate: [{ type: core.ContentChild, args: ['brand',] }]
        };
        return BasicNavigatorComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Button component that implements consistent styling, behavior. Button can be rendered either as
     * a button or as a link. It could be standalone or be part of a form.
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *   <aw-form-table >
     *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
     *
     *           <aw-button [type]="'submit'" [name]="'button'"
     *                     (action)="onClicked($event)" [value]="command"
     *                     [style]="'warning'" >Button</aw-button>
     *       </aw-form-row>
     *   </aw-form-table>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(value:string) {
     *           if (value) {
     *              // submit form.
     *           }
     *        }
     *    }
     */
    var ButtonComponent = (function (_super) {
        __extends(ButtonComponent, _super);
        function ButtonComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Button types  [ button | submit | reset ]
             *
             */
            _this.type = 'button';
            /**
             * styling for this button. See ButtonStyle for all supported styles.
             */
            _this.style = 'primary';
            /**
             * sizing for this button. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            // Default button class is secondary.
            // Default button class is secondary.
            _this.buttonClass = 'ui-button-secondary';
            // Default disabled
            // Default disabled
            _this.disabled = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // How to style this button.
                if (core$1.isPresent(this.style)) {
                    if (this.style === 'primary') {
                        // Default .ui-button and .ui-button-primary get the same style.
                        // .ui-button-primary is necessary because button style can be overridden
                        // when included inside other widgets. So specify primary
                        this.buttonClass = 'ui-button-primary';
                    }
                    else {
                        this.buttonClass = 'ui-button-' + this.style;
                    }
                }
                // Determine the button class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.buttonClass += ' btn-lg';
                            break;
                        case 'normal':
                            this.buttonClass += ' btn-mid';
                            break;
                        case 'small':
                            this.buttonClass += ' btn-sm';
                            break;
                    }
                }
            };
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * @Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         */
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
        ButtonComponent.prototype.ngAfterViewInit = /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.element)) {
                    /** @type {?} */
                    var button = this.element.nativeElement.querySelector('button');
                    /** @type {?} */
                    var buttonTitle = button.children[0];
                    button.children[0].textContent = this.element.nativeElement.textContent.trim()
                        .replace('ui-button', '').replace('ui-btn', '');
                    button.classList.remove('ui-button-text-empty');
                    button.textContent = '';
                    button.appendChild(buttonTitle);
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
        ButtonComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                this.action.emit(core$1.isBlank(this.value) ? $event : this.value);
            };
        ButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-button',
                        template: "<button\n    pButton\n    [attr.type]=\"type\"\n    [attr.name]=\"name\"\n    [ngClass]=\"buttonClass\"\n    [disabled]=\"disabled\"\n    [attr.value]=\"value\"\n    (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</button>\n",
                        styles: [".ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}"]
                    }] }
        ];
        /** @nocollapse */
        ButtonComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        ButtonComponent.propDecorators = {
            type: [{ type: core.Input }],
            name: [{ type: core.Input }],
            style: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return ButtonComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWButtonModule = (function () {
        function AWButtonModule() {
        }
        AWButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ButtonModule,
                        ],
                        entryComponents: [
                            ButtonComponent
                        ],
                        exports: [
                            ButtonComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWBasicNavigatorModule = (function () {
        function AWBasicNavigatorModule() {
        }
        AWBasicNavigatorModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BasicNavigatorComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ToolbarModule,
                            AWButtonModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            BasicNavigatorComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWBasicNavigatorModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CardZoneTopComponent = (function () {
        function CardZoneTopComponent() {
        }
        CardZoneTopComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-top",
                        host: {
                            'class': 'w-card-ztop'
                        }
                    },] }
        ];
        return CardZoneTopComponent;
    }());
    var CardZoneBottomComponent = (function () {
        function CardZoneBottomComponent() {
        }
        CardZoneBottomComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-bottom",
                        host: {
                            'class': 'w-card-zbottom'
                        }
                    },] }
        ];
        return CardZoneBottomComponent;
    }());
    /**
     *
     * Card component is a container rendering its content inside 3 different zones.
     *
     *  ------------------------------------------
     *  |   TITLE                       | ACTION |
     *  |-----------------------------------------
     *  |                                        |
     *  |   TOP                                  |
     *  |                                        |
     *  ------------------------------------------
     *  |                                        |
     *  |   BOTTOM                               |
     *  |                                        |
     *  |                                        |
     *  ------------------------------------------
     *
     *
     *  There are 3 zones  + 1 placeholder for the actionIcon
     *
     *  Cards can be selectable which means when you click on it there will be rendered a border with
     *  a check mark inside Action zone (this is default behavior).
     *  You can use [selectable] binding to disable this, in such case card will have just a border
     *  without any check mark.
     *
     *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
     *  application level you can listen for (click) events as well as you can provide your own action
     *  icon
     *
     *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
     *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
     *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
     *  only one action which click on the hover overlay.
     *
     *
     * ###example 1:
     *  Basic hover card which by default support selectable mode
     *
     * ```
     *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *  ###example 2:
     *   Hover card with custom action. when unselected action will appear and user can click on it.
     *
     * ```
     *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
     *                     (onAction)="onAction(3, $event)">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *
     *
     */
    var CardComponent = (function (_super) {
        __extends(CardComponent, _super);
        function CardComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Tells if we should explicitly hide the action
             *
             */
            _this.hasAction = false;
            /**
             *
             * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
             * ACTION zone when selected
             *
             */
            _this.selectable = true;
            /**
             * Option to pass custom "Card Selected" Icon
             *
             */
            _this.selectedIcon = 'icon-accept';
            /*
                 * Enable and disables hover effect on top of the card
                 */
            _this.hasHover = false;
            /**
             *
             * Default icon name for the hover overlay. This icons shows up in the middle over the card
             * vertically and horizontally centered
             *
             */
            _this.hoverIcon = 'icon-add';
            /**
             *  Selection state
             *
             */
            _this.selected = true;
            /**
             * Fired when the card is selected.
             *
             */
            _this.onSelect = new core.EventEmitter();
            /**
             * Fired when action icon is clicked.
             *
             */
            _this.onAction = new core.EventEmitter();
            /**
             * Fired when the user clicks on the hover overlay.
             *
             */
            _this.onHoverAction = new core.EventEmitter();
            /**
             * Usually when template is provided we want to use it and replace internal one but in this
             * case it will be always conditional and application developer can switch between default
             * template with zones and custom one provided by developer.
             *
             */
            _this.useBodyTemplate = false;
            // sets default value
            // sets default value
            _this.width = '202px';
            _this.height = '154px';
            return _this;
        }
        /**
         * @return {?}
         */
        CardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If application wants to use action it must provide actionIcon
                if (core$1.isBlank(this.actionIcon) && this.hasAction) {
                    throw new Error('You need to provide action icon');
                }
            };
        /**
         * @return {?}
         */
        CardComponent.prototype.showBottomSection = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bottom);
            };
        /**
         * fires select and unselect event.
         */
        /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.toggleSelect = /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.selectable) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    this.selected = !this.selected;
                    this.onSelect.emit(this.selected);
                }
            };
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         */
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.onActionClick = /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.hasAction && (!this.selected || !this.selectable)) {
                    this.onAction.emit(this.selected);
                }
            };
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         */
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
        CardComponent.prototype.onHover = /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
            function (isEnter) {
                if (core$1.isPresent(this.hoverDiv)) {
                    this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
                }
            };
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         */
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
        CardComponent.prototype.showBodyTemplate = /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bodyTemplate) && this.useBodyTemplate;
            };
        CardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-card',
                        template: "<div class=\"w-card\" [style.width]=\"width\" [style.height]=\"height\"\n     [class.u-is-hover]=\"hasHover\"\n     (mouseenter)=\"onHover(true)\"\n     (mouseleave)=\"onHover(false)\"\n     [class.u-card-selected]=\"selected\"\n     [class.u-card-unselected]=\"!selected\"\n     [ngClass]=\"styleClass\"\n>\n\n    <div class=\"card-body ui-g\"  *ngIf=\"!showBodyTemplate()\">\n        <!-- Hover element that is triggered by mouseenter, mouseleave events-->\n        <div #hoverDiv *ngIf=\"hasHover\" class=\"u-card-hover\" (click)=\"onHoverAction.emit($event)\">\n            <span [style.width]=\"'100%'\" class=\"sap-icon\" [ngClass]=\"hoverIcon\"></span>\n        </div>\n        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->\n        <div class=\"ui-g-12 ui-g-nopad w-card-header\">\n            <div class=\"w-card-ztitle ui-g-nopad\" (click)=\"toggleSelect($event)\"\n                 [class.u-card-pointer]=\"selectable\"\n                 [ngClass]=\"{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}\">\n                <ng-content select=\"aw-card-title\"></ng-content>\n            </div>\n\n            <div *ngIf=\"hasAction || selectable\" class=\"w-card-zaction ui-g-nopad ui-g-3\">\n\n                <span *ngIf=\"selected && selectable\" class=\"sap-icon selection\"\n                      [class.u-card-pointer]=\"selectable\"\n                      [class.u-card-action-bg]=\"selected\"\n                      (click)=\"toggleSelect($event)\"\n                      [ngClass]=\"selectedIcon\"></span>\n\n\n                <span *ngIf=\"hasAction && (!selected || !selectable) \"\n                      class=\"sap-icon action\"\n                      [class.u-card-pointer]=\"true\"\n                      (click)=\"onActionClick($event)\"\n                      [ngClass]=\"actionIcon\"\n                ></span>\n            </div>\n        </div>\n\n        <!--TOP CARD SECTION-->\n        <div class=\"w-card-ztop ui-g-nopad ui-g-12 \"\n             (click)=\"toggleSelect($event)\"\n             [class.u-card-pointer]=\"selectable\">\n            <ng-content select=\"aw-card-top\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-g-nopad w-card-line-divider  \" *ngIf=\"showBottomSection()\"></div>\n        <!--BOTTOM CARD SECTION-->\n        <div *ngIf=\"showBottomSection()\" class=\"ui-g-12 ui-g-nopad w-card-zbottom\"\n             [class.u-card-pointer]=\"selectable\"\n             (click)=\"toggleSelect($event)\">\n            <ng-content select=\"aw-card-bottom\"></ng-content>\n        </div>\n    </div>\n\n    <div *ngIf=\"showBodyTemplate()\" class=\"w-card-user-cnt\" >\n        <ng-container *ngTemplateOutlet=\"bodyTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n",
                        styles: [".w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}"]
                    }] }
        ];
        /** @nocollapse */
        CardComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        CardComponent.propDecorators = {
            hasAction: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            selectedIcon: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            hasHover: [{ type: core.Input }],
            hoverIcon: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            onSelect: [{ type: core.Output }],
            onAction: [{ type: core.Output }],
            onHoverAction: [{ type: core.Output }],
            bottom: [{ type: core.ContentChild, args: [CardZoneBottomComponent,] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }],
            hoverDiv: [{ type: core.ViewChild, args: ['hoverDiv',] }]
        };
        return CardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Maps our internal alignment value to real css values
     *
      @type {?} */
    var VAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'flex-start',
        'top-right': 'flex-start',
        'center-left': 'center',
        'center-center': 'center',
        'center-right': 'center',
        'bottom-left': 'flex-end',
        'bottom-center': 'flex-end',
        'bottom-right': 'flex-end'
    };
    /** @type {?} */
    var HAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'center',
        'top-right': 'flex-end',
        'center-left': 'flex-start',
        'center-center': 'center',
        'center-right': 'flex-end',
        'bottom-left': 'flex-start',
        'bottom-center': 'center',
        'bottom-right': 'flex-end'
    };
    /**
     * Title zone provides a content placeholder for the Title Area. This zone is adding ability
     * to align its content into 9 different position.
     *
     * You can use this Title zone within <aw-card> as:
     *
     *
     * ```html
     *
     *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
     *                       [selectable]="false" [hasAction]="false"
     *                  (onHoverAction)="onAction(7, $event)" >
     *
     *                  <aw-card-title [align]="'bottom-left'">
     *                      <span class="a-supplier-tag">
     *                          Preferred
     *                      </span>
     *                  </aw-card-title>
     *
     *   </aw-card>
     *
     * ```
     * Default alignment is top-left
     *
     *
     *
     *
     */
    var CardZoneTitleComponent = (function (_super) {
        __extends(CardZoneTitleComponent, _super);
        function CardZoneTitleComponent(env, elem) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elem = elem;
            /**
             * Special property which is used to apply flex properties for aligning content vertically
             * as well as horizontally
             *
             */
            _this.align = 'top-left';
            return _this;
        }
        /**
         * @return {?}
         */
        CardZoneTitleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
                this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
            };
        CardZoneTitleComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-title",
                        host: {
                            'class': 'w-card-title'
                        }
                    },] }
        ];
        /** @nocollapse */
        CardZoneTitleComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        CardZoneTitleComponent.propDecorators = {
            align: [{ type: core.Input }]
        };
        return CardZoneTitleComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWCardModule = (function () {
        function AWCardModule() {
        }
        AWCardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        entryComponents: [
                            CardComponent
                        ],
                        exports: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     *
     * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
     * {\@link CheckboxComponent}: form and action checkbox as described above.
     *
     *
     * Usage: Basic example having red checkbox checked
     *
     * ```HTML
     *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
     *                                        [(ngModel)]="model">
     *        </aw-checkbox>
     *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                                        [(ngModel)]="model">
     *       </aw-checkbox>
     *
     * ```
     *
     * ```ts
     *
     *
     *   class CBBasicWithNgModelComponent
     *   {
     *
     *       model: string[] = ['red'];
     *
     *       constructor()
     *       {
     *       }
     *   }
     *
     * ```
     *
     * For more examples please see a playground or unit test.
     *
      @type {?} */
    var CB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var CheckboxComponent = (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this checkbox
             *
             */
            _this.value = '';
            /**
             * Type of checkbox. Form based updates model and Action based only fires click events
             *
             */
            _this.type = 'form';
            /**
             * Trigger click event.
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
             * remove values.
             *
             * In our case Checktype = Action is always binary or when this.value is boolean
             *
             */
            _this.isBinary = false;
            return _this;
        }
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.model = this.value;
                this.type = this.action.observers.length > 0 ? 'action' : this.type;
                if (this.isFormType()) {
                    _super.prototype.ngOnInit.call(this);
                    if (this.isStandalone) {
                        _super.prototype.registerFormControl.call(this, this.value);
                        this.model = this.formControl.value;
                        this.onModelChanged(this.model);
                    }
                    else {
                        // get control from parent
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // When value is boolean we are dealing with PrimeNg Binary checkbox
                // which only sets TRUE/FALSE and does not add or remove values
                this.isBinary = core$1.isBoolean(this.value);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['value']) &&
                    (changes['value'].currentValue !== changes['value'].previousValue)) {
                    this.model = changes['value'].currentValue;
                }
            };
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         */
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
        CheckboxComponent.prototype.onChange = /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFormType()) {
                    this.onModelChanged(this.model);
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model);
                    }
                }
                else {
                    this.action.emit(event);
                }
            };
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         */
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
        CheckboxComponent.prototype.isFormType = /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
            function () {
                return this.type === 'form';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model && this.isFormType()) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.onModelChanged(this.model);
                        this.formControl.setValue(this.model);
                    }
                }
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox',
                        template: "<span class=\"w-checkbox\">\n\n    <ng-template [ngIf]=\"editable && isFormType()\">\n        <p-checkbox [name]=\"name\" [value]=\"value\" [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    [binary]=\"isBinary\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\"\n                    [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        >\n        </p-checkbox>\n    </ng-template>\n\n\n    <ng-template [ngIf]=\"!isFormType()\">\n        <p-checkbox [binary]=\"isBinary\"\n                    [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\">\n        </p-checkbox>\n\n    </ng-template>\n</span>\n",
                        providers: [
                            CB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckboxComponent; }) }
                        ],
                        styles: ["/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}"]
                    }] }
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        CheckboxComponent.propDecorators = {
            value: [{ type: core.Input }],
            type: [{ type: core.Input }],
            label: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return CheckboxComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWCheckBoxModule = (function () {
        function AWCheckBoxModule() {
        }
        AWCheckBoxModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckboxComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CheckboxModule
                        ],
                        entryComponents: [
                            CheckboxComponent
                        ],
                        exports: [
                            CheckboxComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWCheckBoxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
     * component
     *
     * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
     * primitive values.
     *
     * @see {\@link check-box/check-box.component.ts}
     *
     *
     * ### Example
     *
     *
     * \@Component({
     *       selector: 'showCheckBoxList' ,
     *       template: `
     *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
     *
     *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
     *           </aw-checkbox-list>
     *       `
     *
     *       })
     *        class MyShowCLComponent
     *        {
     *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
     *     'silver' , 'black' ,
     *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *
     *            formGroup: FormGroup = new FormGroup({});
     *
     *
     *            onCBClick (event): void
     *            {
     *                console.log('onCBClick = ' + event);
     *            }
     *
     *        }
     * *
      @type {?} */
    var CB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckBoxListComponent; }),
        multi: true
    };
    var CheckBoxListComponent = (function (_super) {
        __extends(CheckBoxListComponent, _super);
        function CheckBoxListComponent(env, cd, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.cd = cd;
            _this.parentContainer = parentContainer;
            /**
             * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
             * actuall internal model value in this case array of choices
             *
             */
            _this.onSelection = new core.EventEmitter();
            /**
             * Internal model
             */
            _this.model = [];
            return _this;
        }
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.selections)) {
                    this.selections = [];
                }
                this.registerFormControl(this.selections);
                this.updateModel(this.selections);
                this.onModelChanged(this.selections);
            };
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var updatedModel = [];
                this.model.forEach(function (index) { return updatedModel.push(_this.list[index]); });
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                this.cd.detectChanges();
            };
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         */
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.labelValue = /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         */
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
        CheckBoxListComponent.prototype.onChange = /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var updatedModel = [];
                this.model.forEach(function (index) {
                    updatedModel.push(_this.list[index]);
                });
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
        CheckBoxListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
            function (sourceList) {
                var _this = this;
                sourceList.forEach(function (item) {
                    /** @type {?} */
                    var index = _this.list.findIndex(function (elem) {
                        return core$1.equals(item, elem);
                    });
                    _this.model.push(index);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckBoxListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isPresent(this.model) && core$1.isPresent(value)) {
                    /** @type {?} */
                    var newModel = value;
                    this.updateModel(newModel);
                    // this.cd.markForCheck();
                }
            };
        CheckBoxListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox-list',
                        template: "<div *ngFor=\"let item of list; let i = index\" class=\"ui-g\">\n\n    <!-- in the future we should be able to to support inline and stack-->\n    <div class=\"ui-g-12\">\n        <aw-checkbox [(ngModel)]=\"model\"\n                     (ngModelChange)=\"onChange($event)\"\n                     [editable]=\"editable\"\n                     [isStandalone]=\"false\"\n                     [name]=\"name\"\n                     [value]=\"i\"\n                     [label]=\"labelValue(item)\">\n\n        </aw-checkbox>\n    </div>\n\n</div>\n\n",
                        providers: [
                            CB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckBoxListComponent; }) }
                        ],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        CheckBoxListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CheckBoxListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selections: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            labelFormatter: [{ type: core.Input }]
        };
        return CheckBoxListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWCheckBoxListModule = (function () {
        function AWCheckBoxListModule() {
        }
        AWCheckBoxListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckBoxListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCheckBoxModule
                        ],
                        exports: [
                            CheckBoxListComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWCheckBoxListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
     * native link functionality. In addition, it supports navigation to components through the action
     * binding.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link button/button.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
     *                        (action)="onClicked($event)" [value]="customerId"
     *                        [size]="'large'" >my link</aw-hyperlink>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(customerId:string) {
     *           if (customerId) {
     *              // display customer details component.
     *           }
     *        }
     *    }
     */
    var HyperlinkComponent = (function (_super) {
        __extends(HyperlinkComponent, _super);
        function HyperlinkComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * sizing for this link. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            /**
             * Internal CSS class that styles this hyperlink based on input 'size'
             */
            _this.linkClass = 'link';
            return _this;
        }
        /**
         * @return {?}
         */
        HyperlinkComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // Determine the link class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.linkClass += ' link-lg';
                            break;
                        case 'normal':
                            this.linkClass += ' link-mid';
                            break;
                        case 'small':
                            this.linkClass += ' link-sm';
                            break;
                    }
                }
                // If I have an action tag, and no href. We add default styling and behavior.
                if (this.action.observers.length > 0) {
                    this.linkClass += ' link-bh';
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
        HyperlinkComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.action.emit({
                    event: event,
                    value: this.value
                });
            };
        HyperlinkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hyperlink',
                        template: "<a [attr.type]=\"type\"\n   [attr.href]=\"href\"\n   [attr.rel]=\"rel\"\n   [attr.target]=\"target\"\n   [ngClass]=\"linkClass\"\n   [class.disabled]=\"disabled\"\n   (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</a>\n",
                        styles: [".link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}"]
                    }] }
        ];
        /** @nocollapse */
        HyperlinkComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        HyperlinkComponent.propDecorators = {
            type: [{ type: core.Input }],
            href: [{ type: core.Input }],
            rel: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return HyperlinkComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWHyperlinkModule = (function () {
        function AWHyperlinkModule() {
        }
        AWHyperlinkModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HyperlinkComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            HyperlinkComponent
                        ],
                        exports: [
                            HyperlinkComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWHyperlinkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */
    var /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */ ChooserSelectionState = (function () {
        function ChooserSelectionState() {
        }
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         */
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserSelectionState.prototype.setSelectionState = /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
            };
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         */
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObject = /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         * The most recent selections.
         *
         */
        /**
         * The most recent selections.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObjects = /**
         * The most recent selections.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         *
         * Check if the item selection items is in the selectedObjects
         */
        /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
        ChooserSelectionState.prototype.isSelected = /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return core$1.unimplemented();
            };
        return ChooserSelectionState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */
    var /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */ ChooserState = (function () {
        function ChooserState(chooserSelectionState, isMulti) {
            if (isMulti === void 0) {
                isMulti = true;
            }
            /**
             * Indicates if there are any validation like entered value does not much with the source list.
             *
             */
            this.isInvalid = false;
            /**
             *
             * indicates that we started to some editing e.g. starting to type in something into the
             * filter, or removing already selected items
             */
            this.addMode = false;
            this.recentSelectedDisplayed = 0;
            /**
             * When this option is active we do not show all selected items, but max number that is
             * defined. User is able to toggle to expand the view to see all selections and hide them as
             * well
             */
            this.showAllRecentlySelected = false;
            this.selectionState = chooserSelectionState;
            this.multiselect = isMulti;
            if (core$1.isBlank(this.selectionState)) {
                this.selectionState = new DefaultSelectionState(this.multiselect);
            }
        }
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         */
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
        ChooserState.prototype.updatedSelectedObjects = /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    item = this.currentItem;
                }
                if (!this.multiselect) {
                    this.setSelectionState(item, true);
                }
                else {
                    /** @type {?} */
                    var selectedObject = this.selectedObject();
                    /** @type {?} */
                    var selectedObjects = this.selectedObjects();
                    if (this.addMode) {
                        if (this.isInvalid) {
                            if (core$1.isPresent(selectedObject)) {
                                this.setSelectionState(selectedObject, false);
                            }
                        }
                        this.setSelectionState(item, !core$1.ListWrapper.containsComplex(selectedObjects, item));
                    }
                    else {
                        if (core$1.isPresent(selectedObject)) {
                            this.setSelectionState(selectedObject, false);
                        }
                        this.setSelectionState(item, true);
                    }
                }
            };
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         */
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
        ChooserState.prototype.toggleAllSelected = /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
            function () {
                this.showAllRecentlySelected = !this.showAllRecentlySelected;
            };
        Object.defineProperty(ChooserState.prototype, "recentSelectedObjects", {
            /**
             *
             * Renders user's selection under the input field
             *
             */
            get: /**
             *
             * Renders user's selection under the input field
             *
             * @return {?}
             */ function () {
                if (!this.multiselect) {
                    return [];
                }
                /** @type {?} */
                var recentSelectedObjects = [];
                this.recentSelectedDisplayed = 0;
                /** @type {?} */
                var selectedObjects = this.selectedObjects();
                /** @type {?} */
                var size = selectedObjects.length;
                /** @type {?} */
                var maxCount = DataSource.MaxRecentSelected;
                if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
                    maxCount -= 1;
                }
                if (this.showAllRecentlySelected) {
                    maxCount = size;
                }
                for (var i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
                    /** @type {?} */
                    var selection = selectedObjects[i];
                    recentSelectedObjects.push(selection);
                    this.recentSelectedDisplayed++;
                }
                return recentSelectedObjects;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObject();
            };
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObjects();
            };
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (core$1.isPresent(selection)) {
                    this.selectionState.setSelectionState(selection, selected);
                }
            };
        return ChooserState;
    }());
    /**
     * Dummy implementation ChooserSelectionState
     */
    var /**
     * Dummy implementation ChooserSelectionState
     */ DefaultSelectionState = (function (_super) {
        __extends(DefaultSelectionState, _super);
        function DefaultSelectionState(multiSelect) {
            var _this = _super.call(this) || this;
            _this.multiSelect = multiSelect;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        DefaultSelectionState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected) {
                    this._selectedObject = selection;
                    if (this.multiSelect && !core$1.ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                        this.selectedObjects().push(selection);
                    }
                }
                else {
                    if (this.multiSelect) {
                        core$1.ListWrapper.removeIfExist(this.selectedObjects(), selection);
                    }
                }
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this._selectedObject;
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this._selectedObjects)) {
                    this._selectedObjects = [];
                }
                return this._selectedObjects;
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        DefaultSelectionState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return _super.prototype.isSelected.call(this, selection);
            };
        return DefaultSelectionState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */
    var /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */ ChooserDataSource = (function (_super) {
        __extends(ChooserDataSource, _super);
        function ChooserDataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            return _this;
        }
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         */
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
        ChooserDataSource.prototype.init = /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                /** @type {?} */
                var init = args[0];
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                if (core$1.isPresent(init.state)) {
                    this.state = init.state;
                }
                else {
                    this.state = new ChooserState(null, init.multiselect);
                }
                this.dataFinder.lookupKey = init.lookupKey;
                this.state.lookupKey = init.lookupKey;
            };
        /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
        ChooserDataSource.prototype.find = /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
            function (pattern, max) {
                var _this = this;
                this.state.pattern = pattern;
                this.state.lastFullMatchPattern = pattern;
                if (pattern.length === 0) {
                    return;
                }
                if (pattern === '*') {
                    // query everything
                    pattern = '';
                }
                /** @type {?} */
                var origKey = this.dataFinder.lookupKey;
                this.dataFinder.lookupKey = this.state.lookupKey;
                this.dataFinder.forData(this.dataProvider).match(pattern, max)
                    .subscribe(function (result) {
                    _this.state.matches = result;
                    if (_this.state.multiselect) {
                        for (var i = 0; i < _this.state.selectedObjects().length; i++) {
                            /** @type {?} */
                            var item = _this.state.selectedObjects()[i];
                            core$1.ListWrapper.removeIfExist(_this.state.matches, item);
                        }
                    }
                    _this.dataFinder.lookupKey = origKey;
                });
            };
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         */
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
        ChooserDataSource.prototype.showMoreSelected = /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
            function () {
                return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.open = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        ChooserDataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
                this.state = null;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.instant = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.data();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ChooserDataSource.prototype.updateValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                this.state.addMode = true;
                if (core$1.isArray(value)) {
                    /** @type {?} */
                    var items = value;
                    items.forEach(function (item) { return _this.state.updatedSelectedObjects(item); });
                }
                else {
                    this.state.updatedSelectedObjects(value);
                }
                this.state.addMode = false;
            };
        Object.defineProperty(ChooserDataSource.prototype, "lookupKey", {
            get: /**
             * @return {?}
             */ function () {
                return this.dataFinder.lookupKey;
            },
            enumerable: true,
            configurable: true
        });
        return ChooserDataSource;
    }(DataSource));
    /**
     * @param {?} init
     * @return {?}
     */
    function isDSChooserInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
     * requires little bit different setup. It requires at minimum \@Input dataSource or
     * destinationClass
     *
     *
     * By default chooser is multi-select. If you want single select then you must provide multi-select
     * with \@Input.
     *
     * ### Example
     *
     * In simple scenario you can use Chooser like so:
     *
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
     *                      [dataSource]="ds"></aw-chooser>`
     *  })
     *  export class MyChooserApp
     *  {
     *
     *      ds: ChooserDataSource;
     *
     *     constructor(private data: DataProviders, private finders: DataFinders){
     *          this.ds = new ChooserDataSource(this.data, this.finders);
     *
     *       this.ds.init({
     *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
     *            multiselect: true
     *       });
     *
     *     }
     *  }
     *
     * ````
     *  Above example will use provided dataSource and render multi-select chooser. With default
     *  implementation  selected values will appear as a tags under the input box
     *
     *
     *
     * * ### Example
     *
     *  In this example we provide custom template to change the way how chooser's MenuItem are
     *     rendered as well as template for the selection item looks like
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
     *
     *          <ng-template #menuItem let-item>
     *             	<span>
     *             		<i class="fa fa-envira " ></i>
     *             		{{item}}
     *             	</span>
     *
     *          </ng-template>
     *
     *          <ng-template #selectionItem let-item>
     *             	<span class="tag tag-circle">
     *             		item: {{item }}
     *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
     *             	</span>
     *
     *
     *          </ng-template>
     *
     *
     *          </aw-chooser>
     *      `
     *      style: [`
     *              .tag-circle {
     *              	border-radius: 6rem;
     *              	height: 7rem;
     *              	color: #e8eef1;
     *              	background-color: rgba(53, 56, 58, 0.67);
     *              	line-height: 6rem;
     *              }
     *      `]
     *  })
     *
     * ````
     *
     *  In above example we change how the chooser's menu item look like as well as we define custom
     *     template for selection item to turn all selection to circles with text in the middle.
     *
     *
     *
      @type {?} */
    var CHOOSER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ChooserComponent; }),
        multi: true
    };
    var ChooserComponent = (function (_super) {
        __extends(ChooserComponent, _super);
        function ChooserComponent(env, elemementRef, _defaultDS, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.elemementRef = elemementRef;
            _this._defaultDS = _defaultDS;
            _this.parentContainer = parentContainer;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.maxLength = 10;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.minLenForSearch = 1;
            /**
             * Is this multiselect
             *
             */
            _this.multiselect = true;
            _this.delay = 300;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            if (core$1.isBlank(_this.placeHolder)) {
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                _this.placeHolder = 'Search';
            }
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            _this.hideLink = 'Hide';
            return _this;
        }
        /**
         * @return {?}
         */
        ChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.dataSource)) {
                    this.dataSource = this._defaultDS;
                    this.initDatasource();
                }
                if (core$1.isPresent(this.formControl) && core$1.isPresent(this.formControl.value)) {
                    this.dataSource.updateValue(this.formControl.value);
                }
                this.initInternalModel();
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.internalChooserModel);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
            };
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         */
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewInit = /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                /** @type {?} */
                var searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
                if (core$1.isPresent(searchInput)) {
                    /** @type {?} */
                    var iconElement = document.createElement('span');
                    iconElement.className = 'search-icon-right fa fa-fw fa-search';
                    searchInput.appendChild(iconElement);
                }
                if (core$1.isPresent(this.selectionAppendTo) && core$1.isPresent(this.selectionViewElem)) {
                    /** @type {?} */
                    var parentElem = this.selectionAppendTo instanceof core.ElementRef ?
                        this.selectionAppendTo.nativeElement : this.selectionAppendTo;
                    parentElem.appendChild(this.selectionViewElem.nativeElement);
                }
            };
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         */
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewChecked = /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                /** @type {?} */
                var tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
                if (core$1.isPresent(tokens) && tokens.length > 0) {
                    tokens.forEach(function (item) {
                        item.remove();
                    });
                }
            };
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         */
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
        ChooserComponent.prototype.match = /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
            function (pattern) {
                /** @type {?} */
                var maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
                this.dataSource.find(pattern, maxLen);
                // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
                // doesn't give us any popup panel
                if (this.env.inTest && core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         */
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
        ChooserComponent.prototype.onDropdownClick = /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.match('*');
                setTimeout(function () {
                    _this.match('*');
                }, 100);
            };
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         */
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.selectItem = /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.dataSource.state.addMode = true;
                this.onModelChanged(this.internalChooserModel);
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = true;
                if (!this.dataSource.state.multiselect) {
                    this.autoCompleteComponent.inputEL.nativeElement.value =
                        this.displayItem(this.internalChooserModel);
                }
            };
        /**
         *
         * Unselect item
         *
         */
        /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.removeValue = /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.dataSource.state.addMode = true;
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = false;
                this.internalChooserModel = this.dataSource.state.selectedObjects();
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.onModelChanged(this.internalChooserModel);
                if (core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         */
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.displayItem = /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return null;
                }
                this.dataSource.state.currentItem = item;
                if (core$1.isPresent(this.valueTransformer)) {
                    return this.valueTransformer(item);
                }
                else if (core$1.isPresent(this.dataSource.lookupKey)) {
                    return item[this.dataSource.lookupKey];
                }
                else {
                    return item.toString();
                }
            };
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         */
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
        ChooserComponent.prototype.moreSelectString = /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var moreSelected = this.dataSource.state.selectedObjects().length -
                    this.dataSource.state.recentSelectedDisplayed;
                if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
                    return '';
                }
                if (this.dataSource.state.showAllRecentlySelected) {
                    return this.hideLink;
                }
                return moreSelected + " more selected...";
            };
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         */
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
        ChooserComponent.prototype.singleValueSelected = /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
            function () {
                return !this.dataSource.state && core$1.isPresent(this.dataSource.state.currentItem)
                    && !this.dataSource.state.addMode;
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasMenuTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.menuTemplate);
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasSelectionTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.selectionTemplate);
            };
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         */
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
        ChooserComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isBlank(value)) {
                    return;
                }
                if (core$1.isPresent(this.dataSource)) {
                    this.dataSource.updateValue(value);
                }
                else {
                    /** @type {?} */
                    var selState = new DefaultSelectionState(this.multiselect);
                    /** @type {?} */
                    var chState = new ChooserState(selState, this.multiselect);
                    this.initDatasource(chState);
                    this.dataSource.updateValue(value);
                }
                this.initInternalModel();
            };
        /**
         * @param {?=} chooserState
         * @return {?}
         */
        ChooserComponent.prototype.initDatasource = /**
         * @param {?=} chooserState
         * @return {?}
         */
            function (chooserState) {
                core$1.assert(core$1.isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
                this.dataSource.init({
                    obj: this.destinationClass,
                    queryType: QueryType.FullText,
                    lookupKey: this.field,
                    state: chooserState,
                    multiselect: this.multiselect
                });
            };
        /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
        ChooserComponent.prototype.initInternalModel = /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
            function () {
                if (this.dataSource.state.multiselect) {
                    this.internalChooserModel = this.dataSource.state.selectedObjects();
                }
                else {
                    this.internalChooserModel = this.dataSource.state.selectedObject();
                }
                if (core$1.isPresent(this.formControl)) {
                    this.formControl.setValue(this.internalChooserModel);
                }
            };
        ChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-chooser',
                        template: "<div class=\"w-chooser \">\n\n    <p-autoComplete #autoCompplete [(ngModel)]=\"internalChooserModel\"\n                    [suggestions]=\"dataSource.state.matches\"\n                    [multiple]=\"dataSource.state.multiselect\"\n                    [dropdown]=\"!dataSource.state.multiselect\"\n                    [minLength]=\"minLenForSearch\"\n                    [placeholder]=\"placeHolder\"\n                    [delay]=\"delay\"\n                    [disabled]=\"disabled\"\n                    (onDropdownClick)=\"onDropdownClick($event)\"\n                    (completeMethod)=\"match($event.query)\"\n                    (onSelect)=\"selectItem($event)\"\n                    (onUnselect)=\"removeValue($event)\">\n\n\n        <ng-template let-internalChooserModel pTemplate=\"item\">\n            <ng-template [ngIf]=\"!hasMenuTemplate()\">\n                {{ displayItem(internalChooserModel) }}\n            </ng-template>\n            <ng-template [embeddedItem]=\"menuTemplate\" [item]=\"internalChooserModel\"\n                         *ngIf=\"hasMenuTemplate()\"></ng-template>\n        </ng-template>\n    </p-autoComplete>\n\n    <!--\n        Wrap whole selection with one extra element so we can move it around\n\n         see: selectionAppendTo\n    -->\n    <span #selectionView>\n        <div class=\"w-chooser-selections\"\n             *ngIf=\"multiselect && dataSource.state.recentSelectedObjects.length > 0\">\n\n        <ng-template [ngIf]=\"!hasSelectionTemplate()\">\n\n            <!-- no selection template render it as it is from CORE-->\n            <ul class=\"ui-autocomplete-multiple-container ui-widget ui-state-default \"\n                [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}\">\n\n                <li #token *ngFor=\"let item of dataSource.state.recentSelectedObjects\"\n                    class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\" tabindex=\"0\"\n                    (keyup.delete)=\"removeValue(item)\"\n                    (keyup.backspace)=\"removeValue(item)\">\n\t\t\t\t\t<span class=\"ui-autocomplete-token-icon sap-icon icon-decline\"\n                          (click)=\"removeValue(item)\"></span>\n                    <span class=\"ui-autocomplete-token-label\">{{ displayItem(item) }}</span>\n                </li>\n            </ul>\n        </ng-template>\n\n            <!--Yes there is selection template let's iterate and push each item to be rendered-->\n        <ng-template ngFor [ngForOf]=\"dataSource.state.recentSelectedObjects\" let-item>\n            <ng-template [embeddedItem]=\"selectionTemplate\" [item]=\"item\"\n                         *ngIf=\"hasSelectionTemplate()\"></ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"dataSource.showMoreSelected()\">\n\t\t\t<span class=\"more-selected\">\n\t\t\t\t<aw-hyperlink [size]=\"'small'\" (action)=\"dataSource.state.toggleAllSelected()\">\n\t\t\t\t\t{{moreSelectString()}}\n\t\t\t\t</aw-hyperlink>\n\t\t\t</span>\n        </ng-template>\n    </div>\n    </span>\n\n\n</div>\n\n",
                        providers: [
                            CHOOSER_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ],
                        styles: ["/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}"]
                    }] }
        ];
        /** @nocollapse */
        ChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ChooserComponent.propDecorators = {
            maxLength: [{ type: core.Input }],
            minLenForSearch: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            selectionAppendTo: [{ type: core.Input }],
            delay: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            field: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            menuTemplate: [{ type: core.ContentChild, args: ['menuItem',] }],
            selectionTemplate: [{ type: core.ContentChild, args: ['selectionItem',] }],
            autoCompleteComponent: [{ type: core.ViewChild, args: ['autoCompplete',] }],
            selectionViewElem: [{ type: core.ViewChild, args: ['selectionView',] }]
        };
        return ChooserComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWChooserModule = (function () {
        function AWChooserModule() {
        }
        AWChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.AutoCompleteModule,
                            AWHyperlinkModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            ChooserComponent
                        ],
                        exports: [
                            ChooserComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * A popup like component rendering list of values as. Based on PrimeNG component and one of the
     * main reason why we need to wrap this is to extend its capabilities to accept almost any
     * data type without using Primens's specific SelectItem type.
     *
     *
     * ### Example
     *
     * ```
     * \@Component({
     *      selector: 'showDropDown' ,
     *      template: '<aw-dropdown [list]="testItemSmall"
     *     (onSelection)="onSelection($event)"></aw-dropdown>'
     *  })
     *  export class MyDropComponent
     *  {
     *      testItemSmall: string[] = ['view' , 'edit'];
     *
     *      // when you switch list binding to refert to large item fiilter automatically is shown and
     *     max 10 items are
     *      // visible
     *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
     *     'Computer' , 'A Desk' ,
     *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
     *     'Czech Republic' ,
     *      'Last Item'];
     *
     *
     *      itemSelected: string = 'view';
     *      itemSelectedLg: string = 'Monday';
     *
     *      noselString: string = '(no selection)';
     *
     *
     *      onSelection (event): void
     *      {
     *          this.itemSelected = event;
     *
     *      }
     *  }
     *
     *  ```
     *
      @type {?} */
    var DD_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DropdownComponent; }),
        multi: true
    };
    var DropdownComponent = (function (_super) {
        __extends(DropdownComponent, _super);
        function DropdownComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         */
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
        DropdownComponent.prototype.ngOnInit = /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
            function () {
                if (this.isStandalone) {
                    _super.prototype.ngOnInit.call(this);
                    _super.prototype.registerFormControl.call(this, this.selection);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // transform a value to PrimeNg Format, we are not really be using a label field only a
                // value.
                this.internalList = [];
                // if (isPresent(this.noSelectionString)) {
                //     this.internalList.push({
                //         label: this.noSelectionString,
                //         value: null
                //     });
                //
                //     if (isBlank(this.selection)) {
                //         this.selection = this.noSelectionString;
                //     }
                // }
                if (core$1.isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
                    this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
                else if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.slice(0).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
            };
        /**
         * @return {?}
         */
        DropdownComponent.prototype.hasEmbeddedTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.itemTemplate);
            };
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         */
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.itemExist = /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item);
            };
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         */
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
        DropdownComponent.prototype.showFilter = /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
            function () {
                return false;
                // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
            };
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         */
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.onItemSelection = /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value.value;
                this.onSelection.emit(value.value);
                if (this.isStandalone) {
                    this.formControl.setValue(this.selection);
                    this.formControl.markAsDirty({ onlySelf: true });
                }
                this.onModelChanged(value.value);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.displayItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item) ? item.label : 'No Selection';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    this.formControl.setValue(value);
                }
            };
        DropdownComponent.MaxNumShown = 10;
        DropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dropdown',
                        template: "<div class=\"w-dropdown\" [formGroup]=\"formGroup\">\n\n    <ng-template [ngIf]=\"isStandalone\">\n        <p-dropdown [options]=\"internalList\"\n                    [formControlName]=\"name\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n\n                </ng-template>\n            </ng-template>\n\n\n        </p-dropdown>\n    </ng-template>\n</div>\n\n\n<!-- no formControl Name here. ngModel cannot have formGroup around -->\n<ng-template [ngIf]=\"!isStandalone\">\n    <div class=\"w-dropdown\">\n        <p-dropdown [options]=\"internalList\"\n                    [(ngModel)]=\"selection\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n                </ng-template>\n            </ng-template>\n        </p-dropdown>\n    </div>\n</ng-template>\n",
                        providers: [
                            DD_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DropdownComponent; }) }
                        ],
                        styles: ["/deep/ .ui-dropdown-panel{z-index:10010!important;top:35px!important}/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}"]
                    }] }
        ];
        /** @nocollapse */
        DropdownComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        DropdownComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            itemTemplate: [{ type: core.ContentChild, args: ['itemTemplate',] }]
        };
        return DropdownComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWDropdownModule = (function () {
        function AWDropdownModule() {
        }
        AWDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DropdownComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.DropdownModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            DropdownComponent
                        ],
                        exports: [
                            DropdownComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Lightweight and configurable Currency component based on the ng bootstrap directive. This
     * component combines an input and currency code dropdown.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link currency/currency.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'amount' ,
     *    template: `
     *
     *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
     *      </aw-currency>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        amount: number = 1000;
     *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
     *        currencyCode: string = this.currencies[0];
     *
     *        constructor ()
     *        {
     *        }
     *    }
      @type {?} */
    var CURRENCY_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CurrencyComponent; }),
        multi: true
    };
    var CurrencyComponent = (function (_super) {
        __extends(CurrencyComponent, _super);
        function CurrencyComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Disable user to change Money's currency code and still
             * allow user to edit Money's amount.
             */
            _this.readonlyCurrencyCode = false;
            // Initialize currencies.
            // Initialize currencies.
            _this.initCurrencies();
            _this.currencyPipe = new common.CurrencyPipe(env.locale);
            env.onLocaleChange.subscribe(function (locale) {
                _this.currencyPipe = new common.CurrencyPipe(locale);
                if (core$1.isPresent(_this.money)) {
                    _this.displayValue = _this.formatCurrency(_this.money.amount);
                }
            });
            return _this;
        }
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.money);
                this.initCurrencies();
                if (core$1.isBlank(this.currencySelection)) {
                    this.currencySelection = this._currencies[0];
                }
                // ready the money field if it exists. and override the existing values.
                if (this.money) {
                    this.currencySelection = this.money.currency;
                }
                else {
                    this.money = new Money(null, this.currencySelection);
                }
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.initCurrencies = /**
         * @return {?}
         */
            function () {
                if (!this._currencies || this._currencies.length === 0) {
                    this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
                }
            };
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param el
         */
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onFocus = /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (core$1.isPresent(this.money) && core$1.isPresent(this.money.amount)) {
                    this.displayValue = this.money.amount.toString();
                }
            };
        /**
         * display the formatted currency value when the user navigates away.
         * @param el
         */
        /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onBlur = /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
            function (el) {
                this.money = this.money.clone({ amount: Number(el.value) });
                this.displayValue = this.formatCurrency(this.money.amount);
                this.onModelChanged(this.money);
            };
        /**
         * @param {?} currency
         * @return {?}
         */
        CurrencyComponent.prototype.onSelection = /**
         * @param {?} currency
         * @return {?}
         */
            function (currency) {
                this.currencySelection = currency;
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
        CurrencyComponent.prototype.formatCurrency = /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
            function (val) {
                if (!val || val.length === 0) {
                    return val;
                }
                if (isNaN(val)) {
                    return val;
                }
                /** @type {?} */
                var code = 'USD';
                if (this.currencySelection) {
                    code = this.currencySelection;
                }
                this.money = this.money.clone({ currency: this.currencySelection });
                /** @type {?} */
                var digits = '1.0-2';
                // If precision is present, use it for format the money value for display.
                if (core$1.isPresent(this.precision)) {
                    digits = '1.0-' + this.precision;
                }
                return this.currencyPipe.transform(val, code, 'symbol', digits);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.getMoneyCurrency = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.displayValue) && this.displayValue.length > 0) {
                    return this.currencySelection;
                }
                return '';
            };
        Object.defineProperty(CurrencyComponent.prototype, "currencies", {
            get: /**
             * @return {?}
             */ function () {
                return this._currencies;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (core$1.isPresent(value)) {
                    this._currencies = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CurrencyComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if ((value instanceof Money) && !core$1.equals(value, this.money)) {
                    this.money = value;
                    if (core$1.isPresent(this.money.currency)) {
                        this.currencySelection = this.money.currency;
                    }
                    this.displayValue = this.formatCurrency(this.money.amount);
                    this.formControl.setValue(this.money);
                }
            };
        CurrencyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-currency',
                        template: "<ng-template [ngIf]=\"editable\">\n    <div class=\"w-currency-field ui-fluid\" [formGroup]=\"formGroup\">\n        <div class=\"ui-g \">\n            <div class=\"ui-g-8 ui-g-nopad \">\n                <input #currencyInput\n                       pInputText\n                       type=\"text\" class=\"w-text-field currency-format\"\n                       [attr.name]=\"name\"\n                       [attr.placeholder]=\"placeHolder\"\n                       [value]=\"displayValue\"\n                       (focus)=\"onFocus(currencyInput)\"\n                       (blur)=\"onBlur(currencyInput)\"\n                       [disabled]=\"disabled\">\n            </div>\n            <div class=\"ui-g-4 ui-g-nopad w-cc-field\">\n                <aw-dropdown *ngIf=\"!readonlyCurrencyCode\"\n                             [isStandalone]=\"false\" [list]=\"currencies\"\n                             [selection]=\"money.currency\"\n                             (onSelection)=\"onSelection($event)\"\n                             [disabled]=\"disabled\">\n\n                </aw-dropdown>\n                <div *ngIf=\"readonlyCurrencyCode\" class=\"w-cc-readonly-field\">{{money.currency}}</div>\n            </div>\n        </div>\n    </div>\n</ng-template>\n\n<!-- currency:'USD':true -->\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{displayValue}} {{ getMoneyCurrency() }}\"></aw-string>\n</ng-template>\n",
                        providers: [
                            CURRENCY_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CurrencyComponent; }) }
                        ],
                        styles: [".w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}"]
                    }] }
        ];
        /** @nocollapse */
        CurrencyComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CurrencyComponent.propDecorators = {
            money: [{ type: core.Input }],
            readonlyCurrencyCode: [{ type: core.Input }],
            currencySelection: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            currencies: [{ type: core.Input }]
        };
        return CurrencyComponent;
    }(BaseFormComponent));
    /**
     * Money object is represented as a value, locale, and currencyCode
     */
    var /**
     * Money object is represented as a value, locale, and currencyCode
     */ Money = (function () {
        function Money(amount, currency, locale) {
            if (amount === void 0) {
                amount = 0;
            }
            if (currency === void 0) {
                currency = 'USD';
            }
            if (locale === void 0) {
                locale = 'en_US';
            }
            this.amount = amount;
            this.currency = currency;
            this.locale = locale;
        }
        /**
         * @return {?}
         */
        Money.prototype.getTypes = /**
         * @return {?}
         */
            function () {
                return {
                    amount: Number,
                    currency: String,
                    locale: String
                };
            };
        /**
         * @return {?}
         */
        Money.prototype.className = /**
         * @return {?}
         */
            function () {
                return 'Money';
            };
        /**
         * @return {?}
         */
        Money.prototype.$proto = /**
         * @return {?}
         */
            function () {
                return new Money(1, '23', '33');
            };
        /**
         * @return {?}
         */
        Money.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
            };
        /**
         * @param {?=} data
         * @return {?}
         */
        Money.prototype.clone = /**
         * @param {?=} data
         * @return {?}
         */
            function (data) {
                if (data === void 0) {
                    data = {};
                }
                return new Money(core$1.isPresent(data.amount) ? data.amount : this.amount, core$1.isPresent(data.currency) ? data.currency : this.currency, core$1.isPresent(data.locale) ? data.locale : this.locale);
            };
        return Money;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWCurrencyModule = (function () {
        function AWCurrencyModule() {
        }
        AWCurrencyModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CurrencyComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextModule,
                            primeng.DropdownModule,
                            AWDropdownModule,
                            AWStringFieldModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            CurrencyComponent
                        ],
                        exports: [
                            CurrencyComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: [common.CurrencyPipe]
                    },] }
        ];
        return AWCurrencyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Lightweight and configurable Date and Time component based on the primeng. This
     * component combines both date picker as well as time picker
     *
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *
     *        date: Date = new Date();
     *
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     * By default you will see date field and time field is hidden to show both you just do following:
     *
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *
     *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *        date: Date = new Date();
     *        showTime = true;
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     *
     *
      @type {?} */
    var DATETIME_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DateAndTimeComponent; }),
        multi: true
    };
    var DateAndTimeComponent = (function (_super) {
        __extends(DateAndTimeComponent, _super);
        function DateAndTimeComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Default date format pattern used if none is passed
             *
             */
            _this.formatPattern = 'mm/dd/yy';
            /**
             * Special workaround as formatters in the primeNG and angular are different so until its
             * fixed we need to keep this extra pattern.
             */
            _this.formatPatternNG = 'MM/dd/yy';
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showNavigation = false;
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showIcon = true;
            /**
             * Whether to show timepicker
             */
            _this.showTime = false;
            /**
             * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
             * true
             */
            _this.showDate = true;
            /**
             *
             * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
             * it shows the AM, PM
             *
             */
            _this.hourFormat = '24';
            /**
             * Triggers event when specific date is clicked inside DatePicker
             *
             */
            _this.onChange = new core.EventEmitter();
            /**
             * Set the date to highlight on first opening if the field is blank.
             *
             */
            _this.defaultDate = new Date();
            _this.timePlaceHolder = 'hh:ss';
            return _this;
        }
        /**
         * @return {?}
         */
        DateAndTimeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                // default to dateTime pattern which is defined in resource files
                if (this.hourFormat !== '12' && this.hourFormat !== '24') {
                    this.hourFormat = '24';
                }
                this.timePlaceHolder = (this.hourFormat === '12') ?
                    " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
                this.initTranslations();
                this.env.onLocaleChange.subscribe(function (locale) {
                    _this.initTranslations();
                });
            };
        /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
        DateAndTimeComponent.prototype.initTranslations = /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
            function () {
                this.formatNameWithTime = this.formatPattern;
                if (!this.showDate) {
                    this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                if (this.showTime) {
                    /** @type {?} */
                    var timeStarts = this.formatPattern.indexOf('h');
                    if (timeStarts !== -1) {
                        this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
                    }
                    this.formatPatternNG += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                this.i18n = {
                    firstDayOfWeek: 0,
                    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                        'Saturday'],
                    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                        'September', 'October', 'November', 'December'],
                    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                        'Nov', 'Dec']
                };
            };
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         */
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
        DateAndTimeComponent.prototype.onDateChange = /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event)) {
                    // throw some error ?
                    return;
                }
                this.value = core$1.isDate(event) ? event : new Date(event);
                this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
                this.onModelChanged(this.value);
                this.onChange.emit(this.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DateAndTimeComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        DateAndTimeComponent.NgTime12 = 'hh:mm a';
        DateAndTimeComponent.NgTime24 = 'HH.mm a';
        DateAndTimeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-date-time',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <div class=\"w-datetime \" [class.has-time]=\"showTime\" [formGroup]=\"formGroup\">\n\n        <p-calendar formControlName=\"{{name}}\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    dateFormat=\"{{showTime ? formatNameWithTime : formatPattern}}\"\n                    [yearNavigator]=\"showNavigation\"\n                    [monthNavigator]=\"showNavigation\"\n                    [yearRange]=\"yearRange\"\n                    placeholder=\"{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [timeOnly]=\"!showDate\"\n                    [readonlyInput]=\"true\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n        <p-calendar *ngIf=\"showTime\"\n                    icon=\"icon-history\"\n                    formControlName=\"{{name}}\"\n                    [hourFormat]=\"hourFormat\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    [timeOnly]=\"showTime\"\n                    [showTime]=\"showTime\"\n                    [placeholder]=\"timePlaceHolder\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n    </div>\n</ng-template>\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{value | date: formatPatternNG}}\"></aw-string>\n</ng-template>\n",
                        providers: [
                            DATETIME_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DateAndTimeComponent; }) }
                        ],
                        styles: ["/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}"]
                    }] }
        ];
        /** @nocollapse */
        DateAndTimeComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        DateAndTimeComponent.propDecorators = {
            value: [{ type: core.Input }],
            formatPattern: [{ type: core.Input }],
            formatPatternNG: [{ type: core.Input }],
            showNavigation: [{ type: core.Input }],
            yearRange: [{ type: core.Input }],
            showIcon: [{ type: core.Input }],
            showTime: [{ type: core.Input }],
            showDate: [{ type: core.Input }],
            hourFormat: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return DateAndTimeComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWDateAndTimeModule = (function () {
        function AWDateAndTimeModule() {
        }
        AWDateAndTimeModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DateAndTimeComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CalendarModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            DateAndTimeComponent
                        ],
                        exports: [
                            DateAndTimeComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ]
                    },] }
        ];
        return AWDateAndTimeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogHeaderComponent = (function () {
        function DialogHeaderComponent() {
        }
        DialogHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-header',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        return DialogHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogFooterComponent = (function () {
        function DialogFooterComponent() {
        }
        DialogFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-footer',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        return DialogFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Dialog Component that provides the look and feel for a modal dialog. This component has three
     * sections: header, body, and footer. It can be used by itself or extended.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
     *
     * Usage:
     *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
     * message to the user.
     *
     *             this.modalService.open<DialogComponent>( DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-dialog [(visible)]="display" [modal]="true"
     *                                        (onOpen)="openAction()" (onClose)="closeAction()">
     *
     *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
     *
     *                                     Dialog Body: Creating a dialog using the dialog component
     *
     *                                    <aw-dialog-footer>
     *                                      <aw-button [size]="'small'" [style]="'primary'"
     *                                                 (click)="close()">OK</aw-button>
     *                                    </aw-dialog-footer>
     *                              </aw-dialog>
     *
     *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     dialogAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     openAction()  {
     *                        this.dialogAction = "open";
     *                      }
     *       }
     *
     *
     */
    var DialogComponent = (function (_super) {
        __extends(DialogComponent, _super);
        function DialogComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * whether this dialog blocks the rest of the page or not when displayed.
             */
            _this.modal = true;
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = true;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            _this.width = 300;
            _this.height = 'auto';
            return _this;
        }
        /**
         * Open this dialog.
         */
        /**
         * Open this dialog.
         * @return {?}
         */
        DialogComponent.prototype.open = /**
         * Open this dialog.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                // visible is a 2-way binding variable.
                this.visibleChange.emit(true);
            };
        /**
         * close the dialog
         */
        /**
         * close the dialog
         * @return {?}
         */
        DialogComponent.prototype.close = /**
         * close the dialog
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does this dialog have header.
         *
         */
        /**
         * Does this dialog have header.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasHeader = /**
         * Does this dialog have header.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does this dialog have footer.
         *
         */
        /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasFooter = /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        DialogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog',
                        template: "<p-dialog [header]=\"title\" [(visible)]=\"visible\"\n          [modal]=\"modal\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n          [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onShow)=\"open()\" (onHide)=\"close()\">\n\n    <p-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-dialog-header\"></ng-content>\n    </p-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n    <p-footer *ngIf=\"hasFooter()\">\n        <div class=\"dialog-footer-separator\"></div>\n        <ng-content select=\"aw-dialog-footer\"></ng-content>\n    </p-footer>\n</p-dialog>\n",
                        styles: ["::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}"]
                    }] }
        ];
        /** @nocollapse */
        DialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        DialogComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            modal: [{ type: core.Input }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DialogHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [DialogFooterComponent,] }]
        };
        return DialogComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWDialogModule = (function () {
        function AWDialogModule() {
        }
        AWDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            dialog.DialogModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        exports: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] }
        ];
        return AWDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
     * Chooser. The type of the chooser may be determined dynamically based on the number of items in
     * the data source list, or can be specified explicitly via the "type" binding.
     *
     *
     *
     */
    var GenericChooserComponent = (function (_super) {
        __extends(GenericChooserComponent, _super);
        function GenericChooserComponent(env, _viewContainer, dataSource, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.dataSource = dataSource;
            _this.parentContainer = parentContainer;
            /**
             *  Is this a List property, or a to-one.
             */
            _this.multiselect = false;
            return _this;
        }
        /**
         * @return {?}
         */
        GenericChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.object)) {
                    this.object = ((this._viewContainer.injector)).view.context;
                }
                this.keyPath = new core$1.FieldPath(this.key);
                /** @type {?} */
                var defaultDataProvider = null;
                if (core$1.isPresent(this.list)) {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.list);
                }
                else {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
                }
                /** @type {?} */
                var projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
                this.initType(projectedSize);
                if (this.type === 'Chooser') {
                    this.dataSource.init({
                        dataProvider: defaultDataProvider,
                        queryType: QueryType.FullText,
                        lookupKey: this.displayKey,
                        state: new ChooserState(new GCChooserState(this), this.multiselect),
                        multiselect: this.multiselect
                    });
                }
                else {
                    // do we need to read this value in async?
                    this.list = defaultDataProvider.data();
                }
                _super.prototype.registerFormControl.call(this, this.selection);
                this.validateRequired();
                if (core$1.isBlank(this.selection)) {
                    // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
                    this.noSelectionString = 'Select a Item';
                }
            };
        /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
        GenericChooserComponent.prototype.initType = /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
            function (projectedSize) {
                if (core$1.isBlank(this.type)) {
                    if (this.multiselect) {
                        this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
                    }
                    else {
                        this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                            : (projectedSize < 6) ? 'Radio' :
                                'Dropdown';
                    }
                }
            };
        /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
        GenericChooserComponent.prototype.validateRequired = /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.object)) {
                    throw Error('Cannot continue without a object');
                }
                if (core$1.isBlank(this.key)) {
                    throw Error('Cannot continue without a key binding');
                }
                if (core$1.isBlank(this.list) && core$1.isBlank(this.destinationClass)) {
                    throw Error('Cannot continue without having either list of values or destinationClass');
                }
                if (core$1.isPresent(this.type) &&
                    (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                        this.type !== 'Chooser')) {
                    throw Error('Cannot instantiate GenericChooser  - invalid type');
                }
                if (core$1.isBlank(this.displayKey)) {
                    this.displayKey = 'toString';
                }
            };
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         */
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
        GenericChooserComponent.prototype.displayValue = /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.displayKey)) {
                    return item;
                }
                /** @type {?} */
                var fieldValue = core$1.FieldPath.getFieldValue(item, this.displayKey);
                if (core$1.isFunction(fieldValue)) {
                    return fieldValue.call(item);
                }
                return fieldValue;
            };
        Object.defineProperty(GenericChooserComponent.prototype, "selection", {
            /**
             *  Retrieve a current value from the parent/target object
             *
             */
            get: /**
             *  Retrieve a current value from the parent/target object
             *
             * @return {?}
             */ function () {
                return this.keyPath.getFieldValue(this.object);
            },
            /**
             *  set value back to the object
             *
             */
            set: /**
             *  set value back to the object
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.keyPath.setFieldValue(this.object, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        GenericChooserComponent.prototype.onSelection = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value;
                this.formControl.setValue(this.selection);
                this.formControl.markAsDirty();
            };
        GenericChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-chooser',
                        template: "<ng-container [ngSwitch]=\"type\">\n\n    <ng-template [ngSwitchCase]=\"'Checkbox'\">\n        <aw-checkbox-list [list]=\"list\"\n                          [editable]=\"editable\"\n                          [selections]=\"selection\"\n                          [name]=\"name\"\n                          [disabled]=\"disabled\"\n                          [labelFormatter]=\"displayValue\"\n                          (onSelection)=\"onSelection($event)\">\n        </aw-checkbox-list>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Radio'\">\n        <aw-radiobutton-list [list]=\"list\"\n                             [selection]=\"selection\"\n                             [editable]=\"editable\"\n                             [name]=\"name\"\n                             [disabled]=\"disabled\"\n                             [labelFormatter]=\"displayValue\"\n                             (onSelection)=\"onSelection($event)\">\n        </aw-radiobutton-list>\n    </ng-template>\n\n    <ng-template [ngSwitchCase]=\"'Dropdown'\">\n        <aw-dropdown [list]=\"list\"\n                     [isStandalone]=\"false\"\n                     [editable]=\"editable\"\n                     [noSelectionString]=\"noSelectionString\"\n                     [selection]=\"selection\"\n                     [disabled]=\"disabled\"\n                     [name]=\"name\"\n                     (onSelection)=\"onSelection($event)\">\n            <ng-template #itemTemplate let-item>\n\n                <!-- todo: allow to pass a PIPE to do some additional formatting -->\n                {{ displayValue(item.value) }}\n            </ng-template>\n        </aw-dropdown>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Chooser'\">\n        <aw-chooser #chooser\n                    [editable]=\"editable\"\n                    [isStandalone]=\"false\"\n                    [name]=\"name\"\n                    [multiselect]=\"multiselect\"\n                    [dataSource]=\"dataSource\"\n                    [valueTransformer]=\"displayValue\"\n                    [disabled]=\"disabled\">\n\n        </aw-chooser>\n\n    </ng-template>\n\n</ng-container>\n",
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return GenericChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        GenericChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        GenericChooserComponent.propDecorators = {
            list: [{ type: core.Input }],
            object: [{ type: core.Input }],
            key: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            choiceProviderParams: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            type: [{ type: core.Input }],
            displayKey: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }]
        };
        return GenericChooserComponent;
    }(BaseFormComponent));
    /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */
    var /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */ GCChooserState = (function (_super) {
        __extends(GCChooserState, _super);
        function GCChooserState(gChooser) {
            var _this = _super.call(this) || this;
            _this.gChooser = gChooser;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        GCChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected === this.isSelected(selection)) {
                    return;
                }
                if (this.gChooser.multiselect) {
                    /** @type {?} */
                    var multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
                    if (core$1.isBlank(multiRel)) {
                        multiRel = [];
                    }
                    else if (core$1.isPresent(multiRel) && !core$1.isArray(multiRel)) {
                        throw new Error('I can not store multiselect value into non-array object');
                    }
                    if (selected) {
                        multiRel.push(selection);
                        this.gChooser.selection = multiRel;
                    }
                    else {
                        core$1.ListWrapper.removeIfExist(multiRel, selection);
                    }
                }
                else {
                    if (!selection) {
                        selection = null;
                    }
                    this.gChooser.selection = selection;
                }
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                if (this.gChooser.multiselect) {
                    /** @type {?} */
                    var objects = this.selectedObjects();
                    return (core$1.isBlank(objects) || core$1.ListWrapper.isEmpty(objects)) ? null : core$1.ListWrapper.last(objects);
                }
                return this.gChooser.selection;
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var selection = this.gChooser.selection;
                if (this.gChooser.multiselect && core$1.isBlank(selection)) {
                    selection = [];
                }
                return (this.gChooser.multiselect && core$1.isArray(selection)) ? selection : [selection];
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        GCChooserState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                if (this.gChooser.multiselect) {
                    return core$1.ListWrapper.containsComplex(this.selectedObjects(), selection);
                }
                /** @type {?} */
                var curValue = this.selectedObject();
                return core$1.equals(curValue, selection);
            };
        return GCChooserState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
     *
     *
     * ### Example
     *
     *
     * ```
     * \@Component({
     *          selector: 'gender-selector' ,
     *          template: `
     *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
     *     [selection]="selectedValue" [name]="'name'">
     *               </aw-radiobutton-list>
     *      `
     *      })
     *      export class GenderSelectorComponent
     *      {
     *          rbListValues: string[] = ['male' , 'female' , 'other'];
     *          selectedValue: string = 'other';
     *          layout: string = 'stacked';
     *
     *
     *          formGroup: FormGroup = new FormGroup({});
     *
     *
     *          onCBClick (event): void
     *          {
     *              console.log('onCBClick = ' + event);
     *          }
     *
     *      }
     *
     * ```
      @type {?} */
    var RB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonListComponent; }),
        multi: true
    };
    var RadioButtonListComponent = (function (_super) {
        __extends(RadioButtonListComponent, _super);
        function RadioButtonListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Fires an event when radio button is selected
             *
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.selection)) {
                    this.model = 0;
                }
                this.updateModel(this.selection);
                this.onModelChanged(this.selection);
                this.registerFormControl(this.selection);
            };
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         */
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.labelValue = /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         */
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
        RadioButtonListComponent.prototype.onChange = /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var updatedModel = this.list[this.model];
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
        RadioButtonListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
            function (souceItem) {
                /** @type {?} */
                var index = this.list.findIndex(function (elem) {
                    return souceItem === elem;
                });
                this.model = index === -1 ? 0 : index;
            };
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var updatedModel = this.list[this.model];
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                // this.cd.detectChanges();
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    /** @type {?} */
                    var newModel = value;
                    this.updateModel(newModel);
                }
            };
        RadioButtonListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton-list',
                        template: "<div *ngFor=\"let item of list;  let i = index\" class=\"ui-g\">\n\n    <div class=\"ui-g-12\">\n        <aw-radiobutton\n            [(ngModel)]=\"model\"\n            (ngModelChange)=\"onChange($event)\"\n            [isStandalone]=\"false\"\n            [name]=\"name\"\n            [value]=\"i\"\n            [label]=\"labelValue(item)\">\n        </aw-radiobutton>\n    </div>\n\n</div>\n",
                        providers: [
                            RB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonListComponent; }) }
                        ],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        RadioButtonListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            labelFormatter: [{ type: core.Input }],
            onSelection: [{ type: core.Output }]
        };
        return RadioButtonListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     *
     * Implements standard HTML radio button on top of PrimeNG with ariba styling
     *
     * ### Example
     *
     * 1. Basic usage using ngModel pre-selected first radio
     *
     *  ```ts
     *
     * \@Component({
     *          selector: 'demo-comp',
     *          template: `
     *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
     *                             [(ngModel)]="model">
     *             </aw-radiobutton>
     *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                      [(ngModel)]="model">
     *              </aw-radiobutton>
     *      `
     *      })*
     *      class BasicWithNgModelComponent
     *      {
     *          model: string[] = ['red'];
     *
     *          constructor()
     *          {
     *          }
     *      }
     *
     *  ```
     *
     *
     * 2. Basic usage with formGroup
     *
     *
     * ```ts
     * \@Component({
     *           selector: 'demo-comp',
     *           template: `
     *          <div [formGroup]="env.currentForm">
     *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *
     *       </div>
     *       `
     *       })
     *       class BasicWithFormGroupComponent implements OnInit
     *       {
     *           model: string = 'blue';
     *
     *           constructor(public env: Environment)
     *           {
     *           }
     *
     *           ngOnInit(): void
     *           {
     *               this.env.currentForm = new FormGroup({});
     *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
     *           }
     *
     *
     *           onChange(event: any): void
     *           {
     *               this.modelSet = event;
     *           }
     *
     *       }
     *  ````
     *
     *
     *
     *
      @type {?} */
    var RAB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var RadioButtonComponent = (function (_super) {
        __extends(RadioButtonComponent, _super);
        function RadioButtonComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this radio
             *
             */
            _this.value = '';
            /**
             * Trigger click event with currrent selected value
             *
             */
            _this.onChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.value);
                    this.model = this.formControl.value;
                    this.onModelChanged(this.model);
                }
                else {
                    this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                }
            };
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         */
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
        RadioButtonComponent.prototype.onModelChange = /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
            function (newVal) {
                this.onModelChanged(this.model);
                if (this.isStandalone) {
                    this.formControl.setValue(this.model, { emitEvent: true });
                }
                this.onChange.emit(this.model);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model, { emitEvent: true });
                    }
                    this.onModelChanged(this.model);
                }
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton',
                        template: "<span class=\"w-radiobutton\">\n\n    <ng-template [ngIf]=\"editable \">\n        <p-radioButton [name]=\"name\"\n                       [value]=\"value\"\n                       [label]=\"label\"\n                       [(ngModel)]=\"model\"\n                       [disabled]=\"disabled\"\n                       (ngModelChange)=\"onModelChange($event)\"\n                       [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\">\n        </p-radioButton>\n    </ng-template>\n</span>\n",
                        providers: [
                            RAB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonComponent; }) }
                        ],
                        styles: ["/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}"]
                    }] }
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonComponent.propDecorators = {
            value: [{ type: core.Input }],
            label: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return RadioButtonComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWRadioButtonModule = (function () {
        function AWRadioButtonModule() {
        }
        AWRadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.RadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonComponent
                        ],
                        exports: [
                            RadioButtonComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWRadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWRadioButtonListModule = (function () {
        function AWRadioButtonListModule() {
        }
        AWRadioButtonListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWRadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonListComponent
                        ],
                        exports: [
                            RadioButtonListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWRadioButtonListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWGenericChooserModule = (function () {
        function AWGenericChooserModule() {
        }
        AWGenericChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            GenericChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWDropdownModule,
                            AWCheckBoxListModule,
                            AWChooserModule,
                            AWRadioButtonListModule
                        ],
                        entryComponents: [
                            GenericChooserComponent
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            GenericChooserComponent
                        ]
                    },] }
        ];
        return AWGenericChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
     * holds all important information for the current outline tree and manages expansion states in form
     * of so called expansionPath and expansionStates
     *
     * We need to have a way how to work with generic data structure in order not to hold UI specific
     * information on the domain object model just like we had it before, where we had an interface
     * called OutlineNode, with fields (expanded, selected, etc.. )
     *
     *
     * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
     * OutlineController.
     *
     *
     * If we are dealing with Entity or anything that has identity then we have easier situation as we
     * can ask for ID and it is more efficient for serialization
     */
    var OutlineState = (function () {
        function OutlineState() {
            /**
             *
             * When outline is rendered for first time or re-rendered and we set default value for the
             * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
             *
             */
            this.isExpandedAll = false;
            /**
             *
             * Holds current level during tree node rendering so we can apply correct indentation
             *
             */
            this.currentLevel = -1;
            this.expansionStates = new Map();
        }
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         */
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
        OutlineState.prototype.collapseAll = /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    // for this case we collapse all but root nodes
                    if (this.outlineFor.pushRootSectionOnNewLine) {
                        this.outlineFor.list.forEach(function (item) {
                            _this.updateNodes(item.children || [], false);
                        });
                    }
                    else {
                        this.updateNodes(this.outlineFor.list || [], false);
                    }
                }
                else {
                    this.expansionStates.clear();
                }
                this.isExpandedAll = false;
            };
        /**
         * @return {?}
         */
        OutlineState.prototype.expandAll = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    this.updateNodes(this.outlineFor.list, true);
                }
                else {
                    this.expansionStates.clear();
                }
                this.isExpandedAll = true;
            };
        Object.defineProperty(OutlineState.prototype, "expansionPath", {
            get: /**
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._expansionPath)) {
                    this._expansionPath = [];
                }
                return this._expansionPath;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                this._expansionPath = value;
                if (core$1.isBlank(this._expansionPath)) {
                    return;
                }
                this._expansionPath.forEach(function (item) {
                    _this.setExpansionState(item, true);
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} currentPath
         * @param {?=} children
         * @return {?}
         */
        OutlineState.prototype.toggleExpansion = /**
         * @param {?} currentPath
         * @param {?=} children
         * @return {?}
         */
            function (currentPath, children) {
                if (core$1.isBlank(currentPath)) {
                    return;
                }
                /** @type {?} */
                var item = core$1.ListWrapper.last(currentPath);
                /** @type {?} */
                var itemChildren = children || [];
                /** @type {?} */
                var newState = !this.isExpanded(item);
                this.setExpansionState(item, newState);
                if (!newState) {
                    core$1.ListWrapper.removeLast(currentPath);
                    this.updateNodes(itemChildren, newState);
                }
                this.setExpansionPath(currentPath);
            };
        /**
         * @param {?} nodes
         * @param {?} newState
         * @return {?}
         */
        OutlineState.prototype.updateNodes = /**
         * @param {?} nodes
         * @param {?} newState
         * @return {?}
         */
            function (nodes, newState) {
                var _this = this;
                nodes.forEach(function (child) {
                    /** @type {?} */
                    var items = _this.outlineFor.childrenForItem(child);
                    if (core$1.isPresent(items) && items.length > 0) {
                        _this.updateNodes(items, newState);
                    }
                    _this.setExpansionState(child, newState);
                });
            };
        /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
        OutlineState.prototype.setExpansionState = /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
            function (item, isExpanded) {
                // Even for tree mode format save the state so we can use it later on in case object
                // references gets meesed up
                if (this.outlineFor &&
                    this.outlineFor.isTreeModelFormat()) {
                    ((item)).isExpanded = isExpanded;
                }
                else {
                    /** @type {?} */
                    var key = this.itemToKey(item);
                    if (isExpanded === this.isExpandedAll) {
                        this.expansionStates.delete(key);
                    }
                    else {
                        this.expansionStates.set(key, (isExpanded) ? true : false);
                    }
                }
            };
        /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.itemToKey = /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        /**
         * @param {?} items
         * @return {?}
         */
        OutlineState.prototype.setExpansionPath = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                this.expansionPath = items;
                items.forEach(function (node) {
                    _this.setExpansionState(node, true);
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    return ((item)).isExpanded;
                }
                else {
                    /** @type {?} */
                    var key = this.itemToKey(item);
                    if (!this.expansionStates.has(key)) {
                        return this.isExpandedAll;
                    }
                    return this.expansionStates.get(key);
                }
            };
        OutlineState.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        OutlineState.ctorParameters = function () { return []; };
        return OutlineState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Checks type for OutlineNode
     *
     * @param {?} node
     * @return {?}
     */
    function isOutlineNode(node) {
        return core$1.isPresent(node) && core$1.isPresent(((node)))
            && core$1.isPresent(((node)).parent)
            && core$1.isPresent(((node)).children);
    }
    /**
     *
     * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
     * those cases where an item may have children.
     *
     *
     * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
     * and other things.
     *
     *
     * This component has minimal styling to make sure it can be changed easily.
     *
     * ### Example rendering tree section, where based on the type we format the out plus
     * for the main root section we always render little popup menu.
     *
     * ```
     *
     *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
     *
     *       <ng-template #outline let-item>
     *
     *           <div class="my-section">
     *               <div class="outline">
     *                   <aw-outline-control>
     *                       <ng-container [ngSwitch]="item.type">
     *                           <ng-template [ngSwitchCase]="'text'">
     *                               <div class="as-paragraf">
     *                                   {{item?.content}}
     *                               </div>
     *                           </ng-template>
     *
     *
     *                           <ng-template ngSwitchDefault>
     *                               {{item?.content}}
     *                           </ng-template>
     *
     *
     *                       </ng-container>
     *
     *
     *                   </aw-outline-control>
     *               </div>
     *
     *               <div class="filters" *ngIf="item.type === 'section'" >
     *
     *                   <aw-hover-card [linkTitle]="'Filter Items'">
     *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
     *                   </aw-hover-card>
     *
     *               </div>
     *           </div>
     *     </ng-template>`
     *   </aw-outline-for>
     *
     * ```
     *
     *
     * We can use it also in embedded mode where we use the `awOutlineFor` directive
     *
     * ## Example
     *
     *
     * ````
     *  <table  class="tree-table" >
     *      <thead>
     *          <tr>
     *              <th>Name</th>
     *              <th>Type</th>
     *          </tr>
     *      </thead>
     *      <tbody #ooo2 awOutlineFor [list]="list"
     *             [hasChildren]="hasChildren"
     *             class="outline-table"
     *      >
     *          <ng-template #outline let-item>
     *              <tr>
     *                  <td class="item-name outline-animation">
     *                      <div><aw-outline-control>
     *                          {{item?.content}}
     *                      </aw-outline-control></div>
     *                  </td>
     *                  <td class="item-type outline-animation">
     *                      <div>{{item.type}}</div>
     *                  </td>
     *              </tr>
     *          </ng-template>
     *      </tbody>
     *  </table>
     *
     * ```
     *
     * I was thinking maybe for first time we don't need the same animation like expanding and
     * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
     * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
     * execute the same rendering just without [\@section]
     *
     *
     * Todo: Think about how to do animation for the table case. Must also write unitest - due to
     * AribaLive aggressive schedule we are skipping them for now
     *
     */
    var OutlineForComponent = (function (_super) {
        __extends(OutlineForComponent, _super);
        function OutlineForComponent(env, _viewContainer, builder, element) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.builder = builder;
            _this.element = element;
            /**
             * Tells the component not to render expansion control, in such case we expandAll as a
             * default behavior
             *
             */
            _this.showExpansionControl = true;
            /**
             * Opens all tree nodes.
             *
             */
            _this.expandAll = false;
            /**
             *
             * Set indentation size to be used for each level
             *
             */
            _this.indentationPerLevel = 25;
            _this.pushRootSectionOnNewLine = false;
            /**
             *
             * Identifies current model mode.
             *
             * We recognize two modes:
             *
             * Free - Application needs to implement a children method to retrieve a list of children for
             * each node and format is pretty much upt to the application
             *
             * Tree - this is more restrictive where we have concrete data structure
             * interface that needs to be folled
             *
             * todo: instead of passing format binding try to look into the list to see what type so
             * we dont make it mandatory
             *
             */
            _this.format = 'free';
            /**
             *
             * Used when in selection mode to push current selected Item to the application
             *
             */
            _this.onItemSelected = new core.EventEmitter();
            /**
             *
             * This event is triggered by OutlineControl when node is expanded or collapsed
             *
             */
            _this.onExpandChange = new core.EventEmitter();
            _this.embedded = false;
            /**
             * Flag that tells us that component is fully rendered
             *
             */
            _this.viewInitialized = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.state)) {
                    this.state = new OutlineState();
                }
                if (core$1.isBlank(this.state.outlineFor)) {
                    this.state.outlineFor = this;
                }
                if (this.expandAll) {
                    this.showExpansionControl = false;
                }
                this.state.isExpandedAll = this.expandAll;
                // in case we want to render content of tree outside of outlineFor
                if (core$1.isPresent(this.externalTemplate)) {
                    this.controlTemplate = this.externalTemplate;
                }
                this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
                if (core$1.isBlank(this.context)) {
                    this.context = this;
                }
            };
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
            };
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.isTreeModelFormat = /**
         * @return {?}
         */
            function () {
                return this.format === 'tree';
            };
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         */
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.isExpanded = /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
            function (item, currentLevel) {
                if (currentLevel === void 0) {
                    currentLevel = -1;
                }
                if (currentLevel === 0 && this.pushRootSectionOnNewLine) {
                    // always override/reset for root nodes
                    if (this.isTreeModelFormat()) {
                        ((item)).isExpanded = true;
                    }
                    return true;
                }
                return this.state.isExpanded(item);
            };
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         */
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.childrenForItem = /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.isTreeModelFormat()) {
                    return ((item)).children || [];
                }
                else {
                    return this.hasChildren(item) ? this.doGetChildren(item) : [];
                }
            };
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         */
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.hasChildren = /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.isTreeModelFormat()) {
                    /** @type {?} */
                    var children = ((item)).children;
                    return core$1.isPresent(children) && children.length > 0;
                }
                else if (core$1.isBlank(this.children) && core$1.isBlank(item.children)) {
                    core$1.assert(false, 'Missing [children] method binding');
                }
                return this.doGetChildren(item).length > 0;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.doGetChildren = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.children.apply(this.context, [item]);
            };
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         */
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
        OutlineForComponent.prototype.toggleExpansion = /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.animationInProgress) {
                    // backup procedure in case onAnimationDone fails
                    setTimeout(function () {
                        if (_this.animationInProgress) {
                            // change only if its fails
                            _this.animationInProgress = false;
                        }
                    }, 200);
                    return;
                }
                if (!this.embedded) {
                    this.animationInProgress = true;
                }
                /** @type {?} */
                var currentItem = core$1.ListWrapper.last(this.state.currentPath);
                this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
                if (this.embedded) ;
            };
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         */
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
        OutlineForComponent.prototype.onAnimationDone = /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.animationInProgress = false;
            };
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         */
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.indentation = /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
            function (currentLevel) {
                if (this.pushRootSectionOnNewLine && currentLevel > 0) {
                    currentLevel -= 1;
                }
                return (currentLevel === 0 && this.pushRootSectionOnNewLine)
                    ? 0 : (this.indentationPerLevel * currentLevel);
            };
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         */
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.isVisible = /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.filterOut)) {
                    return !this.filterOut(item);
                }
                return true;
            };
        OutlineForComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-for, [awOutlineFor]',
                        template: "<!--\n    Starts with the list, where nestingLevel is -1.\n    call template outlineItems to iterate and render each item\n-->\n<ng-container [ngIf]=\"list\" *ngTemplateOutlet=\"outlineItems;\n            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}\">\n</ng-container>\n\n<!--\n    Main Entry point for the recursion. this is called by the block above as well as byt the inner\n    piece that calls this template recursively again when an item has children\n-->\n<ng-template #outlineItems let-children let-nestingLevel=\"nestingLevel\"\n             let-parent=\"parentItem\" let-expanded=\"expanded\">\n\n    <ng-template ngFor let-item [ngForOf]=\"children\" let-rowIndex=\"index\">\n\n        <ng-container *ngTemplateOutlet=\"outlineItem;\n            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,\n            expanded: expanded, rowIndex:rowIndex}\">\n        </ng-container>\n\n        <!--\n\n            Recursion piece:\n\n            For non embedded case when even if its not expanded we need to iterate children\n            as we want to apply animation that should go with ngIf which inside the outineItem\n            template\n\n            Dont recurse/ render items that are not visible.\n        -->\n\n        <ng-template [ngIf]=\"hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)\">\n            <ng-container *ngTemplateOutlet=\"outlineItems;\n                        context:{ $implicit: childrenForItem(item),\n                                nestingLevel: nestingLevel+1,\n                                expanded: isExpanded(item, nestingLevel),\n                                parentItem:item }\">\n            </ng-container>\n        </ng-template>\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Renders actual outline node and applies animation while expanding and collapsing\n\n    [@section]=\"expanded || isExpanded(item) ? 'visible' : 'hidden'\"\n-->\n<ng-template #outlineItem let-item let-nestingLevel=\"nestingLevel\" let-parent=\"parentItem\"\n             let-rowIndex=\"rowIndex\"\n             let-expanded=\"expanded\">\n\n    <div class=\"w-outline-item\"\n         *ngIf=\"!embedded && expanded\"\n         [style.padding-left.px]=\"indentation(nestingLevel)\"\n         initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n         [setCurrrentItem]=\"item\"\n         [@section]\n         (@section.done)=\"onAnimationDone($event)\">\n\n        <ng-container *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }\">\n        </ng-container>\n    </div>\n\n    <!--\n        When outline control is used as embedded meaning its inside e..g datatable we\n        cannot have any tags around it.\n\n        Todo: Refactor this in the way so we can do animation when table lines are\n        expanded. Since its embedded we can not have any wrapping element around, the template\n        is fully responsible\n    -->\n    <ng-template [ngIf]=\"embedded && expanded\"\n                 initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n                 [setCurrrentItem]=\"item\"\n    >\n        <ng-container #renderedItem *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }\">\n        </ng-container>\n    </ng-template>\n\n</ng-template>\n\n\n",
                        animations: [
                            animations.trigger('section', [
                                animations.state('*', animations.style({
                                    'overflow-y': 'hidden',
                                    'height': '*',
                                    'opacity': '1'
                                })),
                                animations.state('void', animations.style({
                                    'height': '0',
                                    'opacity': '0',
                                    'overflow-y': 'hidden'
                                })),
                                animations.transition('* => void', animations.animate('200ms ease-out')),
                                animations.transition('void => *', animations.animate('200ms ease-in'))
                            ]),
                        ],
                        styles: [".is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}"]
                    }] }
        ];
        /** @nocollapse */
        OutlineForComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: animations.AnimationBuilder },
                { type: core.ElementRef }
            ];
        };
        OutlineForComponent.propDecorators = {
            list: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            children: [{ type: core.Input }],
            filterOut: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            state: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            externalTemplate: [{ type: core.Input }],
            context: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            format: [{ type: core.Input }],
            onItemSelected: [{ type: core.Output }],
            onExpandChange: [{ type: core.Output }],
            controlTemplate: [{ type: core.ContentChild, args: ['outline',] }],
            outlineItem: [{ type: core.ViewChild, args: ['renderedItem',] }]
        };
        return OutlineForComponent;
    }(BaseComponent));
    /**
     *
     * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
     * use this directive to do the Job
     *
     */
    var InitNestingDirective = (function () {
        function InitNestingDirective(outline) {
            this.outline = outline;
        }
        /**
         * @return {?}
         */
        InitNestingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.setLevel)) {
                    this.outline.state.currentLevel = this.setLevel;
                }
                if (core$1.isPresent(this.setCurrrentItem)) {
                    this.outline.currentItem = this.setCurrrentItem;
                    if (this.outline.isTreeModelFormat()) {
                        this.outline.currentItem['$$parentItem']
                            = ((this.setCurrrentItem)).parent;
                    }
                }
                if (!this.outline.isTreeModelFormat() && core$1.isPresent(this.setParentItem)) {
                    this.outline.currentItem['$$parentItem'] = this.setParentItem;
                }
            };
        InitNestingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[initNesting]'
                    },] }
        ];
        /** @nocollapse */
        InitNestingDirective.ctorParameters = function () {
            return [
                { type: OutlineForComponent }
            ];
        };
        InitNestingDirective.propDecorators = {
            setLevel: [{ type: core.Input }],
            setCurrrentItem: [{ type: core.Input }],
            setParentItem: [{ type: core.Input }]
        };
        return InitNestingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
     * It should be used either in the body of an OutlineFor component, or inside datatable
     *
     *
     * ##Usage inside body:
     *
     *  Here you can see that we need to wrap out content inside ng-template which will push us
     *  give us current item item and then we can place OutlineControlComponent to control
     *  the tree.
     *
     * ```
     *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
     *
     *      <ng-template #outline let-item>
     *          <div class="my-section">
     *              <div class="outline">
     *                  <aw-outline-control>
     *                      {{item?.content}}
     *                  </aw-outline-control>
     *              </div>*
     *          </div>
     *      </ng-template>
     *  </aw-outline-for2>
     *
     *
     * ```
     *
     *
     *
     *
     */
    var OutlineControlComponent = (function (_super) {
        __extends(OutlineControlComponent, _super);
        function OutlineControlComponent(env, outlineState, parentControl, outlineFor) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.outlineState = outlineState;
            _this.parentControl = parentControl;
            _this.outlineFor = outlineFor;
            /**
             *
             *  If TRUE it changes the behavior of the outline node text which click is triggered
             *  it selects the item and broadcast the `onItemSelected` event
             *
             */
            _this.allowSelection = false;
            _this.allowEdit = false;
            /**
             *
             * Triggers action when outline item is expanded
             *
             */
            _this.action = new core.EventEmitter();
            _this.isRootItem = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.prepareControl();
            };
        /**
         *
         * We dont show expansion icons when there no children
         *
         */
        /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
        OutlineControlComponent.prototype.hasExpansionControl = /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
            function () {
                return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.isSelected = /**
         * @return {?}
         */
            function () {
                return this.outlineFor.state.selectedItem === this.item;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.calculateStyleClass = /**
         * @return {?}
         */
            function () {
                if (!this.hasExpansionControl() ||
                    (this.outlineFor.pushRootSectionOnNewLine && core$1.isBlank(this.item.$$parentItem))) {
                    return '';
                }
                if (this.outlineFor.embedded) {
                    return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                        : 'icon-slim-arrow-right';
                }
                else {
                    return this.outlineFor.isExpanded(this.item)
                        ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
                }
            };
        /**
         * Collapses and expands current node
         *
         */
        /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
        OutlineControlComponent.prototype.toggleExpansion = /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.outlineFor.state.currentPath = [];
                /** @type {?} */
                var currentPath = this.item;
                while (core$1.isPresent(currentPath)) {
                    this.outlineFor.state.currentPath.unshift(currentPath);
                    currentPath = currentPath.$$parentItem;
                }
                this.outlineFor.toggleExpansion();
                /** @type {?} */
                var payload = {
                    item: this.item,
                    expanded: this.outlineFor.state.isExpanded(this.item)
                };
                this.action.emit(payload);
                this.outlineFor.onExpandChange.emit(payload);
                event.stopPropagation();
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                this.outlineFor.state.selectedItem = this.item;
                this.outlineFor.onItemSelected.emit(this.item);
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.prepareControl = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.outlineFor) && core$1.isPresent(this.outlineState)) {
                    this.outlineFor = this.outlineState.outlineFor;
                }
                core$1.assert(core$1.isPresent(this.outlineFor), 'Missing outlineFor component');
                if (this.outlineFor.embedded) {
                    /** @type {?} */
                    var level = this.outlineFor.state.currentLevel;
                    if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                        level -= 1;
                    }
                    this.indentation = (this.outlineFor.indentationPerLevel * level);
                }
                this.item = this.outlineFor.currentItem;
                this.isRootItem = core$1.isBlank(this.item.$$parentItem);
            };
        OutlineControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-control',
                        template: "<!--\n    Control is just the two flex box items for displaying expand/collapse icon and content\n\n    Since we animate only standalone/non-embedded case now then we need to also animate the icon\n    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.\n\n    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down\n-->\n<div class=\"w-outline-control\"\n     [ngClass]=\"{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}\">\n    <div class=\"outline-icon sap-icon\"\n         *ngIf=\"!outlineFor.pushRootSectionOnNewLine || !isRootItem\"\n         (click)=\"toggleExpansion($event)\"\n         [style.margin-left.px]=\"indentation\"\n         [ngClass]=\"calculateStyleClass()\">\n    </div>\n\n    <ng-container *ngIf=\"allowSelection; then withSelection else withoutSelection\">\n    </ng-container>\n</div>\n\n<!--\n We support two case for the content\n\n Selection: When you click on the content it will add extra class so you can style currently\n selected item as well as broadcast event outside so developer can hook in some custom logic\n\n If we dont support selection: Then clicking on the content is just like clicking on expandable\n icon, it toggles the state\n-->\n\n<ng-template #withSelection>\n     <span class=\"outline-content outline-content-selected\" *ngIf=\"!allowEdit && isSelected()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span class=\"outline-content\" *ngIf=\"!allowEdit && !isSelected()\" (click)=\"select()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n\n</ng-template>\n\n\n<ng-template #withoutSelection>\n    <span *ngIf=\"!allowEdit\" class=\"outline-content\" (click)=\"toggleExpansion($event)\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span *ngIf=\"allowEdit\" class=\"outline-content\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n</ng-template>\n\n\n<ng-template #ngContent>\n    <ng-content></ng-content>\n</ng-template>\n\n",
                        styles: [".w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;-ms-grid-row-align:center;align-self:center;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}"]
                    }] }
        ];
        /** @nocollapse */
        OutlineControlComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: OutlineState, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineState; }),] }] },
                { type: OutlineControlComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineControlComponent; }),] }] },
                { type: OutlineForComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineForComponent; }),] }] }
            ];
        };
        OutlineControlComponent.propDecorators = {
            allowSelection: [{ type: core.Input }],
            allowEdit: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return OutlineControlComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWOutlineForModule = (function () {
        function AWOutlineForModule() {
        }
        AWOutlineForModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            InitNestingDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWOutlineForModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Renders html text area component
     *
     * ### Example
     *
     * ```typescript
     *
     * \@Component({
     *          selector: 'myNote' ,
     *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
     *              </aw-text-area>'
     *      })
     *      export class MyNoteComponent
     *      {
     *          inputValue: string = 'Some really long text';
     *          autoResize: false;
     *      }
     *
     * ```
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
      @type {?} */
    var TEXTAREA_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TextAreaComponent; }),
        multi: true
    };
    var TextAreaComponent = (function (_super) {
        __extends(TextAreaComponent, _super);
        function TextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to store and read user input
             *
             */
            _this.value = '';
            /**
             * Spefifies visible number of lines
             */
            _this.rows = 2;
            /**
             * Specifies visible width
             */
            _this.columns = 20;
            /**
             * when this option is TRUE and user starts typing it will maximize textarea's width and height
             */
            _this.autoResize = true;
            return _this;
        }
        /**
         * @return {?}
         */
        TextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        TextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        TextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-text-area',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\">\n\n\t<textarea\n        pInputTextarea\n        [attr.name]=\"name\"\n        class=\"w-text-area\"\n        [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        [class.disabled]=\"disabled\"\n        formControlName=\"{{name}}\"\n        [rows]=\"rows\"\n        [cols]=\"columns\"\n        [autoResize]=\"autoResize\"\n        [attr.placeholder]=\"placeHolder\"\n\n    ></textarea>\n\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        providers: [
                            TEXTAREA_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return TextAreaComponent; }) }
                        ],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        TextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        TextAreaComponent.propDecorators = {
            value: [{ type: core.Input }],
            rows: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            autoResize: [{ type: core.Input }]
        };
        return TextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWTextAreaModule = (function () {
        function AWTextAreaModule() {
        }
        AWTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextareaModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            TextAreaComponent
                        ],
                        exports: [
                            TextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Page-Notification component that implements a notification system for the user regarding
     * the current object he's working on. Typical notification are:
     *      Success - saved.
     *      Warning - Sourcing request requires 3 suppliers.
     *      Error   - cannot connect to server, check internet connection.
     *
     *
     *
     * Usage 1:  As part of page wrapper.
     *
     * \@Component({
     *    selector: 'MyPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="MyPage"
     *                        [objectType]="MyType"
     *                        [notification]="pageNotification">
     *             page content
     *          `
     *       </aw-object-pager-wrapper>
     *    })
     *    export class MyPage
     *    {
     *
     *        pageNotification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     * Usage 2: directly into the page.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *      <aw-header></aw-header>
     *        Page Header
     *
     *        <ng-template [ngIf]="hasNotifications()">
     *          <div class="ui-g-12 u-nopadding">
     *            <aw-page-notification [notification]="notification"></aw-page-notification>
     *          </div>
     *        </ng-template>
     *
     *      <aw-footer></aw-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        notification: PageNotification = new PageNotification("warning",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     */
    var PageNotificationComponent = (function (_super) {
        __extends(PageNotificationComponent, _super);
        function PageNotificationComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationClass = /**
         * @return {?}
         */
            function () {
                return "notification-" + this.notification.type;
            };
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationIcon = /**
         * @return {?}
         */
            function () {
                return "ariba-icon icon-" + this.notification.type;
            };
        PageNotificationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-notification',
                        template: "<div class=\"page-notification\">\n    <div [class]=\"notificationClass()\">\n        <i [class]=\"notificationIcon()\"></i>\n        <span class=\"content\">\n              <span class=\"title\">{{notification.title}}</span>\n              <span class=\"description\">\n                    <ng-template *ngIf=\"notification.hasTemplate(); else description\"\n                                 [ngTemplateOutlet]=\"notification.contentTmpl\">\n                    </ng-template>\n                    <ng-template #description>{{notification.description}}</ng-template>\n              </span>\n      </span>\n    </div>\n</div>\n",
                        styles: [".page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:\"\\EA9D\"}.icon-warning:before{content:\"\\EA9C\"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}"]
                    }] }
        ];
        /** @nocollapse */
        PageNotificationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageNotificationComponent.propDecorators = {
            notification: [{ type: core.Input }]
        };
        return PageNotificationComponent;
    }(BaseComponent));
    /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */
    var /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */ PageNotification = (function () {
        function PageNotification(type, title, description, contentTmpl) {
            this.type = type;
            this.title = title;
            this.description = description;
            this.contentTmpl = contentTmpl;
        }
        /**
         * @return {?}
         */
        PageNotification.prototype.hasTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.contentTmpl);
            };
        /**
         * @return {?}
         */
        PageNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.type + ', title: ' + this.title + ', description:  ' + this.description;
            };
        return PageNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWPageNotificationModule = (function () {
        function AWPageNotificationModule() {
        }
        AWPageNotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            PageNotificationComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            PageNotificationComponent
                        ],
                        exports: [
                            PageNotificationComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWPageNotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Represents an event triggered when a page has been initialized.
     *
     */
    var /**
     * Represents an event triggered when a page has been initialized.
     *
     */ PageInitialized = (function () {
        function PageInitialized(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageInitialized.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageInitializied(title: " + this.title + ")";
            };
        return PageInitialized;
    }());
    /**
     * Represents an event triggered when a page has been destroyed.
     *
     */
    var /**
     * Represents an event triggered when a page has been destroyed.
     *
     */ PageDestroyed = (function () {
        function PageDestroyed(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageDestroyed.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageDestroyed(title: " + this.title + ")";
            };
        return PageDestroyed;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Page LifeCycle Service monitors all page initialization and destructions.
     * The purpose of this service is to help the application monitor page lifecycle, subscribe
     * to lifecycle events and execute actions such as user analytics.
     *
     * Usage:
     *
     *    1.  Inject PageLifeCycleService into your constructor
     *
     *    constructor(pageLifecycle:PageLifeCycleService) {
     *        pageLifecycle.pageEvents.subscribe(event:Event => {
     *            if(event instanceof PageInitialized) {
     *            }
     *            // PageDestroyed
     *
     *        });
     *     }
     */
    var PageLifeCycleService = (function () {
        /**
         *
         */
        function PageLifeCycleService() {
            /**
             * Page event queue when all page lifecycle events: init, destroy are emitted.
             * Listeners can subscribe to these events.
             */
            this.pageEvents = new rxjs.Subject();
        }
        /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageInit = /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageInitialized(pageTitle));
            };
        /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageDestroy = /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageDestroyed(pageTitle));
            };
        PageLifeCycleService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PageLifeCycleService.ctorParameters = function () { return []; };
        return PageLifeCycleService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var PageType = {
        Init: 0,
        // Init Page type
        Login: 1,
        // Login Page
        Object: 2,
        // Object detail page
        List: 3,
        // List Page
        MasterDetail: 4,
        // MasterDetail
        Dashboard: 5,
        // Dashboard page
        Modal: 6 // Modal page, it can be configured to be a popup, or standalone page.
        ,
    };
    PageType[PageType.Init] = 'Init';
    PageType[PageType.Login] = 'Login';
    PageType[PageType.Object] = 'Object';
    PageType[PageType.List] = 'List';
    PageType[PageType.MasterDetail] = 'MasterDetail';
    PageType[PageType.Dashboard] = 'Dashboard';
    PageType[PageType.Modal] = 'Modal';
    /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */
    var /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */ PageWrapper = (function (_super) {
        __extends(PageWrapper, _super);
        function PageWrapper(env, pageType, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.componentRegistry = componentRegistry;
            _this.pageLifecycleService = pageLifecycleService;
            /**
             * What type of page this is.
             *
             */
            _this.pageType = PageType.Init;
            _this.pageType = pageType;
            return _this;
        }
        /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
        PageWrapper.prototype.getId = /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
            function () {
                if (this.id) {
                    return this.id;
                }
                this.id = this.generatePageId();
            };
        return PageWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Header component that implements consistent styling, behavior for an Ariba page.
     * Header includes a menu, user profile, and alerts.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
     *                                 [menuItems]="menuItems" [notifications]="userNotifications">
     *                     <div class="page-header-center">
     *                           <a class="navbar-brand" tabindex="0" href="/">
     *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
     *                                   alt="Go to homepage" data-pin-nopin="true">
     *                          </a>
     *                     </div>
     *                </aw-page-header>
     *
     *    `
     *    })
     *    export class MyPage
     *    {
     *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
     *                                  new PageMenuItem('icon-expense-report', 'Reports',
     *                                                     '/play/pageheader'),
     *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
     *                                                       '/play/pageheader'),
     *                                  new PageMenuItem('icon-account', 'Accounts',
     *                                                     '/play/pageheader')];
     *
     *     userNotifications: UserNotification[] = [
     *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
     *                             '/play/'),
     *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
     *                             '/play/'),
     *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
     *                               '/play/')
     *        ];
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageHeaderComponent = (function (_super) {
        __extends(PageHeaderComponent, _super);
        function PageHeaderComponent(element, env, routing) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            _this.routing = routing;
            /**
             * Should the user notification icon be hidden. Default it to show the icon even
             * if there's no notifications.
             *
             */
            _this.hideNotification = false;
            /**
             * displays the back link that navigates user to the previous page when clicked.
             */
            _this.showBackAction = false;
            _this.showNotificationPanel = false;
            return _this;
        }
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.backAction = /**
         * @return {?}
         */
            function () {
                this.routing.goBack();
            };
        /**
         * Do i have any menu items.
         *
         */
        /**
         * Do i have any menu items.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasMenuItems = /**
         * Do i have any menu items.
         *
         * @return {?}
         */
            function () {
                return (this.menuItems && this.menuItems.length > 0);
            };
        /**
         * Toggle the side navigation menu.
         */
        /**
         * Toggle the side navigation menu.
         * @return {?}
         */
        PageHeaderComponent.prototype.showHideMenu = /**
         * Toggle the side navigation menu.
         * @return {?}
         */
            function () {
                this.sidenav.toggle();
            };
        /**
         * Do I have any notifications.
         *
         */
        /**
         * Do I have any notifications.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasNotifications = /**
         * Do I have any notifications.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.notifications) && this.notifications.length > 0;
            };
        /**
         * toggling wheather notification panel is displayed or not.
         */
        /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
        PageHeaderComponent.prototype.toggleNotificationPanel = /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
            function () {
                this.showNotificationPanel = !this.showNotificationPanel;
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-header',
                        template: "<nav class=\"navbar page-header\" role=\"navigation\">\n\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-4 navbar-left\">\n\n        <span *ngIf=\"hasMenuItems()\">\n            <a (click)=\"showHideMenu()\">\n                <i class=\"sap-icon icon-paging\"></i>\n            </a>\n\n            <!-- Side menu -->\n            <aw-sidenav #sidemenu [items]=\"menuItems\"></aw-sidenav>\n        </span>\n            <!-- End Hamburger menu. -->\n\n            <!--  back action -->\n            <span class=\"back-action\">\n            <a (click)=\"backAction()\">\n                <i *ngIf=\"showBackAction\" class=\"sap-icon icon-arrow-left\" role=\"button\"></i>\n            </a>\n        </span>\n\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-center\">\n\n            <!-- central section.  Application can add Ariba-logo, search box, etc -->\n            <ng-content select=\".page-header-center\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-right\">\n        <span *ngIf=\"userName\">\n            <img id=\"userProfilePicture\" class=\"profile-logo\" aria-hidden=\"true\"\n                 [title]=\"userName\" src=\"{{assetFolder}}/images/default_image_small.png\">\n            <span class=\"profile-user\" title=\"{{userName}}\">{{userName}}</span>\n        </span>\n\n            <span *ngIf=\"!hideNotification\" class=\"notification-container\">\n\n            <i #notificationIcon class=\"ariba-icon icon-notification\"\n               (click)=\"toggleNotificationPanel()\"></i>\n            <span *ngIf=\"hasNotifications()\" class=\"notification-badge\" aria-hidden=\"true\">{{notifications.length}}</span>\n\n                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.\n                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->\n            <div *ngIf=\"showNotificationPanel\" class=\"notification-panel\">\n\n                <div class=\"notification-header\">\n                     Notifications\n                </div>\n\n                <ul class=\"notification-content\">\n                    <li *ngFor=\"let noti of notifications\" class=\"notification-item\">\n                        <a [routerLink]=\"noti.link\">\n                            <span class=\"notification-item-icon\"><i\n                                [ngClass]=\"'sap-icon ' + noti.icon\"></i></span>\n                            {{noti.label}}\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </span>\n        </div>\n\n\n    </div>\n</nav>\n",
                        styles: [".page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:\"\\eA14\"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:.3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}"]
                    }] }
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core$1.RoutingService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            menuItems: [{ type: core.Input }],
            notifications: [{ type: core.Input }],
            hideNotification: [{ type: core.Input }],
            showBackAction: [{ type: core.Input }],
            userName: [{ type: core.Input }],
            sidenav: [{ type: core.ViewChild, args: ['sidemenu',] }]
        };
        return PageHeaderComponent;
    }(BaseComponent));
    /**
     * PageMenuItem represents an item in the page menu structure.
     */
    var /**
     * PageMenuItem represents an item in the page menu structure.
     */ PageMenuItem = (function () {
        /**
         * @param icon    - Icon of this menu item.
         * @param label   - label of this item.
         * @param link    - link to the destination when user clicks on it.
         */
        function PageMenuItem(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        PageMenuItem.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageMenuItem: (label, " + this.label + ")";
            };
        return PageMenuItem;
    }());
    /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */
    var /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */ UserNotification = (function () {
        /**
         * @param icon   - alert notification icon
         * @param label  - alert notification label
         * @param link   - link
         */
        function UserNotification(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        UserNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageUserNotification: (label, " + this.label + ")";
            };
        return UserNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Footer component that implements consistent styling, behavior.
     * This footer component self contained.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *          <aw-page-footer>
     *               <div class="page-footer-logo">
     *                   <img src="images/ariba_logo_white_bkgd.png">
     *               </div>
     *               <div class="page-footer-user-info">
     *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
     *                   | Buyer Organization
     *               </div>
     *               <span class="page-footer-copyright" #copyright>
     *                   <p> 20202028 The Future, Inc. All rights reserved</p>
     *               </span>
     *           </aw-page-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageFooterComponent = (function (_super) {
        __extends(PageFooterComponent, _super);
        function PageFooterComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * show default copyright. If copyright is passed in, then show the passed in one.
             */
            _this.showDefaultCopyright = true;
            return _this;
        }
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.showDefaultCopyright = !core$1.isPresent(this.copyright);
            };
        PageFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-footer',
                        template: "<div class=\"page-footer\">\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-8\">\n\n            <ng-content select=\".page-footer-logo\"></ng-content>\n\n            <div class=\"user-info\">\n                <ng-content select=\".page-footer-user-info\"></ng-content>\n            </div>\n\n            <ul class=\"footer-links\">\n                <li role=\"presentation\"><a href=\"http://www.ariba.com/legal/ariba_tou.cfm\">Terms of\n                    Use</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_security_policy.cfm\">Security\n                    Disclosure</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_privacy_statement.cfm\">Privacy\n                    Statement</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Cookie Statement</a>\n                </li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Participant\n                    Statement</a></li>\n            </ul>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4\">\n            <div class=\"u-bottom-align\"></div>\n            <div class=\"u-hright copyright\">\n                <ng-content select=\".page-footer-copyright\"></ng-content>\n            </div>\n\n            <!-- Default Copyright -->\n            <div *ngIf=\"showDefaultCopyright\" class=\"u-hright copyright\">\n                <p>\u00A9 1996\u20132017 Ariba, Inc. All rights reserved</p>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                        styles: [".page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:\" \";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}"]
                    }] }
        ];
        /** @nocollapse */
        PageFooterComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageFooterComponent.propDecorators = {
            copyright: [{ type: core.ContentChild, args: ['copyright',] }]
        };
        return PageFooterComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
     * Header, Page title, Page notification, actions, content, and Footer.
     *
     *
     *  Usage:
     *
     * \@Component({
     *    selector: 'RFXPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="rfxEntity.headerInfo.title"
     *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
     *                        [notification]="pageNotification">
     *
     *
     *           <aw-page-actions>
     *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
     *                   Edit
     *                </aw-button>
     *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
     *                                                         [style]="'secondary'">
     *                  Cancel
     *               </aw-button>
     *           </aw-page-actions>
     *
     *           <aw-page-content>
     *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
     *
     *                   <m-context [object]="rfxEntity.headerInfo"
     *                              [operation]="this.editabilityState.headerInfoOp"
     *                              layout="Inspect"
     *                              uiGroup="HeaderGeneral"
     *                   >
     *                       <m-include-component></m-include-component>
     *                   </m-context>
     *
     *             </aw-section>
     *           </aw-page-content>
     *       </aw-object-page-wrapper>
     *    `
     *    })
     *    export class RFXPage
     *    {
     *       // To keep track what section is editable and which read only
     *       editabilityState: EditabilityState;
     *
     *       // Current RFX event
     *       rfxEntity: RfxEventEntity;
     *
     *       // Notifications
     *       notification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var ObjectPageWrapperComponent = (function (_super) {
        __extends(ObjectPageWrapperComponent, _super);
        function ObjectPageWrapperComponent(element, env, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env, PageType.Object, componentRegistry, pageLifecycleService) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Set true if page should not include any header. Need to set to true even no header
             * object is passed in. Otherwise, a default Header component will be added.
             */
            _this.hideHeader = false;
            /**
             * Set true if page should not include any footer. Need to set to true even no footer
             * object is passed in. Otherwise, a default Footer component will be added.
             */
            _this.hideFooter = false;
            /**
             * The positioning of the page actions (page buttons)
             *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
             *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
             *   'both'   : page buttons are placed at both top and bottom.
             *
             */
            _this.pageActionPosition = 'top';
            /**
             * This flag is driven by pageActionPosition. The default position is top.
             * Value is true for both 'top' and 'both' of pageActionPosition.
             */
            _this.hasTopPageActions = true;
            _this.objectStateIndex = 0;
            // Setting Default header component
            // Setting Default header component
            _this.header = PageHeaderComponent;
            _this.footer = PageFooterComponent;
            return _this;
        }
        /**
         * Generate a unique Id for this object.
         *
         */
        /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.generatePageId = /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
            function () {
                return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
            };
        /**
         * Does my page have page notification?
         *
         */
        /**
         * Does my page have page notification?
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasNotifications = /**
         * Does my page have page notification?
         *
         * @return {?}
         */
            function () {
                return (this.notifications && this.notifications.length > 0);
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasObjectStates = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.objectStates);
            };
        /**
         * Initialize my local components
         */
        /**
         * Initialize my local components
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnInit = /**
         * Initialize my local components
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // New Component types that are used in c-include-component
                if (this.header) {
                    this.componentRegistry.registerType(this.header.name, this.header);
                }
                // New Component types that are used in c-include-component
                if (this.footer) {
                    this.componentRegistry.registerType(this.footer.name, this.footer);
                }
                /** notify subscribers of the page lifecycle service  */
                this.pageLifecycleService.onPageInit(this.title);
                // Setting the page action position.
                if (this.pageActionPosition === 'bottom') {
                    this.hasTopPageActions = false;
                    this.hasBottomPageActions = true;
                }
                else if (this.pageActionPosition === 'both') {
                    this.hasTopPageActions = true;
                    this.hasBottomPageActions = true;
                }
                if (core$1.isPresent(this.objectStates) && this.objectStates.length > 1
                    && core$1.isPresent(this.currentState)) {
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['currentState']) &&
                    changes['currentState'].currentValue !== changes['currentState'].previousValue) {
                    // we dont need to check if objectStates exists
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.pageLifecycleService.onPageDestroy(this.title);
            };
        ObjectPageWrapperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-object-page-wrapper',
                        template: "<div class=\"page-wrapper\">\n    <ng-template [ngIf]=\"!hideHeader\">\n        <aw-include-component [name]='header.name'></aw-include-component>\n    </ng-template>\n\n    <div class=\"arc-object-detail\">\n\n        <div class=\"ui-g\">\n\n            <!-- page header -->\n            <div class=\"ui-g-12 page-title\">\n\n                <!-- page title -->\n                <div class=\"ui-g-8 ui-md-8 page-title-text\">{{title}}</div>\n\n                <div class=\"ui-g-4 ui-md-4 page-status\">\n                    <span class=\"object-status-label\">{{objectStatusLabel}} &nbsp;</span>\n                    <span class=\"object-status\">{{objectStatus}}</span>\n                </div>\n            </div>\n\n            <!-- page actions -->\n            <div class=\"ui-g-12 page-actions\" *ngIf=\"hasTopPageActions\">\n                <ng-template [embeddedItem]=\"actionsTemplate\"\n                             *ngIf=\"hasTopPageActions\"></ng-template>\n            </div>\n\n            <!-- object states  displays only if state exists. -->\n            <div class=\"ui-g-12 page-state\">\n                <div class=\"ui-g-3 page-state-left\" [class.content]=\"hasObjectStates()\">\n                    <ng-content select=\".page-state-left\"></ng-content>\n                </div>\n                <div class=\"ui-g-6 page-state-center\">\n                    <ng-container *ngIf=\"hasObjectStates()\">\n                        <aw-stepper [steps]=\"objectStates\"\n                                    [currentStep]=\"objectStateIndex\"></aw-stepper>\n                    </ng-container>\n                </div>\n                <div class=\"ui-g-3 page-state-right\">\n                    <ng-content select=\".page-state-right\"></ng-content>\n                </div>\n            </div>\n\n\n            <!-- Page Notification -->\n            <ng-template [ngIf]=\"hasNotifications()\">\n                <div class=\"ui-g-12 u-nopadding\">\n\n                    <aw-page-notification *ngFor=\"let notification of notifications\"\n                                          [notification]=\"notification\"></aw-page-notification>\n                </div>\n            </ng-template>\n\n            <!-- additional content -->\n            <ng-content select=\"aw-page-content\"></ng-content>\n\n        </div>\n\n    </div>\n\n    <!-- page actions -->\n    <div class=\"ui-g-12 page-actions-bottom\" *ngIf=\"hasBottomPageActions\">\n        <ng-template [embeddedItem]=\"actionsTemplate\"\n                     *ngIf=\"hasBottomPageActions\"></ng-template>\n\n    </div>\n\n    <div class=\"page-push\"></div>\n</div>\n\n<ng-template [ngIf]=\"!hideFooter\">\n    <aw-include-component [name]='footer.name'></aw-include-component>\n</ng-template>\n",
                        styles: [".page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\x000a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}"]
                    }] }
        ];
        /** @nocollapse */
        ObjectPageWrapperComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: ComponentRegistry },
                { type: PageLifeCycleService }
            ];
        };
        ObjectPageWrapperComponent.propDecorators = {
            title: [{ type: core.Input }],
            objectType: [{ type: core.Input }],
            objectStatusLabel: [{ type: core.Input }],
            objectStatus: [{ type: core.Input }],
            objectStates: [{ type: core.Input }],
            currentState: [{ type: core.Input }],
            header: [{ type: core.Input }],
            hideHeader: [{ type: core.Input }],
            footer: [{ type: core.Input }],
            hideFooter: [{ type: core.Input }],
            pageActionPosition: [{ type: core.Input }],
            actionsTemplate: [{ type: core.ContentChild, args: ['pageActions',] }],
            notifications: [{ type: core.Input }]
        };
        return ObjectPageWrapperComponent;
    }(PageWrapper));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
     * page. The wrapper use the ability to position it as needed.
     */
    var PageActionsComponent = (function (_super) {
        __extends(PageActionsComponent, _super);
        function PageActionsComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-actions',
                        template: "<div class=\"page-actions\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".page-actions{text-align:right;padding-top:0;padding-right:0}"]
                    }] }
        ];
        /** @nocollapse */
        PageActionsComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageActionsComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Page content is a wrapper for page content.
     * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
     * the page content area will likely get affected.
     */
    var PageContentComponent = (function (_super) {
        __extends(PageContentComponent, _super);
        function PageContentComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-content',
                        template: '<ng-content></ng-content>',
                        styles: [':host {width: 100%; padding: 0 .5em;}']
                    }] }
        ];
        /** @nocollapse */
        PageContentComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageContentComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var STEPPER_COMPLETED_STEP_COLOR = '#58b957';
    /** @type {?} */
    var STEPPER_CURRENT_STEP_COLOR = '#0076CB';
    /** @type {?} */
    var STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
    /**
     * Stepper component displays a list of steps for user to follow. It can be used as a checklist
     * to indicate completed, current and remaining items. It could be also be used to indicate
     * the state of an document, created, submitted, approved, etc...
     *
     *
     * Usage:
     *   1.   Use the component inside your template. provide a list of steps and the current step.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
     *
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
     *                     currentStep: number = 1;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *   2.  Override the default colors.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
     *                                        [stepColorRemaining]="'#CC0000'"
     *                                        [stepColorCompleted]="'#97a822'"
     *                                        [currentStep]="currentStep">
     *                            </aw-stepper>
     *                  `
     */
    var StepperComponent = (function (_super) {
        __extends(StepperComponent, _super);
        function StepperComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Local variable to indicate whether to use the colors array or not.
             */
            _this.bUseColorArray = false;
            /**
             * The current step that's on. If not provided default to the first step.
             */
            _this.currentStep = 0;
            // Initial color for the different stages of steps.
            // Initial color for the different stages of steps.
            _this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
            _this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
            _this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
            return _this;
        }
        /**
         * @return {?}
         */
        StepperComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // Calculate the connector width based on how many steps
                if (core$1.isPresent(this.steps) && this.steps.length > 1) {
                    // (100% - 20% (side margins)) / (NumOfSteps -1)
                    this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
                }
                /**
                         * Use the color array if it's defined.
                         */
                if (core$1.isPresent(this.colors)) {
                    this.bUseColorArray = true;
                    if (this.colors.length !== this.steps.length) {
                        throw new Error("The size of the steps and colors don't match:\n                  (steps.length = " + this.steps.length + "), (colors.length = " + this.colors.length);
                    }
                }
            };
        /**
         * Getting the color of the step for the current index
         *
         * @param index
         */
        /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getStepColor = /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else if (index === this.currentStep) {
                    return this.stepColorCurrent;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * The connector colors are driven by the step colors.
         *
         */
        /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getConnectorColor = /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * Next step.
         */
        /**
         * Next step.
         * @return {?}
         */
        StepperComponent.prototype.nextStep = /**
         * Next step.
         * @return {?}
         */
            function () {
                this.currentStep++;
            };
        /**
         * previous step.
         */
        /**
         * previous step.
         * @return {?}
         */
        StepperComponent.prototype.prevStep = /**
         * previous step.
         * @return {?}
         */
            function () {
                this.currentStep--;
            };
        StepperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-stepper',
                        template: "<div class=\"stepper-container\">\n    <div class=\"steps\">\n        <div class=\"step-spacing\"></div>\n\n        <ng-container *ngFor=\"let step of steps; let i=index; let last=last;\">\n            <div class=\"step\">\n                <aw-step [title]=\"step\" [color]=\"getStepColor(i)\"></aw-step>\n            </div>\n            <div *ngIf=\"!last\" class=\"step-connector\" [style.width]=\"connectorWidth\">\n                <div class=\"connector\" [style.borderBottomColor]=\"getConnectorColor(i)\"></div>\n            </div>\n        </ng-container>\n\n        <div class=\"step-spacing\"></div>\n    </div>\n\n    <div class=\"step-labels\"></div>\n</div>\n\n\n",
                        styles: [".stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}"]
                    }] }
        ];
        /** @nocollapse */
        StepperComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepperComponent.propDecorators = {
            steps: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            stepColorCompleted: [{ type: core.Input }],
            stepColorCurrent: [{ type: core.Input }],
            stepColorRemaining: [{ type: core.Input }],
            currentStep: [{ type: core.Input }]
        };
        return StepperComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * Renders html step component
     *
     *  * Usage:
     *       Straight forward to use. But mostly it would be used as part of the stepper component.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                           <aw-step [title]="step" [color]="color"></aw-step>
     *                           `
      @type {?} */
    var DEFAULT_COLOR = '#58b957';
    var StepComponent = (function () {
        function StepComponent(env) {
            this.env = env;
        }
        /**
         * @return {?}
         */
        StepComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.color)) {
                    this.color = DEFAULT_COLOR;
                }
            };
        StepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-step',
                        template: "<div class=\"step-container\">\n    <div class=\"outer-circle\" [style.borderColor]=\"color\">\n        <div class=\"inner-circle\" [style.borderColor]=\"color\" [style.backgroundColor]=\"color\"></div>\n    </div>\n\n    <div class=\"step-title\">{{title}}</div>\n</div>\n\n",
                        styles: [".step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}"]
                    }] }
        ];
        /** @nocollapse */
        StepComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepComponent.propDecorators = {
            color: [{ type: core.Input }],
            title: [{ type: core.Input }]
        };
        return StepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWStepperModule = (function () {
        function AWStepperModule() {
        }
        AWStepperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StepComponent,
                            StepperComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                        ],
                        entryComponents: [
                            StepComponent,
                            StepperComponent
                        ],
                        exports: [
                            StepComponent,
                            StepperComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWStepperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *  This is a temporary implementation for the page header component.
     *  When the real implementation of side menu is done, PageHeaderComponent will
     *  be swaped to use it.
     *
     */
    var SidenavComponent = (function (_super) {
        __extends(SidenavComponent, _super);
        function SidenavComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        SidenavComponent.prototype.getSidenavClass = /**
         * @return {?}
         */
            function () {
                // Only show if I have items
                return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.open = /**
         * @return {?}
         */
            function () {
                this.show = true;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.show = false;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.show = !this.show;
            };
        SidenavComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-sidenav',
                        template: "<div [ngClass]=\"getSidenavClass()\">\n    <div class=\"sidenav-content\">\n        <a *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n            <span class=\"sidenav-icon\"><i [ngClass]=\"'sap-icon ' + item.icon\"></i></span>\n            {{item.label}}\n        </a>\n    </div>\n</div>\n",
                        styles: [".sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}"]
                    }] }
        ];
        /** @nocollapse */
        SidenavComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SidenavComponent.propDecorators = {
            items: [{ type: core.Input }],
            show: [{ type: core.Input }]
        };
        return SidenavComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWPageWrapperModule = (function () {
        function AWPageWrapperModule() {
        }
        AWPageWrapperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            AWCoreComponentModule,
                            AWStepperModule,
                            AWPageNotificationModule
                        ],
                        entryComponents: [
                            PageFooterComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageHeaderComponent
                        ],
                        exports: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        providers: [PageLifeCycleService]
                    },] }
        ];
        return AWPageWrapperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var EditorType = {
        Default: 0,
        // Default Editor supports Minimal set of functionality
        // [ bold | italic | underline | ordered | bullet | alignment]
        Full: 1,
        // The full list of functionality,
        TextFormat: 2,
        // Functionalities that affects text formatting.
        Custom: 3 // Custom toolbar.
        ,
    };
    EditorType[EditorType.Default] = 'Default';
    EditorType[EditorType.Full] = 'Full';
    EditorType[EditorType.TextFormat] = 'TextFormat';
    EditorType[EditorType.Custom] = 'Custom';
    /** @type {?} */
    var EDITOR_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RichTextAreaComponent; }),
        multi: true
    };
    var RichTextAreaComponent = (function (_super) {
        __extends(RichTextAreaComponent, _super);
        function RichTextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * A value used to save and read when rendering and updating this component
             */
            _this.value = '';
            /**
             * Expose editorType so that it can be used in this components template.
             */
            _this.EditorType = EditorType;
            _this.type = EditorType.Default;
            _this.styleClass = 'default-editor';
            return _this;
        }
        /**
         * @return {?}
         */
        RichTextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         */
        /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
        RichTextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        RichTextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-richtextarea',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <!-- Basic editor, also the default, which the most used features enabled. -->\n    <div *ngIf=\"type === EditorType.Default\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                    <span class=\"ql-formats\">\n                        <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                        <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                        <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                        <button class=\"ql-list\" value=\"ordered\"></button>\n                        <button class=\"ql-list\" value=\"bullet\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                            <button value=\"left\" selected></button>\n                            <button value=\"center\"></button>\n                            <button value=\"right\"></button>\n                            <button value=\"justify\"></button>\n                    </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Editor with all the features enabled -->\n    <div *ngIf=\"type === EditorType.Full\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\"></p-editor>\n    </div>\n\n    <!-- Editor with all Text formatting  -->\n    <div *ngIf=\"type === EditorType.TextFormat\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n            <span class=\"ql-format-group\">\n              <select title=\"Font\" class=\"ql-font\">\n                <option value=\"sans-serif\" selected=\"\">Sans Serif</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"monospace\">Monospace</option>\n              </select>\n              <select title=\"Size\" class=\"ql-size\">\n                <option value=\"10px\">Small</option>\n                <option value=\"13px\" selected=\"\">Normal</option>\n                <option value=\"18px\">Large</option>\n                <option value=\"32px\">Huge</option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-format-group\">\n              <select title=\"Text Color\" class=\"ql-color\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\" selected=\"\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n              <span class=\"ql-format-separator\"></span>\n              <select title=\"Background Color\" class=\"ql-background\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\" selected=\"\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                <button class=\"ql-list\" value=\"ordered\"></button>\n                <button class=\"ql-list\" value=\"bullet\"></button>\n            </span>\n                <span class=\"ql-formats\">\n                    <button value=\"left\" selected></button>\n                    <button value=\"center\"></button>\n                    <button value=\"right\"></button>\n                    <button value=\"justify\"></button>\n            </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Custom header Text Editor -->\n    <div *ngIf=\"type === EditorType.Custom\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                <ng-content select=\"custom-header\"></ng-content>\n            </p-header>\n        </p-editor>\n    </div>\n\n</ng-template>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        providers: [
                            EDITOR_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RichTextAreaComponent; }) }
                        ],
                        styles: ["/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}"]
                    }] }
        ];
        /** @nocollapse */
        RichTextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RichTextAreaComponent.propDecorators = {
            type: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return RichTextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWRichTextAreaModule = (function () {
        function AWRichTextAreaModule() {
        }
        AWRichTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RichTextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.EditorModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            RichTextAreaComponent
                        ],
                        exports: [
                            RichTextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWRichTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Allow developer to override default actions. Must have this declared before class when we
     * want to have this declaration inside the same file.
     */
    var SectionActionsComponent = (function () {
        function SectionActionsComponent() {
        }
        SectionActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section-actions',
                        template: "<ng-content></ng-content> "
                    }] }
        ];
        return SectionActionsComponent;
    }());
    /**
     *
     * Section component that implements a section of the page. It's an outline box that
     * has the ability to expand and hide its content.
     *
     * ```ts
     * \@Component({
     *    selector: 'rfx-details' ,
     *    template: `
     *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
     *                          [editable]="true">
     *
     *                <m-context [object]="rfxEntity.headerInfo"
     *                          [operation]="this.editabilityState.headerInfoOp"
     *                          layout="Inspect"
     *                          uiGroup="HeaderGeneral">
     *                   <m-include-component></m-include-component>
     *               </m-context>
     *           </aw-section>
     *
     *
     *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
     *                [opened]="false">
     *               <supplier-profile-card></supplier-profile-card>
     *           </aw-section>
     *
     *           <aw-section title="RFQ Details"
     *                       description="Review and update information for suppliers to respond."
     *                       [disableClose]="true">
     *
     *               <aw-subsection title="Event timeline">
     *                   <aw-form-table [useFiveZone]="false" [editable]="true">
     *
     *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
     *                                   [highlightRow]="true">
     *                           <aw-date-time
     *                               formatName="dateTime"
     *                               name="startDate" [value]="rfxEntity.created"
     *                               [showTime]="true"></aw-date-time>
     *                       </aw-form-row>
     *                   </aw-form-table>
     *               </aw-subsection>
     *          </aw-section>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     *
     * ```
     *
     * Section component also supports editability modes and if enabled it will render action buttons
     * in the footer. Developer can also override default behavior and provide custom actions.
     *
     *
     * e.g:
     *
     * ```
     *      <aw-section [title]="title" [editable]="true"
     *                          (onCancelAction)="someHandler1($event)"
     *                          (onSaveAction)="someHandler2($event)" >
     *              section content
     *
     *
     *   </aw-section>
     *
     * ```
     *
     * or custom action buttons:
     *
     *
     * ```html
     *
     *       <aw-section-actions>
     *                      <aw-button >
     *                            ButtonTest1
     *                      </aw-button>
     *                      <aw-button>
     *                            ButtonTest2
     *                      </aw-button>
     *     </aw-section-actions>
     *
     * ```
     *
     *
     * There are two edit modes
     *  # Default
     *      Renders action buttons in the footers and emit actions to the application
     *
     *  # External
     *     No action buttons are shown in the footer and behavior is handled by application. Only event
     *     is emited.
     *
     *
     *  e.g:
     *
     *  ```ts
     *
     *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
     *                  [editable]="true" [editMode]="'external'" >
     *                  <div>
     *                      Content
     *                  </div>
     *      </aw-section>
     *
     *  ```
     *
     * Note: When using editing mode you have to call at the end of the editing cycle method
     * `completeEditing()` to commit editing which changes internal state of the Section.
     *
     *
     *
     */
    var SectionComponent = (function (_super) {
        __extends(SectionComponent, _super);
        function SectionComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Should this section be opened at the start. Default is opened.
             */
            _this.opened = true;
            /**
             * Whether this section can be closed or not.
             *
             */
            _this.disableClose = false;
            /**
             * Whether this section is in EditState or not.
             *
             * When in editing state and we show "Cancel / Save" button developer needs use this binding
             * to control the state.
             */
            _this.editState = false;
            /**
             * Current Editing mode. Tells the components if its its default behavior or driven by
             * application using this component.
             *
             * {\@see EditMode}
             *
             */
            _this.editMode = 'default';
            /**
             * Developer can provide custom Edit action icon that will appear in the right top corner
             */
            _this.actionIcon = 'icon-edit';
            /**
             * Event emitted when the section is fully opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Event emitted when the section is fully closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Edit state to broadcast state of current section
             */
            _this.onEdit = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Cancel action
             */
            _this.onCancelAction = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Save action
             */
            _this.onSaveAction = new core.EventEmitter();
            _this.onEditingComplete = new core.EventEmitter();
            _this.editable = false;
            return _this;
        }
        /**
         * @return {?}
         */
        SectionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If I have not header, then I can't close the section.
                if (!this.isHeaderDisplayed()) {
                    this.disableClose = true;
                }
                // If I can't close the section, then it should default open.
                if (this.disableClose) {
                    this.opened = true;
                }
                // initialize the expanded state.
                this.expanded = this.opened;
            };
        /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
        SectionComponent.prototype.isHeaderDisplayed = /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.title) || core$1.isPresent(this.description));
            };
        /**
         * Css Class that control the look and feel for section component.
         */
        /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
        SectionComponent.prototype.aClass = /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
            function () {
                if (!this.isHeaderDisplayed()) {
                    return 'section-no-header';
                }
                return '';
            };
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         */
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
        SectionComponent.prototype.onEditAction = /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                // when in editing make sure we dont switch state as there can be some Form errors
                // which needs to be handled by developer and only then change the editState
                if (!this.editState) {
                    this.editState = !this.editState;
                    /** @type {?} */
                    var state = (this.editState) ? 'inEdit' : 'notInEdit';
                    this.onEdit.emit(state);
                    this.open();
                }
                // prevent the original event from bubbling up. Because the edit icon is inside
                // the header. If the click even is bubbled up, this event will cause the section to
                // expand or collapse.
                if (core$1.isPresent($event.event)) {
                    $event.event.stopPropagation();
                    $event.event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        SectionComponent.prototype.hasDescription = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.description);
            };
        /**
         * Open this section, if it's already open, will do nothing.
         */
        /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
        SectionComponent.prototype.open = /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                if (!this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Close this section, if it's already close, will do nothing.
         */
        /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.close = /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Callback to be invoked when accordion is opened
         *
         */
        /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionOpen = /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = true;
                this.onOpen.emit('open');
            };
        /**
         * Callback to be invoked when accordion is closed
         *
         */
        /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionClose = /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                this.onClose.emit('close');
            };
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         */
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
        SectionComponent.prototype.hasCustomActions = /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.customActions);
            };
        /**
         * Emit the editing state back to non-editable
         */
        /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
        SectionComponent.prototype.completeEditing = /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
            function () {
                this.editState = false;
                this.onEditingComplete.emit(this.editState);
            };
        SectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section',
                        template: "<div class=\"ui-g-12 section-container\"\n     [class.editing]=\"editable && editState && editMode === 'default'\">\n\n    <p-accordion (onOpen)=\"onSectionOpen($event)\" (onClose)=\"onSectionClose($event)\"\n                 [styleClass]=\"aClass()\">\n        <p-accordionTab #accordionTab [selected]=\"opened\" [disabled]=\"disableClose\">\n            <p-header>\n                <!-- title and description -->\n                <div class=\"section-header-container\">\n                    <div class=\"section-title\">{{title}}</div>\n                    <div *ngIf=\"hasDescription()\" class=\"section-description\">{{description}}</div>\n\n                    <!-- actions: Hide when in editing and editMode is default -->\n                    <div *ngIf=\"(editable && !editState && editMode === 'default') ||\n                        (editable && editMode === 'external')\"\n                         class=\"section-actions\">\n                        <aw-hyperlink (action)=\"onEditAction($event)\">\n                            <i class=\"sap-icon section-edit-action\" [ngClass]=\"actionIcon\"></i>\n                        </aw-hyperlink>\n                    </div>\n                </div>\n            </p-header>\n\n            <ng-content></ng-content>\n        </p-accordionTab>\n    </p-accordion>\n    <!--\n        need to put it outside of p-accordion otherwise button will inherit different\n        color scheme\n    -->\n    <div class=\"section-footer-container\" *ngIf=\"editable && editState &&\n            editMode === 'default'\">\n        <div class=\"footer-actions\">\n\n            <ng-template [ngIf]=\"!hasCustomActions()\">\n                <aw-button [style]=\"'secondary'\" size=\"small\"\n                           (action)=\"onCancelAction.emit($event)\">\n                    Cancel\n                </aw-button>\n                <aw-button size=\"small\" (action)=\"onSaveAction.emit($event)\">\n                    Save\n                </aw-button>\n            </ng-template>\n\n            <ng-content select=\"aw-section-actions\"></ng-content>\n        </div>\n    </div>\n</div>\n",
                        styles: [".section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:\"SAP icon fonts\";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:\"\\e1ed\"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:\"\\e1ef\"}"]
                    }] }
        ];
        /** @nocollapse */
        SectionComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SectionComponent.propDecorators = {
            title: [{ type: core.Input }],
            description: [{ type: core.Input }],
            opened: [{ type: core.Input }],
            disableClose: [{ type: core.Input }],
            editState: [{ type: core.Input }],
            editMode: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            onOpen: [{ type: core.Output }],
            onClose: [{ type: core.Output }],
            onEdit: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            onSaveAction: [{ type: core.Output }],
            onEditingComplete: [{ type: core.Output }],
            accordionTab: [{ type: core.ViewChild, args: ['accordionTab',] }],
            customActions: [{ type: core.ContentChild, args: [SectionActionsComponent,] }]
        };
        return SectionComponent;
    }(BaseComponent));
    var SubSectionComponent = (function () {
        function SubSectionComponent() {
        }
        SubSectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-subsection',
                        template: "\n                    <h4 class=\"subsection-title\">{{title}}</h4>\n                    <ng-content></ng-content>\n                 ",
                        styles: ['.subsection-title {color: #363636; }']
                    }] }
        ];
        SubSectionComponent.propDecorators = {
            title: [{ type: core.Input }]
        };
        return SubSectionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWSectionModule = (function () {
        function AWSectionModule() {
        }
        AWSectionModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.AccordionModule,
                            core$1.AribaCoreModule,
                            AWStringFieldModule,
                            AWHyperlinkModule,
                            AWButtonModule,
                            primeng.SharedModule
                        ],
                        entryComponents: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        exports: [
                            SectionComponent,
                            SectionActionsComponent,
                            SubSectionComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWSectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * DTColumn represent single column including header and its body. Each column has its own
     * rendererTemplate which a entry to this component.
     *
     * Keeping this separate from the datatable where DT is not really aware what it is rendering,
     * it allows us more flexibility in terms of different type of column inheriting from this
     * one.. Such as:
     *  DTRowDetail  column
     *  DTSingleSelection column
     *  DTMultiSelection column
     *
     * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
     *
     *  Then later on this will let us create additional logic for the pivotal layout. Because DT
     *  does know anything about the type of the column so whatever is added to the DT.columns it
     *  will be rendered.
     *
     *
     *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
     *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
     *  binding to be set (in px).
     *  We need this to be able to properly position the second table which is changed to absolute
     *  positioning.
     *
     *
     *
     */
    var DTColumn2Component = (function (_super) {
        __extends(DTColumn2Component, _super);
        function DTColumn2Component(env, domHandler) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * Cell alignment. It inserts regular align attribute to the table cell
             *
             */
            _this.align = 'left';
            /**
             *
             * If false applies dt-is-hidden style that hides the column
             *
             */
            _this.isVisible = true;
            /**
             * Sorting direction
             *
             */
            _this.sortOrdering = 'descending';
            /**
             * Tells the template if whether to render a label
             *
             */
            _this.showColumnLabel = true;
            /**
             *
             * See AWDataTable
             *
             */
            _this.showSubHeader = false;
            /**
             *
             * Used together with cell selectionMode to tell which column is selectable
             *
             */
            _this.selectable = false;
            /**
             * Use globally defined HEADER template for current column
             *
             */
            _this.useGlobalHeader = true;
            /**
             * Use globally defined SubHeader template for current column
             *
             */
            _this.useGlobalSubHeader = true;
            /**
             * Use globally defined body template
             *
             */
            _this.useGlobalBody = true;
            /**
             * Tells if the column is data column  - if it is rendering data or just a label or some
             * control
             *
             * This is important when calculating a column span and we need to know which columns are or
             * will be just for selection controls and which holds data
             */
            _this.isDataColumn = true;
            /**
             * Identifies column that will not scroll horizontally with other columns. Column is
             * frozen.
             *
             * For such columns that are marked as frozen binding [width] is required.
             *
             */
            _this.frozen = false;
            _this.maxWidthPx = 0;
            _this.minWidthPx = 0;
            _this.widthPx = 0;
            _this.widestCell = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.key) && core$1.isBlank(this.label)) {
                    throw new Error('Missing required binding: ' +
                        '[key] or [label] bindings must be used at minimum');
                }
                // To be able to position second DT we require [width] to be set as well
                if (this.frozen && core$1.isBlank(this.width)) {
                    throw new Error('Missing required binding [width]: ' +
                        'when [frozen]=true then [width] binding needs to be specified.');
                }
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // need to deffer this and trigger change detection otherwise I get
                // value was changed after it was checked error
                // setTimeout(() =>
                // {
                // });
            };
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         */
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
        DTColumn2Component.prototype.handleHeaderClick = /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
            function (event, element) {
                if (this.isHeaderSelectable()) {
                    this.dt.onHeaderSelectionChange(element, this);
                }
                else if (this.sortable) {
                    this.sort(event);
                }
                event.preventDefault();
            };
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         */
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
        DTColumn2Component.prototype.sort = /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.sortable) {
                    return;
                }
                /** @type {?} */
                var targetNode = event.target;
                if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-title') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
                    if (core$1.isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                        this.sortOrder = this.sortOrder * -1;
                        this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
                    }
                    else {
                        this.dt.sortColumn = this;
                    }
                    this.dt.dataSource.state.sortKey = this.key;
                    this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
                    this.dt.sortSingle();
                }
                this.dt.updateDataToRender();
            };
        /**
         * Calculated style class based on data
         *
         *
         */
        /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.dynamicBodyClass = /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var dynClass = core$1.isPresent(this.bodyClassFn)
                    ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
                if (core$1.isPresent(this.bodyStyleClass)) {
                    dynClass += ' ' + this.bodyStyleClass;
                }
                else if (core$1.isPresent(this.styleClass)) {
                    dynClass += ' ' + this.styleClass;
                }
                return dynClass;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isRowSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.dt.isRowSelectable)) {
                    return this.dt.isRowSelectable(item);
                }
                return false;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isCellSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isHeaderSelectable = /**
         * @return {?}
         */
            function () {
                return this.dt.selectionMode === 'cell' && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.getSortOrder = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var order = 0;
                if (core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
                    order = this.dt.sortColumn.sortOrder;
                }
                return order;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isSorted = /**
         * @return {?}
         */
            function () {
                if (!this.sortable) {
                    return false;
                }
                return core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
            };
        /**
         * @param {?} table
         * @return {?}
         */
        DTColumn2Component.prototype.initialize = /**
         * @param {?} table
         * @return {?}
         */
            function (table) {
                this.dt = table;
                if (core$1.isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
                    this.sortable = true;
                    this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
                    this.dt.sortColumn = this;
                }
                if (core$1.isBlank(this.bodyTemplate) && this.useGlobalBody) {
                    this.bodyTemplate = this.dt.bodyTemplate;
                }
                if (core$1.isBlank(this.headerTemplate) && this.useGlobalHeader) {
                    this.headerTemplate = this.dt.headerTemplate;
                }
                if (core$1.isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
                    this.subHeaderTemplate = this.dt.subHeaderTemplate;
                }
                if (core$1.isBlank(this.bodyClassFn)) {
                    this.bodyClassFn = this.dt.bodyClassFn;
                }
                this.maxWidthPx = this.widthToPx(this.maxWidth);
                this.minWidthPx = this.widthToPx(this.minWidth);
                this.widthPx = this.widthToPx(this.width);
            };
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         */
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
        DTColumn2Component.prototype.postInitialize = /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
            function (myIndex) {
                var _this = this;
                /** @type {?} */
                var colIndex = myIndex + 1;
                /** @type {?} */
                var table;
                if (this.dt.hasFrozenColumns()) {
                    table = ((this.dt)).el
                        .nativeElement.querySelector('.dt-body-frozen table');
                }
                else {
                    table = ((this.dt)).el.nativeElement.querySelector('table');
                }
                if (this.widestCell > 0) {
                    /** @type {?} */
                    var all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                        'tr td:nth-child(' + colIndex + ')').forEach(function (node) {
                        node.style.width = _this.widestCell + 'px';
                    });
                }
            };
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         */
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
        DTColumn2Component.prototype.isValueColumn = /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.isDataColumn) && core$1.BooleanWrapper.isTrue(this.isDataColumn)) ||
                    core$1.isPresent(this.key);
            };
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         */
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
        DTColumn2Component.prototype.indentForControl = /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
            function (cell, level) {
                if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
                    && core$1.isPresent(cell.nextElementSibling)) {
                    /** @type {?} */
                    var outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
                    // 1st level is pushed as root
                    if (this.dt.pushRootSectionOnNewLine) {
                        return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                            - outlineNodePadding;
                    }
                    else {
                        return (this.dt.indentationPerLevel * level) + outlineNodePadding;
                    }
                }
                return null;
            };
        /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
        DTColumn2Component.prototype.widthToPx = /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
            function (width) {
                /** @type {?} */
                var px;
                if (core$1.isPresent(width)) {
                    if (width.indexOf('%') > 0) {
                        /** @type {?} */
                        var nonPc = parseFloat(width) / 100;
                        px = nonPc * ((this.dt)).el.nativeElement.offsetWidth;
                    }
                    else {
                        px = parseFloat(width);
                    }
                }
                return px;
            };
        DTColumn2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-column2',
                        template: "<!--\n    To make it more readable Each Column type has its own rendering template instead of putting\n    all this into datatable as this is more responsibility of the column. And the main goal\n    was try to be modular as possible. When There will be different types of columns\n\n    - Regular DTColumn (current implementation),\n    - SelectionColumn (Single/Multi select) - todo,\n    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.\n\n    When implementing new column type you just inherit this DTColumnComponent and provide your\n    own rendering template and DT take care of the rest.\n\n    todo: We have SingleSelect, Multiselect rendering template that is Added programatically\n    todo: We have pivotal rendering template\n\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,\n                 rowIndex:rowIndex}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Templates for header columns. Here we are rendering two types. Header and Subheader that we\n    usually use here as some kind of summary columns. Not really having summary at the bottom like other\n    DT.\n\n    TH column and their text are usually unselectable and most of these were inherited from\n    original PrimeNg DT even not many things got left after we refactor this but the idea is the\n    same.\n\n    Each cell has its dt-cell-def class that sets default styling like font, background, alignment\n    padding, etcs..\n\n\n-->\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\" let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <th #headerCell1 [class]=\"headerStyleClass||styleClass\" *ngIf=\"!isSubHeader\"\n        (click)=\"handleHeaderClick($event, headerCell1)\"\n        [ngClass]=\"{'dt-is-default dt-u-unselectable-text' :true,\n                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),\n                    'dt-u-sortable': sortable,\n                    'dt-is-active': isSorted(),\n                    'dt-is-hidden': !isVisible}\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [attr.tabindex]=\"sortable ? 1 : null\"\n        [dtMaxWidth]=\"maxWidthPx\"\n    >\n\n        <ng-template [ngIf]=\"dt.headerFilterTemplate && columnIndex === 0 \">\n            <ng-container *ngTemplateOutlet=\"dt.headerFilterTemplate\">\n            </ng-container>\n        </ng-template>\n        <!--\n            when cell are selectable we need two version where one wrap the cell content in div\n        -->\n        <ng-template [ngIf]=\"isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"selectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n    </th>\n\n    <th #headerCell2 [class]=\"headerStyleClass||styleClass\" *ngIf=\"isSubHeader\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}\"\n        [dtMaxWidth]=\"maxWidthPx\">\n\n        <span class=\"dt-col-title\" *ngIf=\"dt.showSubHeader && subHeaderTemplate\">\n            <ng-container *ngTemplateOutlet=\"subHeaderTemplate;\n                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </span>\n    </th>\n</ng-template>\n\n\n<!--\n    Template for the body = the TD. For the body and we might want to do the same for header we\n    allow to have calculated body class that comes from the application. So based on the data types\n    you might want to apply different class in order to apply custom styling.\n-->\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        (click)=\"dt.onCellSelectionChange(cell, this, data)\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{ 'dt-is-default': true,\n        'dt-cell-def': !isCellSelectable(data),\n        'dt-is-hidden': !isVisible}\"\n        [dtMaxWidth]=\"maxWidthPx\"\n        >\n\n        <!--\n            Since we need to support cell selection when we need to draw border around it\n            We are wrapping such sells with div which gives us better flexibility\n        -->\n        <ng-template [ngIf]=\"isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"selectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex }\">\n            </ng-container>\n\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </ng-template>\n\n    </td>\n</ng-template>\n\n<!--\n    Todo: create better solution instead of using different template create directive that wraps\n    it with the div conditionally\n-->\n<ng-template #selectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isHeaderSelected(this)}\">\n        <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #headerCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && !headerTemplate\">\n                {{label}}\n    </span>\n\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && headerTemplate\">\n                    <ng-container *ngTemplateOutlet=\"headerTemplate;\n                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }\">\n                    </ng-container>\n    </span>\n\n    <span class=\"dt-col-sortable-icon sap-icon icon-sort\" *ngIf=\"sortable\"\n          [ngClass]=\"{'icon-sort-descending': (getSortOrder() == -1),\n                           'icon-sort-ascending': (getSortOrder() == 1)}\">\n    </span>\n</ng-template>\n\n\n<ng-template #selectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isBodyCellSelected(this, data)}\">\n        <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #bodyCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <!--\n           when no template is used use our FieldPath to access the object value based on the\n           key binding\n        -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"!bodyTemplate\">\n            {{dt.getValue(data, key)}}\n        </span>\n\n\n    <!--\n        In case application wants to provide their own cell component they use\n        #body ng-template to do so.\n    -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"bodyTemplate\">\n            <ng-container *ngTemplateOutlet=\"bodyTemplate;\n            context: {$implicit: this, rowData: data, rowIndex: rowIndex}\"></ng-container>\n        </span>\n</ng-template>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler],
                        styles: [".dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}"]
                    }] }
        ];
        /** @nocollapse */
        DTColumn2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTColumn2Component.propDecorators = {
            label: [{ type: core.Input }],
            key: [{ type: core.Input }],
            align: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isVisible: [{ type: core.Input }],
            sortable: [{ type: core.Input }],
            sortOrdering: [{ type: core.Input }],
            showColumnLabel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            headerStyleClass: [{ type: core.Input }],
            bodyStyleClass: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            useGlobalHeader: [{ type: core.Input }],
            useGlobalSubHeader: [{ type: core.Input }],
            useGlobalBody: [{ type: core.Input }],
            isDataColumn: [{ type: core.Input }],
            frozen: [{ type: core.Input }],
            maxWidth: [{ type: core.Input }],
            minWidth: [{ type: core.Input }],
            rendererTemplate: [{ type: core.ViewChild, args: ['renderingTemplate',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['header',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['subHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }]
        };
        return DTColumn2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * An datatable header area.
     *
     * See {\@link DataTableComponent} for more explanation.
     */
    var DTHeaderComponent2 = (function () {
        function DTHeaderComponent2() {
        }
        DTHeaderComponent2.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-header2',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        return DTHeaderComponent2;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Custom column implementation to render detail row spaning its column across whole table width.
     *
     *
     */
    var DTDetailRowComponent = (function (_super) {
        __extends(DTDetailRowComponent, _super);
        function DTDetailRowComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * tells if we need to render a line between item row and its detail
             *
             */
            _this.showRowLine = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * Check if we need to keep some leading TDs
         *
         */
        /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
        DTDetailRowComponent.prototype.visibleLeadingCols = /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
            function () {
                return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
            };
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         */
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
        DTDetailRowComponent.prototype.showDetailRow = /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var isVisible = this.isVisible;
                if (core$1.isPresent(this.isVisibleFn)) {
                    isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
                }
                return isVisible;
            };
        /**
         * @param {?} table
         * @return {?}
         */
        DTDetailRowComponent.prototype.initialize = /**
         * @param {?} table
         * @return {?}
         */
            function (table) {
                _super.prototype.initialize.call(this, table);
                this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
            };
        DTDetailRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column',
                        template: "<!--\n    Renders application defined detail column. This template just renders a detail row and\n    not expansion control. This is implemented by different DtColumn implementation and its added\n    (will be) added programmatically during column initialization\n-->\n<ng-template #renderingTemplate let-column=\"column\" let-rowData=\"data\">\n\n    <tr #detailRowElement class=\"dt-body-row dt-detail-row\">\n\n        <td *ngIf=\"dt.hasInvisibleSelectionColumn()\" width=\"1px\"></td>\n        <td *ngIf=\"visibleLeadingCols() > 0\" colspan=\"visibleLeadingCols()\" width=\"1px\">\n            &nbsp;&nbsp;\n        </td>\n        <td [attr.colspan]=\"dt.startOfFirstDataColumn\" [class]=\"dynamicBodyClass(rowData)\"\n            [ngClass]=\"{ 'dt-is-default dt-cell-def': true}\">\n\n            <ng-container\n                *ngTemplateOutlet=\"bodyTemplate; context:{$implicit: this, rowData:rowData}\">\n            </ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DTDetailRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTDetailRowComponent.propDecorators = {
            isVisibleFn: [{ type: core.Input }],
            showRowLine: [{ type: core.Input }]
        };
        return DTDetailRowComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     *
     *
     *
     */
    var DTDetailRowExpanderComponent = (function (_super) {
        __extends(DTDetailRowExpanderComponent, _super);
        function DTDetailRowExpanderComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // we dont want to show the row/column unless application says so
            // we dont want to show the row/column unless application says so
            _this.isVisible = false;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.toggleExpansion = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.dt.detailRowExpansionState.toggle(item);
                event.stopPropagation();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.calculateStyleClass = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.detailRowExpansionState.isExpanded(item) ?
                    'icon-slim-arrow-down' : 'icon-slim-arrow-right';
            };
        DTDetailRowExpanderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column-expand',
                        template: "<!--\n   Special column that renders expand/collapse control for detail row when detail row is enabled.\n\n   Just like for the other column it renders header section as well as body section with\n   expand control to toggle the expansion\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\" let-columnIndex=\"columnIndex\" let-rowIndex=\"rowIndex\">\n\n\n    <ng-template [ngIf]=\"isHeader && !isSubHeader\">\n        <th #headerCell1 [class]=\"headerStyleClass||styleClass\"\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,\n                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}\">\n        </th>\n\n    </ng-template>\n\n    <ng-template [ngIf]=\"!isHeader && !isSubHeader\">\n        <td #cell\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{ 'dt-is-default': true,\n                    'dt-cell-def': !isCellSelectable(dataToRender),\n                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),\n                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}\">\n\n            <span (click)=\"toggleExpansion($event, dataToRender)\"\n                  class=\"dt-det-row-expand sap-icon\"\n                  [ngClass]=\"calculateStyleClass(dataToRender)\">\n\n            </span>\n\n        </td>\n\n    </ng-template>\n\n\n</ng-template>\n\n",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler],
                        styles: [".dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}"]
                    }] }
        ];
        /** @nocollapse */
        DTDetailRowExpanderComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTDetailRowExpanderComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * @license
     * Copyright 2017 SAP Ariba
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     *
     *
     */
    /** @type {?} */
    var DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
        'drop', 'dragend'];
    /** @enum {string} */
    var DragDirection = {
        None: 'none',
        Up: 'dt-drag-row-top',
        Down: 'dt-drag-row-bottom',
        Middle: 'dt-drag-row-both',
    };
    /** @enum {string} */
    var DropPosition = {
        Before: 'before',
        After: 'after',
        Into: 'into',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete DataSource implementation for Datatable which defines state and column definition that
     * can programmatically modify rendered columns (if provided) and method for inserting and
     * and deleting records;
     *
     * All operations dealing with data use Observable<T> and instant() method to retrieve current
     * state is not implemented.
     *
     *
     */
    var DT2DataSource = (function (_super) {
        __extends(DT2DataSource, _super);
        function DT2DataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            _this.initialized = false;
            _this.state = Datatable2State.create();
            _this.debugTime = new Date().getTime();
            return _this;
        }
        /**
         * @param {...?} args
         * @return {?}
         */
        DT2DataSource.prototype.init = /**
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                /** @type {?} */
                var init = args[0];
                // use existing or find best match for dataProvider
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                // use existing or find best match for dataFinder
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                this.dataFinder.lookupKey = init.lookupKey;
                if (core$1.isBlank(init.state)) {
                    this.state = new Datatable2State();
                }
                else {
                    this.state = init.state;
                }
                this.initialized = true;
            };
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         */
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
        DT2DataSource.prototype.fetch = /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
            function (withParams) {
                var _this = this;
                /** @type {?} */
                var params = null;
                if (core$1.isPresent(withParams)) {
                    params = new Map().set('offset', withParams.offset)
                        .set('limit', withParams.limit)
                        .set('orderby', withParams.sortKey)
                        .set('selector', withParams.sortOrder);
                }
                this.dataProvider.fetch(params).subscribe(function (result) {
                    if (withParams.offset > 0) {
                        /** @type {?} */
                        var incrData = __spread(_this.dataProvider.dataChanges.getValue(), result);
                        _this.dataProvider.dataChanges.next(incrData);
                    }
                    else {
                        _this.dataProvider.dataChanges.next(result);
                    }
                });
            };
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         */
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
        DT2DataSource.prototype.open = /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        DT2DataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
            };
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         */
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.insert = /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.insert(object);
                }
                else {
                    this.dataProvider.offScreenData.push(object);
                    this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
                }
            };
        /**
         * Please see {@link insert} method
         *
         */
        /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.remove = /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.remove(object);
                }
                else {
                    core$1.ListWrapper.removeIfExist(this.dataProvider.offScreenData, object);
                    this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
                }
            };
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         */
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
        DT2DataSource.prototype.find = /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
            function (pattern) {
                var _this = this;
                if (core$1.isBlank(pattern) || pattern.length === 0) {
                    // if we received empty string return orginal list
                    this.fetch(this.state);
                    return;
                }
                /** @type {?} */
                var searchParam = pattern;
                if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
                    searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('orderby', this.state.sortKey);
                    }
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('selector', this.state.sortOrder);
                    }
                }
                else {
                    core$1.assert(core$1.isString(pattern), 'Cannot pass non-string value to FullText Finder');
                }
                this.dataFinder.match(searchParam).subscribe(function (result) {
                    _this.dataProvider.dataChanges.next(result);
                });
            };
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         */
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        DT2DataSource.prototype.sort = /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (key, sortOrder) {
                if (core$1.isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
                    return;
                }
                this.state.sortKey = key;
                this.state.sortOrder = sortOrder;
                this.fetch(this.state);
            };
        /**
         *
         * Persist db state
         *
         */
        /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
        DT2DataSource.prototype.updateState = /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
            function (offset, sortField, sOrder) {
                this.state.offset = offset;
                this.state.sortKey = sortField;
                this.state.sortOrder = sOrder;
            };
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         */
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        DT2DataSource.prototype.reorderRows = /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                /** @type {?} */
                var array = this.dataProvider.data().slice();
                // take something from top and drag&drop under
                if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
                    newPos -= 1;
                    // take something from bottom and drag&drop above
                }
                else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
                    newPos += 1;
                }
                array.splice.apply(array, __spread([newPos, 0], array.splice(origPos, 1)[0]));
                this.dataProvider.dataChanges.next(array);
            };
        DT2DataSource.MaxLimit = 100;
        return DT2DataSource;
    }(DataSource));
    /**
     * Keeps current datatable state the state which drivers the way while fetching the data as well
     * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
     * browser refresh
     *
     *
     * todo: Create methods to convert this state from and to JSON for easier serialization
     */
    var Datatable2State = (function () {
        function Datatable2State() {
            /**
             * Properties for paging and fetching
             */
            this.offset = 0;
            this.limit = 0;
            /**
             * Identifies default value that is used to render N number of rows in non-fullscreen
             * mode
             *
             */
            this.displayLimit = 0;
            /**
             * Sorting order of the sort field. DataTable support sorting for multiple column but we
             * dont persist it now. Maybe in the future
             */
            this.sortOrder = Datatable2State.Ascending;
            /**
             * If we are using global filter for current datatable then save it here
             */
            this.currentSearchQuery = '';
            this.outlineState = new Map();
            this.detailRowExpandState = new Map();
        }
        /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
        Datatable2State.create = /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
            function (offset, limit, displayLimit, sortField, sOrder, searchQuery, filter, outlineState, detailRowState) {
                if (offset === void 0) {
                    offset = 0;
                }
                if (limit === void 0) {
                    limit = 15;
                }
                if (displayLimit === void 0) {
                    displayLimit = 5;
                }
                if (sortField === void 0) {
                    sortField = '';
                }
                if (sOrder === void 0) {
                    sOrder = 0;
                }
                if (outlineState === void 0) {
                    outlineState = new Map();
                }
                if (detailRowState === void 0) {
                    detailRowState = new Map();
                }
                /** @type {?} */
                var s = new Datatable2State();
                s.offset = offset;
                s.limit = limit;
                s.displayLimit = displayLimit;
                s.sortKey = sortField;
                s.sortOrder = sOrder;
                s.currentSearchQuery = searchQuery;
                s.currentFilter = filter;
                s.outlineState = outlineState;
                s.detailRowExpandState = detailRowState;
                return s;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.fromJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var state = JSON.parse(data);
                /** @type {?} */
                var ds = new Datatable2State();
                ds.offset = state.offset;
                ds.limit = state.limit;
                ds.displayLimit = state.displayLimit;
                ds.sortKey = state.sortKey;
                ds.sortOrder = state.sortOrder;
                ds.currentSearchQuery = state.currentSearchQuery;
                ds.outlineState = core$1.MapWrapper.createFromAnyMap(state.outlineState);
                ds.detailRowExpandState = core$1.MapWrapper.createFromAnyMap(state.detailRowExpandState);
                return ds;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.toJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var toConvert = {
                    offset: data.offset,
                    limit: data.limit,
                    displayLimit: data.displayLimit,
                    sortKey: data.sortKey,
                    sortOrder: data.sortOrder,
                    currentSearchQuery: data.currentSearchQuery,
                    outlineState: core$1.MapWrapper.toAnyMap(data.outlineState),
                    detailRowExpandState: core$1.MapWrapper.toAnyMap(data.detailRowExpandState)
                };
                return JSON.stringify(toConvert);
            };
        Datatable2State.Ascending = 1;
        Datatable2State.Descending = -1;
        return Datatable2State;
    }());
    /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */
    var /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */ DetailRowExpansionState = (function () {
        function DetailRowExpansionState(dt) {
            this.dt = dt;
        }
        Object.defineProperty(DetailRowExpansionState.prototype, "detailExpansionEnabled", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this.expansionStates);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.expansionStates = new Map();
                }
                else {
                    this.expansionStates = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.toggle = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var key = this.itemToKey(item);
                if (!this.isExpanded(item)) {
                    this.expansionStates.set(key, true);
                }
                else {
                    this.expansionStates.delete(key);
                }
                this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var key = this.itemToKey(item);
                // handle special case where we collapse parent of parent while detail row is expanded
                if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
                    this.expansionStates.delete(key);
                    return false;
                }
                /** @type {?} */
                var isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
                return core$1.isPresent(key) && this.expansionStates.has(key);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.itemToKey = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        return DetailRowExpansionState;
    }());
    /**
     * @param {?} init
     * @return {?}
     */
    function isDTInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType) || core$1.isPresent(init.entity);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Column implementation for the Multiselection where we show checkbox control
     *
     *
     */
    var DTMultiSelectColumnComponent = (function (_super) {
        __extends(DTMultiSelectColumnComponent, _super);
        function DTMultiSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTMultiSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-multi-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n\n        <ng-template [ngIf]=\"dt.showSelectAll\">\n            <aw-checkbox [type]=\"'action'\" (action)=\"dt.toggleAllColumns($event)\"\n                         [value]=\"dt.isToggleAllColumnSelected()\"\n                         [disabled]=\"dt.isToggleAllColumnDisabled()\">\n            </aw-checkbox>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!dt.showSelectAll\">&nbsp;\n        </ng-template>\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-checkbox [type]=\"'action'\" [value]=\"dt.isRowSelected(data)\">\n        </aw-checkbox>\n\n    </td>\n</ng-template>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DTMultiSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTMultiSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Column implementation for the SingleSelect where we show checkbox control
     *
     *
     */
    var DTSingleSelectColumnComponent = (function (_super) {
        __extends(DTSingleSelectColumnComponent, _super);
        function DTSingleSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTSingleSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-single-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n        &nbsp;\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-radiobutton [name]=\"'DTRadio'\" [value]=\"data\" [(ngModel)]=\"dt.dataSource.state.selection\">\n        </aw-radiobutton>\n    </td>\n</ng-template>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler],
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DTSingleSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTSingleSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * DT component that implements the data grid that shows tabular data. Even the basic
     * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
     * allows more extensibility and trying to stay as close as possible to existing AWL implementation
     *
     * There are 3 main pieces:
     *
     *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
     *  contains any additional panels that datatable needs such as our new concept how editing will
     *  work - sliding panel from the bottom
     *
     *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
     *  column into separate component. This way component column has its own renderer template which
     *  can render both header and data cells.
     *  Later on DTColumn is then extended to support other additional column types
     *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
     *
     * To support pivotal layout this can be extended for other additional columns that implements their
     * own rendering templates
     *
     * Datatable - The main component that is only focus on header and body rendering and basaed on the
     * column type it will render the correct template
     * column type it will render the correct template
     *
     *
     *
     *
     *
     */
    var Datatable2Component = (function (_super) {
        __extends(Datatable2Component, _super);
        /**
         *
         * In case of outline table we are inject OutlineState which is provided in the DT component
         * definition. This is used by nested outlineFor component it set itself as reference and
         * initialize the state so it can be used later on inside OutlineControl
         *
         *
         * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
         * inside are unique for this component
         *
         */
        function Datatable2Component(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.el = el;
            _this._defaultDS = _defaultDS;
            _this.changeDetector = changeDetector;
            _this.factoryResolver = factoryResolver;
            _this.outlineState = outlineState;
            _this.zone = zone;
            _this.injector = injector;
            /**
             *  Hides or shows table heading where we have filters and tools menus
             */
            _this.showTableHeader = true;
            /**
             * See AWDataTable
             *
             */
            _this.pivotalLayout = false;
            /**
             * See AWDataTable
             */
            _this.initialSortOrder = 'descending';
            /**
             * When DT is loaded in the page and we are not in the full screen (full page mode), this
             * is hte number of lines that DT will show
             *
             * todo: come up with better name
             */
            _this.displayRowSize = 10;
            /**
             * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
             *
             * todo: come up with better name !!!
             *
             */
            _this.pageSize = 15;
            /**
             * Default message when there are no data .
             *
             * todo: Use i18n value and create resource file
             */
            _this.emptyMessage = 'No records found';
            /**
             *
             * See AWDataTable
             *
             */
            _this.selectionMode = 'none';
            /**
             *
             * Can provide custom icon. These icons are not animated divs, we used css
             * transformation to rotate them.
             *
             */
            _this.loadingIcon = 'icon-synchronize';
            /**
             * Additional indent can be added when rendering detail row
             */
            _this.indentDetailRow = false;
            /**
             * See AWDataTable
             *
             */
            _this.indentationPerLevel = 25;
            /**
             *
             *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
             *  the regular table header
             *
             */
            _this.showSubHeader = false;
            /**
             * See OutlineFor - only used in the tree mode
             */
            _this.expandAll = false;
            /**
             *
             * See OutlineFor  - format - only used in the tree mode
             */
            _this.outlineFormat = 'free';
            /**
             * See AWDataTable
             */
            _this.pushRootSectionOnNewLine = true;
            /**
             * Render or hide expansion control for row detail columns. Expansion control makes sense for
             * simple table, when using this inside outline (tree table), its driven by outline control
             */
            _this.showRowDetailExpansionControl = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectionColumn = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectAll = true;
            /**
             * Show or hide global search term input field in the header
             */
            _this.showGlobalSearch = true;
            /**
             * Enables or disables row reordering
             *
             */
            _this.dndRowEnabled = false;
            /**
             *
             * Fires event that sorting is enabled for column and we trigger sorting
             *
             */
            _this.onSort = new core.EventEmitter();
            /**
             * Based on selection mode it triggers even
             *
             */
            _this.onRowClick = new core.EventEmitter();
            /**
             *
             * When multi or single selection mode is enabled it will trigger event when checkbox or
             * radio buttons is selected
             *
             * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
             */
            _this.onRowSelectionChange = new core.EventEmitter();
            /**
             * When cell body selection changes we fire event
             *
             */
            _this.onCellChange = new core.EventEmitter();
            /**
             * When cell header selection changes we fire event
             *
             */
            _this.onHeaderSelection = new core.EventEmitter();
            /**
             *
             * Triggers when items in the list are updated
             *
             */
            _this.valueChange = new core.EventEmitter();
            _this.classList = 'w-datatable ';
            /**
             *  Indicates that columns were initialed Also used when we hide and show column to trigger
             *  change.
             *
             */
            _this.columnsChanged = false;
            /**
             * See AWDataTable
             */
            _this.numberOfColsBeforeData = 0;
            /**
             * See AWDataTable
             */
            _this.startOfFirstDataColumn = 0;
            _this.dataSource = _this._defaultDS;
            return _this;
        }
        Object.defineProperty(Datatable2Component.prototype, "state", {
            /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             */
            get: /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             * @return {?}
             */ function () {
                return this.dataSource.state;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this.dataSource.state = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.list) && core$1.isPresent(this.destinationClass)) {
                    throw new Error('You cannot use both bindings [list] and [destinationClass]!');
                }
                this.detailRowExpansionState = new DetailRowExpansionState(this);
                // init default columns
                this.rowDetailExpandColumn = this.factoryResolver
                    .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
                this.multiSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
                this.singleSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
                /**
                         * If the data are not deferred and we get list directly then it creates DS. If
                         * ngOnChanges is called first we properly init DS and clean this.list
                         *
                         */
                if (core$1.isPresent(this.destinationClass) || core$1.isPresent(this.list)) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.initDatasource(false);
                }
                // since we work with references let's pass created map inside our state
                this.outlineState.expansionStates = this.state.outlineState;
            };
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         */
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
        Datatable2Component.prototype.ngOnChanges = /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (changes['list'] && core$1.isPresent(changes['list'].currentValue)
                    && !this.dataSource.initialized) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.dataSource.dataProvider.dataChanges.next(this.list);
                }
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // make sure we init a state when detail column is present
                // todo: move this initialization to datasource
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn);
                this.initColumns();
                this.columnsSubscription = this.colsQuery.changes.subscribe(function (_) {
                    _this.initColumns();
                    _this.changeDetector.markForCheck();
                });
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // assign it programatically as we want to have a context for the filter
                if (core$1.isPresent(this.rowDetailColumn) && core$1.isPresent(this.outlineState.outlineFor)) {
                    this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
                }
                if (core$1.isPresent(this.outlineState.outlineFor)) ;
                this.initialized = true;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.columnsChanged && this.el.nativeElement.offsetParent) {
                    this.columnsChanged = false;
                }
                if (this.hasFrozenColumns()) {
                    this.frozenColumns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
                else {
                    this.columns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
            };
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         */
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumns = /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.columns = [];
                this.frozenColumns = [];
                if (this.detailRowExpansionState.detailExpansionEnabled) {
                    this.initDetailColumnExpansion();
                }
                if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
                    this.multiSelectColumn.initialize(this);
                    this.columns.push(this.multiSelectColumn);
                }
                else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
                    this.singleSelectColumn.initialize(this);
                    this.columns.push(this.singleSelectColumn);
                }
                /**
                         * Add expansion column when detail row is enabled
                         */
                if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
                    this.rowDetailExpandColumn.initialize(this);
                    this.columns.push(this.rowDetailExpandColumn);
                }
                this.colsQuery
                    .filter(function (col1) { return !col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.columns.push(col);
                });
                this.initFrozenColumns();
                this.initColumnInfo();
                this.columnsChanged = true;
            };
        /**
         * Check if current column is programmatically created
         *
         */
        /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
        Datatable2Component.prototype.isInternalColumn = /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
            function (col) {
                return col instanceof DTSingleSelectColumnComponent ||
                    col instanceof DTMultiSelectColumnComponent ||
                    col instanceof DTDetailRowExpanderComponent;
            };
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         */
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
        Datatable2Component.prototype.initDatasource = /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
            function (initialize) {
                var _this = this;
                if (initialize === void 0) {
                    initialize = true;
                }
                if (core$1.isBlank(this.state)) {
                    this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
                }
                else {
                    this.state.limit = this.state.displayLimit = this.displayRowSize;
                    if (core$1.isPresent(this.initialSortKey)) {
                        this.state.sortKey = this.initialSortKey;
                        this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
                    }
                }
                if (initialize) {
                    /** @type {?} */
                    var qType = (this.isOutline() && this.outlineFormat === 'tree') ?
                        QueryType.FullTextOutline : QueryType.FullText;
                    this.dataSource.init({
                        obj: core$1.isPresent(this.destinationClass) ? this.destinationClass : this.list,
                        queryType: qType,
                        state: this.state,
                        multiselect: false
                    });
                }
                this.dataSource.fetch(this.state);
                // reset list to make sure it comes from DataProvider, we use list  to initialize
                this.list = null;
                // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
                // here. We dont work directly with LIST. Any change is reactive and here is listener
                this.dataSource.open().subscribe(function (data) {
                    _this.updateList(data);
                });
            };
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         */
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
        Datatable2Component.prototype.initDetailColumnExpansion = /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.rowDetailColumn)) {
                    this.rowDetailColumn.initialize(this);
                }
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn) &&
                    core$1.BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
            };
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         */
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumnInfo = /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.numberOfColsBeforeData = 0;
                this.columns.forEach(function (col) {
                    if (!col.isValueColumn()) {
                        _this.numberOfColsBeforeData++;
                    }
                });
                if (this.indentDetailRow) {
                    this.numberOfColsBeforeData++;
                }
                this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onCellSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (cell, column, item) {
                if (this.selectionMode !== 'cell') {
                    return;
                }
                /** @type {?} */
                var lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    /** @type {?} */
                    var foundIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey);
                    /** @type {?} */
                    var isSelected = foundIndex_1 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_1; });
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [lookupKey]);
                    }
                }
                else {
                    this.state.selection = [lookupKey];
                }
                this.onCellChange.emit(this.state.selection);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
        Datatable2Component.prototype.onHeaderSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
            function (cell, column) {
                if (core$1.isPresent(this.state.headerSelection)) {
                    if (this.isHeaderSelected(column)) {
                        this.state.headerSelection = null;
                    }
                    else {
                        this.state.headerSelection = column;
                    }
                }
                else {
                    this.state.headerSelection = column;
                }
                this.onHeaderSelection.emit(this.state.headerSelection);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onHandleRowClicked = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                // special alt key modifier. When used with rows it indicates there is a D&D enabled
                if (event.altKey) {
                    return;
                }
                if (this.selectionMode === 'multi') {
                    this.onRowToggle(event, item);
                }
                else if (this.selectionMode === 'single') {
                    this.onRowSelect(event, item);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowToggle = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                /** @type {?} */
                var rowSelected = true;
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    /** @type {?} */
                    var foundIndex_2 = core$1.ListWrapper.findIndexComplex(this.state.selection, item);
                    /** @type {?} */
                    var isSelected = foundIndex_2 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_2; });
                        rowSelected = false;
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [item]);
                    }
                    // for the outline go up and down the sync with treeitems
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, isSelected);
                        this.oHandleOutlineRowToggleToParent(item, isSelected);
                    }
                }
                else {
                    this.state.selection = [item];
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, false);
                        this.oHandleOutlineRowToggleToParent(item, false);
                    }
                }
                this.onRowSelectionChange.emit({
                    isSelected: rowSelected,
                    item: this.state.selection
                });
                event.stopPropagation();
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowSelect = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.state.selection = item;
                event.stopPropagation();
                this.onRowSelectionChange.emit(item);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.onHandleOutlineRowToggleToChildren = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                /** @type {?} */
                var childrenForNode = this.children.apply(this.context, [currentItem]) || [];
                if (childrenForNode.length > 0) {
                    // If is selected currently then toggle to other state
                    if (!isSelected) {
                        // when checking all from root, deselect children and add all
                        this.onHandleOutlineRowToggleToChildren(currentItem, true);
                        this.state.selection = __spread(this.state.selection, childrenForNode);
                    }
                    else {
                        var _loop_1 = function (child) {
                            /** @type {?} */
                            var foundIndex = core$1.ListWrapper.findIndexComplex(this_1.state.selection, child);
                            this_1.state.selection = this_1.state.selection
                                .filter(function (val, index) { return index !== foundIndex; });
                        };
                        var this_1 = this;
                        try {
                            // remove each child
                            for (var childrenForNode_1 = __values(childrenForNode), childrenForNode_1_1 = childrenForNode_1.next(); !childrenForNode_1_1.done; childrenForNode_1_1 = childrenForNode_1.next()) {
                                var child = childrenForNode_1_1.value;
                                _loop_1(child);
                            }
                        }
                        catch (e_1_1) {
                            e_1 = { error: e_1_1 };
                        }
                        finally {
                            try {
                                if (childrenForNode_1_1 && !childrenForNode_1_1.done && (_a = childrenForNode_1.return))
                                    _a.call(childrenForNode_1);
                            }
                            finally {
                                if (e_1)
                                    throw e_1.error;
                            }
                        }
                    }
                    try {
                        // apply the same for children of children
                        for (var childrenForNode_2 = __values(childrenForNode), childrenForNode_2_1 = childrenForNode_2.next(); !childrenForNode_2_1.done; childrenForNode_2_1 = childrenForNode_2.next()) {
                            var child = childrenForNode_2_1.value;
                            this.onHandleOutlineRowToggleToChildren(child, isSelected);
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_2_1 && !childrenForNode_2_1.done && (_b = childrenForNode_2.return))
                                _b.call(childrenForNode_2);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                var e_1, _a, e_2, _b;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.oHandleOutlineRowToggleToParent = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                /** @type {?} */
                var parent = currentItem.$$parentItem;
                if (core$1.isPresent(parent)) {
                    /** @type {?} */
                    var childrenForNode = this.children.apply(this.context, [parent]) || [];
                    /** @type {?} */
                    var allSelected = true;
                    try {
                        for (var childrenForNode_3 = __values(childrenForNode), childrenForNode_3_1 = childrenForNode_3.next(); !childrenForNode_3_1.done; childrenForNode_3_1 = childrenForNode_3.next()) {
                            var child = childrenForNode_3_1.value;
                            allSelected = core$1.ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                                && allSelected;
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_3_1 && !childrenForNode_3_1.done && (_a = childrenForNode_3.return))
                                _a.call(childrenForNode_3);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                    if (!isSelected) {
                        if (allSelected) {
                            this.state.selection.push(parent);
                        }
                    }
                    else {
                        if (!allSelected) {
                            /** @type {?} */
                            var parentIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, parent);
                            this.state.selection = this.state.selection
                                .filter(function (val, index) { return index !== parentIndex_1; });
                        }
                    }
                    this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
                }
                var e_3, _a;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        Datatable2Component.prototype.onDnDRowDrop = /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                if (core$1.isPresent(this.dataSource)) {
                    // console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
                    this.dataSource.reorderRows(origPos, newPos, dropPos);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.onOutlineExpandChange = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var item = event.item;
                // We dont really need to store a state form outline locally as we are using the same object
                // reference
                // this.state.outlineState = this.outlineState.expansionStates;
                if (this.canUseForDetailRow(item)) {
                    this.detailRowExpansionState.toggle(item);
                }
            };
        /**
         * See AWDataTable
         *
         *
         */
        /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
        Datatable2Component.prototype.sortSingle = /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.list) && core$1.isPresent(this.sortColumn)) {
                    core$1.assert(core$1.isPresent(this.sortColumn.key), 'Invalid column to sort');
                    this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
                    this.onSort.emit({
                        field: this.sortColumn.key,
                        order: this.sortColumn.sortOrder
                    });
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.handleDataChange = /**
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state.sortKey || this.sortColumn) {
                    if (!this.sortColumn && this.columns) {
                        this.sortColumn = this.columns.find(function (col) { return col.key === _this.state.sortKey; });
                    }
                }
                this.updateDataToRender();
                this.valueChange.emit(this.list);
            };
        /**
         * @param {?=} datasource
         * @return {?}
         */
        Datatable2Component.prototype.updateDataToRender = /**
         * @param {?=} datasource
         * @return {?}
         */
            function (datasource) {
                this.dataToRender = datasource || this.list;
                if (core$1.isBlank(this.children) && core$1.isPresent(this.dataToRender)
                    && this.dataToRender.length > 0 && isOutlineNode(this.dataToRender[0])) {
                    this.outlineFormat = 'tree';
                }
                // this.changeDetector.markForCheck();
                this.changeDetector.detectChanges();
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.reset = /**
         * @return {?}
         */
            function () {
                this.sortColumn = null;
                this.updateDataToRender();
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isHeaderSelected = /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.state.headerSelection)) {
                    return false;
                }
                /** @type {?} */
                var colMatched = item.key || item.label;
                /** @type {?} */
                var currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
                return colMatched === currentCol;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isBodyCellSelected = /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (column, item) {
                /** @type {?} */
                var lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                return core$1.isPresent(this.state.selection) &&
                    core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
            };
        /**
         *  See AWDataTable
         *
         */
        /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isRowSelected = /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.hasLeadingSelectColumn() && core$1.isPresent(this.state.selection)) {
                    if (this.selectionMode === 'multi') {
                        return core$1.ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
                    }
                    else if (this.selectionMode === 'single') {
                        return core$1.equals(this.state.selection, item);
                    }
                }
                return false;
            };
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         */
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
        Datatable2Component.prototype.isEmpty = /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
            function () {
                return core$1.isBlank(this.dataToRender) || (this.dataToRender.length === 0);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.hasFrozenColumns = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @return {?}
         */
        Datatable2Component.prototype.hasInvisibleSelectionColumn = /**
         * See AWDataTable
         * @return {?}
         */
            function () {
                return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.hasLeadingSelectColumn = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.visibleColumns = /**
         * @return {?}
         */
            function () {
                return this.columns ? this.columns.filter(function (c) { return c.isVisible; }) : [];
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForString = /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 'ascending') {
                    return 1;
                }
                if (core$1.isBlank(direction) || direction === 'descending') {
                    return -1;
                }
                // todo: log bad key
                return 1;
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForNumber = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 1) {
                    return 'ascending';
                }
                if (core$1.isBlank(direction) || direction === -1) {
                    return 'descending';
                }
                // todo: log bad key
                return 'ascending';
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.toggleAllColumns = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var currentItems = this.dataToRender || [];
                /** @type {?} */
                var selectedObject = this.state.selection || [];
                if (selectedObject.length >= currentItems.length) {
                    this.state.selection = [];
                }
                else {
                    this.state.selection = [];
                    this.state.selection = __spread(currentItems);
                }
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnSelected = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentItems = this.dataToRender || [];
                /** @type {?} */
                var selectedObject = this.state.selection || [];
                return currentItems.length > 0 && selectedObject.length >= currentItems.length;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnDisabled = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentItems = this.dataToRender || [];
                return currentItems.length === 0;
            };
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         */
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.showDetailColumn = /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
                    return true;
                }
                return false;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isOutline = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.children) || this.outlineFormat === 'tree';
            };
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         */
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.skipOutlineItem = /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.canUseForDetailRow(item);
            };
        /**
         *
         * See AWDaTable
         *
         */
        /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
        Datatable2Component.prototype.getValue = /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
            function (data, field) {
                return core$1.FieldPath.getFieldValue(data, field);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (this.columnsSubscription) {
                    this.columnsSubscription.unsubscribe();
                }
            };
        /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
        Datatable2Component.prototype.initFrozenColumns = /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.colsQuery
                    .filter(function (col1) { return col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.frozenColumns.push(col);
                });
                if (this.frozenColumns.length > 0) {
                    /** @type {?} */
                    var lastInx = this.columns.slice()
                        .reverse()
                        .findIndex(function (col) { return _this.isInternalColumn(col); });
                    if (lastInx !== -1) {
                        /** @type {?} */
                        var idx = this.columns.length - 1 - lastInx;
                        /** @type {?} */
                        var internalCols = this.columns.splice(0, idx + 1);
                        this.frozenColumns = __spread(internalCols, this.frozenColumns);
                    }
                    /** @type {?} */
                    var hasValidCols = this.columns
                        .findIndex(function (col) { return core$1.isBlank(col.width); }) === -1;
                    core$1.assert(hasValidCols || core$1.isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                        'column or [scrollWidth] on datatable!');
                    core$1.assert(core$1.isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
                }
            };
        /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
        Datatable2Component.prototype.updateList = /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
            function (newList) {
                var _this = this;
                setTimeout(function () {
                    _this.list = newList;
                    _this.handleDataChange();
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.canUseForDetailRow = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(this.rowDetailColumn) &&
                    ((this.rowDetailColumn)).showDetailRow(item);
            };
        Datatable2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-datatable2',
                        template: "<!--\n    This template focus only on header and body rendering.\n\n    This datatable also supports frozen column and for this rendering it is pretty much transparent\n    as it received sets of column that it needs to render from the TableWrapper.\n\n    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to\n    render to separate tables where one has frozen columns and another one has the rest and its\n    scrollable\n-->\n\n<aw-dt-wrapper #dtWrapper>\n    <ng-template #headingArea>\n        <ng-content select=\"aw-dt-header2\"></ng-content>\n    </ng-template>\n\n    <ng-template #headerRows let-colsToRender let-frozenView=\"frozenColumns\">\n        <ng-container\n            *ngTemplateOutlet=\"header; context:{$implicit: colsToRender, frozen:frozenView }\">\n        </ng-container>\n    </ng-template>\n\n    <ng-template #bodyRows let-colsToRender>\n        <ng-template [ngIf]=\"isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyOutline; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n        <ng-template [ngIf]=\"!isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyPlain; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n    </ng-template>\n</aw-dt-wrapper>\n\n\n<!--\n    Each rendering column has its own renderTemplate which define how things should be render.\n    Based on different column types this code should be transparent as we dont care on this\n    level what kind of column we are rendering.\n\n    Later on when we will support single/multi selection, this will be just another column extending\n    DTColumn and providing its own template\n\n    We pass into this template if we are rendering header, subHeader, or data\n-->\n<ng-template #header let-colsToRender let-frozen=\"frozen\">\n    <tr>\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\"\n                     let-columnIndex=\"index\">\n\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:false,\n                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n\n    <tr *ngIf=\"showSubHeader\">\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:true}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n<ng-template #bodyPlain let-colsToRender>\n\n    <tbody [ngClass]=\"{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}\">\n\n    <ng-template ngFor let-rowData [ngForOf]=\"dataToRender\" let-even=\"even\" let-odd=\"odd\"\n                 let-rowIndex=\"index\" [ngForTrackBy]=\"rowTrackBy\">\n\n        <ng-container *ngTemplateOutlet=\"rowTemplate; context:{$implicit: rowData, even:even,\n                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n\n<ng-template #bodyOutline let-colsToRender>\n    <tbody #outlineFor awOutlineFor [list]=\"dataToRender\"\n           [format]=\"outlineFormat\"\n           [context]=\"context\"\n           [indentationPerLevel]=\"indentationPerLevel\"\n           [pushRootSectionOnNewLine]=\"pushRootSectionOnNewLine\"\n           [children]=\"children\" [expandAll]=\"expandAll\"\n           [state]=\"outlineState\"\n           [ngClass]=\"{'dt-content dt-data-cells ': true,\n                           'dt-is-hoverable-row': rowHover}\"\n           (onExpandChange)=\"onOutlineExpandChange($event)\">\n\n    <ng-template #outline let-rowData let-nestingLevel=\"nestingLevel\" let-rowIndex=\"rowIndex\">\n        <ng-container *ngTemplateOutlet=\"rowTemplate;\n                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n<!--\n    Default template that is display when there are no data\n-->\n<ng-template #noData>\n    <tr *ngIf=\"isEmpty()\" class=\" dt-emptymessage-row\"\n        [style.visibility]=\"loading ? 'hidden' : 'visible'\">\n\n        <td [attr.colspan]=\"visibleColumns().length\" class=\"dt-emptymessage\">\n            <span *ngIf=\"!emptyMessageTemplate\">{{emptyMessage}}</span>\n            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n<!--\n    Template that renders actual row. Renders both header and body column. Each rendered\n    column has its own template called rendererTemplate that has all things that needs to be\n    rendered and we just tell the template if we are rendering header, subheader or body\n-->\n<ng-template #rowTemplate let-rowData let-even=\"event\" let-odd=\"odd\" let-rowIndex=\"rowIndex\"\n             let-nestingLevel=\"nestingLevel\" let-colsToRender=\"colsToRender\">\n\n\n    <tr #rowElement dtDraggableRow [dndRowIndex]=\"rowIndex\"\n        class=\"dt-body-row\"\n        (click)=\"onHandleRowClicked($event, rowData)\"\n        [attr.nestingLevel]=\"nestingLevel\"\n        [ngClass]=\"{'dt-even-row': even, 'dt-odd-row': odd,\n            'dt-row-selected': isRowSelected(rowData),\n            'dt-row-draggable': dndRowEnabled,\n            'dt-root-section': nestingLevel === 0 }\">\n\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-colIndex=\"index\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,\n                    nestingLevel:nestingLevel}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n",
                        providers: [
                            objectutils.ObjectUtils,
                            OutlineState,
                            { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}"]
                    }] }
        ];
        /** @nocollapse */
        Datatable2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: DT2DataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: core.ChangeDetectorRef },
                { type: core.ComponentFactoryResolver },
                { type: OutlineState },
                { type: core.NgZone },
                { type: core.Injector }
            ];
        };
        Datatable2Component.propDecorators = {
            list: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            tableStyleClass: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isRowSelectable: [{ type: core.Input }],
            showTableHeader: [{ type: core.Input }],
            pivotalLayout: [{ type: core.Input }],
            context: [{ type: core.Input }],
            initialSortOrder: [{ type: core.Input }],
            initialSortKey: [{ type: core.Input }],
            displayRowSize: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            emptyMessage: [{ type: core.Input }],
            rowTrackBy: [{ type: core.Input }],
            rowHover: [{ type: core.Input }],
            loading: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            loadingIcon: [{ type: core.Input }],
            indentDetailRow: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            children: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            outlineFormat: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            showRowDetailExpansionControl: [{ type: core.Input }],
            showSelectionColumn: [{ type: core.Input }],
            showSelectAll: [{ type: core.Input }],
            showGlobalSearch: [{ type: core.Input }],
            scrollWidth: [{ type: core.Input }],
            dndRowEnabled: [{ type: core.Input }],
            onSort: [{ type: core.Output }],
            onRowClick: [{ type: core.Output }],
            onRowSelectionChange: [{ type: core.Output }],
            onCellChange: [{ type: core.Output }],
            onHeaderSelection: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DTHeaderComponent2,] }],
            emptyMessageTemplate: [{ type: core.ContentChild, args: ['noDataTempl',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['dtHeader',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['dtSubHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['dtBody',] }],
            headerFilterTemplate: [{ type: core.ContentChild, args: ['headerFilter',] }],
            colsQuery: [{ type: core.ContentChildren, args: [DTColumn2Component,] }],
            rowDetailColumn: [{ type: core.ContentChild, args: [DTDetailRowComponent,] }],
            valueChange: [{ type: core.Output }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            state: [{ type: core.Input }]
        };
        return Datatable2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Please see datatable for more detail description. But the main goal of this wrapper to remove
     * all the common surrounding parts around the datatable and make sure DT can focus only actual
     * header and body structure
     *
     * It is expected that wrapper also provides some code for the sliding up panel containing
     * buttons and other actions that will be used during editing
     *
     *
     * Todo: Extract the expand logic out into some directive or component or just a class
     *
     */
    var DTWrapper = (function (_super) {
        __extends(DTWrapper, _super);
        function DTWrapper(env, render, thisElement, domUtils, platformId, dt) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.render = render;
            _this.thisElement = thisElement;
            _this.domUtils = domUtils;
            _this.platformId = platformId;
            _this.dt = dt;
            /**
             * Color that is used by full screen div overlay to create expanding effect which needs to have
             * little tent;
             *
             */
            _this.expandColorFrom = '#f3f3f3';
            /**
             * Color that is used to set after we are in the full screen so our overlay div hide everything
             * on the page
             *
             */
            _this.expandColorTo = '#FFFFFF';
            /**
             * In order to debounce the typing we need to use subject
             *
             */
            _this.searchTerms = new rxjs.Subject();
            /**
             *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
             *
             */
            _this.isFullScreenMode = false;
            /**
             * Tells if we can support full screen mode - only available for the browser
             *
             */
            _this.supportFullScreen = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                this.querySubscription = this.searchTerms.pipe(
                // wait 300ms after each keystroke before considering the term
                operators.debounceTime(300), 
                // ignore new term if same as previous term
                operators.distinctUntilChanged(), operators.switchMap(function (term) { return rxjs.of(term); })).subscribe(function (term) {
                    if (core$1.isPresent(term)) {
                        _this.dt.dataSource.find(term);
                    }
                });
                this.loadingSub = this.dt.valueChange
                    .subscribe(function (data) { return _this.loadingFinished(); });
            };
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         */
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateFrozenWidth = /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
            function () {
                if (!this.dt.hasFrozenColumns()) {
                    return null;
                }
                /** @type {?} */
                var fWidth = 0;
                this.dt.frozenColumns.forEach(function (col) {
                    if (col.maxWidthPx > 0) {
                        fWidth += col.widestCell;
                    }
                    else {
                        fWidth += parseInt(col.width);
                    }
                });
                return fWidth;
            };
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         */
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
        DTWrapper.prototype.alignTablesHeights = /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
            function (frozenView, unFrozenView) {
                core$1.assert(core$1.isPresent(frozenView) && core$1.isPresent(frozenView), 'Cant align table views as one of the view is undefined');
                /** @type {?} */
                var frozenRows = frozenView.querySelectorAll('table tr');
                /** @type {?} */
                var unFrozenRows = unFrozenView.querySelectorAll('table tr');
                core$1.assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
                Array.from(frozenRows).forEach(function (frozen, index) {
                    /** @type {?} */
                    var h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
                    frozen.style.height = h + 'px';
                    unFrozenRows[index].style.height = h + 'px';
                });
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.initFullScreen();
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.dt.hasFrozenColumns()) {
                    /** @type {?} */
                    var frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
                    /** @type {?} */
                    var unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
                    /** @type {?} */
                    var frozenWidth = this.calculateFrozenWidth();
                    frozenView.style.width = frozenWidth + 'px';
                    if (core$1.isPresent(unFrozenView)) {
                        // include border and create indent effect by having 1px white space
                        unFrozenView.style.left = (frozenWidth + 2) + 'px';
                        unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                            - frozenView.offsetWidth + 'px';
                        this.alignTablesHeights(frozenView, unFrozenView);
                    }
                }
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.querySubscription)) {
                    this.querySubscription.unsubscribe();
                }
                if (core$1.isPresent(this.loadingSub)) {
                    this.loadingSub.unsubscribe();
                }
            };
        /**
         * FULL SCREEN MODE methods
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreen = /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFullScreenMode) {
                    this.closeFullScreen(event);
                }
                else {
                    this.openFullScreen(event);
                }
            };
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         */
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.openFullScreen = /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.isFullScreenMode = true;
                this.runExpandEffect();
                this.originalScrollPosition = window.pageYOffset;
                window.scroll(0, 0);
                this.toggleFullScreenOnDT(true);
                /** @type {?} */
                var parentNode = this.thisElement.nativeElement.parentNode;
                while (core$1.isPresent(parentNode) && parentNode.tagName !== 'BODY') {
                    parentNode.classList.add('u-full-screen-element');
                    parentNode = parentNode.parentNode;
                }
                this.hideNonFullScreenElement(document.body);
                this.dt.state.limit = Math.round(this.calculateLimit());
                this.dt.dataSource.fetch(this.dt.state);
                // once loaded set back correct page size we use when loading data
                this.dt.state.limit = this.dt.pageSize;
            };
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         */
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.closeFullScreen = /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.isFullScreenMode = false;
                this.showNonFullScreenElement();
                this.runCollapseEffect();
                this.toggleFullScreenOnDT(false);
                this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
                this.dt.dataSource.state.offset = 0;
                this.dt.dataSource.fetch(this.dt.dataSource.state);
                setTimeout(function () {
                    window.scroll(0, _this.originalScrollPosition);
                }, 300);
            };
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         */
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreenOnDT = /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
            function (fullScreen) {
                var _this = this;
                this.dt.el.nativeElement.style.opacity = 0;
                setTimeout(function () {
                    if (fullScreen) {
                        _this.dt.classList += 'dt-full-screen';
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                    else {
                        _this.dt.classList = _this.dt.classList.replace('dt-full-screen', '');
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                }, 200);
            };
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         */
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.onLazyLoad = /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.isLoad) {
                    this.dt.state.offset = event.offset;
                    this.dt.dataSource.fetch(this.dt.state);
                }
                else {
                    /** @type {?} */
                    var dataProvider = this.dt.dataSource.dataProvider;
                    /** @type {?} */
                    var data = dataProvider.dataChanges.getValue();
                    dataProvider.dataChanges.next(data.slice(0, event.offset));
                }
            };
        /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
        DTWrapper.prototype.runExpandEffect = /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
            function () {
                var _this = this;
                this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
                this.updateElement();
                this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
                this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
                this.applyTransformation(true);
                setTimeout(function () {
                    _this.dtFullScreenOverlay.nativeElement.style.backgroundColor = _this.expandColorTo;
                }, 300);
            };
        /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
        DTWrapper.prototype.runCollapseEffect = /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
            function () {
                var _this = this;
                this.updateElement();
                this.applyTransformation(false);
                setTimeout(function () {
                    _this.updateElement();
                    _this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
                }, 200);
                setTimeout(function () {
                    _this.updateElement(_this.dtBoundingClientRect.left, _this.dtBoundingClientRect.top, 0, 0);
                }, 400);
            };
        /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
        DTWrapper.prototype.hideNonFullScreenElement = /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
            function (parentElement) {
                if (this.thisElement.nativeElement.parentNode === parentElement) {
                    return;
                }
                for (var i = 0; i < parentElement.children.length; i++) {
                    /** @type {?} */
                    var element = parentElement.children[i];
                    if (this.needTraverseDown(element)) {
                        this.hideNonFullScreenElement(element);
                    }
                    else if (!element.classList.contains('dt-full-screen')) {
                        element.classList.add('u-fs-element-out');
                    }
                }
            };
        /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
        DTWrapper.prototype.showNonFullScreenElement = /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
            function () {
                Array.from(document.querySelectorAll('.u-fs-element-out'))
                    .forEach(function (elem) { return elem.classList.remove('u-fs-element-out'); });
            };
        /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
        DTWrapper.prototype.needTraverseDown = /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return core$1.isPresent(element) && element.tagName !== 'SCRIPT' &&
                    element.classList.contains('u-full-screen-element') &&
                    !element.classList.contains('dt-full-screen');
            };
        /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateLimit = /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var browserH = this.domUtils.browserDimentions().height;
                /** @type {?} */
                var rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
                return (core$1.isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
            };
        /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
        DTWrapper.prototype.updateElement = /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
            function (l, t, w, h) {
                if (l === void 0) {
                    l = this.dtBoundingClientRect.left;
                }
                if (t === void 0) {
                    t = this.dtBoundingClientRect.top;
                }
                if (w === void 0) {
                    w = this.dtBoundingClientRect.width;
                }
                if (h === void 0) {
                    h = this.dtBoundingClientRect.height;
                }
                this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
                this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
                this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
                this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
            };
        /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
        DTWrapper.prototype.applyTransformation = /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
            function (expand) {
                /** @type {?} */
                var x;
                /** @type {?} */
                var y;
                /** @type {?} */
                var tx;
                /** @type {?} */
                var ty;
                if (expand) {
                    x = window.innerWidth / this.dtBoundingClientRect.width;
                    y = window.innerHeight / this.dtBoundingClientRect.height;
                    tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                        - this.dtBoundingClientRect.left) / x;
                    ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                        - this.dtBoundingClientRect.top) / y;
                }
                else {
                    x = 1;
                    y = 1;
                    tx = this.dtBoundingClientRect.left;
                    ty = this.dtBoundingClientRect.top;
                }
                this.dtFullScreenOverlay.nativeElement.style.transform =
                    'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
            };
        /**
         * INFINITE SCROLLING METHODS
         * @return {?}
         */
        DTWrapper.prototype.initFullScreen = /**
         * INFINITE SCROLLING METHODS
         * @return {?}
         */
            function () {
                if (!common.isPlatformBrowser(this.platformId)) {
                    this.supportFullScreen = false;
                    return;
                }
                this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
            };
        /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
        DTWrapper.prototype.loadingFinished = /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.infiniteScroll)) {
                    setTimeout(function () { return _this.infiniteScroll.complete(); }, 200);
                }
            };
        DTWrapper.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-wrapper',
                        template: "<div [ngClass]=\"dt.styleClass\" [class.dt-full-screen-mode]=\"isFullScreenMode\"\n     [style.width]=\"dt.width\"\n>\n    <div class=\"dt-loading-overlay\" *ngIf=\"dt.loading\"></div>\n    <div class=\"dt-loading-content\" *ngIf=\"dt.loading\">\n        <i [class]=\"'sap-icon u-dt-spin-icon ' + dt.loadingIcon\"></i>\n    </div>\n\n    <div class=\"dt-header\" *ngIf=\"dt.showTableHeader\">\n        <ng-template *ngIf=\"dt.header; then appDefinedHeader else defaultHeader\"></ng-template>\n    </div>\n\n    <!-- DT BODY with table headers and values -->\n    <div class=\"dt-body-wrapper-view\">\n        <ng-template\n            *ngIf=\"dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns\">\n        </ng-template>\n    </div>\n\n    <!--<div class=\"dt-footer\" *ngIf=\"footer\">-->\n    <!--&lt;!&ndash; footerArea&ndash;&gt;-->\n    <!--<ng-content select=\"aw-dt-footer\"></ng-content>-->\n    <!--</div>-->\n</div>\n\n<!-- todo: dont activate this if we reached the end of list - -->\n<aw-infinite-scroll #infiniteScroll *ngIf=\"isFullScreenMode\"\n                    [distance]=\"'10%'\"\n                    [fetchSize]=\"dt.state.limit\"\n                    (onLoad)=\"onLazyLoad($event)\">\n</aw-infinite-scroll>\n\n\n<ng-template #appDefinedHeader>\n    <ng-container *ngTemplateOutlet=\"heading;\"></ng-container>\n</ng-template>\n\n<ng-template #defaultHeader>\n    <div class=\"dt-global-filter\">\n        <span class=\"sap-icon icon-filter\"></span>\n    </div>\n\n    <div class=\"dt-global-actions\">\n        <div class=\"dt-action-combo\">\n            <span *ngIf=\"supportFullScreen\" class=\"sap-icon icon-resize\"\n                  (click)=\"toggleFullScreen($event)\"></span>\n\n            <aw-input-field *ngIf=\"dt.showGlobalSearch\" styleClass=\"dt-table-search\"\n                            [(ngModel)]=\"dt.state.currentSearchQuery\"\n                            placeHolder=\"search\"\n                            icon=\"icon-search\"\n                            (ngModelChange)=\"searchTerms.next($event)\">\n            </aw-input-field>\n            <span class=\"ariba-icon icon-more\"></span>\n        </div>\n    </div>\n</ng-template>\n\n<!--\n    Each section frozen/non-frozen is calculated inside table-wrapper in the ngAfterViewChecked, where we set\n    proper width for each frame as well as left coordinates for the right one\n-->\n<ng-template #dtBodyNoFrozenColumns>\n    <!--\n        For non-frozen case we also need to set TRUE as the view is actually frozen and does not\n        scroll.\n        We use this frozenColumns flag inside DT to properly set column index on the header level\n        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))\n\n        therefore we need to set true even in this case to return real columnIndex since we dont\n        have the second table.\n    -->\n    <ng-container *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: true }\">\n    </ng-container>\n</ng-template>\n\n<ng-template #dtBodyWithFrozenColumns>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }\">\n    </ng-container>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: false }\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #dtBody let-columns let-frozenColumns=\"frozenColumns\">\n\n    <div #dtContainer class=\"dt-body-wrapper\"\n         [style.width.px]=\"this.calculateFrozenWidth()\"\n         [class.dt-body-unfrozen]=\"dt.hasFrozenColumns() && !frozenColumns\"\n         [class.dt-body-frozen]=\"dt.hasFrozenColumns() && frozenColumns\"\n    >\n\n        <table [ngClass]=\"dt.tableStyleClass\"\n               [style.width]=\"frozenColumns ? null : dt.scrollWidth\"\n               [class.dt-pivot-layout]=\"dt.pivotalLayout\"\n               [class.dt-plain-layout]=\"!dt.pivotalLayout && !dt.isOutline()\">\n\n            <!-- Render TH header rows-->\n            <thead class=\"dt-thead\">\n            <ng-container *ngTemplateOutlet=\"headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }\">\n            </ng-container>\n            </thead>\n\n            <!--\n                Render data rows. For data rows we need to keep tbody tag inside DT table\n                due to Outline\n             -->\n            <ng-container *ngTemplateOutlet=\"bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }\">\n            </ng-container>\n        </table>\n    </div>\n</ng-template>\n\n\n<div #dtFullScreenOverlay class=\"dt-full-screen-overlay u-full-screen-element\"></div>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        styles: [".dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;-ms-grid-row-align:center;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:.4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}"]
                    }] }
        ];
        /** @nocollapse */
        DTWrapper.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.Renderer2 },
                { type: core.ElementRef },
                { type: DomUtilsService },
                { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] }
            ];
        };
        DTWrapper.propDecorators = {
            expandColorFrom: [{ type: core.Input }],
            expandColorTo: [{ type: core.Input }],
            heading: [{ type: core.ContentChild, args: ['headingArea',] }],
            headerRows: [{ type: core.ContentChild, args: ['headerRows',] }],
            bodyRows: [{ type: core.ContentChild, args: ['bodyRows',] }],
            footer: [{ type: core.ContentChild, args: ['footerArea',] }],
            dtFullScreenOverlay: [{ type: core.ViewChild, args: ['dtFullScreenOverlay',] }],
            infiniteScroll: [{ type: core.ViewChild, args: ['infiniteScroll',] }]
        };
        return DTWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * This directive is responsible for checking and setting the widest content width onto
     * Column component as the widestCell property.
     *
     * We use this directive inside dt-column.component to store a current width for each td,th
     *
     *
     */
    var SetCellMaxWidthDirective = (function () {
        function SetCellMaxWidthDirective(element, render, td) {
            this.element = element;
            this.render = render;
            this.td = td;
        }
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // console.log('Cell Max Width: ' + this.dtMaxWidth, this.dtMaxWidth > 0);
                if (core$1.isPresent(this.dtMaxWidth) && this.dtMaxWidth > 0) {
                    /** @type {?} */
                    var inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
                    if (core$1.isPresent(inlineData)) {
                        inlineData.style.whiteSpace = 'nowrap';
                        inlineData.style.display = 'inline-block';
                        /** @type {?} */
                        var cellWidth = inlineData.offsetWidth; // td
                        inlineData.style.whiteSpace = 'normal';
                        inlineData.style.display = 'inline';
                        if (!this.isInThresHold(cellWidth)) {
                            return;
                        }
                        cellWidth += this.tdPadding();
                        if (cellWidth > this.td.widthPx) {
                            if (cellWidth < this.dtMaxWidth) {
                                this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                                    this.td.widestCell;
                            }
                            else if (cellWidth >= this.dtMaxWidth) {
                                this.td.widestCell = (this.dtMaxWidth > this.td.widestCell)
                                    ? this.dtMaxWidth : this.td.widestCell;
                            }
                        }
                    }
                }
            };
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         */
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.isInThresHold = /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
            function (newWidth) {
                if (this.td.widestCell > 0) {
                    return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
                }
                return true;
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.tdPadding = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var computedStyle = getComputedStyle(this.element.nativeElement);
                /** @type {?} */
                var cell = parseInt(computedStyle.paddingLeft) || 0;
                cell += parseInt(computedStyle.paddingRight) || 0;
                cell += parseInt(computedStyle.borderRightWidth) || 0;
                cell += parseInt(computedStyle.borderLeftWidth) || 0;
                // plus give it some little space around the text so it nots px to px inner width of the td
                // cuz it could wrap
                cell += 5;
                return cell;
            };
        SetCellMaxWidthDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dtMaxWidth]'
                    },] }
        ];
        /** @nocollapse */
        SetCellMaxWidthDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: DTColumn2Component }
            ];
        };
        SetCellMaxWidthDirective.propDecorators = {
            dtMaxWidth: [{ type: core.Input }]
        };
        return SetCellMaxWidthDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Directive used inside DT in order to support table rows re-ordering. This manages all the
     * D&D necessary logic for this functionality.
     *
     * [dtDraggableRow] is used inside the `rowTemplate` like this:
     *
     *
     * ```html
     *
     * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
     *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
     *
     *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
     *          class="dt-body-row"
     *
     *
     *
     * ```
     *
     * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
     *
     *
     *
     */
    var DTDraggableRowDirective = (function () {
        function DTDraggableRowDirective(element, dt, domUtils, ngZone) {
            this.element = element;
            this.dt = dt;
            this.domUtils = domUtils;
            this.ngZone = ngZone;
            /**
             *
             * Tells the directive if we enable middle row zone to create an effect that we are dropping
             * into the row. Used for outline DT mainly.
             *
             */
            this.dropIntoEnabled = false;
            /**
             * Current TR index number
             *
             */
            this.dndRowIndex = 0;
            /**
             * Holds information about our dragging direction UP and DOWN in order to assign correct style
             * that highlights the row at the top or bottom
             *
             */
            this.dragDir = DragDirection.None;
            /**
             * Indicates that we dragged our row and stopped in the middle of the other row
             *
             */
            this.inMiddle = false;
            /**
             *
             * Current drag Y coordinates which is used together with the dragDir when assinging dragging
             * direction.
             *
             */
            this.dragY = 0;
        }
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.setupEventListeners();
                }
            };
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.releaseEventListeners();
                }
            };
        /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
        DTDraggableRowDirective.prototype.setupEventListeners = /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
            function () {
                var _this = this;
                this.ngZone.runOutsideAngular(function () {
                    _this.eventHandlers = {};
                    _this.eventHandlers['mousedown'] = _this.onMouseDownEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('mousedown', _this.eventHandlers['mousedown']);
                    _this.eventHandlers['dragstart'] = _this.onDragStartEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragstart', _this.eventHandlers['dragstart']);
                    _this.eventHandlers['dragover'] = _this.onDragOverEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragover', _this.eventHandlers['dragover']);
                    _this.eventHandlers['dragleave'] = _this.onDragLeaveEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragleave', _this.eventHandlers['dragleave']);
                    _this.eventHandlers['drop'] = _this.onDropEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('drop', _this.eventHandlers['drop']);
                    _this.eventHandlers['dragend'] = _this.onDragEndEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragend', _this.eventHandlers['dragend']);
                });
            };
        /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
        DTDraggableRowDirective.prototype.releaseEventListeners = /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
            function () {
                var _this = this;
                DragEvents.forEach(function (name) {
                    document.removeEventListener('name', _this.eventHandlers[name]);
                });
            };
        /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onMouseDownEvent = /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
                    this.element.nativeElement.draggable = true;
                    /** @type {?} */
                    var elToBeDragged = this.domUtils.elementDimensions(event.target);
                    this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
                }
                else {
                    this.element.nativeElement.draggable = false;
                }
            };
        /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragStartEvent = /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                setTimeout(function () {
                    if (core$1.isPresent(event.target.classList)) {
                        event.target.classList.add('dt-row-dragging');
                    }
                }, 200);
                this.dt.env.setValue('isDragging', true);
                this.dt.env.setValue('dndId', this.dndRowIndex);
                event.dataTransfer.setData('text', this.dndRowIndex);
            };
        /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragOverEvent = /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.dataTransfer.dropEffect = 'move';
                if (this.dragY < event.pageY) {
                    this.dragDir = DragDirection.Down;
                }
                else if (this.dragY > event.pageY) {
                    this.dragDir = DragDirection.Up;
                }
                // dont set again unless its different
                if (this.dragY !== event.pageY) {
                    this.dragY = event.pageY;
                }
                if (this.isValidDropTarget(event)) {
                    // todo test this preventDefault() so it does not create some sideeffect
                    event.preventDefault();
                    this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
                }
            };
        /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDropEvent = /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.clearClasses(event.target.parentElement);
                /** @type {?} */
                var origIndx = this.dt.env.getValue('dndId');
                /** @type {?} */
                var dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
                this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
                this.inMiddle = false;
                this.dragY = 0;
            };
        /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragLeaveEvent = /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var tr = this.domUtils.closest(event.target, 'tr');
                this.clearClasses(tr);
                this.dt.env.deleteValue('dndOnHoldIndex');
            };
        /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragEndEvent = /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(event.target.classList)) {
                    event.target.classList.remove('dt-row-dragging');
                }
                this.clearClasses(event.target);
                this.element.nativeElement.draggable = false;
                this.dt.env.deleteValue('isDragging');
                this.dt.env.deleteValue('dndId');
                this.dt.env.deleteValue('ddClickDeviance');
            };
        /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
        DTDraggableRowDirective.prototype.markRowWithClass = /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
            function (event, activeRow) {
                this.clearClasses(activeRow);
                /** @type {?} */
                var currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
                /** @type {?} */
                var draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
                if (this.dropIntoEnabled) {
                    this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
                }
                if (this.inMiddle) {
                    activeRow.classList.add(DragDirection.Middle);
                }
                else {
                    activeRow.classList.add(this.dragDir);
                }
            };
        /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.isValidDropTarget = /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var origInx = this.dt.env.getValue('dndId');
                /** @type {?} */
                var siblingRow = this.dndRowIndex - origInx;
                return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
                    !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
                    !(siblingRow === -1 && this.dragDir === DragDirection.Down);
            };
        /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
        DTDraggableRowDirective.prototype.clearClasses = /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
            function (tr) {
                tr.classList.remove('dt-drag-row-top');
                tr.classList.remove('dt-drag-row-bottom');
                tr.classList.remove('dt-drag-row-both');
            };
        /**
         *  private
         *
         * @return {?}
         */
        DTDraggableRowDirective.prototype.dragDirToString = /**
         *  private
         *
         * @return {?}
         */
            function () {
                switch (this.dragDir) {
                    case DragDirection.Up:
                        return 'Up';
                    case DragDirection.Down:
                        return 'Down';
                    default:
                        return 'Not Sure';
                }
            };
        DTDraggableRowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dtDraggableRow]'
                    },] }
        ];
        /** @nocollapse */
        DTDraggableRowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] },
                { type: DomUtilsService },
                { type: core.NgZone }
            ];
        };
        DTDraggableRowDirective.propDecorators = {
            dropIntoEnabled: [{ type: core.Input }],
            dndRowIndex: [{ type: core.Input }]
        };
        return DTDraggableRowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWDatatable2Module = (function () {
        function AWDatatable2Module() {
        }
        AWDatatable2Module.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Datatable2Component,
                            DTWrapper,
                            DTColumn2Component,
                            DTHeaderComponent2,
                            DTDetailRowComponent,
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent,
                            DTDraggableRowDirective,
                            SetCellMaxWidthDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            AWCoreComponentModule,
                            AWCheckBoxModule,
                            AWOutlineForModule,
                            AWRadioButtonModule,
                            AWInputFieldModule
                        ],
                        entryComponents: [
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent
                        ],
                        exports: [
                            Datatable2Component,
                            DTColumn2Component,
                            AWOutlineForModule,
                            DTHeaderComponent2,
                            DTDetailRowComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWDatatable2Module;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationHeaderComponent = (function () {
        function ConfirmationHeaderComponent() {
        }
        ConfirmationHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-header',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        return ConfirmationHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationFooterComponent = (function () {
        function ConfirmationFooterComponent() {
        }
        ConfirmationFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-footer',
                        template: '<ng-content></ng-content>'
                    }] }
        ];
        return ConfirmationFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
     * functionality. It behaves like a dialog, is modal, and not closable by default.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
     *        a confirmation to the user.
     *
     *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
     *                        title: 'Confirmation',
     *                        body: ` Are you sure ? `,
     *                        width: 300,
     *                        onConfirm: () => {
     *                              this.confirmAction();
     *                        },
     *                        onCancel: () => {
     *                              this.cancelAction();
     *                        }
     *           });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-confirmation [title]="'Confirmation'"
     *                                      [(visible)]="display"
     *                                     (onConfirm)="confirmAction()"
     *                                    (onCancel)="cancelAction()">
     *                                       <i class="sap-icon icon-alert"></i>
     *                                       Are you sure you want to delete your hard drive?
     *                            </aw-confirmation>
     *
     *                                   <aw-button [size]="'small'" (click)="open()">
     *                                       Open Confirmation
     *                                   </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     confirmAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     confirmAction()  {
     *                        this.confirmAction = "confirmed";
     *                      }
     *
     *                      close() {
     *                         this.display = false;
     *                      }
     *
     *                      cancelAction() {
     *                          this.confirmAction = "canceled";
     *                      }
     *
     *       }
     *
     *
     */
    var ConfirmationComponent = (function (_super) {
        __extends(ConfirmationComponent, _super);
        function ConfirmationComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = false;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Fired when user clicked on confirm button.
             */
            _this.onConfirm = new core.EventEmitter();
            /**
             * Fired when user clicked on cancel button.
             */
            _this.onCancel = new core.EventEmitter();
            _this.width = 400;
            _this.height = 'auto';
            // Todo: internationalize.
            // Todo: internationalize.
            _this.confirmActionLabel = 'Confirm';
            _this.cancelActionLabel = 'Cancel';
            return _this;
        }
        /**
         * open confirmation.
         */
        /**
         * open confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.open = /**
         * open confirmation.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                this.visibleChange.emit(true);
            };
        /**
         * close confirmation.
         */
        /**
         * close confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.close = /**
         * close confirmation.
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does the confirmation have header content?
         */
        /**
         * Does the confirmation have header content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasHeader = /**
         * Does the confirmation have header content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does the confirmation have footer content?
         */
        /**
         * Does the confirmation have footer content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasFooter = /**
         * Does the confirmation have footer content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        /**
         * Confirm action.
         */
        /**
         * Confirm action.
         * @return {?}
         */
        ConfirmationComponent.prototype.confirm = /**
         * Confirm action.
         * @return {?}
         */
            function () {
                this.close();
                this.onConfirm.emit();
            };
        /**
         * Cancel action.
         */
        /**
         * Cancel action.
         * @return {?}
         */
        ConfirmationComponent.prototype.cancel = /**
         * Cancel action.
         * @return {?}
         */
            function () {
                this.close();
                this.onCancel.emit();
            };
        ConfirmationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation',
                        template: "<aw-dialog [title]=\"title\" [(visible)]=\"visible\"\n           [modal]=\"true\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n           [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onOpen)=\"open()\" (onClose)=\"close()\">\n\n    <aw-dialog-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-confirmation-header\"></ng-content>\n    </aw-dialog-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n\n    <aw-dialog-footer *ngIf=\"hasFooter(); else defaultFooter\">\n        <ng-content select=\"aw-confirmation-footer\"></ng-content>\n    </aw-dialog-footer>\n\n    <ng-template #defaultFooter>\n        <aw-dialog-footer>\n            <aw-button name=\"confirm\" [style]=\"'primary'\" (action)=\"confirm()\">\n                {{confirmActionLabel}}\n            </aw-button>\n\n            <aw-button name=\"cancel\" [style]=\"'secondary'\" (action)=\"cancel()\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n        </aw-dialog-footer>\n    </ng-template>\n\n</aw-dialog>\n",
                        styles: [".confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}"]
                    }] }
        ];
        /** @nocollapse */
        ConfirmationComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        ConfirmationComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            confirmActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            onConfirm: [{ type: core.Output }],
            onCancel: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [ConfirmationHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [ConfirmationFooterComponent,] }]
        };
        return ConfirmationComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWConfirmationModule = (function () {
        function AWConfirmationModule() {
        }
        AWConfirmationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            AWDialogModule,
                            AWButtonModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        exports: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWConfirmationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Container panel providing scrolling functionality for its children. You can configure this
     * container to let it to scroll its content either horizontally, vertically or let the content
     * wrap.
     *
     *
     * Usage is pretty simple:
     *
     *  ### Example using horizontal scroll (default behavior):
     *
     *  ```
     *            <aw-scrollable>
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     *  ```
     *
     *  ### Example using vertical scroll:
     *
     *  ```
     *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     * ```
     *
     *  ### Example scrolling is disabled and content wraps and centers:
     *
     *  ```
     *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *  ```
     *
     * ### Height property:
     *
     * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
     * is set automatically based on its content. The height should be always 100% when using
     * this in parent container.
     *
     * If "vertical scrolling" is used you need to make sure that:
     *   - your parent container sets the boundaries with correctly set width and height
     *   otherwise it will use 100% of the viewport
     *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
     *   the document
     *
     *
     *
     *
     */
    var ScrollableContainerComponent = (function (_super) {
        __extends(ScrollableContainerComponent, _super);
        function ScrollableContainerComponent(env, elementRef) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elementRef = elementRef;
            /**
             * Defines scrolling direction of the container meaning tells which overflow axies will be
             * disabled or enabled.
             *
             * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
             *
             * When scrolling direction is "vertical" please make sure you maintain correct height and
             * width.
             *
             */
            _this.direction = 'horizontal';
            /**
             * Defines how flexbox container items should be aligned. Default behavior is LEFT
             *
             */
            _this.alignment = 'left';
            _this.height = '100%';
            _this.width = '100%';
            return _this;
        }
        /**
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initDefault();
            };
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         */
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnChanges = /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.initDefault();
            };
        /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.initDefault = /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
            function () {
                this.layoutClass = 'u-scrollable-fh';
                if (this.direction === 'vertical') {
                    this.layoutClass = 'u-scrollable-fv';
                }
                if (this.direction === 'vertical-row') {
                    this.layoutClass = 'u-scrollable-fv-row';
                }
                else if (this.direction === 'both') {
                    this.layoutClass = 'u-scrollable-fb';
                }
                else if (this.direction === 'none') {
                    this.layoutClass = 'u-scrollable-fn';
                }
                this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
                if (core$1.isPresent(this.styleClass)) {
                    this.layoutClass += " " + this.styleClass;
                }
                // make sure we default width and height to some value in case somebody passes null
                if (core$1.isBlank(this.width)) {
                    this.width = '100%';
                }
                if (core$1.isBlank(this.height)) {
                    this.height = '100%';
                }
            };
        /**
         * Tells if the horizontal scrollbar is visible
         *
         */
        /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasHorizontalScroll = /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollWidth > scrollContainer.clientWidth;
            };
        /**
         * Tells if the vertical scrollbar is visible
         *
         */
        /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasVerticalScroll = /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollHeight > scrollContainer.clientHeight;
            };
        ScrollableContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-scrollable',
                        template: "<div class=\"w-scrollable\" [ngClass]=\"layoutClass\" [style.width]=\"width\"\n     [style.height]=\"height\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}"]
                    }] }
        ];
        /** @nocollapse */
        ScrollableContainerComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        ScrollableContainerComponent.propDecorators = {
            direction: [{ type: core.Input }],
            alignment: [{ type: core.Input }]
        };
        return ScrollableContainerComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWScrollableContainerModule = (function () {
        function AWScrollableContainerModule() {
        }
        AWScrollableContainerModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ScrollableContainerComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            ScrollableContainerComponent
                        ],
                        exports: [
                            ScrollableContainerComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWScrollableContainerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ListComponent; }),
        multi: true
    };
    /**
     *
     * The List component represent a structure which contains a list of selectable items. Items
     * selection can be configured in single-selection, multi-selection or multi-selection with visible
     * checkboxes mode.
     * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
     * easy way for application developer to layout its own custom content or even change out of box
     * behavior.
     *
     *
     *  ### Examples
     *
     *  1. Render simple single selection list
     *
     *  ```html
     *
     *      <aw-list [list]="list"></aw-list>
     *
     *  ```
     *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
     *  is selected
     *
     *  ```html
     *
     *   <aw-list #awlist [list]="list"
     *                       height="150px"
     *                       width="250px"
     *                       [selectionMode]="'multi'">
     *
     *                  <ng-template #right let-item>
     *
     *                      <span class="sap-icon"
     *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
     *                            '': !awlist.pListBox.isSelected(item)}">
     *
     *                      </span>
     *                  </ng-template>
     *   </aw-list>
     *
     *  ```
     *
     * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
     *  the way item name is rendered
     *
     *
     *
     *  ```html
     *
     *   <aw-list [list]="list" height="180px"
     *                       width="200px"
     *                       [selection]="selection"
     *                       [selectionMode]="'multiWithCheckbox'">
     *
     *                  <ng-template #middle let-item>
     *                      XX-{{item.value}}
     *                  </ng-template>
     *    </aw-list>
     *
     *  ```
     *
     *
     *
     */
    var ListComponent = (function (_super) {
        __extends(ListComponent, _super);
        function ListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Component recognizes 3 modes: single, multi, multi with visible checkboxes
             */
            _this.selectionMode = 'single';
            /**
             * Don't render Listbox border. Used for embedding this inside other components
             *
             */
            _this.borderless = false;
            /**
             * Triggered when we double click on the list Item
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * Event fired when user select a item
             *
             */
            _this.onSelection = new core.EventEmitter();
            _this.listStyle = {};
            _this.isMultiple = false;
            _this.showCheckbox = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.isMultiple = this.selectionMode === 'multi' ||
                    this.selectionMode === 'multiWithCheckbox';
                this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
                // cannot have both either we use field to get display value or valueTransformer
                if (core$1.isPresent(this.field) && core$1.isPresent(this.valueTransformer)) {
                    throw new Error('You can have either [field] or [valueTransformer].');
                }
                if (core$1.isPresent(this.list)) {
                    this.initList();
                }
                else {
                    throw new Error('Missing [list] binding.');
                }
                // Also add overflowY to make sure it can scroll and does not expand based on its content
                if (core$1.isPresent(this.height)) {
                    this.listStyle['height'] = this.height;
                    this.listStyle['overflow-y'] = 'auto';
                }
                if (core$1.isPresent(this.width)) {
                    this.listStyle['width'] = this.width;
                }
                if (this.borderless) {
                    this.listStyle['border-color'] = 'transparent';
                }
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.selection);
                    if (core$1.isBlank(this.selection)) {
                        this.selection = this.formControl.value;
                    }
                }
            };
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         */
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
        ListComponent.prototype.itemClicked = /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
            function (event, item, checkbox) {
                this.pListBox.onOptionClick(event, item);
                event.stopPropagation();
                event.preventDefault();
            };
        /**
         * Internal
         *
         */
        /**
         * Internal
         *
         * @return {?}
         */
        ListComponent.prototype.hasRightTempl = /**
         * Internal
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.rZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasLeftTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.lZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasMiddleTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.mZoneTempl);
            };
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         */
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
        ListComponent.prototype.onItemSelected = /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event.value)) {
                    return;
                }
                this.onSelection.emit(event.value);
                if (this.isStandalone) {
                    this.formControl.setValue(event.value, { emitEvent: true });
                }
                this.onModelChanged(event.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        ListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(value);
                    }
                }
            };
        /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
        ListComponent.prototype.initList = /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.map(function (item) {
                        return { label: _this.displayValue(item), value: item };
                    });
                }
            };
        /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
        ListComponent.prototype.displayValue = /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return '';
                }
                /** @type {?} */
                var val = item.toString();
                if (core$1.isPresent(this.field)) {
                    val = item[this.field];
                }
                else if (core$1.isPresent(this.valueTransformer)) {
                    val = this.valueTransformer(item);
                }
                return val;
            };
        ListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-list',
                        template: "<p-listbox #listbox [options]=\"internalList\" [multiple]=\"isMultiple\" [checkbox]=\"showCheckbox\"\n           [(ngModel)]=\"selection\" [disabled]=\"disabled\" [style]=\"listStyle\" [showToggleAll]=\"false\"\n           (onChange)=\"onItemSelected($event)\" (onDblClick)=\"action.emit($event.value)\"\n           [styleClass]=\"styleClass\">\n\n\n    <ng-template let-item pTemplate=\"item\">\n        <div class=\"w-li-wrapper\">\n            <div class=\"w-li-left\">\n                <ng-template *ngIf=\"hasLeftTempl(); else defaultLeft\"\n                             [ngTemplateOutlet]=\"lZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n\n                <ng-template #defaultLeft>\n                    <span (click)=\"itemClicked($event, item, null)\">\n                        <aw-checkbox #check *ngIf=\"isMultiple && showCheckbox\"\n                                     [isStandalone]=\"false\"\n                                     [value]=\"listbox.isSelected(item)\"\n                                     type=\"action\">\n                    </aw-checkbox></span>\n                </ng-template>\n            </div>\n\n            <div class=\"w-li-middle\" (click)=\"itemClicked($event, item, null)\">\n\n                <ng-template *ngIf=\"hasMiddleTempl(); else defaultMiddle\"\n                             [ngTemplateOutlet]=\"mZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n                <ng-template #defaultMiddle>\n                    {{item.label}}\n                </ng-template>\n\n            </div>\n\n            <div class=\"w-li-right\" *ngIf=\"hasRightTempl()\">\n                <ng-template [ngTemplateOutlet]=\"rZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\">\n                </ng-template>\n\n            </div>\n        </div>\n    </ng-template>\n</p-listbox>\n",
                        providers: [
                            LB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ListComponent; }) }
                        ],
                        styles: ["::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}"]
                    }] }
        ];
        /** @nocollapse */
        ListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            field: [{ type: core.Input }],
            borderless: [{ type: core.Input }],
            action: [{ type: core.Output }],
            onSelection: [{ type: core.Output }],
            pListBox: [{ type: core.ViewChild, args: ['listbox',] }],
            lZoneTempl: [{ type: core.ContentChild, args: ['left',] }],
            mZoneTempl: [{ type: core.ContentChild, args: ['middle',] }],
            rZoneTempl: [{ type: core.ContentChild, args: ['right',] }]
        };
        return ListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWListModule = (function () {
        function AWListModule() {
        }
        AWListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            primeng.ListboxModule,
                            AWCheckBoxModule
                        ],
                        entryComponents: [
                            ListComponent
                        ],
                        exports: [
                            ListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] }
        ];
        return AWListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WizardProgressComponent = (function () {
        function WizardProgressComponent() {
            this.currentStep = 0;
            this.stepChanged = new core.EventEmitter();
            this.totalSteps = 0;
        }
        /**
         * @return {?}
         */
        WizardProgressComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.steps) {
                    /** @type {?} */
                    var currentIndex = this.steps.indexOf(this.steps.filter(function (step) { return step.current; })[0]);
                    this.totalSteps = this.steps.length;
                    this.setCurrentStep(~currentIndex ? currentIndex : 0);
                }
            };
        /**
         * @param {?=} index
         * @return {?}
         */
        WizardProgressComponent.prototype.setCurrentStep = /**
         * @param {?=} index
         * @return {?}
         */
            function (index) {
                if (index === void 0) {
                    index = 0;
                }
                this.steps[index].current = true;
                this.currentStep = index;
                this.stepChanged.emit({ current: this.currentStep });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        WizardProgressComponent.prototype.goToStep = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (!this.steps[index].complete) {
                    return;
                }
                /** @type {?} */
                var currentIndex = this.steps.indexOf(this.steps.filter(function (step) { return step.current; })[0]);
                this.steps[currentIndex].current = false;
                this.setCurrentStep(index);
            };
        WizardProgressComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-wizard-progress',
                        template: "<div class=\"step-indicator\">{{currentStep + 1}}/{{totalSteps}}</div>\n<div class=\"aw-step-progress\">\n    <div class=\"aw-step-progress__item\" *ngFor=\"let step of steps; let i = index;\"\n         [ngClass]=\"{ 'aw-step-progress__item--is-active': step.current === true }\"\n         (click)=\"goToStep(i);\">\n    </div>\n</div>\n",
                        styles: [":host{display:block}.step-indicator{width:100%;text-align:center;font-size:14px;font-weight:600;padding-bottom:.3rem}.aw-step-progress{display:flex;flex-direction:row;padding:.2rem;justify-content:center}.aw-step-progress__item{cursor:pointer;list-style:none;width:1.2rem;margin:0 .2rem;border-radius:.3rem;height:.4rem;background-color:#eaeaea}.aw-step-progress__item:last-child{margin-right:0}.aw-step-progress__item:first-child{margin-left:0}.aw-step-progress__item--is-active{background-color:#09a7af}"]
                    }] }
        ];
        /** @nocollapse */
        WizardProgressComponent.ctorParameters = function () { return []; };
        WizardProgressComponent.propDecorators = {
            steps: [{ type: core.Input }],
            currentStep: [{ type: core.Input }],
            stepChanged: [{ type: core.Output }]
        };
        return WizardProgressComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WizardProgressModule = (function () {
        function WizardProgressModule() {
        }
        WizardProgressModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            WizardProgressComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            WizardProgressComponent
                        ],
                        exports: [
                            WizardProgressComponent
                        ],
                        providers: []
                    },] }
        ];
        return WizardProgressModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Renders a Toggle Switch
     *
     * ### Example
     *
     * ```typescript
     *
     * \@Component({
     *          selector: 'myToggleSection' ,
     *          template: '<aw-toggle [model]="inputValue" [labelText]="labelText" >
     *              </aw-toggle>'
     *      })
     *      export class MyNoteComponent
     *      {
     *          inputValue: boolean = false;
     *          labelText: string = 'my label';
     *      }
     *
     * ```
     */
    var ToggleSwitchComponent = (function (_super) {
        __extends(ToggleSwitchComponent, _super);
        function ToggleSwitchComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * toggle model
             */
            _this.model = false;
            return _this;
        }
        /**
         * click handler for toggle
         */
        /**
         * click handler for toggle
         * @return {?}
         */
        ToggleSwitchComponent.prototype.changeHandler = /**
         * click handler for toggle
         * @return {?}
         */
            function () {
                this.model = !this.model;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-toggle',
                        template: "<div class=\"w-toggle\">\n    <label class=\"w-toggle__label\" *ngIf=\"labelText\">\n        {{ labelText }}\n    </label>\n    <div class=\"slider\" (click)=\"changeHandler()\">\n        <div class=\"slider__button\" [ngClass]=\"{ 'slider__button--is-active': model === true }\"></div>\n    </div>\n</div>\n",
                        styles: [":host{display:block}.w-toggle input{display:none}.w-toggle__label{color:#999;margin-right:.2rem}.w-toggle .slider{position:relative;height:.6rem;width:1.5rem;background-color:#d8d8d8;border-radius:.9rem;display:inline-block;border-top:1px solid #7e7e7e;border-left:1px solid #b5b5b5;border-right:1px solid #b5b5b5}.w-toggle .slider__button{left:-.1rem;transition:left .1s ease-out;cursor:pointer;position:absolute;height:1rem;width:1rem;border-radius:50%;background-color:#eaeaea;top:-.2rem}.w-toggle .slider__button--is-active{left:calc(100% - .8rem);background-color:#09a7af}"]
                    }] }
        ];
        /** @nocollapse */
        ToggleSwitchComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        ToggleSwitchComponent.propDecorators = {
            model: [{ type: core.Input }],
            labelText: [{ type: core.Input }]
        };
        return ToggleSwitchComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ToggleSwitchComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            ToggleSwitchComponent
                        ],
                        exports: [
                            ToggleSwitchComponent
                        ],
                        providers: []
                    },] }
        ];
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Overlay Component is a simple version of the dialog where there's only content.
     * Overlay will appear at the position where the action performed trigger an overlay.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
     *        because angular currently doesn't support dynamic content projection.
     *
     *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
     *
     *            // Add content. There's not support for dynamic content projection yet.
     *            // So have add content directly.
     *            // This is probably not the best way.
     *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
     *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
     *
     *          // delay the opening after ng lifecycle has been initialized.
     *          setTimeout(() => { overlay.instance.open(event); }, 1);
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
     *                                                     (onClose)="overlayAction='close'">
     *                                      <img src="sales.png" alt="Chart"/>
     *                                </aw-overlay>
     *
     *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
     *                                    Open Overlay
     *                                </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     overlayAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *
     */
    var OverlayComponent = (function (_super) {
        __extends(OverlayComponent, _super);
        function OverlayComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Enables hide overlay when outside is clicked.
             */
            _this.dismissable = true;
            /**
             * displays the close icon 'x' at top of right corner.
             */
            _this.showCloseIcon = false;
            /**
             * Event fired when overlay is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired just before overlay is closed
             */
            _this.beforeClose = new core.EventEmitter();
            /**
             * Event fired when the overlay is opened.
             */
            _this.onOpen = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        OverlayComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        OverlayComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // place holder to be overridden by Modal Service
            };
        /**
         * @return {?}
         */
        OverlayComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // place holder to be overridden by Modal Service
            };
        /**
         * Open Overlay
         * @param event
         */
        /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.open = /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                setTimeout(function () {
                    _this.overlay.show(event);
                    _this.onOpened(null);
                }, 1);
            };
        /**
         * Close Overlay
         */
        /**
         * Close Overlay
         * @return {?}
         */
        OverlayComponent.prototype.close = /**
         * Close Overlay
         * @return {?}
         */
            function () {
                this.beforeClose.emit(null);
                this.overlay.hide();
            };
        /**
         * toggle open and close.
         * @param event
         */
        /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.toggle = /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                setTimeout(function () {
                    _this.overlay.toggle(event);
                }, 0);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onOpened = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onOpen.emit(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onClosed = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onClose.emit(event);
            };
        OverlayComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-overlay',
                        template: "<p-overlayPanel [dismissable]=\"dismissable\" [showCloseIcon]=\"showCloseIcon\"\n                [styleClass]=\"styleClass\" [appendTo]=\"appendTo\"\n                (onHide)=\"onClosed($event)\">\n    <ng-content></ng-content>\n</p-overlayPanel>\n",
                        styles: ["::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}"]
                    }] }
        ];
        /** @nocollapse */
        OverlayComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        OverlayComponent.propDecorators = {
            dismissable: [{ type: core.Input }],
            showCloseIcon: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            beforeClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            overlay: [{ type: core.ViewChild, args: [primeng.OverlayPanel,] }]
        };
        return OverlayComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var HCCardPosition = {
        top: 0,
        bottom: 1,
        none: 2,
    };
    HCCardPosition[HCCardPosition.top] = 'top';
    HCCardPosition[HCCardPosition.bottom] = 'bottom';
    HCCardPosition[HCCardPosition.none] = 'none';
    /** @enum {number} */
    var HCCardAlignment = {
        left: 0,
        paddedLeft: 1,
        right: 2,
        paddedRight: 3,
        default: 4,
    };
    HCCardAlignment[HCCardAlignment.left] = 'left';
    HCCardAlignment[HCCardAlignment.paddedLeft] = 'paddedLeft';
    HCCardAlignment[HCCardAlignment.right] = 'right';
    HCCardAlignment[HCCardAlignment.paddedRight] = 'paddedRight';
    HCCardAlignment[HCCardAlignment.default] = 'default';
    /** *
     * Maps position to styles that are applied to the Card container. This is just to make it easier
     * as we are working with enumerations and have already enum type.
     *
     * u-hc-arrow-b: Arrow will appear at the bottom
     * u-hc-arrow-t: Arrow will appear at the top
     *
     * u-hc-shadow-t: Border shadow will appear at the top
     * u-hc-shadow-b: Border shadow will appear at the bottom
      @type {?} */
    var PositionToStyle = {
        top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
        bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
        none: ''
    };
    /** *
     *
     * Maps aligned Card container to custom styles in order to apply correct arrow
     *
     * -ll: Stands for Large Left (large: there is plenty of space around )
     * -lr: Stands for Large right
     * -sl: Stands for Small left (Small and resized screen where we try to fit card container
     * somewhere in between)
     * -sr: Stands for Large right
     *
      @type {?} */
    var AlignmentToStyle = {
        left: ' u-hc-arrow-ll',
        right: ' u-hc-arrow-lr',
        paddedLeft: ' u-hc-arrow-sl',
        paddedRight: ' u-hc-arrow-sr',
        default: ' u-hc-arrow-ll',
    };
    /**
     * The HoverCard components adds hover behavior to text, the specified content is loaded
     * on the left or right side of the element.
     *
     * Todo: extends so we can wrap any element and any element can be triggering this. Not only
     * linkTitle
     *
     *
     * ### Example:
     *
     * ```
     *
     *   <aw-hover-card [linkTitle]="'Frank kolar'">
     *       <h3>My Card Title</h3>
     *       <div>
     *
     *           This is my contents
     *
     *       </div>
     *
     *
     *    </aw-hover-card>
     * ```
     *
     * By default there is [forceClose]=true which forces the user to use X close icon
     *
     *
     *
     */
    var HoverCardComponent = (function (_super) {
        __extends(HoverCardComponent, _super);
        function HoverCardComponent(elem, env, cd) {
            var _this = _super.call(this, env) || this;
            _this.elem = elem;
            _this.env = env;
            _this.cd = cd;
            /**
             * Should we keep the hover card open and force user to manually close
             *
             */
            _this.forceClose = true;
            /**
             *
             * This current workaround until we find better solution. PrimeNG overlays operates within
             * its relative element so if the overlay is wrapped inside some other relative container
             * the overlay content is croped by its parent and content is not visible.
             *
             * They have [appendTo] binding which we need to use for this purpose
             *
             */
            _this.appendContentToBody = true;
            /**
             *
             * Internal style class to use to apply additional styles when it needs to show a Arrow on the
             * card
             *
             */
            _this.arrowClass = '';
            _this.opening = false;
            _this.currrentPosition = HCCardPosition.none;
            return _this;
        }
        /**
         * @return {?}
         */
        HoverCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                core$1.assert(core$1.isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
                // make sure there is open HC when we start new component
                this.env.deleteValue('hc-open');
                if (!this.appendContentToBody) {
                    this.appendTo = null;
                }
                this.overlayOnAnimationStart = this.awOverlay.overlay.onAnimationStart;
                this.awOverlay.overlay.onAnimationStart = function (event) {
                    _this.overlayOnAnimationStart.call(_this.awOverlay.overlay, event);
                    _this.cardOpened();
                    _this.onAnimationStart(event);
                };
                // this span is always available
                this.dynamicContent = this.elem.nativeElement.querySelector('.u-ngcontent');
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.onAnimationStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.opening) {
                    /** @type {?} */
                    var container = this.awOverlay.overlay.container;
                    /** @type {?} */
                    var cntRect = container.getBoundingClientRect();
                    if (this.currrentPosition !== HCCardPosition.none) {
                        this.adjustCard(container, cntRect, this.awOverlay.overlay);
                    }
                    else {
                        this.arrowClass = '';
                    }
                    this.opening = false;
                }
            };
        /**
         * @return {?}
         */
        HoverCardComponent.prototype.injectDynamicContent = /**
         * @return {?}
         */
            function () {
                if (this.awOverlay.overlay.visible) {
                    /** @type {?} */
                    var overlayCnt = this.elem.nativeElement
                        .querySelector('.ui-overlaypanel-content .u-ngcontent');
                    if (core$1.isBlank(overlayCnt) && this.dynamicContent.children.length > 0) {
                        overlayCnt = this.elem.nativeElement.querySelector('.ui-overlaypanel-content');
                        overlayCnt.prepend(this.dynamicContent);
                        this.dynamicContent.style = 'block';
                    }
                }
                else {
                    this.dynamicContent.style = 'none';
                }
            };
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         */
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
        HoverCardComponent.prototype.initElements = /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
                /** @type {?} */
                var triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
                this.titleAreaRect = titleElem.getBoundingClientRect();
                this.trigRect = triggerElem.getBoundingClientRect();
                this.trigIconMiddle = this.trigRect.width / 2;
            };
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         */
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.openCard = /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
                    this.awOverlay.open(event);
                    this.cd.detectChanges();
                    this.env.setValue('hc-open', true);
                }
            };
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         */
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?=} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardOpened = /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var container = this.awOverlay.overlay.container;
                /** @type {?} */
                var target = this.awOverlay.overlay.target;
                this.openForAdjustments(container);
                this.injectDynamicContent();
                // pre-run positioning so we can calculate new coordinates
                this.awOverlay.overlay.domHandler.absolutePosition(container, target);
                /** @type {?} */
                var cntRect = container.getBoundingClientRect();
                this.currrentPosition = this.positionForCard(container, cntRect);
                this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
                this.closeForAdjustments(container);
                this.opening = true;
            };
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         */
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardClosed = /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.env.deleteValue('hc-open');
            };
        /**
         *
          * Before overlay is closed we hide internal content other it does little shake..
         *
         *
         */
        /**
         *
         * Before overlay is closed we hide internal content other it does little shake..
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.beforeClose = /**
         *
         * Before overlay is closed we hide internal content other it does little shake..
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dynamicContent.style = 'none';
            };
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         */
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.adjustCard = /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                /** @type {?} */
                var diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
                /** @type {?} */
                var scrollTop = modalContainer.domHandler.getWindowScrollTop();
                /** @type {?} */
                var posWithScroll = containerRect.top + scrollTop;
                container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
                /** @type {?} */
                var alignment = this.alignmentForCard(containerRect, modalContainer);
                container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
            };
        /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.applyStyleClass = /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                if (this.currrentPosition !== HCCardPosition.none) {
                    /** @type {?} */
                    var alignment = this.alignmentForCard(containerRect, modalContainer);
                    this.arrowClass = ((PositionToStyle))[((HCCardPosition))[this.currrentPosition]];
                    this.arrowClass += ((AlignmentToStyle))[((HCCardAlignment))[alignment]];
                }
                else {
                    this.arrowClass = '';
                }
            };
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         */
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
        HoverCardComponent.prototype.positionForCard = /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
            function (container, boundingRect) {
                /** @type {?} */
                var borderWidth = getComputedStyle(container).borderWidth;
                /** @type {?} */
                var cntWidth = parseFloat(borderWidth || '0');
                /** @type {?} */
                var pos = HCCardPosition.none;
                if (this.trigRect.bottom < boundingRect.top) {
                    pos = HCCardPosition.bottom;
                }
                else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
                    pos = HCCardPosition.top;
                }
                return pos;
            };
        /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.alignmentForCard = /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (boundingRect, modalContainer) {
                /** @type {?} */
                var alignment = HCCardAlignment.left;
                /** @type {?} */
                var viewPort = modalContainer.domHandler.getViewport();
                if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
                    boundingRect.left > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.left;
                }
                else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedLeft;
                }
                else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedRight;
                }
                else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
                    (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.right;
                }
                else {
                    alignment = HCCardAlignment.default;
                }
                return alignment;
            };
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         */
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.openForAdjustments = /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'hidden';
                container.style.display = 'block';
                this.initElements();
            };
        /**
         *
         * Turn off display back NONE
         *
         */
        /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.closeForAdjustments = /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'visible';
                // container.style.display = 'none';
            };
        /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
        HoverCardComponent.prototype.calcLeftForAlignment = /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
            function (boundingRect, alignment) {
                /** @type {?} */
                var wLargeTriangle = boundingRect.width * 0.25;
                /** @type {?} */
                var wSmallTriangle = boundingRect.width * 0.10;
                switch (alignment) {
                    case HCCardAlignment.right:
                        /** @type {?} */
                        var shiftRight = boundingRect.left + wLargeTriangle;
                        /** @type {?} */
                        var trigRight = this.trigRect.right - this.trigIconMiddle;
                        return shiftRight - (boundingRect.right - trigRight);
                    case HCCardAlignment.paddedRight:
                        /** @type {?} */
                        var shiftRightS = boundingRect.left + wSmallTriangle;
                        /** @type {?} */
                        var trigRightS = this.trigRect.right - this.trigIconMiddle;
                        return shiftRightS - (boundingRect.right - trigRightS);
                    case HCCardAlignment.paddedLeft:
                        /** @type {?} */
                        var shiftLeftPad = boundingRect.left - wSmallTriangle;
                        return shiftLeftPad + this.trigIconMiddle;
                    case HCCardAlignment.left:
                    default:
                        /** @type {?} */
                        var shiftLeft = boundingRect.left - wLargeTriangle;
                        return shiftLeft + this.trigIconMiddle;
                }
            };
        /**
         * Default padding representing a height of the Arrow for which we need to vertically adjust
         * Card container
         *
         */
        HoverCardComponent.ArrowPad = 10;
        /**
         * Defines safe threshold where there might not be enough space around or Card is aligned with
         * the left or right edge of the viewport for which we need to position the Arrow closer to the
         * side of the card
         *
         */
        HoverCardComponent.SpacingLimit = 50;
        HoverCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hover-card',
                        template: "<span class=\"w-hc\">\n    <span class=\"w-hc-title\">\n        <aw-string [value]=\"linkTitle\"></aw-string>\n        <span class=\"sap-icon icon-slim-arrow-down\" (mouseover)=\"openCard($event)\"></span>\n    </span>\n\n    <div class=\"w-hc-body\">\n\n         <aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"\n                     [styleClass]=\"arrowClass\"\n                     [appendTo]=\"appendTo\"\n                     (beforeClose)=\"beforeClose($event)\"\n                     (onClose)=\"cardClosed($event)\">\n             <ng-content></ng-content>\n        </aw-overlay>\n\n\n        <!-- this is workaround to create a dynamic _ngcontent  reference so we can refer to later on with dynamic\n                projection. We cannot really use componentFactory.create[injector, projectedContent] as what we\n                want to add is another angular component that needs to be still rendered.\n\n                Starting PrimeNG 6.1+ they put in ngIf which complicates programmatic creation of this\n                component and injecting another dynamic content into ngContent is hard, so we need to little\n                hacky hackity hack.\n\n                We have this extra span with a class that we use to insert out dynamic content using nativeElement\n                and its DOM manipulation and once the overlay is shown and ng-content appears we move \"u-ngcontent\"\n                to new location.\n\n         -->\n        <span class=\"u-ngcontent\" [style.display]=\"'none'\">\n        </span>\n    </div>\n</span>\n\n\n",
                        styles: [".w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}"]
                    }] }
        ];
        /** @nocollapse */
        HoverCardComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef }
            ];
        };
        HoverCardComponent.propDecorators = {
            linkTitle: [{ type: core.Input }],
            forceClose: [{ type: core.Input }],
            appendContentToBody: [{ type: core.Input }],
            awOverlay: [{ type: core.ViewChild, args: ['overlay',] }]
        };
        return HoverCardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
     *
     * ###Usage
     *
     * ```
     *   <my-directive spyhooks><my-directive>
     *
     * ```
     */
    var SpyLifeCycleHooksDirective = (function () {
        function SpyLifeCycleHooksDirective(elementRef) {
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.logIt('onInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.logIt('onDestroy');
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.logIt('ngOnChanges = ' + changes);
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                this.logIt('ngDoCheck');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentChecked');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewChecked');
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.logIt = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                /** @type {?} */
                var level = 0;
                /** @type {?} */
                var me = this.elementRef.nativeElement;
                /** @type {?} */
                var tagBody = me;
                while ((tagBody = tagBody.parentNode) != null) {
                    level++;
                    if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                        break;
                    }
                }
                /** @type {?} */
                var indent = '';
                /** @type {?} */
                var indentNumber = level;
                while (level > 0) {
                    indent += '\t';
                    level--;
                }
                /** @type {?} */
                var params = '';
                if (core$1.isPresent(me.attributes)) {
                    for (var i = 0; i < me.attributes.length; i++) {
                        /** @type {?} */
                        var attr = me.attributes.item(i);
                        if (this.ignore(attr.name.toLowerCase())) {
                            continue;
                        }
                        params += '(' + attr.name + '=' + attr.value + '),  ';
                    }
                }
                core$1.print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ignore = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return name.indexOf('_ng') > -1 ||
                    name.indexOf('ng-') > -1 ||
                    name.indexOf('spyhooks') > -1;
            };
        SpyLifeCycleHooksDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[spyHooks]' },] }
        ];
        /** @nocollapse */
        SpyLifeCycleHooksDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        return SpyLifeCycleHooksDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    var components = /*#__PURE__*/Object.freeze({
        AWCoreComponentModule: AWCoreComponentModule,
        ErrorMessagesComponent: ErrorMessagesComponent,
        ModalContainer: ModalContainer,
        ModalService: ModalService,
        ModalComponent: ModalComponent,
        CurrencyFormatPipe: CurrencyFormatPipe,
        BaseComponent: BaseComponent,
        BaseFormComponent: BaseFormComponent,
        WidgetSizeColumns: WidgetSizeColumns,
        DomUtilsService: DomUtilsService,
        EmbeddedItemDirective: EmbeddedItemDirective,
        EmbededItem: EmbededItem,
        ErrorManagerService: ErrorManagerService,
        GenericContainerComponent: GenericContainerComponent,
        IncludeComponentDirective: IncludeComponentDirective,
        ComponentRegistry: ComponentRegistry,
        DataTypeProviderRegistry: DataTypeProviderRegistry,
        DataProviders: DataProviders,
        DataFinders: DataFinders,
        DataFinder: DataFinder,
        FullTextArrayDataFinder: FullTextArrayDataFinder,
        QueryType: QueryType,
        DATA_SOURCE: DATA_SOURCE,
        DataProvider: DataProvider,
        ArrayDataProvider: ArrayDataProvider,
        NgForSetDirective: NgForSetDirective,
        AwNameDirective: AwNameDirective,
        AwNameStore: AwNameStore,
        FormTableComponent: FormTableComponent,
        AWFormTableModule: AWFormTableModule,
        FormRowComponent: FormRowComponent,
        TopZoneComponent: TopZoneComponent,
        LeftZoneComponent: LeftZoneComponent,
        MiddleZoneComponent: MiddleZoneComponent,
        RightZoneComponent: RightZoneComponent,
        BottomZoneComponent: BottomZoneComponent,
        AWInputFieldModule: AWInputFieldModule,
        AWStringFieldModule: AWStringFieldModule,
        AWBasicNavigatorModule: AWBasicNavigatorModule,
        AWButtonModule: AWButtonModule,
        AWCardModule: AWCardModule,
        AWCheckBoxModule: AWCheckBoxModule,
        AWCheckBoxListModule: AWCheckBoxListModule,
        AWHyperlinkModule: AWHyperlinkModule,
        AWChooserModule: AWChooserModule,
        AWDropdownModule: AWDropdownModule,
        AWCurrencyModule: AWCurrencyModule,
        AWDateAndTimeModule: AWDateAndTimeModule,
        AWDialogModule: AWDialogModule,
        AWGenericChooserModule: AWGenericChooserModule,
        AWRadioButtonModule: AWRadioButtonModule,
        AWRadioButtonListModule: AWRadioButtonListModule,
        AWOutlineForModule: AWOutlineForModule,
        AWTextAreaModule: AWTextAreaModule,
        AWPageNotificationModule: AWPageNotificationModule,
        AWPageWrapperModule: AWPageWrapperModule,
        AWRichTextAreaModule: AWRichTextAreaModule,
        AWSectionModule: AWSectionModule,
        AWStepperModule: AWStepperModule,
        AWDatatable2Module: AWDatatable2Module,
        AWConfirmationModule: AWConfirmationModule,
        AWScrollableContainerModule: AWScrollableContainerModule,
        AWListModule: AWListModule,
        WizardProgressModule: WizardProgressModule,
        ToggleSwitchModule: ToggleSwitchModule,
        BasicNavigatorComponent: BasicNavigatorComponent,
        ButtonComponent: ButtonComponent,
        CheckBoxListComponent: CheckBoxListComponent,
        CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
        ChooserComponent: ChooserComponent,
        ChooserState: ChooserState,
        DefaultSelectionState: DefaultSelectionState,
        ChooserSelectionState: ChooserSelectionState,
        ChooserDataSource: ChooserDataSource,
        isDSChooserInitParams: isDSChooserInitParams,
        CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
        CurrencyComponent: CurrencyComponent,
        Money: Money,
        DateAndTimeComponent: DateAndTimeComponent,
        DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
        DialogComponent: DialogComponent,
        DialogHeaderComponent: DialogHeaderComponent,
        DialogFooterComponent: DialogFooterComponent,
        ConfirmationComponent: ConfirmationComponent,
        ConfirmationHeaderComponent: ConfirmationHeaderComponent,
        ConfirmationFooterComponent: ConfirmationFooterComponent,
        OverlayComponent: OverlayComponent,
        DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
        DropdownComponent: DropdownComponent,
        GCChooserState: GCChooserState,
        GenericChooserComponent: GenericChooserComponent,
        HyperlinkComponent: HyperlinkComponent,
        INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
        InputFieldComponent: InputFieldComponent,
        RadioButtonListComponent: RadioButtonListComponent,
        StringComponent: StringComponent,
        TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
        TextAreaComponent: TextAreaComponent,
        CardComponent: CardComponent,
        CardZoneTitleComponent: CardZoneTitleComponent,
        CardZoneTopComponent: CardZoneTopComponent,
        CardZoneBottomComponent: CardZoneBottomComponent,
        OutlineForComponent: OutlineForComponent,
        OutlineControlComponent: OutlineControlComponent,
        OutlineState: OutlineState,
        isOutlineNode: isOutlineNode,
        PageContentComponent: PageContentComponent,
        PageNotificationComponent: PageNotificationComponent,
        PageNotification: PageNotification,
        PageInitialized: PageInitialized,
        PageDestroyed: PageDestroyed,
        PageWrapper: PageWrapper,
        PageLifeCycleService: PageLifeCycleService,
        ObjectPageWrapperComponent: ObjectPageWrapperComponent,
        PageHeaderComponent: PageHeaderComponent,
        PageMenuItem: PageMenuItem,
        UserNotification: UserNotification,
        PageFooterComponent: PageFooterComponent,
        SidenavComponent: SidenavComponent,
        PageActionsComponent: PageActionsComponent,
        SectionComponent: SectionComponent,
        SubSectionComponent: SubSectionComponent,
        SectionActionsComponent: SectionActionsComponent,
        EditorType: EditorType,
        RichTextAreaComponent: RichTextAreaComponent,
        CheckboxComponent: CheckboxComponent,
        RadioButtonComponent: RadioButtonComponent,
        StepperComponent: StepperComponent,
        StepComponent: StepComponent,
        ScrollableContainerComponent: ScrollableContainerComponent,
        HoverCardComponent: HoverCardComponent,
        ListComponent: ListComponent,
        Datatable2Component: Datatable2Component,
        DTHeaderComponent2: DTHeaderComponent2,
        DTColumn2Component: DTColumn2Component,
        DTDetailRowComponent: DTDetailRowComponent,
        Datatable2State: Datatable2State,
        isDTInitParams: isDTInitParams,
        DT2DataSource: DT2DataSource,
        DetailRowExpansionState: DetailRowExpansionState,
        DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
        WizardProgressComponent: WizardProgressComponent,
        ToggleSwitchComponent: ToggleSwitchComponent,
        DomHandler: primeng.DomHandler,
        TreeDragDropService: primeng.TreeDragDropService,
        ConfirmationService: primeng.ConfirmationService,
        MessageService: primeng.MessageService,
        Header: primeng.Header,
        Footer: primeng.Footer,
        PrimeTemplate: primeng.PrimeTemplate,
        Column: primeng.Column,
        Row: primeng.Row,
        HeaderColumnGroup: primeng.HeaderColumnGroup,
        FooterColumnGroup: primeng.FooterColumnGroup,
        SharedModule: primeng.SharedModule,
        AccordionTab: primeng.AccordionTab,
        Accordion: primeng.Accordion,
        AccordionModule: primeng.AccordionModule,
        AUTOCOMPLETE_VALUE_ACCESSOR: primeng.AUTOCOMPLETE_VALUE_ACCESSOR,
        AutoComplete: primeng.AutoComplete,
        AutoCompleteModule: primeng.AutoCompleteModule,
        BlockUI: primeng.BlockUI,
        BlockUIModule: primeng.BlockUIModule,
        Breadcrumb: primeng.Breadcrumb,
        BreadcrumbModule: primeng.BreadcrumbModule,
        ButtonDirective: primeng.ButtonDirective,
        Button: primeng.Button,
        ButtonModule: primeng.ButtonModule,
        Captcha: primeng.Captcha,
        CaptchaModule: primeng.CaptchaModule,
        CALENDAR_VALUE_ACCESSOR: primeng.CALENDAR_VALUE_ACCESSOR,
        Calendar: primeng.Calendar,
        CalendarModule: primeng.CalendarModule,
        Card: primeng.Card,
        CardModule: primeng.CardModule,
        Carousel: primeng.Carousel,
        CarouselModule: primeng.CarouselModule,
        UIChart: primeng.UIChart,
        ChartModule: primeng.ChartModule,
        CHECKBOX_VALUE_ACCESSOR: primeng.CHECKBOX_VALUE_ACCESSOR,
        Checkbox: primeng.Checkbox,
        CheckboxModule: primeng.CheckboxModule,
        CHIPS_VALUE_ACCESSOR: primeng.CHIPS_VALUE_ACCESSOR,
        Chips: primeng.Chips,
        ChipsModule: primeng.ChipsModule,
        CodeHighlighter: primeng.CodeHighlighter,
        CodeHighlighterModule: primeng.CodeHighlighterModule,
        COLORPICKER_VALUE_ACCESSOR: primeng.COLORPICKER_VALUE_ACCESSOR,
        ColorPicker: primeng.ColorPicker,
        ColorPickerModule: primeng.ColorPickerModule,
        ConfirmDialog: primeng.ConfirmDialog,
        ConfirmDialogModule: primeng.ConfirmDialogModule,
        ContextMenuSub: primeng.ContextMenuSub,
        ContextMenu: primeng.ContextMenu,
        ContextMenuModule: primeng.ContextMenuModule,
        DataGrid: primeng.DataGrid,
        DataGridModule: primeng.DataGridModule,
        DataList: primeng.DataList,
        DataListModule: primeng.DataListModule,
        DataScroller: primeng.DataScroller,
        DataScrollerModule: primeng.DataScrollerModule,
        DTRadioButton: primeng.DTRadioButton,
        DTCheckbox: primeng.DTCheckbox,
        ColumnHeaders: primeng.ColumnHeaders,
        ColumnFooters: primeng.ColumnFooters,
        TableBody: primeng.TableBody,
        ScrollableView: primeng.ScrollableView,
        DataTable: primeng.DataTable,
        DataTableModule: primeng.DataTableModule,
        DeferredLoader: primeng.DeferredLoader,
        DeferModule: primeng.DeferModule,
        Dialog: primeng.Dialog,
        DialogModule: primeng.DialogModule,
        Draggable: primeng.Draggable,
        Droppable: primeng.Droppable,
        DragDropModule: primeng.DragDropModule,
        DROPDOWN_VALUE_ACCESSOR: primeng.DROPDOWN_VALUE_ACCESSOR,
        Dropdown: primeng.Dropdown,
        DropdownModule: primeng.DropdownModule,
        EDITOR_VALUE_ACCESSOR: primeng.EDITOR_VALUE_ACCESSOR,
        Editor: primeng.Editor,
        EditorModule: primeng.EditorModule,
        Fieldset: primeng.Fieldset,
        FieldsetModule: primeng.FieldsetModule,
        FileUpload: primeng.FileUpload,
        FileUploadModule: primeng.FileUploadModule,
        Galleria: primeng.Galleria,
        GalleriaModule: primeng.GalleriaModule,
        GMap: primeng.GMap,
        GMapModule: primeng.GMapModule,
        Growl: primeng.Growl,
        GrowlModule: primeng.GrowlModule,
        InplaceDisplay: primeng.InplaceDisplay,
        InplaceContent: primeng.InplaceContent,
        Inplace: primeng.Inplace,
        InplaceModule: primeng.InplaceModule,
        INPUTMASK_VALUE_ACCESSOR: primeng.INPUTMASK_VALUE_ACCESSOR,
        InputMask: primeng.InputMask,
        InputMaskModule: primeng.InputMaskModule,
        INPUTSWITCH_VALUE_ACCESSOR: primeng.INPUTSWITCH_VALUE_ACCESSOR,
        InputSwitch: primeng.InputSwitch,
        InputSwitchModule: primeng.InputSwitchModule,
        InputText: primeng.InputText,
        InputTextModule: primeng.InputTextModule,
        InputTextarea: primeng.InputTextarea,
        InputTextareaModule: primeng.InputTextareaModule,
        KEYFILTER_VALIDATOR: primeng.KEYFILTER_VALIDATOR,
        KeyFilter: primeng.KeyFilter,
        KeyFilterModule: primeng.KeyFilterModule,
        Lightbox: primeng.Lightbox,
        LightboxModule: primeng.LightboxModule,
        LISTBOX_VALUE_ACCESSOR: primeng.LISTBOX_VALUE_ACCESSOR,
        Listbox: primeng.Listbox,
        ListboxModule: primeng.ListboxModule,
        MegaMenu: primeng.MegaMenu,
        MegaMenuModule: primeng.MegaMenuModule,
        MenuItemContent: primeng.MenuItemContent,
        Menu: primeng.Menu,
        MenuModule: primeng.MenuModule,
        MenubarSub: primeng.MenubarSub,
        Menubar: primeng.Menubar,
        MenubarModule: primeng.MenubarModule,
        Messages: primeng.Messages,
        MessagesModule: primeng.MessagesModule,
        UIMessage: primeng.UIMessage,
        MessageModule: primeng.MessageModule,
        MULTISELECT_VALUE_ACCESSOR: primeng.MULTISELECT_VALUE_ACCESSOR,
        MultiSelect: primeng.MultiSelect,
        MultiSelectModule: primeng.MultiSelectModule,
        OrderList: primeng.OrderList,
        OrderListModule: primeng.OrderListModule,
        OrganizationChartNode: primeng.OrganizationChartNode,
        OrganizationChart: primeng.OrganizationChart,
        OrganizationChartModule: primeng.OrganizationChartModule,
        OverlayPanel: primeng.OverlayPanel,
        OverlayPanelModule: primeng.OverlayPanelModule,
        Paginator: primeng.Paginator,
        PaginatorModule: primeng.PaginatorModule,
        Panel: primeng.Panel,
        PanelModule: primeng.PanelModule,
        BasePanelMenuItem: primeng.BasePanelMenuItem,
        PanelMenuSub: primeng.PanelMenuSub,
        PanelMenu: primeng.PanelMenu,
        PanelMenuModule: primeng.PanelMenuModule,
        Password: primeng.Password,
        PasswordModule: primeng.PasswordModule,
        PickList: primeng.PickList,
        PickListModule: primeng.PickListModule,
        ProgressBar: primeng.ProgressBar,
        ProgressBarModule: primeng.ProgressBarModule,
        ProgressSpinner: primeng.ProgressSpinner,
        ProgressSpinnerModule: primeng.ProgressSpinnerModule,
        RADIO_VALUE_ACCESSOR: primeng.RADIO_VALUE_ACCESSOR,
        RadioButton: primeng.RadioButton,
        RadioButtonModule: primeng.RadioButtonModule,
        RATING_VALUE_ACCESSOR: primeng.RATING_VALUE_ACCESSOR,
        Rating: primeng.Rating,
        RatingModule: primeng.RatingModule,
        Schedule: primeng.Schedule,
        ScheduleModule: primeng.ScheduleModule,
        ScrollPanel: primeng.ScrollPanel,
        ScrollPanelModule: primeng.ScrollPanelModule,
        SELECTBUTTON_VALUE_ACCESSOR: primeng.SELECTBUTTON_VALUE_ACCESSOR,
        SelectButton: primeng.SelectButton,
        SelectButtonModule: primeng.SelectButtonModule,
        SlideMenuSub: primeng.SlideMenuSub,
        SlideMenu: primeng.SlideMenu,
        SlideMenuModule: primeng.SlideMenuModule,
        SLIDER_VALUE_ACCESSOR: primeng.SLIDER_VALUE_ACCESSOR,
        Slider: primeng.Slider,
        SliderModule: primeng.SliderModule,
        Sidebar: primeng.Sidebar,
        SidebarModule: primeng.SidebarModule,
        SPINNER_VALUE_ACCESSOR: primeng.SPINNER_VALUE_ACCESSOR,
        Spinner: primeng.Spinner,
        SpinnerModule: primeng.SpinnerModule,
        SplitButton: primeng.SplitButton,
        SplitButtonModule: primeng.SplitButtonModule,
        Steps: primeng.Steps,
        StepsModule: primeng.StepsModule,
        TabViewNav: primeng.TabViewNav,
        TabPanel: primeng.TabPanel,
        TabView: primeng.TabView,
        TabViewModule: primeng.TabViewModule,
        TabMenu: primeng.TabMenu,
        TabMenuModule: primeng.TabMenuModule,
        Terminal: primeng.Terminal,
        TerminalModule: primeng.TerminalModule,
        TieredMenuSub: primeng.TieredMenuSub,
        TieredMenu: primeng.TieredMenu,
        TieredMenuModule: primeng.TieredMenuModule,
        TOGGLEBUTTON_VALUE_ACCESSOR: primeng.TOGGLEBUTTON_VALUE_ACCESSOR,
        ToggleButton: primeng.ToggleButton,
        ToggleButtonModule: primeng.ToggleButtonModule,
        Toolbar: primeng.Toolbar,
        ToolbarModule: primeng.ToolbarModule,
        Tooltip: primeng.Tooltip,
        TooltipModule: primeng.TooltipModule,
        UITreeNode: primeng.UITreeNode,
        Tree: primeng.Tree,
        TreeModule: primeng.TreeModule,
        TreeTableService: primeng.TreeTableService,
        TreeTable: primeng.TreeTable,
        TTBody: primeng.TTBody,
        TTScrollableView: primeng.TTScrollableView,
        TTSortableColumn: primeng.TTSortableColumn,
        TTSortIcon: primeng.TTSortIcon,
        TTResizableColumn: primeng.TTResizableColumn,
        TTReorderableColumn: primeng.TTReorderableColumn,
        TTSelectableRow: primeng.TTSelectableRow,
        TTSelectableRowDblClick: primeng.TTSelectableRowDblClick,
        TTContextMenuRow: primeng.TTContextMenuRow,
        TTCheckbox: primeng.TTCheckbox,
        TTHeaderCheckbox: primeng.TTHeaderCheckbox,
        TTEditableColumn: primeng.TTEditableColumn,
        TreeTableCellEditor: primeng.TreeTableCellEditor,
        TreeTableToggler: primeng.TreeTableToggler,
        TreeTableModule: primeng.TreeTableModule,
        TRISTATECHECKBOX_VALUE_ACCESSOR: primeng.TRISTATECHECKBOX_VALUE_ACCESSOR,
        TriStateCheckbox: primeng.TriStateCheckbox,
        TriStateCheckboxModule: primeng.TriStateCheckboxModule
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWOverlayModule = (function () {
        function AWOverlayModule() {
        }
        AWOverlayModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OverlayComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            primeng.OverlayPanelModule
                        ],
                        entryComponents: [
                            OverlayComponent
                        ],
                        exports: [
                            OverlayComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] }
        ];
        return AWOverlayModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AWHoverCardModule = (function () {
        function AWHoverCardModule() {
        }
        AWHoverCardModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HoverCardComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWOverlayModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            HoverCardComponent
                        ],
                        exports: [
                            HoverCardComponent
                        ],
                        providers: []
                    },] }
        ];
        return AWHoverCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Component module is core module for the common layouts and widgets libraries.
     *
     * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
     * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
     * not much option with angular.
     *
     */
    var AribaComponentsModule = (function () {
        function AribaComponentsModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            core$1.AribaCoreModule,
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            WizardProgressModule,
                            ToggleSwitchModule,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.SharedModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.AccordionModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule,
                            primeng.TreeModule
                        ],
                        declarations: [
                            SpyLifeCycleHooksDirective,
                        ],
                        bootstrap: [],
                        entryComponents: [
                            primeng.Checkbox,
                            primeng.Dialog
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            SpyLifeCycleHooksDirective,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            EmbeddedItemDirective,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            WizardProgressModule,
                            ToggleSwitchModule,
                            primeng.SharedModule,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule
                        ]
                    },] }
        ];
        return AribaComponentsModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * This module is used mainly for tests as importing a module with all the components and you
     * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
     * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
     *
     * I havent noticed anything similar in application its only jasmine/karma that needs to init
     * components for every test.
     *
     */
    var AribaComponentsTestProviderModule = (function () {
        function AribaComponentsTestProviderModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsTestProviderModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsTestProviderModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents$1,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsTestProviderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: []
                    },] }
        ];
        return AribaComponentsTestProviderModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents$1(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.ErrorMessagesComponent = ErrorMessagesComponent;
    exports.ModalContainer = ModalContainer;
    exports.ModalService = ModalService;
    exports.ModalComponent = ModalComponent;
    exports.CurrencyFormatPipe = CurrencyFormatPipe;
    exports.BaseComponent = BaseComponent;
    exports.WidgetSizeColumns = WidgetSizeColumns;
    exports.DomUtilsService = DomUtilsService;
    exports.EmbeddedItemDirective = EmbeddedItemDirective;
    exports.EmbededItem = EmbededItem;
    exports.ErrorManagerService = ErrorManagerService;
    exports.GenericContainerComponent = GenericContainerComponent;
    exports.IncludeComponentDirective = IncludeComponentDirective;
    exports.ComponentRegistry = ComponentRegistry;
    exports.AWCoreComponentModule = AWCoreComponentModule;
    exports.BaseFormComponent = BaseFormComponent;
    exports.DataTypeProviderRegistry = DataTypeProviderRegistry;
    exports.DataProvider = DataProvider;
    exports.DataProviders = DataProviders;
    exports.DataFinders = DataFinders;
    exports.DataFinder = DataFinder;
    exports.QueryType = QueryType;
    exports.FullTextArrayDataFinder = FullTextArrayDataFinder;
    exports.DATA_SOURCE = DATA_SOURCE;
    exports.ArrayDataProvider = ArrayDataProvider;
    exports.NgForSetDirective = NgForSetDirective;
    exports.AwNameDirective = AwNameDirective;
    exports.AwNameStore = AwNameStore;
    exports.FormTableComponent = FormTableComponent;
    exports.FormRowComponent = FormRowComponent;
    exports.TopZoneComponent = TopZoneComponent;
    exports.LeftZoneComponent = LeftZoneComponent;
    exports.MiddleZoneComponent = MiddleZoneComponent;
    exports.RightZoneComponent = RightZoneComponent;
    exports.BottomZoneComponent = BottomZoneComponent;
    exports.AWFormTableModule = AWFormTableModule;
    exports.BasicNavigatorComponent = BasicNavigatorComponent;
    exports.ButtonComponent = ButtonComponent;
    exports.CheckBoxListComponent = CheckBoxListComponent;
    exports.CHOOSER_CONTROL_VALUE_ACCESSOR = CHOOSER_CONTROL_VALUE_ACCESSOR;
    exports.ChooserComponent = ChooserComponent;
    exports.ChooserState = ChooserState;
    exports.DefaultSelectionState = DefaultSelectionState;
    exports.ChooserSelectionState = ChooserSelectionState;
    exports.CURRENCY_CONTROL_VALUE_ACCESSOR = CURRENCY_CONTROL_VALUE_ACCESSOR;
    exports.CurrencyComponent = CurrencyComponent;
    exports.Money = Money;
    exports.DateAndTimeComponent = DateAndTimeComponent;
    exports.DATETIME_CONTROL_VALUE_ACCESSOR = DATETIME_CONTROL_VALUE_ACCESSOR;
    exports.DialogComponent = DialogComponent;
    exports.DialogHeaderComponent = DialogHeaderComponent;
    exports.DialogFooterComponent = DialogFooterComponent;
    exports.ConfirmationComponent = ConfirmationComponent;
    exports.ConfirmationHeaderComponent = ConfirmationHeaderComponent;
    exports.ConfirmationFooterComponent = ConfirmationFooterComponent;
    exports.OverlayComponent = OverlayComponent;
    exports.DropdownComponent = DropdownComponent;
    exports.GCChooserState = GCChooserState;
    exports.GenericChooserComponent = GenericChooserComponent;
    exports.HyperlinkComponent = HyperlinkComponent;
    exports.INPUT_CONTROL_VALUE_ACCESSOR = INPUT_CONTROL_VALUE_ACCESSOR;
    exports.InputFieldComponent = InputFieldComponent;
    exports.RadioButtonListComponent = RadioButtonListComponent;
    exports.StringComponent = StringComponent;
    exports.TEXTAREA_CONTROL_VALUE_ACCESSOR = TEXTAREA_CONTROL_VALUE_ACCESSOR;
    exports.TextAreaComponent = TextAreaComponent;
    exports.OutlineForComponent = OutlineForComponent;
    exports.OutlineControlComponent = OutlineControlComponent;
    exports.PageActionsComponent = PageActionsComponent;
    exports.PageContentComponent = PageContentComponent;
    exports.PageFooterComponent = PageFooterComponent;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageMenuItem = PageMenuItem;
    exports.UserNotification = UserNotification;
    exports.PageNotificationComponent = PageNotificationComponent;
    exports.PageNotification = PageNotification;
    exports.PageInitialized = PageInitialized;
    exports.PageDestroyed = PageDestroyed;
    exports.PageWrapper = PageWrapper;
    exports.PageLifeCycleService = PageLifeCycleService;
    exports.ObjectPageWrapperComponent = ObjectPageWrapperComponent;
    exports.SectionComponent = SectionComponent;
    exports.SubSectionComponent = SubSectionComponent;
    exports.RichTextAreaComponent = RichTextAreaComponent;
    exports.EditorType = EditorType;
    exports.CheckboxComponent = CheckboxComponent;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.StepperComponent = StepperComponent;
    exports.StepComponent = StepComponent;
    exports.AWInputFieldModule = AWInputFieldModule;
    exports.AWStringFieldModule = AWStringFieldModule;
    exports.AWBasicNavigatorModule = AWBasicNavigatorModule;
    exports.AWButtonModule = AWButtonModule;
    exports.AWHyperlinkModule = AWHyperlinkModule;
    exports.AWCardModule = AWCardModule;
    exports.AWCheckBoxModule = AWCheckBoxModule;
    exports.AWCheckBoxListModule = AWCheckBoxListModule;
    exports.AWChooserModule = AWChooserModule;
    exports.AWDropdownModule = AWDropdownModule;
    exports.AWCurrencyModule = AWCurrencyModule;
    exports.AWDateAndTimeModule = AWDateAndTimeModule;
    exports.AWDialogModule = AWDialogModule;
    exports.AWGenericChooserModule = AWGenericChooserModule;
    exports.AWRadioButtonModule = AWRadioButtonModule;
    exports.AWRadioButtonListModule = AWRadioButtonListModule;
    exports.AWTextAreaModule = AWTextAreaModule;
    exports.AWPageNotificationModule = AWPageNotificationModule;
    exports.AWPageWrapperModule = AWPageWrapperModule;
    exports.AWRichTextAreaModule = AWRichTextAreaModule;
    exports.AWSectionModule = AWSectionModule;
    exports.AWStepperModule = AWStepperModule;
    exports.ScrollableContainerComponent = ScrollableContainerComponent;
    exports.AWScrollableContainerModule = AWScrollableContainerModule;
    exports.AWConfirmationModule = AWConfirmationModule;
    exports.ChooserDataSource = ChooserDataSource;
    exports.isDSChooserInitParams = isDSChooserInitParams;
    exports.HoverCardComponent = HoverCardComponent;
    exports.ListComponent = ListComponent;
    exports.AWListModule = AWListModule;
    exports.CardComponent = CardComponent;
    exports.OutlineState = OutlineState;
    exports.Datatable2Component = Datatable2Component;
    exports.DTColumn2Component = DTColumn2Component;
    exports.DTHeaderComponent2 = DTHeaderComponent2;
    exports.DTDetailRowComponent = DTDetailRowComponent;
    exports.DetailRowExpansionState = DetailRowExpansionState;
    exports.Datatable2State = Datatable2State;
    exports.isDTInitParams = isDTInitParams;
    exports.DT2DataSource = DT2DataSource;
    exports.DTMultiSelectColumnComponent = DTMultiSelectColumnComponent;
    exports.AWDatatable2Module = AWDatatable2Module;
    exports.WizardProgressComponent = WizardProgressComponent;
    exports.isOutlineNode = isOutlineNode;
    exports.AWOutlineForModule = AWOutlineForModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.WizardProgressModule = WizardProgressModule;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.AribaComponentsModule = AribaComponentsModule;
    exports.AribaComponentsTestProviderModule = AribaComponentsTestProviderModule;
    exports.SpyLifeCycleHooksDirective = SpyLifeCycleHooksDirective;
    exports.p = registerComponents;
    exports.q = registerComponents$1;
    exports.a = DataSource;
    exports.r = InfiniteScrollComponent;
    exports.h = CardZoneTitleComponent;
    exports.g = CardZoneBottomComponent;
    exports.f = CardZoneTopComponent;
    exports.b = AWCardModule;
    exports.c = CB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.m = CB_CONTROL_VALUE_ACCESSOR;
    exports.u = DTDetailRowExpanderComponent;
    exports.v = DTSingleSelectColumnComponent;
    exports.x = SetCellMaxWidthDirective;
    exports.w = DTDraggableRowDirective;
    exports.t = DTWrapper;
    exports.d = DD_CONTROL_VALUE_ACCESSOR;
    exports.z = AWHoverCardModule;
    exports.o = LB_CONTROL_VALUE_ACCESSOR;
    exports.i = InitNestingDirective;
    exports.y = AWOverlayModule;
    exports.j = SidenavComponent;
    exports.e = RB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.n = RAB_CONTROL_VALUE_ACCESSOR;
    exports.l = EDITOR_CONTROL_VALUE_ACCESSOR;
    exports.k = SectionActionsComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2VtYmVkZGVkLWl0ZW0udHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9nZW5lcmljLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9iYXNlLWZvcm0uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RyaW5nL3N0cmluZy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2luY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Vycm9yLW1lc3NhZ2VzL2Vycm9yLW1lc3NhZ2VzLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvcGlwZXMvY3VycmVuY3ktZm9ybWF0LnBpcGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9vbi1uZ2Zvci1zZXQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYXctbmFtZS9hdy1uYW1lLnN0b3JlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYXctbmFtZS9hdy1uYW1lLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2NvcmUubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9kYXRhL2FycmF5LWRhdGEtcHJvdmlkZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9kYXRhL2RhdGEtc291cmNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZml2ZS16b25lLWxheW91dC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS10YWJsZS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RyaW5nL3N0cmluZy5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9iYXNpYy1uYXZpZ2F0b3IvYmFzaWMtbmF2aWdhdG9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYnV0dG9uL2J1dHRvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9iYXNpYy1uYXZpZ2F0b3IvYmFzaWMtbmF2aWdhdG9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NhcmQvY2FyZC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQtdGl0bGUvY2FyZC10aXRsZS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXItc2VsZWN0aW9uLXN0YXRlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXN0YXRlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLWRhdGEtc291cmNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jdXJyZW5jeS9jdXJyZW5jeS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jdXJyZW5jeS9jdXJyZW5jeS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRlLWFuZC10aW1lL2RhdGUtYW5kLXRpbWUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRhLWFuZC10aW1lLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGlhbG9nL2RpYWxvZy5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9nZW5lcmljLWNob29zZXIvZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi1saXN0L3JhZGlvLWJ1dHRvbi1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9nZW5lcmljLWNob29zZXIvZ2VuZXJpYy1jaG9vc2VyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1mb3IuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3V0bGluZS9vdXRsaW5lLWNvbnRyb2wvb3V0bGluZS1jb250cm9sLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1mb3IubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy90ZXh0LWFyZWEvdGV4dC1hcmVhLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWV2ZW50cy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2Utd3JhcHBlci50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwL3N0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9zaWRlbmF2L3NpZGVuYXYuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2Utd3JhcHBlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yaWNoLXRleHQtYXJlYS9yaWNoLXRleHQtYXJlYS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yaWNoLXRleHQtYXJlYS9yaWNoLXRleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zZWN0aW9uL3NlY3Rpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3ctZXhwYW5kZXIvZHQtZGV0YWlsLXJvdy1leHBhbmRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2F3LWRhdGF0YWJsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL211bHRpLXNlbGVjdC9kdC1tdWx0aS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvdGFibGUtd3JhcHBlci90YWJsZS13cmFwcGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGlyZWN0aXZlcy9kdC1jZWxsLWRpcmVjdGl2ZXMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtZHJhZ2dhYmxlLXJvdy5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jb25maXJtYXRpb24vY29uZmlybWF0aW9uLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3Njcm9sbGFibGUtY29udGFpbmVyL3Njcm9sbGFibGUtY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3Njcm9sbGFibGUtY29udGFpbmVyL3Njcm9sbGFibGUtY29udGFpbmVyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2xpc3QvbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy93aXphcmQtcHJvZ3Jlc3Mvd2l6YXJkLXByb2dyZXNzLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RvZ2dsZS1zd2l0Y2gvdG9nZ2xlLXN3aXRjaC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2gubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvc3B5LWxpZmVjeWNsZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdmVybGF5L292ZXJsYXkubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaG92ZXItY2FyZC9ob3Zlci1jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2FyaWJhLmNvbXBvbmVudC5wcm92aWRlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbWJlZGRlZFZpZXdSZWYsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFdoZW4gd2UgaGF2ZSBhIGN1c3RvbSBjb21wb25lbnQgbGlrZSBkcm9wZG93biwgcmFkaW9idXR0b25saXN0IGFuZFxuICogbWFueSBtb3JlIHdlIHdhbnQgdG8gcHJvdmlkZSBhIGN1c3RvbSBjb250ZW50IHRvIGl0IGxpa2Ugc286XG4gKlxuICogYGBgXG4gKiAgPGF3LWRyb3Bkb3duIFtsaXN0XT1cImxpc3RPZlVzZXJzXCIgbGV0IHNvbWVob3dHZXRJdGVtT3V0PlxuICogICAgICB7e2l0ZW0udXNlck5hbWV9fVxuICpcbiAqICAgPGF3LWRyb3Bkb3duXG4gKlxuICogYGBgXG4gKiBXaG8gZWxzZSB3b3VsZCBrbm93IGhvdyB0byByZW5kZXIgbGlzdCBvZiBvYmplY3RzLi5cbiAqXG4gKiBCdXQgaXRzIG5vdCBwb3NzaWJsZSBpbiBjdXJyZW50IGZvcm0uIGlmIEkgZG8gbm90IHByb3ZpZGUgQW5ndWxhciBzb21lIGFzIHRoZXkgY2FsbCBpdCB0aGlzXG4gKiBzeW50YWN0aWMgc3VnYXIgKixcbiAqXG4gKlxuICogYGBgXG4gKiAgPGF3LWRyb3Bkb3duICpteVN1Z2VyRGlyZWN0aXZlPS4uLi4uPlxuICogICAgICB7e2l0ZW0udXNlck5hbWV9fVxuICpcbiAqICAgPGF3LWRyb3Bkb3duXG4gKiBgYGBcbiAqXG4gKlxuICogdGhlbiBhbmd1bGFyIHdpbGwgbm90IGtub3cgIGluc2lkZSBpcyBhIHRlbXBsYXRlIGFuZCBJIHdvbnQgYmUgYWJsZSB0byBnZXQgaG9sZCBvZiBUZW1wbGF0ZVJlZlxuICogaW5zaWRlIHRoZSBjb21wb25lbnRcbiAqXG4gKiBTbyB0aGUgb25seSB3YXkgSSBmb3VuZCAoZXhwZWN0aW5nIEkgZG8gbm90IHdhbnQgdG8gY2hhbmdlIGFueXRoaW5nIGluIHRlcm1zIG9mIGJpbmRpbmdzIGFuZCB0aGVcbiAqIHNpZ25hdHVyZSBJIHVzZSBpdC4gSSBoYXZlIHRvIHVzZSBpdCBsaWtlIHRoaXM6XG4gKlxuICogYGBgXG4gKiAgPGF3LWRyb3Bkb3duIFtsaXN0XT1cImxpc3RPZlVzZXJzXCIgbGV0IHNvbWVob3dHZXRJdGVtT3V0PlxuICogICAgICA8bmctdGVtcGxhdGUgbGV0LWl0ZW0+IHt7aXRlbS51c2VyTmFtZX19PC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICpcbiAqICBUaGlzIHdheSBpdCBjb3VsZCB3b3JrLiBTaW5jZSBJIGFtIGluc2lkZSBuZ0ZvciBJIHdhbnQgdG8gcmVuZGVyIHRoZSBpdGVtIGludG8gdGhlIGNvcnJlY3RcbiAqIHZpZXdDb250YWluZXIgb2YgbmdGb3IncyBjdXJyZW50IGl0ZW0uXG4gKlxuICogIFRoaXMgd2F5IEkgY2FuIGFsc28gZXhwb3NlIGl0ZW0gb3V0c2lkZSB1c2luZyBBbmd1bGFyJ3Mgc3BlY2lhbCBsb2NhbCB2YXJpYWJsZSBjYWxsZWQ6XG4gKiAkaW1wbGljaXQuXG4gKlxuICogVGhpcyBnZXRzIGV2ZW4gbW9yZSBjb21wbGV4IGlmIHdlIHRyeSB0byBwYXNzIHRoaXMgdGVtcGxhdGUgMiBsZXZlbHMgZG93biwgbGlrZSBpbiBjYXNlIG9mXG4gKiBSYWRpb0J1dHRvbkxpc3QuIEJ1dCBsYXRlciBvbiBJIG1pZ2h0IHdhbnQgdG8gcmVmYWN0b3IgdGhpcyBpbnRvIGN1c3RvbSBORyBGT1JcbiAqXG4gKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBuZ1RlbXBsYXRlT3V0bGV0ICh3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgdmVyc2lvbilcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW2VtYmVkZGVkSXRlbV0nfSlcbmV4cG9ydCBjbGFzcyBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXNcbntcbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSB3ZSB3YW50IHRvIHJlbmRlciBOLVRpbWVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlbWJlZGRlZEl0ZW06IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBpdGVtKGl0ZW06IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VmFsdWUgPSBpdGVtO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ltcGxpY2l0VmFsdWU6IGFueTtcbiAgICBwcml2YXRlIF92aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZilcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl92aWV3UmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5yZW1vdmUodGhpcy5fdmlld0NvbnRhaW5lci5pbmRleE9mKHRoaXMuX3ZpZXdSZWYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5lbWJlZGRlZEl0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBFbWJlZGVkSXRlbSh0aGlzLl9pbXBsaWNpdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmVtYmVkZGVkSXRlbSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGFyb3VuZCBBbmd1bGFyJ3MgRW1iZWRkZWRWaWV3UmVmLmNvbnRleHQoKVxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEVtYmVkZWRJdGVtXG57XG4gICAgY29uc3RydWN0b3IocHVibGljICRpbXBsaWNpdDogYW55KVxuICAgIHtcbiAgICB9XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRG9DaGVjaywgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBNYXBXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGlzIHVzZWQgYnkgaW5jbHVkZS1jb21wb25lbnQuZGlyZWN0aXZlIHRvIGR5bmFtaWNhbGx5IGNyZWF0ZSBhblxuICogSFRNTEVsZW1lbnQgYW5kIHVzZSB0aGlzIGVsZW1lbnQgdG8gd3JhcCBhIGNoaWxkIGNvbXBvbmVudC4gVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG9cbiAqIG1vZGlmeSBhIGNoaWxkIGJ5IHdyYXBwaW5nIGl0IHdpdGggYSBib3JkZXIsIGEgYmFja2dyb3VuZCwgb3IgYm9sZCBpdHMgdGV4dC5cbiAqXG4gKiBUaGUgd3JhcHBlciBlbGVtZW50IGlzIGR5bmFtaWNhbGx5IGNyZWF0ZWQuIEl0J3MgZWxlbWVudCBpcyBzcGVjaWZpZWQgYnkgdGhlIHRhZ05hbWUgcHJvcGVydHkgaW5cbiAqIHRoZSBiaW5kaW5ncyBASW5wdXQuXG4gKlxuICogICMjIyBFeGFtcGxlLiAgRGlyZWN0bHkgaW4gaHRtbFxuICpcbiAqICAgYXBwLmh0bWxcbiAqICAgICAgPGF3LWdlbmVyaWMtY29udGFpbmVyIHRhZ05hbWU9XCJ0YWdOYW1lXCIgYmluZGluZ3M9XCJiaW5kaW5nc1wiPlxuICogICAgICAgICAgPG15LWNvbXBvbmVudCAuLmJpbmRpbmdzLi4+PC9teS1jb21wb25lbnQ+XG4gKiAgICAgIDwvYXctZ2VuZXJpYy1jb250YWluZXI+XG4gKlxuICogICBhcHAuY29tcG9uZW50LnRzXG4gKlxuICogICAgICAgdGFnTmFtZSA9IChiQm9sZCkgPyAnaDEnIDogJ3NwYW4nO1xuICogICAgICAgYmluZGluZ3MgPSB7ICBzdHlsZTogJ2JhY2tncm91bmQtY29sb3I6IHJlZCcgfVxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1nZW5lcmljLWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICBzdHlsZXM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIERvQ2hlY2tcbntcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdGFnTmFtZSBpZiBub25lIGlzIHNwZWNpZmllZCBpbnNpZGUgYmluZGluZ3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVhZG9ubHkgRGVmYXVsdFRhZ05hbWUgPSAnZGl2JztcblxuICAgIC8qKlxuICAgICAqIEJpbmRpbmdzIHRvIGJlIGFkZGVkIGFzIGF0dHJpYnV0ZXMgdG8gdGhlIHRhZ05hbWUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJpbmRpbmdzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudCB0byBiZSBjcmVhdGVkIHRoYXQgd3JhcHMgaXQncyBjb250ZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFnTmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTmF0aXZlIHJvb3QgZWxlbWVudC4gUG9pbnRzIHRvIDxhdy1nZW5lcmljLWNvbnRhaW5lcj5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5hdGl2ZUVsZW1lbnQ6IE5vZGU7XG5cbiAgICBwcml2YXRlIGNoaWxkRWxlbWVudDogTm9kZTtcblxuXG4gICAgLyoqXG4gICAgICogcGFyYW0gcmVuZGVyZXIgLSBSZW5kZXJlciBpcyB1c2VkIHRvIGNyZWF0ZSAndGFnTmFtZScgZWxlbWVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uLCB2ZXJpZnkgdGhhdCBhdCBsZWFzdCBvbmUgaW5wdXQgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gaW5wdXQsIHRoaXMgY29tcG9uZW50IHdvdWxkbid0IGtub3cgd2hhdCB0byBkbyBhbmQgdGhyb3cgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmJpbmRpbmdzKSAmJiBpc0JsYW5rKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpbnB1dCBiaW5kaW5ncyBvciB0YWdOYW1lICcgK1xuICAgICAgICAgICAgICAgICdoYXZlIG5vdCBiZWVuIHNldC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB0YWdOYW1lIGlzIGJsYW5rLCB0aGUgZ2V0IGl0IGZyb20gYmluZGluZ3MuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IHRoaXMuYmluZGluZ3MuZ2V0KCd0YWdOYW1lJyk7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lID0gR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudC5EZWZhdWx0VGFnTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgZmlyc3QgYWRkZWRcbiAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQgPSB0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5kb1JlbmRlcigpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jaGlsZEVsZW1lbnQpICYmXG4gICAgICAgICAgICB0aGlzLmNoaWxkRWxlbWVudC5wYXJlbnROb2RlICE9PSB0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIGNvbnRlbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuIENyZWF0ZSB0aGUgdGFnTmFtZSBlbGVtZW50LiBBcHBseSBhbGwgdGhlIGJpbmRpbmdzIG9uIHRvXG4gICAgICogdGhlIGVsZW1lbnQgYXMgYXR0cmlidXRlLiBGaW5hbGx5LCBtb3ZlIHRoZSBjaGlsZCBlbGVtZW50LCA8bmctY29udGVudD4sIHRvIGluc2lkZSB0aGVcbiAgICAgKiB3cmFwcGVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRvUmVuZGVyKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYXRpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLm5hdGl2ZUVsZW1lbnQsIGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIGJpbmRpbmdzIGFuZCBhZGQgdGhlbSB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgTWFwV3JhcHBlci5pdGVyYWJsZSh0aGlzLmJpbmRpbmdzKS5mb3JFYWNoKCh2LCBrKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCBrLCB2KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXR0YWNoIHRoZSBjb21wb25lbnQgdG8gdGhpcyBkaXZFbGVtZW50LlxuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkRWxlbWVudCk7XG4gICAgfVxuXG5cbn1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0RvQ2hlY2ssIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QXBwQ29uZmlnLCBFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiAgQmFzZSBjb21wb25lbnQgc2hhcmVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGFtb25nIGFsbCB0aGUgY29tcG9uZW50cyAobGF5b3V0cywgd2lkZ2V0cykuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBPbkRlc3Ryb3lcbntcblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGlzYWJsZWQgZmxhZyB0byB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFdlYXRoZXIgdGhpcyBjb21wb25lbnQgaXMgdmlzaWJsZVxuICAgICAqIERlZmF1bHQgaXMgZmFsc2U7XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2aXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUZWxsICB0aGUgY29tcG9uZW50IGlmIHdlIGFyZSBpbiBlZGl0aW5nIG1vZGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRhYmxlPzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSBjb21wb25lbnQgaGF2ZSBvcHRpb24gdG8gc2V0IGEgY3VzdG9tIHdpdGhcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgd2lkdGg6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGNvbXBvbmVudCBoYXZlIG9wdGlvbiB0byBzZXQgYSBjdXN0b20gd2l0aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGVpZ2h0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBvcHRpb25hbCBjc3MgY2xhc3Mgd2hpY2ggY2FuIGJlIHV0aWxpemVkIGJ5IGNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3R5bGVDbGFzczogYW55O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwYWRkaW5nIGZyb20gdGhlIGNvbXBvbmVudC4gVXN1YWxseSB1c2VkIHdoZW4gd2UgYXJlIG5lc3Rpbmcgb3RoZXIgY29tcG9uZW50IHdpdGhcbiAgICAgKiBpdHMgb3duIGdyaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvbWl0UGFkZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgZXh0ZW5zaW9uIHN1cHBvcnQgcmVnaXN0ZXIgaGVyZSBhbnkgZHluYW1pYyBmaWVsZCB0aGF0IGRvZXMgbm90IGV4aXN0aW5nIG9uIHRoZVxuICAgICAqIGNsYXNzL2NvbXBvbmVudFxuICAgICAqL1xuICAgIGV4dEJpbmRpbmdzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBQcmVmaXggZm9yIHRoZSBjb3JyZWN0IGFzc2V0IHBhdGhcbiAgICAgKi9cbiAgICBhc3NldEZvbGRlcjogc3RyaW5nID0gJ2Fzc2V0cyc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52PzogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICB0aGlzLmV4dEJpbmRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgICAgdGhpcy5vbWl0UGFkZGluZyA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5hc3NldEZvbGRlciA9IHRoaXMuZW52LmdldFZhbHVlKEFwcENvbmZpZy5Bc3NldEZvbGRlcik7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICB9XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnQsIG5vb3AsIHV1aWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgUGlwZVRyYW5zZm9ybSwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb250cm9sVmFsdWVBY2Nlc3NvciwgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiB4LXNtYWxsID0gPiAxMiUgID0gPiBjb2wtMVxuICogc21hbGwgPSA+IGBcbiAqIG1lZGl1bSA9ID4gNTAlICAgPSA+IGNvbC02XG4gKiBsYXJnZSA9ID4gNzUlICAgID0gPiBjb2wtOVxuICogbGFyZ2UgPSA+IDEwMCUgICA9ID4gY29sLTEyXG4gKlxuICovXG5leHBvcnQgdHlwZSBXaWRnZXRTaXplID0gJ3gtc21hbGwnIHwgJ3NtYWxsJyB8ICdtZWRpdW0nIHwgJ2xhcmdlJyB8ICd4LWxhcmdlJztcblxuZXhwb3J0IGVudW0gV2lkZ2V0U2l6ZUNvbHVtbnNcbntcbiAgICB4c21hbGwgPSAxLFxuICAgIHNtYWxsID0gMyxcbiAgICBtZWRpdW0gPSA2LFxuICAgIGxhcmdlID0gOSxcbiAgICB4bGFyZ2UgPSAxMlxufVxuXG5cbi8qKlxuICogIEJhc2VGb3JtQ29tcG9ubmV0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBmb3IgYWRkIHNwZWNpZmljIGZvcm0gYmVoYXZpb3JcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlRm9ybUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3Nvclxue1xuICAgIC8qXG4gICAgICogIFN1cHBvcnRlZCBsYXlvdXQgY29uc3RhbnRzLiBJdCBpcyBleHBlY3RlZCB0aGVyZSB3aWxsIGJlIG1vcmUgb3B0aW9ucyBhcyB3ZSBjdXJyZW50bHlcbiAgICAgKiAgc3VwcG9ydCBvbmx5IHRoZXNlIHR3byB0aGVyZSB3aWxsIGJlIG90aGVyIHZhcmlhdGlvbnMgb2YgaXQuIGUuZy4gZm9yIHN0YWNrZWQgaXQgd2lsbCBub3RcbiAgICAgKiAgYmUgMSBjb2x1bW5zIGxpa2UgaXQgaXMgbm93IGJ1dCBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVhZG9ubHkgTGF5b3V0U3RhY2tlZCA9ICdzdGFja2VkJztcbiAgICBzdGF0aWMgcmVhZG9ubHkgTGF5b3V0SW5saW5lID0gJ2lubGluZSc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCBuYW1lIGF0dHJpYnV0ZS4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbmFtZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgSWQuIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlkOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgY3VycmVudCBlbGVtZW50IHZpc2libGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGRlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBwYXNzIGluIGZvcm1Hcm91cCB3aGljaCB3aWxsIGJlIHVzZWQgd2l0aCBpbiB0aGUgZm9ybVxuICAgICAqXG4gICAgICogQElucHV0KCkgLSBzZWUgZ2V0dGVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZm9ybUdyb3VwOiBGb3JtR3JvdXA7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgcmVxdWlyZWQgZmxleCBhcm91bmQgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiAgYSB0ZXh0IGRpc3BsYXllZCB3aGVuIHZhbHVlIGlzIGVtcHR5IG9yIE5VTExcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBsYWNlSG9sZGVyOiBTdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZ5IGlmIHRoaXMgY29udHJvbCBpcyB1c2VkIGRpcmVjdGx5IG9yIGlmIGl0cyBwYXJ0IG9mIHNvbWUgb3RoZXIgY29udHJvbFxuICAgICAqIGUuZy4gR2VuZXJpY0Nob29zZXIgYW5kIG1hbmFnZWQgYnkgdGhpcyBjb250cm9sLlxuICAgICAqIE1lYW5pbmcgU3RhdGUgaXMgbWFuYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1N0YW5kYWxvbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtIENvbnRyb2wgZm9yIHRoZSBjb21wb25lbnQuIEl0cyBlaXRoZXIgaW5oZXJpdGVkIHNpbmNlIGl0IHdhcyBwcmVjcmVhdGVkIGluIHBhcmVudFxuICAgICAqIGNvbXBvbmVudCBvciBpdHMgY3JlYXRlZCBiYXNlZCBvbiBwYXNzZWQgJ25hbWUnIGFuZCByZWdpc3RlcmVkIHdpdGggdGhlICdmb3JtR3JvdXAnXG4gICAgICpcbiAgICAgKiBXaGVuICBpbml0aWFsaXplIEZvcm1Db250cm9sIHdlIGRvIHNldFZhbHVlIHdpdGggb25seVNlbGY6dHJ1ZSBmbGFnIGFuZCB3ZSBkbyBub3QgZW1pdCBhbnlcbiAgICAgKiBldmVudCBvdXRzaWRlXG4gICAgICpcbiAgICAgKi9cbiAgICBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2w7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlciB0aGF0IGNhbiBiZSBhc3NpZ24gdG8gdGhlIGNvbXBvbmVudCBpbiBvcmRlciB0byBmb3JtYXQgaXRzIGlucHV0XG4gICAgICovXG4gICAgZm9ybWF0dGVyOiBQaXBlVHJhbnNmb3JtO1xuXG5cbiAgICBwcm90ZWN0ZWQgb25Nb2RlbENoYW5nZWQ6IChfOiBhbnkpID0+IHZvaWQgPSBub29wO1xuICAgIHByb3RlY3RlZCBvbk1vZGVsVG91Y2hlZDogKF86IGFueSkgPT4gdm9pZCA9IG5vb3A7XG5cblxuICAgIC8qKlxuICAgICAqIFNvbWUgb2YgdGhlIEJhc2VGb3JtQ29tcG9uZW50IGNhbiB3cmFwIG90aGVyIGNvbXBvbmVudCBhbmQgaW4gdGhlc2UgY2FzZXMgd2Ugd2FudCB0b1xuICAgICAqIGluaGVyaXQgc29tZSBvZiB0aGUgYmVoYXZpb3IgZnJvbSBwYXJlbnRcbiAgICAgKlxuICAgICAqIEBJbmplY3QoRW52aXJvbm1lbnQpIHB1YmxpYyBlbnY6IEVudmlyb25tZW50IDogaXMgdGVtIGEgd29ya2Fyb3VuZCBhcyB3aXRob3V0IGluamVjdFxuICAgICAqIG9uIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50IGl0IGNvbXBsYWlucyB0aGF0IEVudmlyb25tZW50IGlzIHVucmVzb2x2ZWQgc3ltYm9sXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoQEluamVjdChFbnZpcm9ubWVudCkgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Hcm91cCA9IHRoaXMucGFyZW50Q29udGFpbmVyLmZvcm1Hcm91cDtcbiAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgPSB0aGlzLnBhcmVudENvbnRhaW5lci5lZGl0YWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hlY2tJbml0Rm9ybSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhdmFpbGFibGUgZm9ybUdyb3VwIGFuZCBOYW1lIGFuZCBJRFxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNoZWNrSW5pdEZvcm0gKClcbiAgICB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5lbnYuY3VycmVudEZvcm0pKSB7XG4gICAgICAgICAgICB0aGlzLmVudi5jdXJyZW50Rm9ybSA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZG86IFJpZ2h0IG5vdyBJIGp1c3QgbmVlZCB0byBpbml0aWFsaXplIG5hbWUgLCBidXQgaWRlYWxseSBpdCBuZWVkcyB0byBiZSBnZW5lcmF0ZWRcbiAgICAgICAgICogbnVtYmVyIGJhc2Vkb24gc29tZSBzZW1hbnRpY3MgYXBwLnBhZ2UuY29tcG9uZW50IGlmIHRoZXJlIGFyZSBtb3JlIGNvbXBvbmVudCBvbiB0aGUgcGFnZVxuICAgICAgICAgKiB0aGVuIGFwcC5wYWdlLmNvbXBvbmVudE51bWJlci4gU2ltcGxlIHNvbHV0aW9uIGlzIHRvIGlzIHRvIGdldCBFbGVtZW50cmVmIGFuZCBxdWVyeSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHV1aWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdXVpZCgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZG9SZWdpc3RlciAobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KTogRm9ybUNvbnRyb2xcbiAgICB7XG5cbiAgICAgICAgbGV0IGZDb250cm9sOiBGb3JtQ29udHJvbDtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUdyb3VwLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBuZXcgRm9ybUNvbnRyb2wodmFsdWUpKTtcbiAgICAgICAgICAgIGZDb250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tuYW1lXTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZkNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdO1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWRWYWx1ZTogYW55ID0gaXNQcmVzZW50KGZDb250cm9sLnZhbHVlKSA/IGZDb250cm9sLnZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgICBmQ29udHJvbC5wYXRjaFZhbHVlKHVwZGF0ZWRWYWx1ZSwge29ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZDb250cm9sO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIEZvcm1zIHRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kIHRvIHJlZ2lzdGVyIGNvbnRyb2xcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGRlZmF1bHQgdmFsdWUgdG8gYmUgcHJlLXNldFxuICAgICAqL1xuICAgIHJlZ2lzdGVyRm9ybUNvbnRyb2wgKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gdGhpcy5kb1JlZ2lzdGVyKHRoaXMubmFtZSwgdmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgQElucHV0KCkgZ2V0IGZvcm1Hcm91cCAoKTogRm9ybUdyb3VwXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2Zvcm1Hcm91cCkgPyB0aGlzLl9mb3JtR3JvdXAgOiB0aGlzLmVudi5jdXJyZW50Rm9ybTtcbiAgICB9XG5cbiAgICBzZXQgZm9ybUdyb3VwICh2YWx1ZTogRm9ybUdyb3VwKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZm9ybUdyb3VwID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHdlIGNhbiBwYXNzIGZpZWxkIHR5cGUgYXMgYSBiaW5kaW5nIHRvIHRoZSBjb21wb25lbnRzLiBlLmcuIElucHV0RmllbGQgbmVlZFxuICAgICAqIHN1Y2ggdHlwZSB0byBjb3JyZWN0bHkgcmVuZGVyIGlucHV0IHR5cGU9dGV4dCwgbnVtYmVyXG4gICAgICpcbiAgICAgKiB0b2RvOiBpcyB0aGlzIG5lZWRlZD8gY2FuIHdlIG1heWJlIHBhc3MgdGhpcyB0byB0aGUgZm9ybVJvdz9cbiAgICAgKi9cbiAgICBjYW5TZXRUeXBlICgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICB3cml0ZVZhbHVlICh2YWx1ZTogYW55KVxuICAgIHtcblxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UgKGZuOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQgKGZuOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RvbVNhbml0aXplcn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTaW1wbGUgY29tcG9uZW50IHJlbmRlcmluZyB2YWx1ZXMgaW4gdGhlIHJlYWQgb25seSBtb2RlLiBKdXN0IG5lZWRlZCBzb21lIGNvbXBvbmVudCB1c2VkXG4gKiB0byByZW5kZXIgU3RyaW5ncyBpbiByZWFkIG9ubHkgbW9kZVxuICpcbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqXG4gKiBVc2luZyBpdCBpbnNpZGUgZm9ybSBjb250YWluZXIgYWxvbmcgd2l0aCBsYWJlbFxuICpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICBzZWxlY3RvcjogJ3VzZXJJbmZvJyAsXG4gKiAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXRhYmxlIFtlZGl0YWJsZV09XCJmYWxzZVwiID5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW25hbWVdPVwiZmllbGROYW1lXCIgIFtsYWJlbF09XCJsYWJlbFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJpbnB1dFZhbHVlXCIgPjwvYXctc3RyaW5nPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXRhYmxlPlxuICpcbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICAgfSlcbiAqICAgICAgICAgIGV4cG9ydCBjbGFzcyBVc2VyUHJvZmlsZUNvbXBvbmVudFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICogICAgICAgICAgICAgIGlucHV0VHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG4gKiAgICAgICAgICAgICAgZmllbGROYW1lOiBzdHJpbmcgPSAnZmlyc3ROYW1lJztcbiAqICAgICAgICAgICAgICBsYWJlbDogc3RyaW5nID0gJ015IE5hbWUnO1xuICogICAgICAgICAgICAgIHJlcXVpcmVkOiBib29sZWFuID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICBlZGl0aW5nOiBib29sZWFuID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICBsYWJlbHNPblRvcDogYm9vbGVhbiA9IGZhbHNlO1xuICpcbiAqICAgICAgICAgIH1cbiAqXG4gKiAgYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgaHRtbCB0YWdzLlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdHJpbmcnLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwidy1zdHJpbmctZmllbGRcIiBbaW5uZXJIVE1MXT1cInZhbHVlXCI+PC9zcGFuPlxuICAgIGAsXG4gICAgc3R5bGVVcmxzOiBbJ3N0cmluZy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0NvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogIFZhbHVlIHRvIGJlIGludGVycG9sYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZyA9ICcnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgfVxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwodGhpcy5fdmFsdWUpO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1N0cmluZ01hcH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBBIGNsYXNzIGhvbGRpbmcgYSByZWZlcmVuY2VzIHRvIGNvbXBvbmVudHMuIFRoZSBtZXRob2RzIGFyZSBzZWxmLWV4cGxhbmF0b3J5LlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbXBvbmVudFJlZ2lzdHJ5XG57XG4gICAgcHJpdmF0ZSBfbmFtZVRvVHlwZTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGl6ZShyZWZlcmVuY2VzOiBhbnkpOiBQcm9taXNlPGFueT5cbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzKTtcbiAgICAgICAgbGV0IHByb21pc2U6IFByb21pc2U8YW55PiA9IG5ldyBQcm9taXNlKChyZXNvbHZlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcblxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlKG5hbWU6IHN0cmluZywgdHlwZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVUb1R5cGUuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lVG9UeXBlLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIWlzU3RyaW5nTWFwKHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhyZWZlcmVuY2VzKS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlKG5hbWUsIHJlZmVyZW5jZXNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGdldCBuYW1lVG9UeXBlKCk6IE1hcDxzdHJpbmcsIGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lVG9UeXBlO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBpc0JsYW5rLCBpc1ByZXNlbnQsIE1hcFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTdHJpbmdDb21wb25lbnR9IGZyb20gJy4uL3dpZGdldHMvc3RyaW5nL3N0cmluZy5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21wb25lbnRSZWZlcmVuY2V9IGZyb20gJy4vY29tcG9uZW50LXJlZmVyZW5jZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcblxuLyoqXG4gKiB0aGlzIGlzIHNwZWNpZmljIGltcG9ydCB0byB3ZSBjYW4gdXNlIGNvbXBvbmVudHMgYXMgY29tcG9uZW50c1t0eXBlbmFtZV0gYW5kICBnZXQgYmFjayBhXG4gKiB0eXBlLlxuICogSSBjb3VsZCBub3QgZmluZCBhbnkgYmV0dGVyIGR5bmFtaWMgd2F5IHVwIHRvIG5vd1xuICovXG4vKipcbiAqICBgSW5jbHVkZUNvbXBvbmVudGAgZGlyZWN0aXZlIGR5bmFtaWNhbGx5IGluc3RhbnRpYXRlIGFuZCBpbnNlcnQgYSBjb21wb25lbnRzIGludG8gdGhlIHNjcmVlblxuICogYmFzZWQgb24gdGhlIG5hbWUuIEl0IGNhbiBhY2NlcHRzIGJpbmRpbmdzIGFzIHdlbGwgd2hpY2ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIGFuZCBhcHBsaWVkXG4gKiB0byB0aGUgY29tcG9uZW50XG4gKlxuICogICMjIyB1c2FnZTpcbiAqXG4gKiAgSW5zdGVhZCBvZiBpbnNlcnRpbmcgY29tcG9uZW50IGluIHRoZSB3YXk6XG4gKlxuICogIGBgYFxuICogICAgPHRleHRmaWVsZCB2YWx1ZT1cInNvbWUgdmFsdWVcIj5cbiAqXG4gKiAgYGBgXG4gKlxuICogIHlvdSBjYW4gZG8gc28gZHluYW1pY2FsbHkgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1pbmNsdWRlLWNvbXBvbmVudCAnVGV4dGZpZWxkQ29tcG9uZW50JyBbYmluZGluZ3NdPWJpbmRpbmdzID48L2F3LWluY2x1ZGUtY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogVGhpcyBpcyB0aGUgbWFpbiBidWlsZGluZyBibG9jayB0byBkeW5hbWljYWxseSBnZW5lcmF0ZWQgVUkuXG4gKlxuICpcbiAqIFRvZG86IEN1cnJlbnRseSB0aGUgd2F5IEFuZ3VsYXIgQVBJIHdvcmsgYW5kIHdlIHVzZSBpdCB0byBjcmVhdGUgcHJvZ3JhbWF0aWNhbGx5IGNvbXBvbmVudHNcbiAqIGlzIHRvbyBjb21wbGV4dCB3ZSBuZWVkIHRvIGNyZWF0ZSBldmVyeXRoaW5nIDMgZGlmZmVyZW50IGNhbGxzIHRvIHBsYWNlIGEgY29tcG9uZW50IHRvIHRoZVxuICogY29udGFpbmVyLiBXaGF0IEkgd2FudCBpcyBpcyB0byBjcmVhdGUgc29tZSBraW5kIG9mIHJlcHJlc2VudGF0aW9uIG9mIENvbnRhaW5lckVsZW1lbnQgYW5kIHRoaXNcbiAqIGNhbiBiZSBhbHNvIHBhcmVudCBmb3Igb3VyIEJhc2VDb21wb25lbnQgd2l0aCBtZXRob2QgYWRkIGFuZCByZW1vdmUgY29udGVudC4gVGhlbiB3ZSBjb3VsZCBoYXZlXG4gKiBzb21lIEFXQ29udGVudC5cbiAqXG4gKiBlLmcuOiB0byByZXBsYWNlIGFwcGx5Q29udGVudEVsZW1lbnRJZkFueSB3aGVyZSB3ZSBoYXZlIHNldmVyYWwgY2FsbHMgdG8gY3JlYXRlIGFuZCBhZGRcbiAqIGNvbXBvbmVudCB0byB0aGUgdmlldy5cbiAqXG4gKiBgYGB0c1xuICogIGxldCBjb250YWluZXJFbGVtZW50ID0gQVdDb25jcmV0ZVRlbXBsYXRlKHZpZXdDb250YWluZXIsIGZhY3RvcnlSZXNvbHZlcilcbiAqICBjb250YWluZXJFbGVtZW50LmFkZCgnQ2xjayBNZScpXG4gKiBgYGBcbiAqXG4gKiBUbyBhc3NlbWJsZSBkaWZmZXJlbnQgY29tcG9uZW50cyB0b2dldGhlciAtIG5vdCBvbmx5IGFkZGluZyBzdHJpbmcgY29udGVudFxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEJ1dHRvbkNvbXBvbmVudCwgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoJ0NsaWNrIE1lJyk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKiBhZGQgbW9yZSBjb21wb25lbnQgaGllcmFyY2h5OlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEhvdmVyQ2FyZENvbXBvbm5ldHMsIGJpbmRpbmdzTWFwKVxuICogIGNvbnRlbnQuYWRkKGNyZWF0ZUxheW91dCgpO1xuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKGNvbnRlbnQpXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2F3LWluY2x1ZGUtY29tcG9uZW50J1xufSlcbmV4cG9ydCBjbGFzcyBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQsIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50ID0gJ25nY29udGVudCc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nQ29udGVudEVsZW1lbnQgPSAnbmdjb250ZW50RWxlbWVudCc7XG5cbiAgICAvKipcbiAgICAgKiBGdWxsIGNvbXBvbmVudCBuYW1lIGUuZy46IERyb3Bkb3duQ29tcG9uZW50IHdoaWNoIGlzIGdvaW5nIHRvIGJlIGluc2VydGVkLiBXZSBuZWVkIHRvIHRha2VcbiAgICAgKiB0aGlzIG5hbWUgYW5kIHRyYW5zbGF0ZSBpdCBpbnRvIGFjdHVhbCBUWVBFLiBJbiBvcmRlciB0byBkbyB0aGlzIHdlIHVzZSBhIHRyaWNrIHdoZXJlIHdlXG4gICAgICogYWNjZXNzIGFuIElNUE9SVEVEIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4uL2NvbXBvbmVudHMnO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlbiB5b3UgY2FuIHJldHJpZXZlIGEgdHlwZSBieSBqdXN0IGNvbXBvbmVudHNbPFN0cmluZyBMaXRlcmFsID5dID0+IENvbXBvbmVudCBUWVBFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBiaW5kaW5ncyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBjb21wb25lbnQgd2hlbiBpbnN0YW50aWF0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY3JlYXRlZCBjb21wb25lbnQgcmVmZXJlbmNlIHVzaW5nIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci4gV2UgdXNlIHRoaXMgdG8gYWNjZXNzXG4gICAgICogdGhlIGFjdHVhbCBjb21wb25lbnQgaW5zdGFuY2UgYW5kIEVsZW1lbnQgUmVmZXJlbmNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRDb21wb25lbnQ6IENvbXBvbmVudFJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogSSB1c2UgdGhpcyBmbGFnIHRvIGlkZW50aWZ5IHRoYXQgY29tcG9uZW50IGlzIHJlbmRlcmluZyBmb3IgZmlyc3QgdGltZSBvciBpdHMgdXBkYXRlZCBkdXJpbmdcbiAgICAgKiBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE5vdCBzdXJlIGlmIHdlIG5lZWQgdGhpcywgYnV0IHdhbnQgdG8ga2VlcCBpdCBoZXJlIG9yIG1heWJlIG1vdmUgaXQgdG8gc29tZSBzZXJ2aWNlIHNvIHdlXG4gICAgICogY2FuIGNhY2hlIGNyZWF0ZWQgY29tcG9uZW50cyBhbmQgbWF5YmUgcmV1c2UgdGhlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjb21wb25lbnRSZWZlcmVuY2VzOiBNYXA8c3RyaW5nLCBDb21wb25lbnRSZWZlcmVuY2U+ID1cbiAgICAgICAgbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogTmVlZCB0byBjYWNoZSB0aGUgcmVzb2x2ZWQgY29tcG9uZW50IHJlZmVyZW5jZSBzbyB3ZSBkb250IGNhbGwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogZXZlcnl0aGluZyB3ZSB3YW50IHRvIHJlZnJlc2ggYSBzY3JlZW5cbiAgICAgKi9cbiAgICByZXNvbHZlZENvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmZXJlbmNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgcHVibGljIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY29tcFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcblxuICAgICAgICB0aGlzLmluaXRSZW5kZXJJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgLy8gdG9kbzogY2hlY2sgaWYgdGhpcyB0aGUgcmlnaHQgbGlmZWN5Y2xlIGNhbGxiYWNrLCB0aGlzIGlzIGNhbGxlZCBvbmx5IG9uY2UgYW5kIHlvdSB3YW50XG4gICAgICAgIC8vIHRvIHByb2JhYmx5IGxpc3RlbiBmb3IgY2hhbmdlcywgYW5kIGNoYW5nZSBkZWN0aW9uIGRlY2lkZSB0aGVyZSBpcyBzb21lIGNoYW5nZSBhbmQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZS1kcmF3IHRoZSB2aWV3XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB0aGlzLmRvUmVuZGVyQ29tcG9uZW50KCk7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWyduYW1lJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1snbmFtZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snbmFtZSddLnByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgYW5kIHJlcG9zaXRpb24gRE9NIGVsZW1lbnQgYm90aCBmb3Igd3JhcHBlciBhbmRcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICB0aGlzLmNyZWF0ZVdyYXBwZXJFbGVtZW50SWZBbnkoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIHJlc29sdmUgYWRkaXRpb25hbCBjb21wb25lbnQgYW5kIHdyYXAgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqIEp1c3QgbGlrZSByZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKSB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSBleGVjdXRlZCBhZnRlciBhbGxcbiAgICAgKiBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCAoaW5zaWRlIHRoZSBuZ0FmdGVyVmlld0luaXQoKSApXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBjb21wb25lbnQgaW50byBhY3R1YWwgVmlldyBDb250YWluZXIuIFRoZSBwcm9jZXNzIGdvZXMgYXMgdGhpcy5cbiAgICAgKiAgMS4gV2UgcmV0cmlldmUgY29tcG9uZW50IFR5cGUgYmFzZWQgb24gdGhlIGNvbXBvbmVudCBuYW1lLCB3aGljaCBjcmVhdGVzIGNvbXBvbmVudFJlZlxuICAgICAqICAyLiBQbGFjZSB0aGUgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlblxuICAgICAqICAzLiBSZWFkIGNvbXBvbmVudCBtZXRhZGF0YSwgbWFpbmx5IElOUFVUcyBhbmQgYXBwbHkgYmluZGluZ3MgZm9yIGVhY2ggb2YgdGhlbVxuICAgICAqICA0LiBNYW51YWxseSBzcGluIGNoYW5nZSBkZXRlY3Rpb24gdG8gdXBkYXRlIHRoZSBzY3JlZW4uIE1haW5seSBmb3IgY2FzZSB3aGVyZSBJIG5lZWQgdG9cbiAgICAgKiByZWRyYXcgYSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9SZW5kZXJDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wbGFjZVRoZUNvbXBvbmVudCgpO1xuICAgICAgICAvLyB0aGlzLmN1cnJlbnRDb21wb25lbnQuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0YWNoKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJpbmRpbmdzKHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCksIHRoaXMuY3VycmVudENvbXBvbmVudCwgdGhpcy5iaW5kaW5ncyk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAgICAgLy8gU3RpbGwgbm90IHN1cmUgYWJvdXQgdGhpcyB3aGF0IGFsbCBJIHNob3VsZCByZWxlYXNlIGhlcmUuXG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5vbkRlc3Ryb3koKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUGxhY2UgYWN0dWFsIGNvbXBvbmVudCBvbnRvIHRoZSBzY3JlZW4gdXNpbmcgVmlld0NvbnRhaW5lclJlZlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBsYWNlVGhlQ29tcG9uZW50KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCByZWZlcmVuY2UgPSB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KHJlZmVyZW5jZS5yZXNvbHZlZENvbXBGYWN0b3J5KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW5zZXJ0aW5nIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGhhdmUgYSBjb250ZW50IGxpa2UgZS5nLiBoeXBlcmxpbmsgb3IgYnV0dG9uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxidXR0b24+IE1ZIE5HIENPTlRFTlQgPC9idXR0b24+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgdGhpcyBtZXRob2QgYXBwbGllcyBhbmQgaW5zZXJ0IGEgY2hpbGQgY29udGVudCBpbnRvIHRoZSBtYWluIGNvbXBvbmVudC4gVGhpcyBtZXRob2QgaW5zZXJ0XG4gICAgICogYSBzaW1wbGUgc3RyaW5nLiBXZSBhcmUgbm90IHdyYXBwaW5nIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIGFub3RoZXIgY29tcG9uZW50IGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG5lZWQgdG8gcnVuIGRldGVjdCBjaGFuZ2VzID8gZGVmYXVsdCBpcyBmYWxzZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk6IGJvb2xlYW5cbiAgICB7XG5cbiAgICAgICAgbGV0IGRldGVjdENoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5nQ29udGVudCA9IHRoaXMubmdDb250ZW50KCk7XG4gICAgICAgIGxldCBuZ0NvbnRlbnRFbGVtZW50ID0gdGhpcy5uZ0NvbnRlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQobmdDb250ZW50KSkge1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbXBvbmVudCA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN0cmluZ0NvbXBvbmVudCk7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChhd0NvbnRlbnRDb21wb25lbnQsIDApO1xuXG4gICAgICAgICAgICAoPFN0cmluZ0NvbXBvbmVudD5jb21wb25lbnQuaW5zdGFuY2UpLnZhbHVlID0gbmdDb250ZW50O1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBhd0NvbnRlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBkZXRlY3RDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobmdDb250ZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb250ZW50IEVsZW1lbnQ6ICcsIG5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRldGVjdENoYW5nZXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGEgTkcgQ29udGVudCBmcm9tIGJpbmRpbmcgbGlzdCBhbmQgcmVtb3ZlIGl0IHNvIGl0IGl0cyBub3QgcHJlcGFnYXRlZCBkb3duIHdoZW5cbiAgICAgKiBhcHBseWluZyBvdGhlciBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgY29udGVudDogYW55O1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRlbnQgPSB0aGlzLmJpbmRpbmdzLmdldChJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgbmdDb250ZW50RWxlbWVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gY29udmVydCBhIGNvbXBvbmVudCBuYW1lIHRvIGFjdHVhbCBhIHR5cGUgYW5kIHRoZW4gdXNlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAqIHRvIGluc3RhbnRpYXRlIGEgYSBjb21wb25lbnQgYW5kIHNhdmUgaXRzIGluZm9ybWF0aW9uIGludG8gb3VyIGNvbXBvbmVudCByZWZlcmVuY2VzLiBUaGVcbiAgICAgKiByZWFzb24gd2h5IHdlIGhhdmUgdGhpcyBjb21wb25lbnQgcmVmZXJlbmNlIGlzIHdlIG5lZWQgdG8gc3RvcmUgQW5ndWxhcidzIGNvbXBvbmVudCBtZXRhZGF0YVxuICAgICAqIHNvIHdlIGNhbiBpdGVyYXRlIHRocnUgYWxsIHRoZSBpbnB1dHMgYW5kIGJpbmQgdGhlbSB0byB0aGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIHJldHVybnMge0NvbXBvbmVudFJlZmVyZW5jZX0gYSByZWZlcmVuY2UgcmVwcmVzZW50aW5nIGEgY29tcG9lbnQgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZSgpOiBDb21wb25lbnRSZWZlcmVuY2VcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyVHlwZSA9IHRoaXMucmVzb2x2ZUNvbXBvbmVudFR5cGUoKTtcbiAgICAgICAgbGV0IGNvbXBvbmVudEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55PiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY3VyclR5cGUpO1xuXG4gICAgICAgIGxldCBjb21wb25lbnRNZXRhOiBDb21wb25lbnQgPSB0aGlzLnJlc29sdmVEaXJlY3RpdmUoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIGxldCBjb21wUmVmZXJlbmNlOiBDb21wb25lbnRSZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY29tcG9uZW50TWV0YSxcbiAgICAgICAgICAgIHJlc29sdmVkQ29tcEZhY3Rvcnk6IGNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBjdXJyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IHRoaXMubmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWYgPSBjb21wUmVmZXJlbmNlO1xuICAgICAgICByZXR1cm4gY29tcFJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJ1IENvbXBvbmVudE1ldGFkYXRhIEBJbnB1dHMoKSBhbmQgY2hlY2sgaWYgd2UgaGF2ZSBhdmFpbGFibGUgYmluZGluZyBpbnNpZGUgdGhlXG4gICAgICogJ3RoaXMuYmluZGluZ3MnXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5QmluZGluZ3MoY1JlZjogQ29tcG9uZW50UmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaW5wdXRzOiBzdHJpbmdbXSA9IGNSZWYubWV0YWRhdGEuaW5wdXRzO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGlucHV0cykgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3VsZCB3ZSBkbyBhbnkgdHlwZSBjb252ZXJzaW9uP1xuICAgICAgICBNYXBXcmFwcGVyLml0ZXJhYmxlKGJpbmRpbmdzKS5mb3JFYWNoKCh2LCBrKSA9PlxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcG9uZW50Lmluc3RhbmNlW2tdKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgc3RyaW5nIGxpdGVyYWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGNvbXBvbmVudCB0eXBlIHVzZWQgYnkgYENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcmBcbiAgICAgKlxuICAgICAqIHRvZG86IHJlbmFtZSB0aGUgbWV0aG9kIHNvIGl0cyBjbGVhciB0aGF0IGl0IHJldHVybnMgY29tcG9uZW50IHR5cGUgYmFzZWQgb24gc3RyaW5nLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZXNvbHZlQ29tcG9uZW50VHlwZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBjb21wb25lbnRUeXBlID0gdGhpcy5jb21wUmVnaXN0cnkubmFtZVRvVHlwZS5nZXQodGhpcy5uYW1lKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhjb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCB0aGlzLm5hbWUgKyAnIGNvbXBvbmVudCBkb2VzIG5vdCBleGlzdHMuIENyZWF0ZSBEdW1teSBDb21wb25lbnQgaW5zdGVhZCcgK1xuICAgICAgICAgICAgICAgICcgb2YgdGhyb3dpbmcgdGhpcyBlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlO1xuICAgIH1cblxuXG4gICAgcHJvdGVjdGVkIHJlc29sdmVEaXJlY3RpdmUoY29tcEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55Pik6IENvbXBvbmVudFxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBNZXRhOiBDb21wb25lbnQgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5LmlucHV0cykgJiYgY29tcEZhY3RvcnkuaW5wdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3RvcnkuaW5wdXRzLmZvckVhY2goKGlucHV0OiB7cHJvcE5hbWU6IHN0cmluZywgdGVtcGxhdGVOYW1lOiBzdHJpbmd9KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhLmlucHV0cy5wdXNoKGlucHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjb21wRmFjdG9yeS5vdXRwdXRzKSAmJiBjb21wRmFjdG9yeS5vdXRwdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3Rvcnkub3V0cHV0cy5mb3JFYWNoKChvdXRwdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEub3V0cHV0cy5wdXNoKG91dHB1dC5wcm9wTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcE1ldGE7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmlld0NvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1cnJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N0cmluZ1dyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEVycm9yIE1hbmFnZXIgaXMgYSBzZXJ2aWNlIHVzZWQgYnkgRm9ybXMgY29tcG9uZW50cyB0byBtYXAgZXJyb3IgY29kZXMgaW50byBtZWFuaW5nZnVsIG1lc3NhZ2VzLlxuICogQ3VycmVudGx5IGl0IGRvZXMgbm90IGhhdmUgbXVjaCBidXQgb25jZSB3ZSBwbHVnIGluIGxvY2FsaXphdGlvbiBpdCB3aWxsIG1ha2UgbW9yZSBzZW5zZVxuICpcbiAqXG4gKiB0b2RvOiBPbmNlIG5nLXRyYW5zbGF0ZSBpcyBpbXBsZW1lbnRlZCByZXBsYWNlIHRoaXMgd2l0aCBuZy10cmFuc2xhdGUgZnVuY3Rpb25hbGl0eSBzbyB3ZSBjYW5cbiAqIGV4dGVybmFsaXplIHRoZXNlIG1lc3NhZ2VzIGludG8gbG9jYWxlIGZpbGVzLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlclNlcnZpY2VcbntcbiAgICBtZXNzYWdlczoge1trZXk6IHN0cmluZ106IGFueX07XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogJ1JlcXVpcmVkIGZpZWxkJyxcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtaW5pbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogJ0ZpZWxkIGRvZXMgbm90IG1lZXQgbWF4aW11bSBsZW5ndGgnLFxuICAgICAgICAgICAgJ2N1c3RvbU1zZyc6ICclcycsXG4gICAgICAgICAgICAnbWV0YXZhbGlkJzogJyVzJ1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZXJyb3JNZXNzYWdlKHZhbGlkYXRvck5hbWU6IHN0cmluZywgdmFsaWRhdG9yVmFsdWU/OiBhbnkpXG4gICAge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbdmFsaWRhdG9yTmFtZV07XG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLmNvbnRhaW5zKG1lc3NhZ2UsICclcycpKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiB1c2UgbmctdHJhbnNsYXRlIHdpdGggcHJvcGVyIG1lc3NhZ2UgZm9ybWF0dGluZ1xuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlci5yZXBsYWNlKG1lc3NhZ2UsICclcycsIHZhbGlkYXRvclZhbHVlLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2x9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi4vLi4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuXG4vKipcbiAqIEVycm9yTWVzc2FnZXNDb21wb25lbnQgaXMgdXNlZCBieSBmb3JtJ3MgY29tcG9uZW50IGxpa2UgRm9ybVJvdyB0byBwcmludCBpdHMgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKiBJdHMgIGJhc2VkIG9uIE1vZGVsRHJpdmVuIChSZWFjdGl2ZSBmb3JtcykgYW5kIGl0IHJlYWRzIGVycm9ycyBmcm9tIEZvcm1Db250cm9sXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYS1lcnJvci1tZXNzYWdlcycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbWFsbCAqbmdJZj1cImhhc01lc3NhZ2UoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInVpLWctMTIgdWktbWVzc2FnZSB1aS1tZXNzYWdlcy1lcnJvciB1aS1jb3JuZXItYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBlcnJvck1zZyB9fVxuICAgICAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICBzdHlsZVVybHM6IFsnZXJyb3ItbWVzc2FnZXMuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2VzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGZvcm0gRm9ybUNvbnRyb2xsIHRvIGNoZWNrIGZvciBFcnJvcnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVyck1hbmFnZXI6IEVycm9yTWFuYWdlclNlcnZpY2UpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICB9XG5cblxuICAgIGhhc01lc3NhZ2UoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IG1zZyA9IHRoaXMuZXJyb3JNc2c7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQobXNnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1lc3NhZ2VzIGlmIGFueSByZWdpc3RlcmVkIGJ5IGFkZGVkIHZhbGlkYXRvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBlcnJvck1zZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5TmFtZSBpbiB0aGlzLmNvbnRyb2wuZXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmVycm9ycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIHRoaXMuY29udHJvbC50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyTWFuYWdlci5lcnJvck1lc3NhZ2UocHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wuZXJyb3JzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaG93IGVycm9ycz8gV2UgY3VycmVudGx5IHNob3dzIGVycm9ycyBpZiB0aGUgY29udHJvbCBpcyBub3QgdmFsaWQsIGl0IHdhcyB0b3VjaGVkIGJ5IHVzZXIuXG4gICAgICogTW9zdCBvZiB0aGUgdHlwZSBvbiBibHVyIGV2ZW50ICBhbmQgYXQgbGFzdCBpdHMgbm90IHByaXN0aW5lIGFueW1vcmUgKGl0cyBkaXJ0eSlcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dFcnJvcnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRyb2wudmFsaWQgJiYgIXRoaXMuY29udHJvbC5wcmlzdGluZSAmJiB0aGlzLmNvbnRyb2wudG91Y2hlZDtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgSW5qZWN0YWJsZSxcbiAgICBUeXBlLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogTW9kYWwgc2VydmljZSBpcyB1c2VkIHRvIHRvIGNyZWF0ZSBtb2RhbCBkaWFsb2dzLiBJdCBjcmVhdGVzIG1vZGFsIGRpYWxvZ3MgZHluYW1pY2FsbHkuXG4gKiBUaGUgc2VydmljZSBhbHNvIGtlZXBzIHRyYWNrIG9mIHRoZSBjcmVhdGVkIG1vZGFsIGRpYWxvZyBhbmQgY2FuIGNsb3NlIGl0IGJ5IGNhbGxpbmcgdGhlXG4gKiBzZXJ2aWNlJ3MgY2xvc2UoKVxuICpcbiAqIE1vZGFsIHNlcnZpY2UgcmVxdWlyZXMgYSBWaWV3Q29udGFpbmVyIHRvIGluc2VydCBuZXdseSBjcmVhdGVkIG1vZGFscy4gVGhpcyBpcyB0YWtlbiBjYXJlXG4gKiBieSB0aGUgTW9kYWxDb21wb25lbnQuXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgQWRkICAgPGF3LW1vZGFsPjwvYXctbW9kYWw+ICBpbnRvIHlvdXIgYXBwbGljYXRpb24gbWFpbiBodG1sLiBJdCBuZWVkcyB0byBiZSBvbiBldmVyeVxuICogICAgIHBhZ2Ugd2hlcmUgYSBtb2RhbCBkaWFsb2cgd2lsbCBhcHBlYXIuXG4gKlxuICogICAgMS4gIFBvcHVwIGEgZGlhbG9nIHdpdGhvdXQgY3JlYXRpbmcgeW91ciBvd24gY29tcG9uZW50LlxuICogICAgICAgIFVzZSB0aGUgZXhpc3RpbmcgRGlhbG9nQ29tcG9uZW50IGluIHdpZGdldHMuXG4gKlxuICogICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxEaWFsb2dDb21wb25lbnQ+KERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBDcmVhdGluZyB5b3VyIG93biBEaWFsb2cgQ29tcG9uZW50IHRvIHBvcHVwLlxuICpcbiAqICAgICAgICAgbGV0IGNvbXBvbmVudFJlZiA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48TXlEaWFsb2dDb21wb25lbnQ+KE15RGlhbG9nQ29tcG9uZW50LFxuICoge2lucHV0c30pO1xuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1teWRpYWxvZycgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2cgKG9uQ2xvc2UpPVwiY2xvc2VQb3B1cCgpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI3RpdGxlVGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVudmlyYVwiID48L2k+VGhpcyBpcyBteVxuICogICAgIFRpdGxlIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JvZHlUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtZW52aXJhXCIgPjwvaT5UaGlzIGlzIG15XG4gKiAgICAgQm9keSA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2c+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeURpYWxvZ0NvbXBvbmVudCBleHRlbmRzIERpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNsb3NlUG9wdXAoKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5jbG9zZSgpO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb2RhbFNlcnZpY2VcbntcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgc3RhdGljIGxpc3Qgb2Ygb3V0cHV0IHBhcmFtZXRlciBmcm9tIERpYWxvZywgQ29uZmlybWF0aW9uIGNvbXBvbmVudHNcbiAgICAgKiB0aGF0IG5lZWRzIHRvIGJlIGhhbmRsZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBPVVRQVVRfUEFSQU1FVEVSUzogc3RyaW5nW10gPSBbJ29uQ2xvc2UnLCAnb25Db25maXJtJywgJ29uQ2FuY2VsJ107XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgbW9kYWwuIFRoaXMgaXMgcGFzc2VkIGluIHRocm91Z2ggdGhlXG4gICAgICogcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKCkuXG4gICAgICovXG4gICAgcHJpdmF0ZSB2Y1JlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNyZWF0ZWQgbW9kYWwgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbnN0YW5jZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogREkgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGJlIHVzZWQgdG8gY3JlYXRlIG1vZGFsIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZnJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUGxhY2VIb2xkZXIgZm9yIG1vZGFsIHRvIGJlIGluc2VydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZjUmVmXG4gICAgICovXG4gICAgcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHZjUmVmOiBWaWV3Q29udGFpbmVyUmVmKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy52Y1JlZiA9IHZjUmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBtb2RhbCBkaWFsb2cgYnkgZHluYW1pY2FsbHkgY3JlYXRpbmcgdGhlIGNvbXBvbmVudCBhbmQgYWRkaW5nIGl0IHRvIHZjUmVmLlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbjxUPihjb21wb25lbnQ6IFR5cGU8VD4sIHBhcmFtZXRlcnM/OiBhbnkpOiBDb21wb25lbnRSZWY8VD5cbiAgICB7XG4gICAgICAgIGNvbnN0IGNmOiBDb21wb25lbnRGYWN0b3J5PFQ+ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgbGV0IGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPFQ+ID0gdGhpcy52Y1JlZi5jcmVhdGVDb21wb25lbnQoY2YpO1xuXG4gICAgICAgIC8vIEF1dG8gc2V0IHZpc2libGl0eSB0byB0cnVlLiBTbyB0aGF0IHRoZSBEaWFsb2cgd2lsbCBkaXNwbGF5XG4gICAgICAgIHBhcmFtZXRlcnMgPSAocGFyYW1ldGVycykgPyBwYXJhbWV0ZXJzIDoge307XG4gICAgICAgIHBhcmFtZXRlcnNbJ3Zpc2libGUnXSA9IHRydWU7XG5cbiAgICAgICAgLy8gSGFuZGxlIG91dHB1dCBwYXJhbWV0ZXJzLlxuICAgICAgICBNb2RhbFNlcnZpY2UuT1VUUFVUX1BBUkFNRVRFUlMuZm9yRWFjaCgocGFyYW0pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICg8YW55PmNvbXBvbmVudFJlZi5pbnN0YW5jZSlbcGFyYW1dLnN1YnNjcmliZShwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtZXRlcnNbcGFyYW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFJlZi5pbnN0YW5jZSwgcGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gaGFkIHRvIGNhc3QgaXQgaW4gb3JkZXIgdG8gYXZvaWQgYW55IGluZGV4IEVycm9yXG4gICAgICAgIC8vIEF0dGFjaCBhIGRlc3Ryb3kgbWV0aG9kIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudC5cbiAgICAgICAgKDxhbnk+Y29tcG9uZW50UmVmLmluc3RhbmNlKVsnZGVzdHJveSddID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW5zdGFuY2UsIHNvIGl0IGNhbiBiZSBkZXN0cm95ZWQgbGF0ZXIuXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjb21wb25lbnRSZWY7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIGNsb3NlKCkgd2lsbCByZW1vdmUgdGhlIG1vZGFsIGZyb20gdmlldy5cbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIE9uSW5pdCwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuLi9tb2RhbC5zZXJ2aWNlJztcblxuXG4vKipcbiAqIFBsYWNlIGhvbGRlciBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFRoaXMgY29tcG9uZW50IHdvcmtzIHdpdGggdGhlIG1vZGFsU2VydmljZSBieSBwcm92aWRpbmdcbiAqIGEgcGxhY2UgaG9sZGVyIGZvciBpdCB0byBpbmplY3QgRGlhbG9nIGNvbXBvbmVudCBpbnRvLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1vZGFsJyxcbiAgICB0ZW1wbGF0ZVVybDogJ21vZGFsLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnbW9kYWwuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBNb2RhbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuXG4gICAgQFZpZXdDaGlsZCgnbW9kYWwnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZn0pXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLnJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZih0aGlzLnZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0N1cnJlbmN5UGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7UGlwZSwgUGlwZVRyYW5zZm9ybX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogVGhpcyBjdXJyZW5jeSBmb3JtYXR0ZXIgd2lsbCBpZ25vcmUgbnVsbCBhbmQgZW1wdHkgc3RyaW5nIGZvciB2YWx1ZS5cbiAqIElzc3VlIDogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvODY5NCAgREkgZmFpbHMgd2hlbiBleHRlbmRzIG90aGVyIGNsYXNzZXNcbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdjdXJyZW5jeUZvcm1hdCcsXG4gICAgcHVyZTogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgQ3VycmVuY3lGb3JtYXRQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybVxue1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjdXJyZW5jeVBpcGU6IEN1cnJlbmN5UGlwZSlcbiAgICB7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogYW55XG4gICAge1xuXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVzXG4gICAgICAgIGxldCBjdXJyZW5jeUNvZGUgPSAnVVNEJywgc3ltYm9sRGlzcGxheSA9IHRydWUsIGRpZ2l0cyA9ICcxLjAtMic7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKGNvZGUgJiYgY29kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3lDb2RlID0gY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbmN5UGlwZS50cmFuc2Zvcm0odmFsdWUsIGN1cnJlbmN5Q29kZSwgc3ltYm9sRGlzcGxheSwgZGlnaXRzKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cblxuLyoqXG4gKiBTaW1wbGUgdXRpbGl0eSBkaXJlY3RpdmUgdGhhdCBpcyB1c2VkIGJ5IE5HIEZvciBjeWNsZSBpbiBzaXR1YXRpb24gd2hlcmUgd2UgbmVlZCB0byBjYWxsIGFcbiAqIG9yIGV4ZWN1dGUgc29tZSBsb2dpYyBhZnRlciBlYWNoIGl0ZXJhdGlvblxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tuZ0ZvclNldF0nXG59KVxuZXhwb3J0IGNsYXNzIE5nRm9yU2V0RGlyZWN0aXZlXG57XG5cbiAgICBAT3V0cHV0KClcbiAgICBvbkl0ZW06IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMub25JdGVtLmVtaXQoJy0tJyk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTaW1wbGUgY29udmVuaWVudCBzZXJ2aWNlIHRvIHdvcmsgd2l0aCB0aGUgZG9tLiBBbGwgdGhlIGZ1dHVyZSBsb2dpYyByZWxhdGVkIHRvIERPTSBtYW5pcHVsYXRpb25cbiAqIG9yIHRyYXZlcnNhbCBzaG91bGQgYmUgcHV0IGludG8gdGhpcyBzZXJ2aWNlXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRG9tVXRpbHNTZXJ2aWNlXG57XG5cbiAgICBjb25zdHJ1Y3RvciAoKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnb2VzIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBib2R5IGFuZCBjaGVja3MgaWYgdGhlcmUgaXMgYSBlbGVtZW50IGlkZW50aWZpZWQgYnkgYSAnc2VsZWN0b3InXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNQYXJlbnQgKG5hdGl2ZUVsZW1lbnQ6IGFueSwgc2VsZWN0b3I6IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jbG9zZXN0KG5hdGl2ZUVsZW1lbnQsIHNlbGVjdG9yKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgVHJhdmVscyBhbGwgdGhlIHdheSB1cCB0byB0aGUgQk9EWSBhbmQgcmV0cmlldmUgZWxlbWVudCBpZGVudGlmaWVkIGJ5ICdzZWxlY3Rvcicgb3IgTlVMTCBpZlxuICAgICAqIG5vdCBmb3VuZFxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VzdCAobmF0aXZlRWxlbWVudDogYW55LCBzZWxlY3Rvcjogc3RyaW5nKTogYW55XG4gICAge1xuICAgICAgICBsZXQgZmlyc3RDaGFyID0gc2VsZWN0b3IuY2hhckF0KDApO1xuXG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gbmF0aXZlRWxlbWVudDtcblxuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJy4nICYmIHBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKHNlbGVjdG9yLnN1YnN0cigxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJyMnICYmIHBhcmVudE5vZGUuaWQgPT09IHNlbGVjdG9yLnN1YnN0cigxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3RvciBpcyBhIHRhZ1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgcGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBhbmd1bGFyIGNvbXBvbmVudCBpcyByZW5kZXJlZCBhbG9uZyB3aXRoIE5HQ29udGVudCBpdCBoYXMgaXRzIG93biBfbmdDb250ZW50X0lOREVYXG4gICAgICogd2hpY2ggYWx3YXlzIGNvcnJlc3BvbmRzIHdpdGggX25naG9zdF9JTkRFWCwgdGhpcyB3b3JrcyBmaW5lIGlmIHdlIGhhdmUgYWN0dWFsIGNvbXBvbmVudFxuICAgICAqIHRoYXQgaXMgYWxyZWFkeSByZW5kZXJlZC4gSWYgd2UgYXJlIGNyZWF0aW5nIGNvbXBvbmVudCBwcm9ncmFtYXRpY2FsbHkgdGhlcmUgaXMgbm8gd2F5IHRvXG4gICAgICogaWRlbnRpZnkgd2hlcmUgdGhlIGFjdHVhbCBuZy1jb250ZW50IGlzIHBsYWNlZCB3aXRoaW4gdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogZS5nLiBDb25zaWRlciBmb2xsb3dpbmcgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqXG4gICAgICogQnV0dG9uIENvbXBvbmVudCBUZW1wbGF0ZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICA8c3BhbiBjbGFzcz1teWJ1dHRvblRpdGxlPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIHlvdSB1c2UgYnV0dG9uIGNvbXBvbmVudCBhcyA8YXctYnV0dG9uPkNsaWNrTWU8L2F3LWJ1dHRvbj4gIHRoZW4gaXRzIHJlbmRlcmVkIGFzXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YXctYnV0dG9uIF9uZ2hvc3RfMTIzPlxuICAgICAqICA8c3BhbiBfbmdjb250ZW50XzEyMyBjbGFzcz1teWJ1dHRvblRpdGxlPkNsaWNrTWU8L3NwYW4+XG4gICAgICogPC9hdy1idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCdXQgd2l0aCBwcm9ncmFtbWF0aWMgQVBJIHlvdSBpbnN0YW50aWF0ZSBCdXR0b24gYW5kIHNpbmNlIGl0IGNyZWF0ZWQgd2l0aG91dCBhIENvbnRlbnQgaXRcbiAgICAgKiBsb29rcyBsaWtlIHRoaXM7XG4gICAgICpcbiAgICAgKiAgYGBgXG4gICAgICogPGF3LWJ1dHRvbiBfbmdob3N0XzEyMz5cbiAgICAgKiAgPHNwYW4gY2xhc3M9bXlidXR0b25UaXRsZT48L3NwYW4+XG4gICAgICogPC9hdy1idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVyZSBkbyB5b3UgcGxhY2UgeW91IGNoaWxkIChjb250ZW50IGNvbXBvbmVudCk/IFRoZXJlZm9yZSB1dGlsaXR5IGNzcyBjbGFzcyB3YXMgY3JlYXRlZFxuICAgICAqIHRvIHdyYXAgPG5nLWNvbnRlbnQ+IHRvIGdldCBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuICAgICAqXG4gICAgICogIGBgYFxuICAgICAqICAgPHNwYW4gY2xhc3M9XCJ1LW5nY29udGVudFwiPlxuICAgICAqICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgPC9zcGFuPlxuICAgICAqICBgYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnRJbnRvUGFyZW50TmdDb250ZW50IChwYXJlbnROYXRpdmVFbDogYW55LCBjaGlsZE5hdGl2ZUVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGluc2VydCBpdCBhcyBjaGlsZCB0byBwYXJlbnROYXRpdmVFbFxuICAgICAgICBsZXQgbmdDb250ZW50UGFyZW50ID0gcGFyZW50TmF0aXZlRWw7XG5cbiAgICAgICAgbGV0IGZvdW5kTmdDb250ZW50ID0gcGFyZW50TmF0aXZlRWwucXVlcnlTZWxlY3RvcignLnUtbmdjb250ZW50Jyk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZm91bmROZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjb3ZlciBhIGNhc2Ugd2hlcmUgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgbmdjb250ZW50c1xuICAgICAgICAgICAgbmdDb250ZW50UGFyZW50ID0gZm91bmROZ0NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbmdDb250ZW50UGFyZW50LmFwcGVuZENoaWxkKGNoaWxkTmF0aXZlRWwpO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGJyb3dzZXIgd2luZG93IHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKlxuICAgICAqL1xuICAgIGJyb3dzZXJEaW1lbnRpb25zICgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodClcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGVsZW1lbWVudHMgZGltZW5zaW9uc1xuICAgICAqXG4gICAgICovXG4gICAgZWxlbWVudERpbWVuc2lvbnMgKGVsZW1lbnQ6IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwfTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIFVuZGVyIEBvcmlnaW5hbC1saWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCBEcmlmdHkgQ28uXG4gKiBodHRwOi8vZHJpZnR5LmNvbS9cbiAqXG4gKiAgTUlUIExpY2Vuc2VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICpcbiAqIENyZWRpdCB0byBkcmlmdHkgZm9yIHRoaXMgZXhjZWxsZW50IGNvbXBvbmVudC4gV2UgaGF2ZSBhIHN0cm9uZyBuZWVkcyBmb3IgZ29vZCBpbmZpbml0ZVxuICogc2Nyb2xsaW5nIGNvbXBvbmVudCBzbyB0aGlzIGlzIGRlcml2ZWQgd29yayBiYXNlZCBvbiB0aGlzIGRyaWZ0eSBjb21wb25lbnQgYXMgd2UgY2FuIG5vdCByZWFsbHlcbiAqIGJyaW5nIGluIHdob2xlIGZyYW1ld29yayBhbmQgdGhlaXIgY29tcG9uZW50L0FQSS4gSXQgd291bGQgYmUgdG9vIGhlYXZ5XG4gKlxuICogQ29tcG9uZW50IGlzIHVwZGF0ZWQgd2l0aCBuYXRpdmUgRE9NIEFQSS4gcGx1cyBzaW1wbGlmaWVkIGJ5IHJlbW92aW5nIHRoaW5nc1xuICogdGhhdCBhcmUgbm90IG5lY2Vzc2FyeSBmb3Igb3VyIHVzZWNhc2UuIFVwZGF0ZWQgZGlyZWN0aXZlIHByZWZpeCB0byBtYXRjaCBvdXIgZ3VpZGVsaW5lc1xuICpcbiAqXG4gKlxuICovXG5cblxuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuLi8uLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGUgSW5maW5pdGUgU2Nyb2xsIGFsbG93cyB5b3UgdG8gcGVyZm9ybSBhbiBhY3Rpb24gd2hlbiB0aGUgdXNlclxuICogc2Nyb2xscyBhIHNwZWNpZmllZCBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b20gb3IgdG9wIG9mIHRoZSBwYWdlLlxuICpcbiAqIFRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvIHRoZSBgaW5maW5pdGVgIGV2ZW50IGlzIGNhbGxlZCB3aGVuXG4gKiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UuIFdoZW4gdGhpcyBleHByZXNzaW9uXG4gKiBoYXMgZmluaXNoZWQgaXRzIHRhc2tzLCBpdCBzaG91bGQgY2FsbCB0aGUgYGNvbXBsZXRlKClgIG1ldGhvZFxuICogb24gdGhlIGluZmluaXRlIHNjcm9sbCBpbnN0YW5jZS5cbiAqXG4gKiAjIyBVc2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiAgPGRpdiAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fSA8L2Rpdj5cbiAqICAgPGF3LWluZmluaXRlLXNjcm9sbCAob25Mb2FkKT1cImRvSW5maW5pdGUoJGV2ZW50KVwiPlxuICogIDwvYXctaW5maW5pdGUtc2Nyb2xsPlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBZb3UgY2FuIGFsc28gc2V0IGEgdGhyZXNob2xkIHRvIGNoYW5nZSB0aGUgZGlzdGFuY2Ugd2hlbiB0aGUgbGF6eSBsb2FkIGtpY2tzXG4gKiBpbi5cbiAqICMjIFVzYWdlXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8ZGl2ICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19IDwvZGl2PlxuICogICA8YXctaW5maW5pdGUtc2Nyb2xsIChvbkxvYWQpPVwiZG9JbmZpbml0ZSgkZXZlbnQpXCIgIFtkaXN0YW5jZV09XCInMTUlJ1wiPlxuICogIDwvYXctaW5maW5pdGUtc2Nyb2xsPlxuICpcbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWluZmluaXRlLXNjcm9sbCcsXG4gICAgdGVtcGxhdGVVcmw6ICdpbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnaW5maXRlLXNjcm9sbC5jb21wb25lbnQuc2NzcyddLFxufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdFxue1xuICAgIF9sYXN0Q2hlY2s6IG51bWJlciA9IDA7XG4gICAgX2xhc3RTY3JvbGxUb3A6IG51bWJlciA9IDA7XG4gICAgX3NjTHNuOiBhbnk7XG4gICAgX3Rocjogc3RyaW5nID0gJzEwJSc7XG4gICAgX3RoclB4OiBudW1iZXIgPSAwO1xuICAgIF90aHJQYzogbnVtYmVyID0gMC4xMDtcbiAgICBfaW5pdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgX2NvbnRlbnQ6IGFueTtcbiAgICBfZG9jQm9keTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGU6IHN0cmluZyA9IFNUQVRFX0VOQUJMRUQ7XG5cbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIHRocmVzaG9sZCBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b21cbiAgICAgKiBvZiB0aGUgY29udGVudCB0byBjYWxsIHRoZSBgb25Mb2FkYCBvdXRwdXQgZXZlbnQgd2hlbiBzY3JvbGxlZC5cbiAgICAgKiBUaGUgdGhyZXNob2xkIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBwZXJjZW50LCBvclxuICAgICAqIGluIHBpeGVscy4gRm9yIGV4YW1wbGUsIHVzZSB0aGUgdmFsdWUgb2YgYDEwJWAgZm9yIHRoZSBgaW5maW5pdGVgXG4gICAgICogb3V0cHV0IGV2ZW50IHRvIGdldCBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgc2Nyb2xsZWQgMTAlXG4gICAgICogZnJvbSB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBVc2UgdGhlIHZhbHVlIGAxMDBweGAgd2hlbiB0aGVcbiAgICAgKiBzY3JvbGwgaXMgd2l0aGluIDEwMCBwaXhlbHMgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlxuICAgICAqIERlZmF1bHQgaXMgYDE1JWAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZGlzdGFuY2UgKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocjtcbiAgICB9XG5cbiAgICBzZXQgZGlzdGFuY2UgKHZhbDogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGhyID0gdmFsO1xuICAgICAgICBpZiAodmFsLmluZGV4T2YoJyUnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJQeCA9IDA7XG4gICAgICAgICAgICB0aGlzLl90aHJQYyA9IChwYXJzZUZsb2F0KHZhbCkgLyAxMDApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aHJQeCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RoclBjID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7Ym9vbGVhbn0gSWYgdHJ1ZSwgV2hldGhlciBvciBub3QgdGhlIGluZmluaXRlIHNjcm9sbCBzaG91bGQgYmVcbiAgICAgKiBlbmFibGVkIG9yIG5vdC4gU2V0dGluZyB0byBgZmFsc2VgIHdpbGwgcmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBhbmQgaGlkZSB0aGUgZGlzcGxheS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBlbmFibGVkIChzaG91bGRFbmFibGU6IGJvb2xlYW4pXG4gICAge1xuICAgICAgICB0aGlzLmVuYWJsZShzaG91bGRFbmFibGUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQG91dHB1dCB7ZXZlbnR9IEVtaXR0ZWQgd2hlbiB0aGUgc2Nyb2xsIHJlYWNoZXNcbiAgICAgKiB0aGUgdGhyZXNob2xkIGRpc3RhbmNlLiBGcm9tIHdpdGhpbiB5b3VyIGluZmluaXRlIGhhbmRsZXIsXG4gICAgICogeW91IG11c3QgY2FsbCB0aGUgaW5maW5pdGUgc2Nyb2xsJ3MgYGNvbXBsZXRlKClgIG1ldGhvZCB3aGVuXG4gICAgICogeW91ciBhc3luYyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkxvYWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cblxuICAgIEBWaWV3Q2hpbGQoJ2xvYWRpblBhbmVsJylcbiAgICBsb2FkUGFuZWw6IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGF6eSBsb2FkIGN1cnJlbnQgbnVtYmVycy4gdGVsbCB0aGUgYXBwIHN0YXJ0aW5nIHBvaW50IGFuZCB3aGF0IGlzIHRoZSBzaXplIG9mIGxvYWRlZFxuICAgICAqIGxpc3RcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZmV0Y2hTaXplOiBudW1iZXIgPSAwO1xuXG4gICAgbG9hZE9mZnNldDogbnVtYmVyID0gMDtcblxuXG4gICAgY29uc3RydWN0b3IgKHByaXZhdGUgX3JlbmRlcjogUmVuZGVyZXIyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgZG9tVXRpbHM6IERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBfY2Q6IENoYW5nZURldGVjdG9yUmVmKVxuICAgIHtcblxuXG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdoYXMtaW5maW5pdGUtc2Nyb2xsJyk7XG5cbiAgICB9XG5cbiAgICBfb25TY3JvbGwgKGV2OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBTVEFURV9ESVNBQkxFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbXVzdCB0aHJvdHRsZSB0aGUgY2xhc3MgYnkgMTAwbXNcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RDaGVjayArIDEwMCA+IGV2LnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjaGVjayBsZXNzIHRoYW4gZXZlcnkgWFhtc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdENoZWNrID0gZXYudGltZVN0YW1wO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3AoKTtcblxuICAgICAgICBsZXQgd2luSGVpZ2h0ID0gdGhpcy5kb21VdGlscy5icm93c2VyRGltZW50aW9ucygpLmhlaWdodDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5fZG9jQm9keS5zY3JvbGxIZWlnaHQsIHRoaXMuX2RvY0JvZHkub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgd2luSGVpZ2h0LCB0aGlzLl9jb250ZW50LnNjcm9sbEhlaWdodCwgdGhpcy5fY29udGVudC5vZmZzZXRIZWlnaHQpO1xuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuX3RoclBjID8gKGhlaWdodCAqIHRoaXMuX3RoclBjKSA6IHRoaXMuX3RoclB4O1xuICAgICAgICBsZXQgZGlzdGFuY2VGcm9tSW5maW5pdGUgPSB0aGlzLl9jb250ZW50LnNjcm9sbEhlaWdodCAtIHdpbkhlaWdodCAtIHNjcm9sbFRvcCAtIHRocmVzaG9sZDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnRG9jdW1lbnQgaGVpZ2h0ICgnICsgaGVpZ2h0ICsgJykgLCBEaXN0YW5jZSBmcm9tIGJvdHRvbSAnXG4gICAgICAgIC8vICsgZGlzdGFuY2VGcm9tSW5maW5pdGUgKyAnLCAgPT4gdGhyZXNob2xkID0gJyArXG4gICAgICAgIC8vICAgICB0aGlzLmRpc3RhbmNlICsgJyAoJyArIHRocmVzaG9sZCArICcpJyk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlRnJvbUluZmluaXRlIDwgMCAmJiB0aGlzLl9sYXN0U2Nyb2xsVG9wIDwgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlMb2FkKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0U2Nyb2xsVG9wID4gc2Nyb2xsVG9wICYmIHNjcm9sbFRvcCA8IHdpbkhlaWdodFxuICAgICAgICAgICAgJiYgdGhpcy5sb2FkT2Zmc2V0ICE9PSB0aGlzLmZldGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5VW5Mb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZG86IHJlZmFjdG9yIHRvIG9uZSBtZXRob2RcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpcmVPbkxhenlMb2FkICgpXG4gICAge1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORyAmJiB0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9MT0FESU5HO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGlzTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMuZmV0Y2hTaXplLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubG9hZE9mZnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9uIHRoZSBuZXh0IHJlY29yZFxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE9mZnNldCArPSB0aGlzLmZldGNoU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGZpcmVPbkxhenlVbkxvYWQgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0xPQURJTkc7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvbiB0aGUgbmV4dCByZWNvcmRcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRPZmZzZXQgPSB0aGlzLmZldGNoU2l6ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpc0xvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5mZXRjaFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sb2FkT2Zmc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBzY3JvbGxUb3AgKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgdGhpcy5fY29udGVudC5zY3JvbGxUb3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYGNvbXBsZXRlKClgIHdpdGhpbiB0aGUgYGluZmluaXRlYCBvdXRwdXQgZXZlbnQgaGFuZGxlciB3aGVuXG4gICAgICogeW91ciBhc3luYyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC4gRm9yIGV4YW1wbGUsIHRoZSBgbG9hZGluZ2BcbiAgICAgKiBzdGF0ZSBpcyB3aGlsZSB0aGUgYXBwIGlzIHBlcmZvcm1pbmcgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbixcbiAgICAgKiBzdWNoIGFzIHJlY2VpdmluZyBtb3JlIGRhdGEgZnJvbSBhbiBBSkFYIHJlcXVlc3QgdG8gYWRkIG1vcmUgaXRlbXNcbiAgICAgKiB0byBhIGRhdGEgbGlzdC4gT25jZSB0aGUgZGF0YSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgVUkgdXBkYXRlZCwgeW91XG4gICAgICogdGhlbiBjYWxsIHRoaXMgbWV0aG9kIHRvIHNpZ25pZnkgdGhhdCB0aGUgbG9hZGluZyBoYXMgY29tcGxldGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2hhbmdlIHRoZSBpbmZpbml0ZSBzY3JvbGwncyBzdGF0ZSBmcm9tIGBsb2FkaW5nYFxuICAgICAqIHRvIGBlbmFibGVkYC5cbiAgICAgKi9cbiAgICBjb21wbGV0ZSAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0VOQUJMRUQ7XG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJpZ2dlciBleHRyYSBkZXRlY3QgY2hhbmdlcyB0byByZXJlbmRlciBsb2FkaW5nIGljb25cbiAgICAgICAgICAgIHRoaXMuX2NkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYGVuYWJsZShmYWxzZSlgIHRvIGRpc2FibGUgdGhlIGluZmluaXRlIHNjcm9sbCBmcm9tIGFjdGl2ZWx5XG4gICAgICogdHJ5aW5nIHRvIHJlY2VpdmUgbmV3IGRhdGEgd2hpbGUgc2Nyb2xsaW5nLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWxcbiAgICAgKiB3aGVuIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRoYXQgY2FuIGJlIGFkZGVkLCBhbmRcbiAgICAgKiB0aGUgaW5maW5pdGUgc2Nyb2xsIGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAgICogQHBhcmFtIHNob3VsZEVuYWJsZSAgSWYgdGhlIGluZmluaXRlIHNjcm9sbCBzaG91bGQgYmVcbiAgICAgKiBlbmFibGVkIG9yIG5vdC4gU2V0dGluZyB0byBgZmFsc2VgIHdpbGwgcmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBhbmQgaGlkZSB0aGUgZGlzcGxheS5cbiAgICAgKi9cbiAgICBlbmFibGUgKHNob3VsZEVuYWJsZTogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAoc2hvdWxkRW5hYmxlID8gU1RBVEVfRU5BQkxFRCA6IFNUQVRFX0RJU0FCTEVEKTtcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKHNob3VsZEVuYWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBuYXRpdmUgd2luZG93cyBzY3JvbGwgZXZlbnRcbiAgICAgKi9cbiAgICBfc2V0TGlzdGVuZXJzIChzaG91bGRMaXN0ZW46IGJvb2xlYW4pXG4gICAge1xuICAgICAgICBpZiAodGhpcy5faW5pdCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZExpc3Rlbikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2NMc24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY0xzbiA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2NMc24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zY0xzbikpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3NjTHNuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NMc24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaXNMb2FkaW5nICgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU1RBVEVfTE9BRElORztcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kb2NCb2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnModGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eUxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGZhbHNlKTtcbiAgICB9XG5cbn1cblxuXG5jb25zdCBTVEFURV9FTkFCTEVEID0gJ2VuYWJsZWQnO1xuY29uc3QgU1RBVEVfRElTQUJMRUQgPSAnZGlzYWJsZWQnO1xuY29uc3QgU1RBVEVfTE9BRElORyA9ICdsb2FkaW5nJztcbiIsImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBd05hbWVTdG9yZSB7XG5cbiAgICBwcml2YXRlIHN0b3JlOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgYWRkKG5hbWU6IHN0cmluZywgZWw6IGFueSkge1xuICAgICAgICBpZiAodGhpcy5jb2xsaWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIGlzIG5vdCB1bmlxdWUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuc2V0KG5hbWUsIGVsKTtcbiAgICB9XG5cbiAgICByZW1vdmUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmRlbGV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuaGFzKG5hbWUpO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1xuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5wdXQsXG4gICAgT25Jbml0LFxuICAgIERpcmVjdGl2ZSxcbiAgICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEFwcENvbmZpZ1xufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuaW1wb3J0IHtcbiAgICBBd05hbWVTdG9yZVxufSBmcm9tICcuL2F3LW5hbWUuc3RvcmUnO1xuXG4vKipcbiAqIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgYXR0YWNoZXMgYSBpZGVudGlmaWVyIHRvIGRlY29yYXRlZCBlbGVtZW50IHRvIGFpZCBzZWxlY3RvcnMgZm9yIHRlc3RpbmdcbiAqIHB1cnBvc2VzLiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIHRyaWVzIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgYmFzZWQgb24gY29udGV4dHVhbCBkYXRhXG4gKiBhbmQgaW5oZXJhbnQgaW1tdXRhYmxlIGVsZW1lbnQgYXR0cmlidXRlcy5cbiAqXG4gKiAqKkdlbmVyYXRpbmcgdGhlIEJhc2UgTmFtZSoqXG4gKlxuICogVGhlICdhd05hbWUnIGRpcmVjdGl2ZSBnZW5lcmF0ZXMgYSBiYXNlIG5hbWUgZnJvbSBlbGVtZW50IHRhZyBuYW1lIGFuZCBhdHRyaWJ1dGVzIHdoaWNoIGFyZVxuICogc3RhdGljIGJ5IG5hdHVyZS5cbiAqXG4gKiAgICAgRXhhbXBsZTpcbiAqICAgICAgICAgPGJ1dHRvbiBuYW1lPVwib3JkZXJcIiBhd05hbWU+XG4gKlxuICogICAgIFJlc3VsdDpcbiAqICAgICAgICAgPGJ1dHRvbiBuYW1lPVwib3JkZXJcIiBhd25hbWU9XCJidXR0b25fb3JkZXJcIj5cbiAqXG4gKiBJZiB0aGUgZWxlbWVudCBoYXMgYW4gJ2lkJywgdGhhdCB2YWx1ZSB0YWtlcyBwcmVjZWRlbnQgYW5kIGlzIHVzZWQgaW5zdGVhZCBvZiBhIGdlbmVyYXRlZFxuICogbmFtZS5cbiAqXG4gKiAgICAgRXhhbXBsZTpcbiAqICAgICAgICAgPGJ1dHRvbiBuYW1lPVwib3JkZXJcIiBpZD1cIm15T3JkZXJCdXR0b25cIiBhd05hbWU+XG4gKlxuICogICAgIFJlc3VsdDpcbiAqICAgICAgICAgPGJ1dHRvbiBuYW1lPVwib3JkZXJcIiBpZD1cIm15T3JkZXJCdXR0b25cIiBhd25hbWU9XCJidXR0b25fbXlPcmRlckJ1dHRvblwiPlxuICpcbiAqXG4gKiAqKlJlcGVhdGVkIEVsZW1lbnRzIGFuZCB0aGUgJ2V4dCcgUGFyYW1ldGVyKipcbiAqXG4gKiBUaGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSBlbGVtZW50cyBhcmUgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IGluIHRoZSBjb2RlIGFzIGxpc3RzIG9yIHRhYmxlcy5cbiAqIEluIHN1Y2ggY2FzZXMsIGl0IG1heSBub3QgYmUgZWFzeSB0byBkaXN0aW5ndWlzaCBpbmRpdmlkdWFsIGVsZW1lbnRzIGJ5IHN0YW5kYXJkIEhUTUxcbiAqIGF0dHJpYnV0ZXMsIHNvIHRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgYWxsb3dzIGN1c3RvbSBleHRlbnRpb25zIHRvIHRoZSBiYXNlIG5hbWUgdG8gYmUgcHJvdmlkZWRcbiAqIHVzaW5nIHRoZSAnZXh0JyBhdHRyaWJ1dGUuXG4gKlxuICogICAgRXhhbXBsZTpcbiAqICAgICAgICBmcnVpdHMgPSBbJ2FwcGxlJywgJ2JhbmFuYScsICdvcmFuZ2UnXTtcbiAqXG4gKiAgICAgICAgPHVsPlxuICogICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGZydWl0IG9mIGZydWl0c1wiIGF3TmFtZSBleHQ9XCJ7e2ZydWl0fX1cIj57e2ZydWl0fX08L2xpPlxuICogICAgICAgIDwvdWw+XG4gKlxuICogICBSZXN1bHQ6XG4gKiAgICAgICA8dWw+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX2FwcGxlXCI+YXBwbGU8L2xpPlxuICogICAgICAgICAgIDxsaSBhd25hbWU9XCJsaV9iYW5hbmFcIj5iYW5hbmE8L2xpPlxuICogICAgICAgICAgIDxsaSBhd25hbWU9XCJsaV9vcmFuZVwiPm9yYW5nZTwvbGk+XG4gKiAgICAgICA8L3VsPlxuICpcbiAqICoqQWRkaW5nIENvbnRleHQgVGhyb3VnaCBBbmNlc3RvciBJbnNwZWN0aW9uKipcbiAqXG4gKiBJbiBvcmRlciB0byBwcm92aWRlIGNvbnRleHQgdG8gdGhlIGVsZW1lbnQgbmFtaW5nLCB0aGUgJ2F3TmFtZScgZGlyZWN0aXZlIGxvb3BzIHRocm91Z2ggdGhlXG4gKiBwYXJlbnQgYW5jZXN0cnkgYW5kIHNlYXJjaGVzIGZvciBhbnkgdW5pcXVlIGVsZW1lbnQgJ2lkJyB0byBwcmVwZW5kIHRvIHRoZSBiYXNlIG5hbWUuXG4gKlxuICogICAgIEV4YW1wbGU6XG4gKiAgICAgICAgIDxmb3JtIGlkPVwiYXBwbGljYW50XCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgPC9mb3JtPlxuICogICAgICAgICA8Zm9ybSBpZD1cInNwb3VzZVwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZmlyc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8Zm9ybSBpZD1cImFwcGxpY2FudFwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZmlyc3ROYW1lXCIgYXduYW1lPVwiYXBwbGljYW50X2lucHV0X2ZpcnN0TmFtZVwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBhd25hbWU9XCJhcHBsaWNhbnRfaW5wdXRfbGFzdE5hbWVcIj5cbiAqICAgICAgICAgPC9mb3JtPlxuICogICAgICAgICA8Zm9ybSBpZD1cInNwb3VzZVwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZmlyc3ROYW1lXCIgYXduYW1lPVwic3BvdXNlX2lucHV0X2ZpcnN0TmFtZVwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBhd25hbWU9XCJzcG91c2VfaW5wdXRfbGFzdG5hbWVcIj5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICoqVW5pcXVlbmVzcyBDaGVjayoqXG4gKlxuICogJ2F3TmFtZScga2VlcHMgdHJhY2sgb2YgdGhlIG5hbWVzIGl0IGNyZWF0ZXMgYnkgYWRkaW5nIHRoZW0gdG8gYSBtYXAgc3RvcmUuIFdoZW5ldmVyIGl0XG4gKiBjcmVhdGVzIGEgbmV3IG5hbWUgZHVyaW5nIHRoZSBgbmdPbkluaXRgIHBoYXNlIGl0IGNoZWNrcyBpdCBhZ2FpbnN0IHRoZSBleGlzdGluZyBtYXAsXG4gKiBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBpdCBlbmNvdW50ZXJzIGEgZHVwbGljYXRlLiBNb3Jlb3ZlciBkdXJpbmcgdGhlIGVsZW1lbnQgZGVzdHJ1Y3Rpb25cbiAqIHBoYXNlLCBgbmdPbkRlc3Ryb3lgLCAnYXdOYW1lJyByZW1vdmVzIHRoZSBnZW5lcmF0ZWQgbmFtZSBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKlxuICogKipJbiBQcm9kdWN0aW9uKipcbiAqXG4gKiBVc2luZyAnYXdOYW1lJyBhZGRzIGEgc21hbGwgYml0IG9mIHJlbmRlcmluZyBvdmVyaGVhZCBmb3IgZWFjaCBlbGVtZW50IGl0IGlzIHVzZWQgb24uIEluXG4gKiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsICdhd05hbWUnIHNlcnZlcyBubyBmdW5jdGlvbmFsaXR5IHRvIHRoZSBlbmQgdXNlciwgYnV0IG1heSBoYXZlXG4gKiBhIHBlcmZvcm1hbmNlIGltcGFjdCBvbiB0aGUgYXBwbGljYXRpb24uIEFzIHN1Y2gsICdhd05hbWUnIHRha2VzIGludG8gYWNjb3VudCB0aGVcbiAqIGBBcHBDb25maWdgIHNldHRpbmdzIGFuZCBkaXNhYmxlcyBuYW1lIGdlbmVyYXRpb24gd2hlbiBgQXBwQ29uZmlnLmlzUHJvZHVjdGlvbk1vZGUoKWBcbiAqIGlzIGB0cnVlYC5cbiAqXG4gKiBJbiB5b3VyIGFwcGxpY2F0aW9uLCB5b3UgY2FuIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIGJ5IHNldHRpbmcgYGRldm1vZGUuZW5hYmxlZGAgdG9cbiAqIGBmYWxzZWAgd2hlbiBjb25maWd1cmluZyBgQXJpYmFDb3JlTW9kdWxlYDpcbiAqXG4gKiAgICAgQXJpYmFDb3JlTW9kdWxlLmZvclJvb3Qoe1xuICogICAgICAgICAnZGV2bW9kZS5lbmFibGVkJzogZmFsc2VcbiAqICAgICB9KVxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbYXdOYW1lXScsXG59KVxuZXhwb3J0IGNsYXNzIEF3TmFtZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGV4dDogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBuYW1lOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIHNlcGFyYXRvcjogc3RyaW5nID0gJ18nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgc3RvcmU6IEF3TmFtZVN0b3JlLFxuICAgICAgICBwcml2YXRlIGNvbmZpZzogQXBwQ29uZmlnXG4gICAgKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNyZWF0ZU5hbWUodGhpcy5lbCk7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRUb1N0b3JlKHRoaXMubmFtZSwgdGhpcy5lbCk7XG4gICAgICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhd25hbWUnLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5yZW1vdmUodGhpcy5uYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZWxlbWVudCBuYW1lL2lkIGFuZCByZWZlcmVuY2UgdG8gbWFwIHN0b3JlLiBJZiBuYW1lL2lkIGFscmVhZHlcbiAgICAgKiBleGlzdHMgaW4gc3RvcmUgdGhlbiBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRFbGVtZW50VG9TdG9yZShuYW1lOiBzdHJpbmcsIGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuYWRkKG5hbWUsIGVsZW0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSArIGAuIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlLmAsIGVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuYW1lL2lkIGZvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqIEByZXR1cm4gU3RyaW5nIE5hbWUvSURcbiAgICAgKi9cbiAgICBjcmVhdGVOYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGhpcy5nZXRUYWdOYW1lKGVsZW0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXJyYXkgb2Ygc3RyaW5nIHBhcnRzXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICAgICAgLy8gRmluZCBhbmNlc3RvciB0YWcgaWQsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBjb25zdCBwYXJlbnRJRCA9IHRoaXMuZ2V0QW5jZXN0b3JJZChlbGVtKTtcbiAgICAgICAgaWYgKHBhcmVudElEKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcmVudElEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB0YWcgdHlwZVxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSB0aGlzLmdldFBhcmVudE5hbWUoZWxlbSk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGFnbmFtZVxuICAgICAgICBwYXJ0cy5wdXNoKHRhZ05hbWUpO1xuXG4gICAgICAgIC8vIENob29zZSBpZCBwcm9wZXJ0eSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5pZCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChlbGVtLm5hdGl2ZUVsZW1lbnQuaWQpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBidWlsZCBleHRlbnNpb24gZnJvbSB0YWcgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCduYW1lJykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZhbHVlIGF0dHJpYnV0ZSBpZiAnb3B0aW9uJyB0YWdcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUoZWxlbS5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjdXN0b20gZXh0ZW5zaW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5leHQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUodGhpcy5leHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMuc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGFnIG5hbWUgZnJvbSBlbGVtZW50IHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWUoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gZWxlbS5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBlbGVtZW50IGFuY2VzdHJ5IGFuZCByZXR1cm4gZmlyc3QgaWQgYXR0cmlidXRlXG4gICAgICogZW5jb3VudGVyZWQuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRBbmNlc3RvcklkKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBsZXQgaWQgPSAnJztcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhaWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBhcmVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbmFtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgaWYgbmFtZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0UGFyZW50TmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4gKHBhcmVudC5uYW1lICYmICFwYXJlbnQuaWQpID8gcGFyZW50Lm5hbWUgOiBudWxsO1xuICAgIH1cblxuICAgIHNwYWNlc1RvVW5kZXJzY29yZShzdHI6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccysvZywgJ18nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RW1iZWRkZWRJdGVtRGlyZWN0aXZlfSBmcm9tICcuL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50fSBmcm9tICcuL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0luY2x1ZGVDb21wb25lbnREaXJlY3RpdmV9IGZyb20gJy4vaW5jbHVkZS1jb21wb25lbnQuZGlyZWN0aXZlJztcbmltcG9ydCB7RXJyb3JNZXNzYWdlc0NvbXBvbmVudH0gZnJvbSAnLi9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0N1cnJlbmN5Rm9ybWF0UGlwZX0gZnJvbSAnLi9waXBlcy9jdXJyZW5jeS1mb3JtYXQucGlwZSc7XG5pbXBvcnQge05nRm9yU2V0RGlyZWN0aXZlfSBmcm9tICcuL29uLW5nZm9yLXNldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7QXdOYW1lRGlyZWN0aXZlfSBmcm9tICcuL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEVtYmVkZGVkSXRlbURpcmVjdGl2ZSxcbiAgICAgICAgSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZSxcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgRXJyb3JNZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIEN1cnJlbmN5Rm9ybWF0UGlwZSxcbiAgICAgICAgTmdGb3JTZXREaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50LFxuICAgICAgICBBd05hbWVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50LCBub29wfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFByb3ZpZGVzIGRlZmF1bHRzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBtb2RhbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RhbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6ICgpID0+IHZvaWQgPSBub29wO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGNsb3NlcyB0aGUgZGlhbG9nIGJ5IGNhbGxpbmcgZGVzdHJveSBvbiB0aGUgY29tcG9uZW50IHJlZmVyZW5jZS5cbiAgICAgKiBNZXRob2QgaW5oZXJpdGVkIGJ5IGFsbCBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2xvc2VNb2RhbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgaXNTdHJpbmdNYXAsIGlzVHlwZSwgb2JqZWN0VG9OYW1lfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSBhZ2dyZWdhdGVzIGRpZmZlcmVudCBEYXRhUHJvdmlkZXJzIHBlciB0eXBlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG57XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGNsYXNzIG5hbWUgdG8gRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeUJ5UHJvdmlkZXI6IE1hcDxzdHJpbmcsIERhdGFQcm92aWRlcjxhbnk+PjtcblxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzIE5hbWUgIHRvIGFjdHVhbCB0eXBlXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeU5hbWVUb0NsYXNzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlciA9IG5ldyBNYXA8c3RyaW5nLCBEYXRhUHJvdmlkZXI8YW55Pj4oKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZXZlcnkgc2luZ2xlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIHdlIGFsc28gbmVlZCBzdG9yZSBpdHMgcHJvdG90eXBlXG4gICAgICogaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBzdXBwb3J0IHNvbWUga2luZCBvZiBpbmhlcml0YW5jZS4gWW91IGNhbiByZWdpc3RlciBhIHByb3ZpZGVyIGZvclxuICAgICAqIGEgcGFyZW50IGNsYXNzIGlmIG5lZWRlZFxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJQcm92aWRlcjxUPih0YXJnZXQ6IGFueSwgcHJvdmlkZXI6IERhdGFQcm92aWRlcjxUPik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRhcmdldCkgfHwgKCFpc1N0cmluZ01hcCh0YXJnZXQpICYmICFpc1R5cGUodGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIENhbm5vdCByZWdpc3RlciBub24tb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmFtZSA9IGlzVHlwZSh0YXJnZXQpID8gdGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIDogdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0cnlCeVByb3ZpZGVyLnNldChuYW1lLCBwcm92aWRlcik7XG5cbiAgICAgICAgbGV0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3Muc2V0KG5hbWUsIHByb3RvdHlwZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGJlc3QgbWF0Y2hpbmcgcHJvdmlkZXIuIElmIG5vdCBmb3VuZCB0aGVuIHVzZSBvYmplY3QgcHJvdG90eXBlIHRvIGdldCBob2xkIG9mIGl0c1xuICAgICAqIHBhcmVudCBhbmQgc2VlIGlmIHRoZXJlIGlzIGEgcHJvdmlkZXIgcmVnaXN0ZXJlZCBvbiB0aGlzIGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBiZXN0TWF0Y2hGb3JDbGFzczxUPihjbGFzc05hbWU6IHN0cmluZyk6IERhdGFQcm92aWRlcjxUPlxuICAgIHtcbiAgICAgICAgbGV0IHJlZ2lzdGVyZWRDbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGxldCBjbGFzc1Byb3RvID0gdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLmdldChjbGFzc05hbWUpO1xuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocmVnaXN0ZXJlZENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+ID0gdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuZ2V0KHJlZ2lzdGVyZWRDbGFzc05hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnR5cGUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHbyB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY2xhc3NQcm90bykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnROYW1lID0gb2JqZWN0VG9OYW1lKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAoaXNQcmVzZW50KHBhcmVudE5hbWUpICYmIHBhcmVudE5hbWUgIT09IHJlZ2lzdGVyZWRDbGFzc05hbWUpID8gcGFyZW50TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIGJlc3RNYXRjaEZvckNsYXNzKCkgd2l0aCB0aGUgZGlmZmVyZW5jZSB0byBwYXNzIGEgdHlwZS4gSWYgeW91IHdhbnQgdG9cbiAgICAgKiBzdXBwb3J0IG9iamVjdCBpbmhlcml0YW5jZSB5b3UgbmVlZCB0aGlzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBiZXN0TWF0Y2hGb3JUeXBlPFQ+KHR5cGU6IFR5cGU8VD4pOiBEYXRhUHJvdmlkZXI8VD5cbiAgICB7XG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBvYmplY3RUb05hbWUodHlwZSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVzdE1hdGNoRm9yQ2xhc3M8VD4obmFtZSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogUHJvdmlkZXIgaXMgYSBkYXRhIGRyaXZlciB0aGF0IGNhbiBhY2Nlc3MgZGF0YSBhbmQgcmV0cmlldmUgdGhlbS4gSXQga25vd3MgaG93IHRvIGdldCAxXG4gKiBvciBtb3JlIHJlY29yZHMsIG1heWJlIGRvIHBhZ2luZyBhbmQgc29tZSBvdGhlciB0aGluZ3MuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVByb3ZpZGVyPFQ+XG57XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXJyZW50IHR5cGUgZm9yIHRoaXMgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgdHlwZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIHRoZSBsaXN0ZW5lcnMgaW4gY2FzZSBvZiBkYXRhIGFyZSBhdmFpbGFibGUgb3IgaWYgdGhleSBjaGFuZ2VkIGR1ZSB0byBzb21lIHVzZXJcbiAgICAgKiBpbnRlcmFjdGlvbiAgKHNlYXJjaCwgYWRkaW5nIG9yIHJlbW92aW5nKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGRhdGFDaGFuZ2VzOiBCZWhhdmlvclN1YmplY3Q8VFtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VFtdPihbXSk7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGRhdGEgc291cmNlIHBvcHVsYXRlZCBieSBmZXRjaCBvciBzZWFyY2guIEpTIGFwcGxpY2F0aW9uIGNhbiBob2xkIGxhcmdlIGFtb3VudCBvZlxuICAgICAqIHJlY29yZHMgd2l0aG91dCBnb2luZyBiYWNrIHRvIHRoZSBSRVNUIHNlcnZlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWNoZSBzZWFyY2ggcmVzdWx0IG9uXG4gICAgICogdGhlIGNsaWVudCBzaXRlLlxuICAgICAqXG4gICAgICovXG4gICAgb2ZmU2NyZWVuRGF0YTogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gc2l6ZSBvZiB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBleHBlY3RlZENvdW50KHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvciB1c2UgY2FzZXMgd2hlcmUgd2UgbmVlZCB0byByZXRyaWV2ZSBkYXRhIGJhc2VkIG9uIHNvbWUgY3JpdGVyaWEgZS5nLlxuICAgICAqXG4gICAgICogIC0gbWF4IG51bWJlciBvZiByZWNvcmRzXG4gICAgICogIC0gc3VwcG9ydCBwYWdpbmcgd2l0aCBvZmZzZXQgYW5kIGxpbWl0XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBieSBmZXRjaFxuICAgICAqL1xuICAgIGFic3RyYWN0IGRhdGFGb3JQYXJhbXMocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogQXJyYXk8VD47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmV0Y2hlcyBkYXRhIGZyb20gdW5kZXJseWluZyBkYXRhUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgZGF0YWZvclBhcmFtc1xuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZmV0Y2gocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogT2JzZXJ2YWJsZTxUW10+O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIG5vbi1hc3luYyBjdXJyZW50IHN0YXRlIG9mIGRhdGFcbiAgICAgKi9cbiAgICBkYXRhKCk6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgSU5TRVJULCBSRU1PVkVcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbkNSVUQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgcXVlcnkgY2FwYWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgY2FuUXVlcnkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBzdXBwb3J0IGluc2VydGlvbi4gQWZ0ZXIgcmVjb3JkIGlzIGluc2VydGVkIGVtaXQgZXZlbnQgZm9yIGRhdGFDaGFuZ2VzIHRvXG4gICAgICogaW5mb3JtIGFsbCBzdWJzY3JpYmVyc1xuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0KG9iajogYW55KTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBzdXBwb3J0IHJlY29yZCByZW1vdmFsLiBBZnRlciByZWNvcmQgaXMgcmVtb3ZlZCBlbWl0IGV2ZW50IGZvciBkYXRhQ2hhbmdlcyB0b1xuICAgICAqIGluZm9ybSBhbGwgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHByb3ZpZGUgYWNjZXNzIHRvIGxvdyBsZXZlbCBzZWFyY2cgQVBJLlxuICAgICAqXG4gICAgICovXG4gICAgcXVlcnkocGFyYW1zOiBNYXA8c3RyaW5nLCBzdHJpbmc+KTogdm9pZFxuICAgIHtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtGaWVsZFBhdGgsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZn0gZnJvbSAncnhqcyc7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBBcnJheXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheURhdGFQcm92aWRlcjxUPiBleHRlbmRzIERhdGFQcm92aWRlcjxUPlxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkICB2YWx1ZXM6IEFycmF5PFQ+KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gQXJyYXk7XG5cbiAgICAgICAgdGhpcy5vZmZTY3JlZW5EYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZXMubmV4dCh0aGlzLnZhbHVlcyk7XG4gICAgfVxuXG4gICAgZXhwZWN0ZWRDb3VudChwYXJhbXM/OiBNYXA8c3RyaW5nLCBhbnk+KTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZTY3JlZW5EYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBkYXRhRm9yUGFyYW1zKHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBBcnJheTxUPlxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmU2NyZWVuRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMub2ZmU2NyZWVuRGF0YTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmFtcykgJiYgcGFyYW1zLmhhcygnb2Zmc2V0JykgJiYgcGFyYW1zLmhhcygnbGltaXQnKSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHBhcmFtcy5nZXQoJ29mZnNldCcpO1xuICAgICAgICAgICAgbGV0IGxpbWl0ID0gcGFyYW1zLmdldCgnbGltaXQnKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gKG9mZnNldCArIGxpbWl0KSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGFzKCdvcmRlcmJ5JykgJiYgcGFyYW1zLmhhcygnc2VsZWN0b3InKSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGRhdGEsIHBhcmFtcy5nZXQoJ29yZGVyYnknKSwgcGFyYW1zLmdldCgnc2VsZWN0b3InKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG5cbiAgICBmZXRjaChwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YodGhpcy5kYXRhRm9yUGFyYW1zKHBhcmFtcykpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igc29ydGluZyBjdXJyZW50IGRhdGFzZXQgYnkgb25lIGNvbHVtbiAvIGtleVxuICAgICAqXG4gICAgICogZm9yIHNvcnRPcmRlcmluZyBwbGVhc2Ugc2VlIERhdGF0YWJsZSBhbmQgaXRzIHNvcnRPcmRlcmluZ0Zvck51bWJlcigpXG4gICAgICpcbiAgICAgKiAgICAgIDEgID0gYXNjZW5kaW5nXG4gICAgICogICAgICAtMSA9IGRlc2NlbmRpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIHNvcnQoYXJyYXlUb1NvcnQ6IGFueVtdLCBrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBhcnJheVRvU29ydC5zb3J0KChkYXRhMTogYW55LCBkYXRhMjogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdmFsdWUxID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTEsIGtleSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUyID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTIsIGtleSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlMSA9PSBudWxsICYmIHZhbHVlMiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlMSAhPSBudWxsICYmIHZhbHVlMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUxID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlMS5sb2NhbGVDb21wYXJlKHZhbHVlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICh2YWx1ZTEgPCB2YWx1ZTIpID8gLTEgOiAodmFsdWUxID4gdmFsdWUyKSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHNvcnRPcmRlciAqIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyLCBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc0FycmF5LCBpc1N0cmluZ30gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuXG5cbi8qKlxuICogUHJvdmlkZXMgdG9wIGxldmVsIGFjY2Vzc29yIGNsYXNzIGluIG9yZGVyIHRvIG1ha2Uge0BsaW5rIERhdGFQcm92aWRlcn0gcmV0cmlldmFsIHByb2Nlc3MgZWFzaWVyLlxuICogVXNpbmcge0BsaW5rIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gd2UgZWl0aGVyIHJldHJpZXZlIHJlZ2lzdGVyZWQgaW5zdGFuY2Ugb2YgY29uY3JldGVcbiAqIHByb3ZpZGVyIG9yIGluc3RhbnRpYXRlIG91ciBpbXBsaWNpdCBwcm92aWRlciBmb3IgbmF0aXZlIHR5cGVzIHN1Y2ggYXMgQXJyYXkuXG4gKlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFQcm92aWRlcnNcbntcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWdpc3RyeTogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5KVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyAgRGF0YVByb3ZpZGVyIG9yIGNyZWF0ZSBuZXcgb25lIGluIGNhc2Ugb2YgQXJyYXlcbiAgICAgKiBNb3JlIHJvb20gdG8gcmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIHNvbWUgb3RoZXIgaW1wbGljaXQgUHJvdmlkZXJzXG4gICAgICovXG4gICAgZmluZCh0YXJnZXQ6IGFueSk6IERhdGFQcm92aWRlcjxhbnk+XG4gICAge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5RGF0YVByb3ZpZGVyKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yQ2xhc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmJlc3RNYXRjaEZvclR5cGUodGFyZ2V0KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgcHJvdmlkZXIgd2l0aGluIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXI8VD4odGFyZ2V0OiBhbnksIHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIodGFyZ2V0LCBwcm92aWRlcik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNBcnJheSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNKc09iamVjdCxcbiAgICBpc1ByZXNlbnQsXG4gICAgb2JqZWN0VG9OYW1lLFxuICAgIG9iamVjdFZhbHVlcyxcbiAgICB1bmltcGxlbWVudGVkXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtBcnJheURhdGFQcm92aWRlcn0gZnJvbSAnLi9hcnJheS1kYXRhLXByb3ZpZGVyJztcbmltcG9ydCB7T3V0bGluZU5vZGV9IGZyb20gJy4uLy4uL3dpZGdldHMvb3V0bGluZS9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIFByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgZGlmZmVyZW50IGRhdGEgRmluZGVycyB1c2VkIG1vc3RseSBieSBEYXRhU291cmNlcy4gQWxsIEZpbmRlcnMgYXJlXG4gKiByZWdpc3RlcmVkIGJ5IHRoaXMgY2xhc3MgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgbmVlZHMgcmlnaHQgbm93IHRvIGV4cG9zZSB0aGlzIHRvIGRldmVsb3Blci5cbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhRmluZGVyc1xue1xuXG4gICAgcHJpdmF0ZSBmaW5kZXJzQnlUeXBlOiBNYXA8RGF0YUZpbmRlciwgVHlwZTxEYXRhRmluZGVyPj4gPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLmluaXRGaW5kZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgRGF0YUZpbmRlciBiYXNlZCBvbiB0aGUgb2JqZWN0IHR5cGUgYW5kIHF1ZXJ5VHlwZS5cbiAgICAgKi9cbiAgICBmaW5kKGZvclByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogRGF0YUZpbmRlclxuICAgIHtcblxuICAgICAgICBsZXQgZmluZGVyTWF0Y2g6IFR5cGU8RGF0YUZpbmRlcj47XG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5mb3JFYWNoKCh2OiBUeXBlPERhdGFGaW5kZXI+LCBrOiBEYXRhRmluZGVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoay5hY2NlcHRzKGZvclByb3ZpZGVyLCBmb3JUeXBlKSkge1xuICAgICAgICAgICAgICAgIGZpbmRlck1hdGNoID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChmaW5kZXJNYXRjaCkpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IGZpbmRlck1hdGNoKCk7XG4gICAgICAgICAgICBjb3B5LmZvckRhdGEoZm9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbmV3IGZpbmRlclxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXI8VD4ocHJvdG90eXBlOiBEYXRhRmluZGVyLCB0eXBlOiBUeXBlPERhdGFGaW5kZXI+KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChwcm90b3R5cGUsIHR5cGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEZpbmRlcnMoKVxuICAgIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcHJvdG90eXBlIGZvciBlYWNoXG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5zZXQobmV3IEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKCksIEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKTtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChuZXcgT3V0bGluZUZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKCksXG4gICAgICAgICAgICBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIpO1xuXG4gICAgfVxufVxuXG4vKipcbiAqIFdlIGhhdmUgZGlmZmVyZW50IG9wdGlvbnMgaG93IHRvIHF1ZXJ5IGRhdGEuIEZ1bGxUZXh0IHVzZXMgYSBzdHJpbmcgd2hlcmUgcHJlZGljYXRlIGlzXG4gKiB1c2luZyBrZXk6dmFsdWUgcGFpciB0byBidWlsdCBhIHF1ZXJ5XG4gKi9cbmV4cG9ydCBlbnVtIFF1ZXJ5VHlwZVxue1xuICAgIEZ1bGxUZXh0LFxuICAgIEZ1bGxUZXh0T3V0bGluZSxcbiAgICBQcmVkaWNhdGUsXG4gICAgRnVsbFRleHRBbmRQcmVkaWNhdGVcbn1cblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWF0Y2hpbmcgY2FwYWJpbGl0eSBmb3IgZ2l2ZW4gRGF0YVByb3ZpZGVyLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YUZpbmRlclxue1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExvb2t1cCBrZXkgdG8gYXBwbHkgd2hlbiBydW5uaW5nIG1hdGNoLiBJZGVhbGx5IHlvdXIgRFMgc2hvdWxkIGJlIGFibGUgdG8gc2V0IGxvb2t1cEtleVxuICAgICAqIGVpdGhlciBnbG9iYWxseSBmb3IgZ2l2ZW4gZGF0YVByb3ZpZGVyIG9yIGxvY2FsbHkgZXZlcnkgdGltZSB5b3UgcnVuIHNlYXJjaC4gVGhpcyBpcyBpblxuICAgICAqIGNhc2UgeW91IGhhdmUgbWFueSBjaG9vc2VycyBmb3IgdGhlIHNhbWUgdHlwZSBhbmQgeW91IHdhbnQgdGhlbSB0byBoYXZlIGRpZmZlcmVudCBsb29rdXBcbiAgICAgKiBrZXkuXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0IGxvb2t1cEtleShrZXk6IHN0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBmaW5kIGNvbmNyZXRlIERhdGFGaW5kZXIgd2UgbmVlZCB0byBrbm93IHRoZSB0YXJnZXQgdHlwZSBhbmQgdGhlIHF1ZXJ5IHR5cGVcbiAgICAgKlxuICAgICAqL1xuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldHMgYSBEYXRhUHJvdmlkZXIgZm9yIERhdGFGaW5kZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGZvckRhdGEocHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+KTogRGF0YUZpbmRlcjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWF0Y2hpbmcgbWV0aG9kcyB3aGljaCBhcmUgZWl0aGVyIGFzeW5jIG9yIHN5bmNcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXTtcblxuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBudW1iZXIpOiBUW107XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUXVlcnkgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyBsaXRlcmFsIG9yIGEgbWFwIGhhdmluZyBkaWZmZXJlbnQga2V5IHZhbHVlIHBhaXIgYXMgYVxuICAgICAqIGZpbHRlclxuICAgICAqXG4gICAgICovXG4gICAgbWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIgPSAtMSk6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cbiAgICBtYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTaW1wbGUgRnVsbFRleHQgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gaW5maXggc3RyaW5nIG1hdGNoaW5nIHdoaWNoIHdvcmtzIG9uIHRvcCBvZlxuICogQXJyYXlEYXRhUHJvdmlkZXIuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFRleHRBcnJheURhdGFGaW5kZXIgZXh0ZW5kcyBEYXRhRmluZGVyXG57XG4gICAgLyoqXG4gICAgICogIElmIGxpc3QgdmFsdWUgaXMgb2JqZWN0IHNldCBrZXlQYXRoIHRvIGdldCB0aGUgb2JqZWN0IHZhbHVlXG4gICAgICovXG4gICAgX2tleVBhdGg6IEZpZWxkUGF0aDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgRGF0YVByb3ZpZGVyIHVzZWQgdG8gYWNjZXNzIGRhdGFcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Byb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcblxuICAgIHNldCBsb29rdXBLZXkoa2V5OiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl9rZXlQYXRoID0gaXNQcmVzZW50KGtleSkgPyBuZXcgRmllbGRQYXRoKGtleSkgOiBudWxsO1xuICAgIH1cblxuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmb3JEYXRhIGluc3RhbmNlb2YgQXJyYXlEYXRhUHJvdmlkZXIgJiYgZm9yVHlwZSA9PT0gUXVlcnlUeXBlLkZ1bGxUZXh0O1xuICAgIH1cblxuICAgIGZvckRhdGEocHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+KTogRnVsbFRleHRBcnJheURhdGFGaW5kZXJcbiAgICB7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc3RhbnRNYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXVxuICAgIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5fcHJvdmlkZXIuZGF0YUZvclBhcmFtcyhuZXcgTWFwKCkuc2V0KCdsaW1pdCcsIG1heCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihsaXN0LCBxdWVyeSwgbWF4KTtcbiAgICB9XG5cbiAgICBpbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zRm9yTWF0Y2g6IGFueVtdLCBxdWVyeTogc3RyaW5nLCBtYXg6IG51bWJlcik6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuX3Byb3ZpZGVyKSwgJ01pc3NpbmcgRGF0YVByb3ZpZGVyJyk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uc0Zvck1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgICAgIGxldCB0b0xvd2VyUGF0dGVybiA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25zRm9yTWF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VsZWN0aW9uc0Zvck1hdGNoW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlcyhpdGVtLCB0b0xvd2VyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBJZiB5b3UgZG9udCBzdXBwbHkgc2VhcmNoIEtleSBhbmQgeW91IHdhbnQgZnVsbHRleHQgc2VhcmNoIGFuZCB5b3UgdXNlIHRoaXNcbiAgICAgKiBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGJlIGF3YXJlIHRoYXQgaXQgY2FuICBwZXJmb3JtIHBvb3JseSBhcyBpdCBpcyBuYWl2ZSBpbXBsZW1lbnRhaW9uXG4gICAgICogdGhhdCBkb2VzIG5vdCBkbyBkZWVwIGNvbXBhcmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBtYXRjaGVzPFQ+KGl0ZW06IGFueSwgcGF0dGVybjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHZhbCA9IChpc1ByZXNlbnQodGhpcy5fa2V5UGF0aCkpID8gdGhpcy5fa2V5UGF0aC5nZXRGaWVsZFZhbHVlKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmNhbGwoaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNKc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzT2JqZWN0VmFsdWUoaXRlbSwgcGF0dGVybik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JsYW5rKHBhdHRlcm4pIHx8XG4gICAgICAgICAgICAgICAgaXNQcmVzZW50KHZhbCkgJiYgdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pID4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuaW5zdGFudE1hdGNoKHF1ZXJ5LCBtYXgpKTtcbiAgICB9XG5cbiAgICBtYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zKHNlbGVjdGlvbnMsIHF1ZXJ5LCBtYXgpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaGFzT2JqZWN0VmFsdWUob2JqOiBhbnksIHBhdHRlcm46IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBvYmplY3RWYWx1ZXMob2JqKTtcbiAgICAgICAgbGV0IHBhcmVudE9iaiA9IG9iamVjdFRvTmFtZShvYmopO1xuICAgICAgICBsZXQgbGVuZ3RoMiA9IHZhbHVlcy5maWx0ZXIoKHZhbHVlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNKc09iamVjdCh2YWx1ZSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pICE9PSAtMTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0pzT2JqZWN0KHZhbHVlKSAmJiBvYmplY3RUb05hbWUodmFsdWUpICE9PSBwYXJlbnRPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPYmplY3RWYWx1ZSh2YWx1ZSwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoMiA+IDA7XG4gICAgfVxufVxuXG5cbi8qKlxuICogRXh0ZW5kcyBiYXNpYyBJbmZpeCBpbXBsZW1lbnRhdGlvbiB0byB3b3JrIG9uIHRvcCBvZiBPdXRsaW5lTm9kZXMuIEl0IGZpcnN0IGNoZWNrcyBhbGwgdGhlXG4gKiBjaGlsZHJlbiBvbiBsb3dlc3QgbGV2ZWwgYW5kIG1vdmluZyB1cCB0byB0aGUgcm9vdCBhbmQgbWFya2luZyBub2RlcyB0aGF0IGNhbiBiZSByZW1vdmVkLlxuICpcbiAqICBGb3Igc2ltcGxlIGRhdGEgc3RydWN0dXJlIHdoaWNoIG9wZXJhdGVzIG9uIGxvY2FsIGFycmF5IHRoaXMgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIHdlIHRoaXNcbiAqICBjYW4gbmV2ZXIgbWF0Y2ggd2l0aCByZWFsIERCIGZ1bGwgdGV4dCBzZWFyY2guXG4gKlxuICovXG5leHBvcnQgY2xhc3MgT3V0bGluZUZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyIGV4dGVuZHMgRnVsbFRleHRBcnJheURhdGFGaW5kZXJcbntcblxuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmb3JEYXRhIGluc3RhbmNlb2YgQXJyYXlEYXRhUHJvdmlkZXIgJiYgZm9yVHlwZSA9PT0gUXVlcnlUeXBlLkZ1bGxUZXh0T3V0bGluZTtcbiAgICB9XG5cblxuICAgIGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBzdHJpbmcsIG1heDogbnVtYmVyKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5fcHJvdmlkZXIpLCAnTWlzc2luZyBEYXRhUHJvdmlkZXInKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25zRm9yTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvTG93ZXJQYXR0ZXJuID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBsZXQgc291cmNlVG9TZWFyY2ggPSBzZWxlY3Rpb25zRm9yTWF0Y2guc2xpY2UoKTtcbiAgICAgICAgdGhpcy5yb2xsdXAoc291cmNlVG9TZWFyY2gsIHRvTG93ZXJQYXR0ZXJuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hha2Uoc291cmNlVG9TZWFyY2gpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHb2luZyB0aHJ1IHRoZSB0cmVlIGZyb20gYm90dG9tIHVwIGFuZCBtYXJrIGFsbCB0aGF0IG1hdGNoZXMgcXVlcnlcbiAgICAgKlxuICAgICAqL1xuICAgIHJvbGx1cChub2RlczogT3V0bGluZU5vZGVbXSwgcXVlcnk6IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKGl0ZW06IE91dGxpbmVOb2RlKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIGJvdHRvbSB1cCBhbmQgY2FwdHVyZSBob3cgbWFueSBvY2N1cnJlbmNlcyBpcyBmb3VuZCBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgbGV0IGhhc0NoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbS5jaGlsZHJlbikgJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW5NYXRjaCA9IHRoaXMucm9sbHVwKGl0ZW0uY2hpbGRyZW4sIHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0udmlzaWJsZSA9IGhhc0NoaWxkcmVuTWF0Y2ggfHwgdGhpcy5tYXRjaGVzKGl0ZW0sIHF1ZXJ5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGVzLnNvbWUoKGl0ZW06IE91dGxpbmVOb2RlKSA9PiBpdGVtLnZpc2libGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBvdXQgYWxsIHRoZSBub2RlcyB0aGF0IGFyZSBtYXJrZWQgYXMgdmlzaWJsZSA9IGZhbHNlIGFuZCBtYWtlIHN1cmUgYW5kXG4gICAgICogZG9uJ3QgbW9kaWZ5IG9yaWdpbmFsIGxpc3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNoYWtlKG5vZGVzOiBPdXRsaW5lTm9kZVtdKTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUudmlzaWJsZSlcbiAgICAgICAgICAgIC5tYXAobm9kZSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgaXNFeHBhbmRlZDogbm9kZS52aXNpYmxlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuICYmIHRoaXMuc2hha2Uobm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHt1bmltcGxlbWVudGVkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5cblxuZXhwb3J0IGNvbnN0IERBVEFfU09VUkNFID0gbmV3IEluamVjdGlvblRva2VuPERhdGFTb3VyY2U+KCdEQVRBX1NPVVJDRScpO1xuXG4vKipcbiAqIERhdGFTb3VyY2UgZGVzY3JpYmVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGhhbmRsaW5nIHN0cmVhbSBvZiBkYXRhIHNwZWNpZmljIHRvIGNvbXBvbmVudFxuICpcbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgRGF0YVNvdXJjZSB3aWxsIGJlIGRlZmluZWQgYXMgY29tcG9uZW50IHByb3ZpZGVyIHVzaW5nXG4gKlxuICogQENvbXBvbmVudHMgKHtcbiAqICAgICAgLi4uXG4gKiAgICAgIHByb3ZpZGVyczpbXG4gKlxuICogICAgICAgICAgcHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZVBsYWluQXJyYXlFeGFtcGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXVxuICogICAgICBdXG4gKlxuICogfSlcbiAqXG4gKlxuICogc28gYWxsIHRoZSBkZXBlbmRlbmNpZXMgKERhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzKSBhcmUgcHJvcGVybHkgaW5qZWN0ZWQuXG4gKlxuICogRGF0YVByb3ZpZGVyIHVzZXMgb3BlbigpIG1ldGhvZCB0byBicm9hZGNhc3QgY2hhbmdlcyB0byBhbGwgdGhlIHN1YnNjcmliZXJzIGluIHJlYWN0aXZlIHdheS5cbiAqIE9yIHlvdSBjYW4gdXNlIGluc3RhbnQoKSBtZXRob2QgdG8gcmV0cmlldmUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIERhdGFTb3VyY2UgKHN5bmMpXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVNvdXJjZVxue1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMZW5ndGggPSAxMDtcbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4UmVjZW50U2VsZWN0ZWQgPSA1O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFYWNoIERhdGFTb3VyY2UgaGF2ZSBpbmplY3RlZCBEYXRhUHJvdmlkZXJzIGFuZCBEYXRhRmluZGVycyB0byByZXRyaWV2ZSBjb25jcmV0ZVxuICAgICAqIGltcGxlbWVudGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHByb3RlY3RlZCBmaW5kZXJzPzogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIGluaXRpYWxpemUgZGF0YSBzb3VyY2UgYW5kIHBhc3Mgc29tZSBhZGRpdGlvbmFsIHZhbHVlc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIERhdGFQcm92aWRlcnMgd29ya3Mgd2l0aCBzdHJlYW0gb2YgZGF0YSBhbmQgdGhpcyBvcGVucyB1cCB0aGUgY2hhbm5lbCBpbiBvcmRlciB0b1xuICAgICAqIGxpc3RlbiBhbmQgcmVhY3QgZm9yIGFueSBjaGFuZ2VzIHRoYXQgY291bGQgaGFwcGVuIGluc2lkZSBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPjtcblxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSBzdWJzY3JpcHRpb24gdG8gRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgYWJzdHJhY3QgY2xvc2UoKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRhdGEgaW5zdGFudGx5IGZyb20gdGhlIGludGVybmFsIHN0YXRlIG9mIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGluc3RhbnQ8VD4oKTogVFtdXG4gICAge1xuXG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEU0luaXRQYXJhbXNcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyBvciB0aGUgb2JqZWN0IHR5cGUgbmFtZSB3ZSB3YW50IHRvIHJlbmRlclxuICAgICAqL1xuICAgIG9iaj86IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGZpbmQgd2Ugd2FudCB0byBsb2FkIEZ1bGxUZXh0IG9yIFByZWRpY2F0ZVxuICAgICAqL1xuICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHNwZWNpZnkgbG9va3VwIEtleSB0byBuYXJyb3cgZG93biB0aGUgc2VhcmNoIHRvIHNwZWNpZmljIGZpZWxkLiBJZiBsb29rdXAga2V5IGlzXG4gICAgICogbnVsbCwgaXRlbXMgYXJlIGFzc3VtZWQgdG8gYmUgc3RyaW5nc1xuICAgICAqL1xuICAgIGxvb2t1cEtleT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBDaG9vc2VyIGlzIHNpbmdsZSBvciBtdWx0aSBzZWxlY3RcbiAgICAgKi9cbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiB0byBwYXNzIGN1c3RvbSBEYXRhUHJvdmlkZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFQcm92aWRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFQcm92aWRlcj86IERhdGFQcm92aWRlcjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFGaW5kZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFGaW5kZXJzIHRvIGZpbmQgbWF0Y2hcbiAgICAgKi9cbiAgICBkYXRhRmluZGVyPzogRGF0YUZpbmRlcjtcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEhvc3RCaW5kaW5nfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBXZSBhcmUgdXNpbmcgdGhlc2UgY29tcG9uZW50cyBhcyBhIGJldHRlciB3YXkgc2VsZWN0b3JzLlxuICpcbiAqL1xuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10b3AnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgVG9wWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQgJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWxlZnQnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgTGVmdFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1pZGRsZScsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBNaWRkbGVab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktbWQtNiB1aS1sZy00IHVpLWctbm9wYWQnO1xufVxuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yaWdodCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBSaWdodFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcblxufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYm90dG9tJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIEJvdHRvbVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBc3luY1ZhbGlkYXRvckZuLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9yc30gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlciwgU3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi4vZm9ybS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudCwgV2lkZ2V0U2l6ZUNvbHVtbnN9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVXNlZCBieSBGb3JtVGFibGUgdG8gbGF5b3V0IGZpZWxkcyBpbnRvIFJvd3MuIEVhY2ggRm9ybVRhYmxlIHJvdyBpcyByZWFzb25hYmxlIGZvciBub3Qgb25seSB0b1xuICogaW5jbHVkZSBhY3R1YWwgY29tcG9uZW50IHN1Y2ggaXMgRHJvcERvd24gb3IgSW5wdXRGaWVsZCBidXQgbWFpbmx5IHByb3ZpZGVzIGEgZW5vdWdoIGNvbnRleHQgZm9yXG4gKiB0aGUgY29tcG9uZW50IHRvIHNwZWNpZnkgdGhlIHNpemUsIGhvdyBpdCBzaG91bGQgbGF5b3V0LCB3aGV0aGVyIHdlIG5lZWQgdG8gc2hvdyByZXF1aXJlZCBmbGFnLFxuICogdG8gc2hvdy9oaWRlIGxhYmVscyBpbiBjYXNlIGlmIHdlIGhhdmUgbm8gbGFiZWwgbGF5b3V0IGFuZCBtdWNoIG1vcmUuXG4gKlxuICogRm9ybVJvdyBjb21wb25lbnQgYWxzbyByZWdpc3RlcnMgYW5ndWxhciB2YWxpZGF0b3IgZm9yIHRoZSBjdXJyZW50IHJvdy9maWVsZC4gQXMgYWxyZWFkeVxuICogbWVudGlvbmVkIFdlIHRyZWF0IG91ciB3aWRnZXRzIHdpdGggbWluaW1hbCByZXNwb25zaWJpbGl0eSBhcyBwb3NzaWJsZSB0byBwcmVzZW50IGFuZCByZXRyaXZlXG4gKiBpbmZvcm1hdGlvbiB0by9mcm9tIHVzZXIgYW5kIGxldCBzb21lYm9keSBlbHNlIHRvIGZpZ3VyZSBvdXQgd2hlcmUgaXQgYXBwZWFyIGFuZCBob3cuXG4gKlxuICogdG9kbzogTW92ZSB1bmRlciBGb3JtVGFibGVcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1mb3JtLXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtLXJvdy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2Zvcm0tcm93LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtUm93Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub0xhYmVsTGF5b3V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJvdyB3aXRoIGhpZ2hsaWdodGVkIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlnaGxpZ2h0Um93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBGaWVsZCBsYWJlbCB0aGF0IHNob3VsZCBhcHBlYXIgYWJvdmUgb3IgbmV4dCB0byB0aGUgY29udHJvbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgdmFsaWRhdG9ycywgbWF4aW1hbCBsZW5ndGggb2YgdGhlIGZpZWxkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtaW5pbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbmd0aDogbnVtYmVyO1xuXG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgZm9ybWF0dGVycy4gSG93IHRoZSBpbnB1dCBmaWVsZHMgc2hvdWxkIGJlXG4gICAgICogZm9ybWF0dGVkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIGFzeW5jIHZhbGlkYXRvcnMgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgQ29udHJvbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VzdG9tQXN5bmNWYWxpZGF0b3JzOiBBc3luY1ZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1c3RvbSAgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21WYWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIGZvcm0gcm93IHRoYXQgd2UgYXJlIHJlbmRlcmluZyBhbm90aGVyIG5lc3RlZCBmb3JtIGluIHRoaXMgcm93LiBzbyB3ZSBuZWVkXG4gICAgICogdG8gZ28gMTAwJVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNOZXN0ZWRMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgaXMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgZmllbGQuIEN1cnJlbnQgd2Ugc3VwcG9ydCA0IGRpZmZlcmVudCBzaXplczogeC1zbWFsbCwgc21hbGwsXG4gICAgICogbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgICAqL1xuICAgIHByaXZhdGUgX3NpemU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRm9yIHNpbmdsZSBjb2x1bW4gbGF5b3V0IHdpdGhvdXQgem9uZXMgd2UgbmVlZCB0byBhcHBseSBncmlkIGRpcmVjdGx5IHRvIHRoZSBGb3JtUm93IHRhZ1xuICAgICAqIHNvIHdlIGRvbid0IG5lZWQgdG8gaW50cm9kdWNlIGV4dHJhIGRpdiBsZXZlbFxuICAgICAqXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJyc7XG5cblxuICAgIHByaXZhdGUgX2xhYmVsc09uVG9wOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgLy8gRXZlbnQgdGhpcyBjcmVhdGVzIENJIGRlcGVuZHMuIE5lZWQgdG8gaGF2ZSBhIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgICAgICAgICAgICAvLyBJIG5lZWQgdG8gcmVmYWN0b3IgbW9yZSBwYXJlbnQgdG8gbm90IHVzZSB0aGlzIGNoaWxkIGFuZCByZWZhY3RvciBsYXlvdXRpbmdcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVRhYmxlQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBGb3JtVGFibGVDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBXaWRnZXRTaXplQ29sdW1ucy5tZWRpdW07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSaWdodCBub3cgd2UganVzdCBpbml0aWFsaXplIHRoaXMgb25jZSBhbmQgdXNlIHRoZSB2YWx1ZXMgd2UgZG8gbm90IGV4cGVjdCBub3cgdG8gcmVhY3QgdG9cbiAgICAgKiBjaGFuZ2VzXG4gICAgICovXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbChudWxsKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFsaWRhdG9ycygpO1xuXG4gICAgICAgIHRoaXMub21pdFBhZGRpbmcgPSB0aGlzLnBhcmVudENvbnRhaW5lci5vbWl0UGFkZGluZztcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgKz0gaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSA/ICcgdWktZy0xMiAnIDogJyc7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5oaWdobGlnaHRSb3cgPyB0aGlzLmNsYXNzTGlzdCArICcgaGlnaGxpZ2h0LXJvdyAnIDogdGhpcy5jbGFzc0xpc3Q7XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgPSB0aGlzLm9taXRQYWRkaW5nID8gdGhpcy5jbGFzc0xpc3QgKyAnIHVpLWctbm9wYWQgJyA6IHRoaXMuY2xhc3NMaXN0O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSnVzdCBhIHNpemUgZ2V0dGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBIHNpemUgc2V0dGVyIHdlIHRyYW5zbGF0ZSBjdXN0b20gc2l6ZXMgaW50byBhY3R1YWwgYm9vdHN0cmFwIGdyaWQgc3lzdGVtLiBXZSB1c2UgbWVkaXVtXG4gICAgICogcmlnaHQgbm93LiBidXQgd2Ugc2hvdWxkIGV4dGVuZCB0aGlzIGZvciBvdGhlciBzY3JlZW4gc2l6ZXNcbiAgICAgKlxuICAgICAqICB0b2RvOiBwcm92aWRlIG1hcHBpbmcgYW5kIGFkZCBvdGhlciBncmlkIGNsYXNzZXMgZm9yIG90aGVyIHNpemVzIHhzLCBzbSwgbGcsIHhsXG4gICAgICpcbiAgICAgKiAgQWxzbyBjaGVjayBpZiB0aGlzIGlzIGR5bmFtaWMgc2l6ZSB0aGF0IHNob3VsZCB2YXJ5IGJhc2VkIG9uIHRoZSBob3cgbWFueSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqIHdlIGhhdmUuIGUuZy4gRGF0ZSB3aWRnZXRzIGlzIGJ5IGRlZmF1bHQgc21hbGwsIGJ1dCBpbiAyLCAzIGNvbHVtbnMgbGF5b3V0IHRoaXMgc21hbGwgaXMgdG9vXG4gICAgICogc21hbGwuXG4gICAgICovXG5cblxuXG4gICAgQElucHV0KClcbiAgICBzZXQgc2l6ZSh2YWx1ZTogc3RyaW5nKVxuICAgIHtcblxuICAgICAgICBsZXQgaXNEeW5WYWwgPSBmYWxzZTtcblxuICAgICAgICBpZiAoU3RyaW5nV3JhcHBlci5zdGFydHNXaWR0aCh2YWx1ZSwgJ2QtJykpIHtcbiAgICAgICAgICAgIGlzRHluVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDIsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkgJiYgIXRoaXMuaXNOZXN0ZWRMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IHRoaXMuZHluU2l6ZSh2YWx1ZSwgaXNEeW5WYWwpO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBkU2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTmVzdGVkTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtMTInO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikgJiYgdGhpcy5lZGl0YWJsZSAhPT0gdGhpcy5wYXJlbnRDb250YWluZXIuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgPSB0aGlzLnBhcmVudENvbnRhaW5lci5lZGl0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2ggb3V0IG9mIGJveCBhbmd1bGFyIHZhbGlkYXRvciBhcyB3ZWxsIGFzIGN1c3RvbSBvbmUgdG8gY3VycmVudCBGb3JtQ29udHJvbFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVnaXN0ZXJWYWxpZGF0b3JzKClcbiAgICB7XG4gICAgICAgIGxldCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gW107XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1heExlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1heExlbmd0aCh0aGlzLm1heExlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1pbkxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1pbkxlbmd0aCh0aGlzLm1pbkxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlcXVpcmVkKSAmJiB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbVZhbGlkYXRvcnMpKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwodmFsaWRhdG9ycywgdGhpcy5jdXN0b21WYWxpZGF0b3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSAmJiB0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBsYWJlbHMgb24gVE9QLCB0cnkgdG8gcmVhZCB0aGlzIGZyb20gUGFyZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgbGFiZWxzT25Ub3AoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fbGFiZWxzT25Ub3ApICYmIGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoPEZvcm1UYWJsZUNvbXBvbmVudD50aGlzLnBhcmVudENvbnRhaW5lcikuaXNMYWJlbHNPblRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FuIHJlZmFjdG9yIGFsbCBpbnRvIDEgbGluZSBidXQgaXRzIGhhcmQgdG8gZGVidWcgc28gdGhpcyBpcyBqdXN0IGZvciByZWFkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGR5blNpemUodmFsdWU6IHN0cmluZywgaXNEeW5WYWx1ZTogYm9vbGVhbik6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZVNpemUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJy0nLCAnJyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikgJiZcbiAgICAgICAgICAgICg8Rm9ybVRhYmxlQ29tcG9uZW50PnRoaXMucGFyZW50Q29udGFpbmVyKS5oYXNUd29Db2x1bW4gJiYgaXNEeW5WYWx1ZSlcbiAgICAgICAge1xuXG4gICAgICAgICAgICBsZXQgZW51bVZhbHVlczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhXaWRnZXRTaXplQ29sdW1ucyk7XG4gICAgICAgICAgICBub3JtYWxpemVTaXplID0gZW51bVZhbHVlc1tlbnVtVmFsdWVzLmluZGV4T2Yobm9ybWFsaXplU2l6ZSkgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxhbnk+V2lkZ2V0U2l6ZUNvbHVtbnMpW25vcm1hbGl6ZVNpemVdO1xuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7XG4gICAgQm90dG9tWm9uZUNvbXBvbmVudCxcbiAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICBUb3Bab25lQ29tcG9uZW50XG59IGZyb20gJy4uL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqIEZvcm1UYWJsZSBpcyBhIHNwZWNpZmljIGxheW91dCBjb21wb25lbnQgZm9yIHJlbmRlcmluZyBMYWJlbHMgYW5kIGl0cyBjb250cm9scyBpbiB0d28gY29sdW1uc1xuICogYW5kIDUgZGlmZmVyZW50IHpvbmVzLlxuICpcbiAqIFdlIHN1cHBvcnQgTEVGVCwgTUlERExFLCBSSUdIVCwgVE9QLCBCT1RUT00gem9uZSB3aGVyZSB3ZSBjYW4gcGxhY2Ugb3VyIGNvbXBvbmVudCBvciB3aWRnZXRzLlxuICogVGhpc1xuICogY29tcG9uZW50IGlzIHVzZWQgYXMgcHJpbWFyeSBsYXlvdXQgdG8gd3JhcCBhbGwgdGhlIGNvbW1vbiB1c2UgY2FzZXMuIEUuZy4gV2hlbiB3ZSBsYXkgb3V0XG4gKiBmaWVsZHMgaW4gdGhlIGZvcm0gSSBkbyBub3Qgd2FudCBjb250cm9scyB0byBiZSBhd2FyZSBvZiBlcnJvciB2YWxpZGF0aW9uLCBzaXplLCBsYWJlbHMsIGFuZFxuICogc29tZSBvdGhlciB0aGluZ3MuIENvbnRyb2wgc3VjaCBJTlBVVCBpcyBqdXN0IHJlc3BvbnNpYmxlIGZvciByZXRyaWV2ZSB1c2VyIHZhbHVlIGJ1dCBub3QgaG93IGl0XG4gKiBhcHBlYXIgb24gdGhlIHBhZ2UuXG4gKlxuICogVGhpcyB3YXkgd2UgY2FuIGJlIGZsZXhpYmxlIGhvdyB3ZSB0cmVhdCB3aWRnZXRzIGZvciBkaWZmZXJlbnQga2luZHMgb2Ygc2l0dWF0aW9uIGRlcGVuZGluZ1xuICogd2hlcmUgdGhleSBhcHBlYXJcblxuICogRm9ybVRhYmxlIGp1c3QgbGlrZSB0aGUgcmVzdCBvZiB0aGUgY29tcG9uZW50cyBhcmUgdXNpbmcgTW9kZWwgZHJpdmVuIGFwcHJvYWNoIGhvdyB0byB3b3JrIHdpdGhcbiAqIGRhdGEsIG1lYW4gd2UgYXJlIHVzaW5nIEZvcm1Hcm91cCwgRm9ybUNvbnRyb2wgZXRjLiBGb3JtR3JvdXAgY2FuIGJlIHBhc3NlZCBpbnRvIHRoZSBGb3JtVGFibGUsXG4gKiBvdGhlcndpc2UgaXRzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCB3aGVuIHRoZSBGb3JtVGFibGUgaXMgaW5zdGFudGlhdGVkLlxuICpcbiAqIEZvcm1Hcm91cCBpcyBzYXZlZCBpbnNvZGUgRW52aXJvbm1lbnQgd2hlcmUgd2UgYXJlIHVzaW5nIHRoaXMgdG8gcGFzcyB0aGlzIGFyb3VuZCB0aGUgcGFnZXMgYW5kXG4gKiBjb21wb25lbnRzLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogU2ltcGxlIExheW91dCBmaWVsZHMgYW5kIGl0cyBjb250cm9sXG4gKlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICd3cmFwcGVyLWNvbXAnICxcbiAqICAgICAgdGVtcGxhdGU6IGBcbiAqICBcdFx0XHQ8YXctZm9ybS10YWJsZSBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIChvblN1Ym1pdCk9PlxuICogIFx0XHRcdFx0PGF3LWZvcm0tcm93IFtsYWJlbF09XCInbmFtZSdcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICBcdFx0XHRcdFx0PGF3LWlucHV0LWZpZWxkIFt0eXBlXT1cIidzdHJpbmcnXCI+PC9hdy1pbnB1dC1maWVsZD5cbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKlxuICogIFx0XHRcdFx0PGF3LWZvcm0tcm93IFtsYWJlbF09XCInUHJlZmVycmVkIENvbG9ycydcIiBbbmFtZV09XCInbXlDb2xvcnMnXCI+XG4gKiAgXHRcdFx0XHRcdDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImNoZWNrQm94TGlzdFZhbHVlc1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbnNdPVwic2VsZWN0ZWRWYWx1ZXNcIlxuICogIFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgIFtsYXlvdXRdPVwiJ2lubGluZSdcIlxuICogIFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvbkNCQ2xpY2soJGV2ZW50KVwiPlxuICogIFx0XHRcdFx0XHQ8L2F3LWNoZWNrYm94LWxpc3Q+XG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICogIFx0XHRcdFx0PGF3LWZvcm0tcm93IFtsYWJlbF09XCInR2VuZGVyJ1wiIFtuYW1lXT1cIidnZW5kZXInXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8YXctcmFkaW9idXR0b24tbGlzdCBbbGlzdF09XCJyYlZhbHVlc1wiIFtzZWxlY3Rpb25dPVwicmJTZWxlY3Rpb25cIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAqXG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICogIFx0XHRcdFx0PGF3LWZvcm0tcm93IFtsYWJlbF09XCInTXkgYmlydGhkYXRlJ1wiIFtuYW1lXT1cIidiaXJ0aERhdGUnXCIgW3NpemVdPVwiJ3NtYWxsJ1wiPlxuICpcbiAqICBcdFx0XHRcdFx0PGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiIFtzaG93VGltZV09XCJzaG93VGltZVwiPlxuICogIFx0XHRcdFx0XHQ8L2F3LWRhdGUtdGltZT5cbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0PC9hdy1mb3JtLXRhYmxlPlxuICogICAgYFxuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIFNob3dVc2VySW5mb0NvbXBvbmVudFxuICogIHtcbiAqICAgICAgIGNoZWNrQm94TGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ3JlZCcgLCAneWVsbG93JyAsICdvcmFuZ2UnICwgJ3doaXRlJyAsICdzaWx2ZXInXG4gKiAgICAgLCAnYmxhY2snICwgJ0dyZWVuJ1xuICogICAgICwgJ0dyYXknICwgJ05hdnknICxcbiAqICAgICAgICAgICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKiAgICAgIHNlbGVjdGVkVmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICogICAgICByYlZhbHVlczogc3RyaW5nW10gPSBbJ21hbGUnICwgJ2ZlbWFsZScgLCAnb3RoZXInXTtcbiAqICAgICAgcmJTZWxlY3Rpb246IHN0cmluZyA9ICdtYWxlJztcbiAqICAgICAgZWRpdGFibGU6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICBzaG93VGltZTogYm9vbGVhbiA9IHRydWU7XG4gKlxuICogICAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICpcbiAqXG4gKiAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgIHtcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNCQ2xpY2sgPSAnICsgZXZlbnQpO1xuICogICAgICB9XG4gKlxuICogICAgICBvblN1Ym1pdCAobW9kZWw6IGFueSk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICBjb25zb2xlLmxvZyhtb2RlbClcbiAqXG4gKiAgICAgICAgIC8vIHdpbGwgcHJpbnQgeyBuYW1lOm51bGwsIG15Q29sb3JzOlsnYmx1ZScgLCAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddLCBnZW5kZXI6XG4gKiAgICAgbWFsZX1cbiAqICAgICAgfVxuICpcbiAqICB9XG4gKlxuICogIGBgYFxuICpcbiAqICBPciB5b3UgY2FuIHVzZSB6b25lIHRvIGxheW91dCB0aGVzZSBmaWVsZHMgaW50byB0d28gY29sdW1uczpcbiAqXG4gKiAgQ3VycmVudCB6b25lcyBhcmUgaW1wbGVtZW50IHdpdGggPG5nLWNvbnRlbnQgU0VMRUNUPiB3aGljaCBpcyBqdXN0IGEgc2VsZWN0b3IgdG8gc2VhcmNoZXMgZm9yXG4gKiAgICAgc3BlY2lmaWMgcGF0dGVybi4gSW4gb3VyIGNhc2UgaW5zdGVhZCBvZiBjcmVhdGluZyBleHRyYSB3cmFwcGVyIGN1c3RvbSBjb21wb25lbnQgdXNlIHNpbXBsZVxuICogICAgIENTUyBjbGFzc1xuICpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1mb3JtLXRhYmxlICNtZXRhRm9ybVRhYmxlIFtlZGl0YWJsZV09XCJlZGl0aW5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbdXNlRml2ZVpvbmVdPVwiaXNGaXZlWm9uZUxheW91dFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU3VibWl0KT1cIm9uU2F2ZUFjdGlvbigkZXZlbnQpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgPGF3LWxlZnQgICpuZ0lmPVwiY2FuU2hvd1pvbmUoJ3pMZWZ0JylcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ25hbWUnXCIgW25hbWVdPVwiJ25hbWUnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctaW5wdXQtZmllbGQgW3R5cGVdPVwiJ3N0cmluZydcIj48L2F3LWlucHV0LWZpZWxkPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInUHJlZmVycmVkIENvbG9ycydcIiBbbmFtZV09XCInbXlDb2xvcnMnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsYXlvdXRdPVwiJ2lubGluZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgIDwvYXctbGVmdD5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgPGF3LXJpZ2h0ICAqbmdJZj1cImNhblNob3dab25lKCd6UmlnaHQnKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidHZW5kZXInXCIgW25hbWVdPVwiJ2dlbmRlcidcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24tbGlzdCBbbGlzdF09XCJyYlZhbHVlc1wiIFtzZWxlY3Rpb25dPVwicmJTZWxlY3Rpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidNeSBiaXJ0aGRhdGUnXCIgW25hbWVdPVwiJ2JpcnRoRGF0ZSdcIlxuICogICAgIFtzaXplXT1cIidzbWFsbCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICogICAgIFtzaG93VGltZV09XCJzaG93VGltZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kYXRlLXRpbWU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICA8Lzxhdy1yaWdodD5cbiAqICAgICAgICAgICAgPC9hdy1mb3JtLXRhYmxlPlxuICpcbiAqICBgYGBcbiAqXG4gKiAgdG9kbzogcmVtb3ZlIG15IGNzcyBzZWxlY3RvcnMgZm9yIHpvbmVzIGFuZCByZXBsYWNlIGl0IHdpdGggcmVhbCBjb21wb25lbnQgZXZlbiBqdXN0IGEgdGFnXG4gKiAgdG9kbzogd291bGQgd29yayBmaWxlXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWZvcm0tdGFibGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnZm9ybS10YWJsZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2Zvcm0tdGFibGUuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGb3JtVGFibGVDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRm9ybVRhYmxlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciB0aGUgZm9ybSBsYXlvdXQgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIGxhYmVscyBzdGFja2VkICBvciBzaWRlIGJ5IHNpZGUgbmV4dCB0b1xuICAgICAqIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsc09uVG9wPzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIHRoaXMgYSA0IHpvbmUgbGF5b3V0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUZpdmVab25lPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGNlcnRhaW4gdXNlY2FzZSB3ZSBkb250IHdhbnQgdG8gc2V0IGF1dG9tYXRpY2FsbHkgdGhpcyB0byBhbGwgY2hpbGRyZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRhYmlsaXR5Q2hlY2s6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogIFRyaWdnZXJzIHdoZW4gdGhlIDxmb3JtPiBpcyBzdWJtaXR0ZWQuIG9uU3VibWl0IHdlIGVtaXQgdGhlIHdob2xlIGZvcm1Db250cm9sbGVyIG9iamVjdHNcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TdWJtaXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHJlcHJlc2VudCBpbmRpdmlkdWFsIHpvbmVzIGFuZCB3ZSB1c2UgdGhlbSB0byBhZGp1c3Qgb3VyIGNvbHVtbiBncmlkXG4gICAgICogbGF5b3V0XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChMZWZ0Wm9uZUNvbXBvbmVudCkgbGVmdFpvbmU6IExlZnRab25lQ29tcG9uZW50O1xuXG4gICAgQENvbnRlbnRDaGlsZChNaWRkbGVab25lQ29tcG9uZW50KSBtaWRkbGVab25lOiBNaWRkbGVab25lQ29tcG9uZW50O1xuXG4gICAgQENvbnRlbnRDaGlsZChSaWdodFpvbmVDb21wb25lbnQpIHJpZ2h0Wm9uZTogUmlnaHRab25lQ29tcG9uZW50O1xuXG4gICAgQENvbnRlbnRDaGlsZChUb3Bab25lQ29tcG9uZW50KSB0b3Bab25lOiBUb3Bab25lQ29tcG9uZW50O1xuXG4gICAgQENvbnRlbnRDaGlsZChCb3R0b21ab25lQ29tcG9uZW50KSBib3R0b21ab25lOiBCb3R0b21ab25lQ29tcG9uZW50O1xuXG5cbiAgICBAQ29udGVudENoaWxkcmVuKEJhc2VGb3JtQ29tcG9uZW50LCB7ZGVzY2VuZGFudHM6IHRydWV9KVxuICAgIGZvcm1GaWVsZHM6IFF1ZXJ5TGlzdDxCYXNlRm9ybUNvbXBvbmVudD47XG5cbiAgICBAQ29udGVudENoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCksIHtkZXNjZW5kYW50czogdHJ1ZX0pXG4gICAgcm93czogUXVlcnlMaXN0PEZvcm1Sb3dDb21wb25lbnQ+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBjYWxjdWxhdGVkIHByb3BlcnRpZXMgd2hlbiBpbml0IHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNPbmVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoYXNUd29Db2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoYXNUaHJlZUNvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgbnVsbCk7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWydlZGl0YWJsZSddKSAmJlxuICAgICAgICAgICAgY2hhbmdlc1snZWRpdGFibGUnXS5wcmV2aW91c1ZhbHVlICE9PSBjaGFuZ2VzWydlZGl0YWJsZSddLmN1cnJlbnRWYWx1ZSkge1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1GaWVsZHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgb25TdWJtaXRGb3JtKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm9uU3VibWl0LmVtaXQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQXJlIGxhYmVscyBvbiB0b3BcbiAgICAgKlxuICAgICAqL1xuICAgIGlzTGFiZWxzT25Ub3AoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzT25Ub3A7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgYnkgY2hpbGQgY29tcG9uZW50IHRvIGluaGVyaXQgZWRpdGFiaWxpdHlcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRm9ybUVkaXRhYmxlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlO1xuICAgIH1cblxuXG4gICAgYXBwbHlDb2x1bW5zKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy51c2VGaXZlWm9uZSAmJiB0aGlzLmhhc0FueVpvbmVzKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWm9uZXMgZGV0ZWN0ZWQgaW4gdGhlIEZvcm1UYWJsZSBidXQgdXNlRml2ZVpvbmUgb3B0aW9uIGlzIGZhbHNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhc09uZUNvbHVtbiA9ICFpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmICFpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcbiAgICAgICAgdGhpcy5oYXNUd29Db2x1bW4gPSBpc1ByZXNlbnQodGhpcy5sZWZ0Wm9uZSkgJiYgaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSAmJlxuICAgICAgICAgICAgIWlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuXG4gICAgICAgIHRoaXMuaGFzVGhyZWVDb2x1bW4gPSBpc1ByZXNlbnQodGhpcy5sZWZ0Wm9uZSkgJiYgaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSAmJlxuICAgICAgICAgICAgaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVHdvQ29sdW1uICYmICF0aGlzLmlzVHdvWm9uZVJlYWR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy02JztcbiAgICAgICAgICAgIHRoaXMucmlnaHRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNUaHJlZUNvbHVtbiAmJiAhdGhpcy5pc1RocmVlWm9uZVJlYWR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy00JztcbiAgICAgICAgICAgIHRoaXMucmlnaHRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNCc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHByaXZhdGUgaGFzQW55Wm9uZXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSB8fCBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpXG4gICAgICAgICAgICB8fCBpc1ByZXNlbnQodGhpcy50b3Bab25lKSB8fCBpc1ByZXNlbnQodGhpcy5ib3R0b21ab25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhlIGNsYXNzTGlzdC5cbiAgICAgKiB0aGVcbiAgICAgKlxuICAgICAqIFRPRE86IFByb2JhYmx5IHN0cmluZyBhcnJheSB3b3VsZCBiZSBlYXNpZXJcbiAgICAgKi9cbiAgICBpc1R3b1pvbmVSZWFkeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNicpID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNicpID4gMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBpbml0aWFsaXplZCB0aGUgY2xhc3NMaXN0LlxuICAgICAqIHRoZVxuICAgICAqXG4gICAgICogVE9ETzogUHJvYmFibHkgc3RyaW5nIGFycmF5IHdvdWxkIGJlIGVhc2llclxuICAgICAqL1xuICAgIGlzVGhyZWVab25lUmVhZHkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTQnKSA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTQnKSA+IDA7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIHByb2JsZW0gc2luY2UgQW5ndWxhciA0LjIsIG5nQWZ0ZXJDb250ZW50SW5pdFxuICAgICAgICAvLyB3aXRob3V0IHRoaXMgSSBnZXQgZXJyb3IgdGhhdCB2YWx1ZSB3YXMgY2hhbmdlZCBhZnRlciB2aWV3IHdhcyBjaGVja2VkXG4gICAgICAgIC8vIHRvZG86IHJlZmFjdG9yICAtIG1haW5seSBvdXIgem9uZXMgbGVmdCwgcmlnaHQgbWlkZGxlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hcHBseUNvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUZpZWxkcygpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RMYXlvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHVwZGF0ZUZvcm1GaWVsZHMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFiaWxpdHlDaGVjayAmJiBpc1ByZXNlbnQodGhpcy5mb3JtRmllbGRzKSAmJiB0aGlzLmZvcm1GaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtRmllbGRzLmZvckVhY2goKGl0ZW06IEJhc2VGb3JtQ29tcG9uZW50KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGl0ZW0uZWRpdGFibGUgPSB0aGlzLmVkaXRhYmxlO1xuICAgICAgICAgICAgICAgIC8vIGl0ZW0uZm9ybUdyb3VwID0gdGhpcy5mb3JtR3JvdXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gaWYgd2UgYXJlIDIgb3IgMyBvciAxIGNvbHVtbiBsYXlvdXQgd2UgbmVlZCB0byBhZGp1c3Qgd2lkZ2V0cyB3aWR0aCB3aXRoaW4gdGhlXG4gICAgICogZm9ybSByb3cuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhZGp1c3RMYXlvdXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd3MpICYmIHRoaXMucm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNUaHJlZUNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRoaXMucm93cy5mb3JFYWNoKChpdGVtOiBGb3JtUm93Q29tcG9uZW50KSA9PiBpdGVtLnNpemUgPSAnbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtJbnB1dFRleHRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHRleHQvaW5wdXR0ZXh0JztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3JtVGFibGVDb21wb25lbnR9IGZyb20gJy4vZm9ybS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIEJvdHRvbVpvbmVDb21wb25lbnQsXG4gICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgVG9wWm9uZUNvbXBvbmVudFxufSBmcm9tICcuLi9maXZlLXpvbmUtbGF5b3V0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRm9ybVRhYmxlQ29tcG9uZW50LFxuICAgICAgICBGb3JtUm93Q29tcG9uZW50LFxuICAgICAgICBUb3Bab25lQ29tcG9uZW50LFxuICAgICAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgICAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgICAgICBCb3R0b21ab25lQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRm9ybVRhYmxlQ29tcG9uZW50LFxuICAgICAgICBGb3JtUm93Q29tcG9uZW50LFxuICAgICAgICBUb3Bab25lQ29tcG9uZW50LFxuICAgICAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgICAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgICAgICBCb3R0b21ab25lQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZvcm1UYWJsZUNvbXBvbmVudCxcbiAgICAgICAgRm9ybVJvd0NvbXBvbmVudCxcbiAgICAgICAgVG9wWm9uZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICAgICAgQm90dG9tWm9uZUNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdGb3JtVGFibGVNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudCwgVmFsdWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0RlY2ltYWxQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVwcmVzZW50IGEgSW5wdXQgZmllbGQgYW5kIGl0IGNhbiAgYWNjZXB0IGRpZmZlcmVudCB0eXBlcyBvZiB2YWx1ZXMgc3VjaCBhc1xuICogdGV4dCwgbnVtYmVyLlxuICpcbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnd3JhcHBlci1jb21wJyAsXG4gKiAgICAgIHRlbXBsYXRlOiAnPGF3LWlucHV0LWZpZWxkIFt2YWx1ZV09XCJpbnB1dFZhbHVlXCIgW3R5cGVdPVwiaW5wdXRUeXBlXCI+PC9hdy1pbnB1dC1maWVsZD4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgVGVzdElucHV0Q29tcG9uZW50XG4gKiAge1xuICogICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqXG4gKiAgICAgIC8vIGJ5IGRlZmF1bHQgaW5wdXQgdHlwZSBpcyB0ZXh0LCB5b3UgY2FuIHBhc3Mgc3RyaW5nLCBTdHJpbmcsIG9yIHRleHRcbiAqICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICB9XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSB3aGVyIGlucHV0IGZpZWxkIGlzIGluaXRpYWxpemVkIHdpdGggbmdNb2RlbFxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICd3cmFwcGVyLWNvbXAnICxcbiAqICAgICAgdGVtcGxhdGU6ICc8YXctaW5wdXQtZmllbGQgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbKG5nTW9kZWwpXT1cImlucHV0VHlwZVwiPjwvYXctaW5wdXQtZmllbGQ+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIFRlc3RJbnB1dENvbXBvbmVudFxuICogIHtcbiAqICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKlxuICogICAgICAvLyBieSBkZWZhdWx0IGlucHV0IHR5cGUgaXMgdGV4dCwgeW91IGNhbiBwYXNzIHN0cmluZywgU3RyaW5nLCBvciB0ZXh0XG4gKiAgICAgIGlucHV0VHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG4gKiAgfVxuICpcbiAqIGBgYFxuICpcbiAqICBOb3RlOiBpZiB5b3UgYXJlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBGb3JtVGFibGUgcGxlYXNlIHByb3ZpZGUgeW91ciBvd24gRm9ybUdyb3VwXG4gKlxuICovXG5cblxuXG5leHBvcnQgY29uc3QgSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0RmllbGRDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5wdXQtZmllbGQnLFxuICAgIHRlbXBsYXRlVXJsOiAnaW5wdXQtZmllbGQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydpbnB1dC1maWVsZC5jb21wb25lbnQuc2NzcyddLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIElOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG5cbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpZWxkQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0RmllbGRDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIHVzZWQgdG8gc2F2ZSBhbmQgcmVhZCAgd2hlbiByZW5kZXJpbmcgYW5kIHVwZGF0aW5nIGEgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB1c2VkIHRvIGZvcm1hdCB0aGUgbnVtYmVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJlY2lzaW9uOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBCaWdEZWNpbWFsIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB2YWx1ZSBhbmQgbG9jYWxlLlxuICAgICAqIElmIHRoaXMgb2JqZWN0IGlzIHNldCwgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmlnRGVjaW1hbDogQmlnRGVjaW1hbDtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgY3VzdG9tIGljb24gdGhhdCBpcyBwbGFjZWQgaW50byB0aGUgaW5wdXQgZmllbGQuXG4gICAgICpcbiAgICAgKiBUb2RvOiBhZGQgZXh0cmEgYmluZGluZyB0aGF0IHdpbGwgYWxsb3cgZGV2ZWxvcGVyIHRvIHRlbGwgcG9zaXRpb24sIGxlZnQgcmlnaHRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGljb246IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZGVjaW1hbCBwaXBlIGlzIHVzZWQgdG8gZm9ybWF0IG91ciBudW1iZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGRlY2ltYWxQaXBlOiBEZWNpbWFsUGlwZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0dGVkIGRlY2ltYWwgdmFsdWUuIFVzZXMgYW5ndWxhciBkZWNpbWFsUGlwZSB0byBmb3JtYXQgYmFzZWQgb24gbG9jYWxlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nID0gJyc7XG4gICAgLyoqXG4gICAgICogSnVzdCB0byBjbGVhbiB1cCBzdWJzY3JpYmVyIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHByaXZhdGUgdmNoU3Vic2NyaWJlcjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgICAgICB0aGlzLmRlY2ltYWxQaXBlID0gbmV3IERlY2ltYWxQaXBlKGVudi5sb2NhbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IGZpZWxkIHR5cGUuIEN1cnJlbnRseSB3ZSBzdXBwb3J0IGVpdGhlciBOdW1iZXIgb3IgdGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgX3R5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuXG4gICAgZ2V0IHR5cGUoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIGdlbmVyYXRlZCBzZXR0ZXIgdG8gY2hlY2sgZm9yIHZhbHVlIGFuZCBub3JtYWxpemluZyBpbnRvIGV4cGVjdGVkIGVpdGhlciBudW1iZXIgb3IgdGV4dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdHlwZSh2YWx1ZTogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdHJpbmcnIHx8IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdudW1iZXInO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLmJpZ0RlY2ltYWwpO1xuXG4gICAgICAgIHRoaXMudmNoU3Vic2NyaWJlciA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh2YWwgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5iaWdEZWNpbWFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuYmlnRGVjaW1hbC5hbW91bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuU2V0VHlwZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvbktleURvd24oZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CbHVyKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYmlnRGVjaW1hbCA9IG5ldyBCaWdEZWNpbWFsKE51bWJlcihlbC52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdE51bWJlcih0aGlzLmJpZ0RlY2ltYWwuYW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmRpc3BsYXlWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwge29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIG51bWJlciBvYmplY3QgYWNjb3JkaW5nIHRvIGl0cyBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBmb3JtYXROdW1iZXIodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgYmlnRGVjaW1hbCB2YWx1ZSBmb3IgZGlzcGxheS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnByZWNpc2lvbikgJiZcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPT09ICdudW1iZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBwcmVjaXNpb24gaXMgMi4gRm9yIGV4YW1wbGUsIDEwLjIzLlxuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgZGlnaXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmNoU3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHRoaXMudmNoU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEJpZ0RlY2ltYWwgb2JqZWN0IGlzIHJlcHJlc2VudGVkIGFzIGEgdmFsdWUsIGxvY2FsZSwgYW5kIGN1cnJlbmN5Q29kZVxuICovXG5leHBvcnQgY2xhc3MgQmlnRGVjaW1hbCBpbXBsZW1lbnRzIFZhbHVlXG57XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKVxuICAgIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxlOiBTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGFzc05hbWUoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gJ0JpZ0RlY2ltYWwnO1xuICAgIH1cblxuICAgICRwcm90bygpOiBCaWdEZWNpbWFsXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoMSwgJ2VuX1VTJyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnQgKyAnLCBsb2NhbGU6ICcgKyB0aGlzLmxvY2FsZTtcbiAgICB9XG5cblxuICAgIGNsb25lKGRhdGE6IHsgYW1vdW50PzogbnVtYmVyLCBsb2NhbGU/OiBzdHJpbmcgfSA9IHt9KTogQmlnRGVjaW1hbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuYW1vdW50KSA/IGRhdGEuYW1vdW50IDogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZSk7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U3RyaW5nQ29tcG9uZW50fSBmcm9tICcuL3N0cmluZy5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTdHJpbmdGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0lucHV0RmllbGRDb21wb25lbnR9IGZyb20gJy4uL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnQsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSW5wdXRGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICpcbiAqIGJhc2ljIG5hdmlnYXRpb24gYmFyIHByb3ZpZGUgYSBtYWluIGFjdGlvbiBidXR0b25zIGZvciBpdHMgY29udGVudCAocGFnZSBsZXZlbCBidXR0b25zKS5cbiAqIFRoaXMgaXMgbm90IHRoZSBUb3AgbGV2ZWwgYXBwbGljYXRpb24gbmF2aWdhdGlvbi4gVGhpcyBjb21wb25lbnQgcHJvdmlkZXMgYnkgZGVmYXVsdCBhY3Rpb24gT0ssXG4gKiBDQU5DRUwgYW5kIHlvdSBhcmUgZnJlZSB0byBtb2RpZnkgaG93IHRoZSBPSyBvciBDQU5DRUwgd2lsbCBiZSBjYWxsIGFzIHdlbGwgYXMgc3Vic2NyaWJlIHRvIHRoZVxuICogZXZlbnQuIE9yIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBidXR0b25zIHRlbXBsYXRlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoaXMgZGVmYXVsdFxuICogb25lLlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAxOlxuICpcbiAqIEluIG9yZGVyIHRvIHVzZSBuYXZpZ2F0aW9uIGJhciBpbiBpdHMgYmFzaWMgdXNhZ2UgeW91IGNhbiBkbyBmb2xsb3dpbmc6XG4gKiB0aGlzIHdpbGwgcmVuZGVyIGJ1dHRvbnMgb24gdGhlIHRvcCBhcyB3ZWxsIGFzIG9uIHRoZSBib3R0b20gYXJvdW5kIHRoZSBjb250ZW50LlxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgICAgPGF3LWJhc2ljLW5hdmlnYXRvciBbYnJhbmRJbWddPVwiJ2ltZy9hcmliYWxvZ29iYWwucG5nJ1wiPlxuICpcbiAqICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICogICAgICAgICAgICAgICAgPGZvcm0+XG4gKiAgICAgICAgICAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT10ZXh0IHZhbHVlPVwicGV0ZXIucGFuXCI+XG4gKiAgICAgICAgICAgICAgICA8Lzxmb3JtPj5cbiAqICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctYmFzaWMtbmF2aWdhdG9yPlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgaWYgeW91IGRvIG5vdCB3YW50IGJ1dHRvbiBvbiB0aGUgdG9wIG9yIGJvdHRvbSB5b3UgY2FuIHNheSB0aGkgdXNpbmcgYmluZGluZyBzaG93VG9wIG9yXG4gKiBzaG93Qm90dG9tLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAyOlxuICogIEluIHRoaXMgZXhhbXBsZSB3ZSBhcmUgcHJvdmlkaW5nIGN1c3RvbSBidXR0b25zIGFzIHdlbGwgYXMgYnJhbmsgc2VjdGlvblxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqXG4gKiAgICAgIDxhdy1iYXNpYy1uYXZpZ2F0b3IgW2JyYW5kSW1nXT1cIidpbWcvYXJpYmFsb2dvYmFsLnBuZydcIj5cbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNidXR0b25zPlxuICogICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXYgZmxvYXQtbWQtcmlnaHQgY29sbGFwc2UgbmF2YmFyLXRvZ2dsZWFibGUteHNcIj5cbiAqICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25TYXZlQWN0aW9uKCRldmVtdClcIj5DYW5jZWw8L2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGFjdGl2ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25DYW5jZWxBY3Rpb24oJGV2ZW50KVwiPiBTYXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gKiAgICAgICAgICAgICAgICA8L3VsPlxuICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNicmFuZD5cbiAqICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYnJhbmQtdGl0bGVcIj5BcmliYTwvc3Bhbj5cbiAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gKiAgICAgICAgICAgICAgICA8Zm9ybT5cbiAqICAgICAgICAgICAgICAgICAgICBVc2VyIG5hbWU6IDxpbnB1dCB0eXBlPXRleHQgdmFsdWU9XCJwZXRlci5wYW5cIj5cbiAqICAgICAgICAgICAgICAgIDwvPGZvcm0+PlxuICogICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1iYXNpYy1uYXZpZ2F0b3I+XG4gKlxuICpcbiAqIGBgYFxuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWJhc2ljLW5hdmlnYXRvcicsXG4gICAgdGVtcGxhdGVVcmw6ICdiYXNpYy1uYXZpZ2F0b3IuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydiYXNpYy1uYXZpZ2F0b3IuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBCYXNpY05hdmlnYXRvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgdG9wXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RvcDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgYm90dG9tXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JvdHRvbTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBicmFuZCBzZWN0aW9uIHRoYXQgaXMgb24gdGhlIGxlZnQgc2lkZSBhbmQgb25seSBpbiB0aGUgdG9wIGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JyYW5kOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBhdGggdG8gYSBpbWFnZS4gSW1hZ2VzIGFyZSBzYXZlZCBpbnNpZGUgYXNzZXRzIGZvbGRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYnJhbmRJbWc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIE9LIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2tBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBhbiBvYmplY3Qgd2hpY2ggaXMgcmVuZGVyZWQgaW5zaWRlIG5hdi1iYXIgY29udGVudC4gU29tZXRpbWVzIHRoZXJlIGFyZSBzaXR1YXRpb25cbiAgICAgKiB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21lIGluZm9ybWF0aW9uIGZyb20gdGhlIG9iamVjdCBpbnNpZGUgbmF2aWdhdGlvbiBiYXIuIFNvIHlvdSBhcmVcbiAgICAgKiBmcmVlIHRvIHBhc3MgYSBjb250ZXh0IG9iamVjdCBhbmQgdGhlbiBhY2Nlc3MgaXQgaW5zaWRlIHlvdXIgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqIGBgYEhUTUxcbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYnJhbmQgbGV0LWl0ZW0+XG4gICAgICogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJicmFuZC10aXRsZVwiPnt7aXRlbS5maXJzdE5hbWV9fTwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzaG93Q2FuY2VsQnV0dG9uOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFdmVudEVtaXR0ZXIgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB5b3UgY2xpY2sgb24gZGVmYXVsdCBPSyBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT0tBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50RW1pdHRlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjbGljayBvbiBkZWZhdWx0IENBTkNFTCBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnV0dG9ucyB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdidXR0b25zJylcbiAgICBidXR0b25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnJhbmQgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYnJhbmQnKVxuICAgIGJyYW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuXG4gICAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgYXBwQ29uZmlnOiBBcHBDb25maWcpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHRvZG86IGxvYWQgdGhpcyBmcm9tIHJlc291cmNlIGZpbGUgdXNpbmcgbmdUcmFuc2xhdGUgc2VydmljZVxuICAgICAgICB0aGlzLm9rQWN0aW9uTGFiZWwgPSAnT0snO1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbkxhYmVsID0gJ0NhbmNlbCc7XG4gICAgICAgIHRoaXMuYnJhbmRJbWcgPSAnaW1hZ2VzL2FyaWJhbG9nb2JhbC5wbmcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2hvd0NhbmNlbEJ1dHRvbikpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NhbmNlbEJ1dHRvbiA9IHRoaXMuZWRpdGFibGUgfHwgKHRoaXMub25DYW5jZWxBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9uT0tBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGJ1dHRvbnNUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0J1dHRvblRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5idXR0b25zVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYnJhbmRUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0JyYW5kVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJyYW5kVGVtcGxhdGUpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEJ1dHRvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEJ1dHRvbiBjYW4gYmUgcmVuZGVyZWQgZWl0aGVyIGFzXG4gKiBhIGJ1dHRvbiBvciBhcyBhIGxpbmsuIEl0IGNvdWxkIGJlIHN0YW5kYWxvbmUgb3IgYmUgcGFydCBvZiBhIGZvcm0uXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICA8YXctZm9ybS10YWJsZSA+XG4gKiAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidBbW91bnQnXCIgW25hbWVdPVwiJ2Ftb3VudCdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ3N1Ym1pdCdcIiBbbmFtZV09XCInYnV0dG9uJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DbGlja2VkKCRldmVudClcIiBbdmFsdWVdPVwiY29tbWFuZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInd2FybmluZydcIiA+QnV0dG9uPC9hdy1idXR0b24+XG4gKiAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQodmFsdWU6c3RyaW5nKSB7XG4gKiAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gKiAgICAgICAgICAgICAgLy8gc3VibWl0IGZvcm0uXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1idXR0b24nLFxuICAgIHRlbXBsYXRlVXJsOiAnYnV0dG9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnYnV0dG9uLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXRcbntcblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiB0eXBlcyAgWyBidXR0b24gfCBzdWJtaXQgfCByZXNldCBdXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZyA9ICdidXR0b24nO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBmb3IgdGhpcyBidXR0b24uIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5hbWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3R5bGluZyBmb3IgdGhpcyBidXR0b24uIFNlZSBCdXR0b25TdHlsZSBmb3IgYWxsIHN1cHBvcnRlZCBzdHlsZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZTogQnV0dG9uU3R5bGUgPSAncHJpbWFyeSc7XG5cblxuICAgIC8qKlxuICAgICAqIHNpemluZyBmb3IgdGhpcyBidXR0b24uIFtsYXJnZSwgbm9ybWFsLCBzbWFsbF0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaXplOiBCdXR0b25TaXplID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSB0YXJnZXQgb2YgdGhlIGJ1dHRvbi4gW19ibGFuayB8IF9zZWxmIHwgX3BhcmVudCB8IF90b3AgfCBmcmFtZW5hbWUgXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byBiZSBzZW5kIHRvIHNlcnZlciB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBQcmltZU5nIGJ1dHRvbiBzaW1wbHkgZG9lcyBub3Qgc3VwcG9ydCBjb250ZW50IHNvIHdlIG5lZWQgdG8gZ2V0IGFyb3VuZCBpdFxuICAgICAqL1xuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBDU1MgY2xhc3MgdGhhdCBzdHlsZXMgdGhpcyBidXR0b24gYmFzZWQgb24gaW5wdXQgJ3N0eWxlJyBhbmQgJ3NpemUnXG4gICAgICovXG4gICAgYnV0dG9uQ2xhc3M6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBidXR0b24gY2xhc3MgaXMgc2Vjb25kYXJ5LlxuICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi1zZWNvbmRhcnknO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZGlzYWJsZWRcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIEhvdyB0byBzdHlsZSB0aGlzIGJ1dHRvbi5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUgPT09ICdwcmltYXJ5Jykge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgLnVpLWJ1dHRvbiBhbmQgLnVpLWJ1dHRvbi1wcmltYXJ5IGdldCB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgICAgICAgICAvLyAudWktYnV0dG9uLXByaW1hcnkgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYnV0dG9uIHN0eWxlIGNhbiBiZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpbmNsdWRlZCBpbnNpZGUgb3RoZXIgd2lkZ2V0cy4gU28gc3BlY2lmeSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tcHJpbWFyeSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLScgKyB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBidXR0b24gY2xhc3MgYmFzZWQgb24gaW5wdXQgc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhcmdlJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tbGcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1taWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLXNtJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgbGl0dGxlIGhhY2t5IGhhY2tpdHkgaGFjayBhcyBjdXJyZW50bHkgcHJpbWVuZyBidXR0b24gZGlyZWN0aXZlIGRvZXMgbm90IHdvcmsgd2l0aFxuICAgICAqIG5nY29udGVudCBwcm9qZWN0aW9uIGJ1dCBpdCBoYXMgYSBsYWJlbCBiaW5kaW5ncywgd2hpY2ggaXMgbm90IHRoZSB3YXkgZGV2ZWxvcGVycyB3b3JrIHdpdGhcbiAgICAgKiBidXR0b24uIHlvdSB3YW50IHRvXG4gICAgICpcbiAgICAgKiA8YnV0dG9uPiBNWSBDT05URU5UPC9idXR0b24gaW5zdGVhZCBvZiA8YnV0dG9uIGxhYmVsPSdNeUNvbnRlbnQnPjwvYnV0dG9uPlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAVG9kbzogQ2hhbmdlIHRoaXMgdW50aWwgdGhlIHRpbWUga2VlcCBhIHRlc3QgdGhhdCBjaGVjayB0aGF0IHRoZXkgYXJlIHN0aWxsIHVzaW5nIHVpLWJ1dHRvblxuICAgICAqICAgICB0aGF0IHdlIGFyZSBleHBlY3RpbmcgYW5kIHJlcGxhY2luZ1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgIGxldCBidXR0b25UaXRsZSA9IGJ1dHRvbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIGJ1dHRvbi5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd1aS1idXR0b24nLCAnJykucmVwbGFjZSgndWktYnRuJywgJycpO1xuXG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgndWktYnV0dG9uLXRleHQtZW1wdHknKTtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGJ1dHRvblRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBY3Rpb24gY2xpY2tlZC4gQ2FsbCBwYXJlbnQgYWN0aW9uLlxuICAgICAqL1xuICAgIGNsaWNrZWQoJGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGlzQmxhbmsodGhpcy52YWx1ZSkgPyAkZXZlbnQgOiB0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTdXBwb3J0ZWQgQnV0dG9uIFN0eWxlXG4gKi9cbmV4cG9ydCB0eXBlIEJ1dHRvblN0eWxlID0gJ2luZm8nIHwgJ3ByaW1hcnknIHwgJ3NlY29uZGFyeScgfCAnd2FybmluZycgfCAnc3VjY2VzcycgfCAnZGFuZ2VyJyB8XG4gICAgJ2xpbmsnO1xuXG4vKipcbiAqIFN1cHBvcnRlZCBCdXR0b24gU2l6ZVxuICovXG5leHBvcnQgdHlwZSBCdXR0b25TaXplID0gJ2xhcmdlJyB8ICdub3JtYWwnIHwgJ3NtYWxsJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QnV0dG9uQ29tcG9uZW50fSBmcm9tICcuL2J1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtCdXR0b25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0J1dHRvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QmFzaWNOYXZpZ2F0b3JDb21wb25lbnR9IGZyb20gJy4vYmFzaWMtbmF2aWdhdG9yLmNvbXBvbmVudCc7XG5pbXBvcnQge1Rvb2xiYXJNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdCYXNpY05hdmlnYXRvck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC10b3BgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC16dG9wJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVUb3BDb21wb25lbnRcbntcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLWJvdHRvbWAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXpib3R0b20nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxue1xufVxuXG4vKipcbiAqXG4gKiBDYXJkIGNvbXBvbmVudCBpcyBhIGNvbnRhaW5lciByZW5kZXJpbmcgaXRzIGNvbnRlbnQgaW5zaWRlIDMgZGlmZmVyZW50IHpvbmVzLlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgVElUTEUgICAgICAgICAgICAgICAgICAgICAgIHwgQUNUSU9OIHxcbiAqICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgVE9QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgQk9UVE9NICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKlxuICogIFRoZXJlIGFyZSAzIHpvbmVzICArIDEgcGxhY2Vob2xkZXIgZm9yIHRoZSBhY3Rpb25JY29uXG4gKlxuICogIENhcmRzIGNhbiBiZSBzZWxlY3RhYmxlIHdoaWNoIG1lYW5zIHdoZW4geW91IGNsaWNrIG9uIGl0IHRoZXJlIHdpbGwgYmUgcmVuZGVyZWQgYSBib3JkZXIgd2l0aFxuICogIGEgY2hlY2sgbWFyayBpbnNpZGUgQWN0aW9uIHpvbmUgKHRoaXMgaXMgZGVmYXVsdCBiZWhhdmlvcikuXG4gKiAgWW91IGNhbiB1c2UgW3NlbGVjdGFibGVdIGJpbmRpbmcgdG8gZGlzYWJsZSB0aGlzLCBpbiBzdWNoIGNhc2UgY2FyZCB3aWxsIGhhdmUganVzdCBhIGJvcmRlclxuICogIHdpdGhvdXQgYW55IGNoZWNrIG1hcmsuXG4gKlxuICogIENhcmRzIGNhbiBhbHNvIGNvbnRhaW4gY3VzdG9tIEFjdGlvbiB3aGljaCBpcyByZW5kZXJlZCBpbnNpZGUgQUNUSU9OIHpvbmUgYW5kIG9uIHRoZVxuICogIGFwcGxpY2F0aW9uIGxldmVsIHlvdSBjYW4gbGlzdGVuIGZvciAoY2xpY2spIGV2ZW50cyBhcyB3ZWxsIGFzIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBhY3Rpb25cbiAqICBpY29uXG4gKlxuICogIEJlc2lkZXMgQUNUSU9OLCBUSVRMRSwgVE9QIGFuZCBCT1RUT00gY29udGVudCB6b25lcyBjYXJkcyBzdXBwb3J0IGhvdmVyIG92ZXJsYXkgZWZmZWN0IGFuZFxuICogIHdoZW4gaXRzIGFjdGl2YXRlZCB0aGVyZSBpcyBhIG92ZXJsYXkgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY2FyZCB3aXRoIEljb24gaW4gdGhlIG1pZGRsZS5cbiAqICBQbGVhc2Ugbm90ZSB3aGVuIFtoYXNIb3Zlcl0gaXMgVFJVRSBhbGwgdGhlIGFjdGlvbnMgYW5kIHNlbGVjdGFiaWxpdHkgYXJlIGRpc2FibGVkIGFzIHRoZXJlIGlzXG4gKiAgb25seSBvbmUgYWN0aW9uIHdoaWNoIGNsaWNrIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICpcbiAqXG4gKiAjIyNleGFtcGxlIDE6XG4gKiAgQmFzaWMgaG92ZXIgY2FyZCB3aGljaCBieSBkZWZhdWx0IHN1cHBvcnQgc2VsZWN0YWJsZSBtb2RlXG4gKlxuICogYGBgXG4gKiAgICAgICAgICA8YXctY2FyZCAjY2FyZDEgW2hhc0FjdGlvbl09XCJmYWxzZVwiIFt3aWR0aF09XCInMjAycHgnXCIgW2hlaWdodF09XCInMTU0cHgnXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICogICMjI2V4YW1wbGUgMjpcbiAqICAgSG92ZXIgY2FyZCB3aXRoIGN1c3RvbSBhY3Rpb24uIHdoZW4gdW5zZWxlY3RlZCBhY3Rpb24gd2lsbCBhcHBlYXIgYW5kIHVzZXIgY2FuIGNsaWNrIG9uIGl0LlxuICpcbiAqIGBgYFxuICogICAgICAgICAgPGF3LWNhcmQgI2NhcmQxIFtzZWxlY3RhYmxlXT1cInRydWVcIiBbYWN0aW9uSWNvbl09XCInaWNvbi1xdWVzdGlvbi1tYXJrJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChvbkFjdGlvbik9XCJvbkFjdGlvbigzLCAkZXZlbnQpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2FyZCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NhcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhcmQuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHNob3VsZCBleHBsaWNpdGx5IGhpZGUgdGhlIGFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoYXNBY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgc2VsZWN0YWJsZSBtb2RlIHN1cHBvcnRlZD8gU2F5aW5nIFllcywgY2FyZCB3aWxsIGhhdmUgYnkgZGVmYXVsdCBjaGVjay1tYXJrIGluIHRoZVxuICAgICAqIEFDVElPTiB6b25lIHdoZW4gc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gXCJDYXJkIFNlbGVjdGVkXCIgSWNvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZEljb246IHN0cmluZyA9ICdpY29uLWFjY2VwdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlIGZvciBhY3Rpb24gaWNvbiwgd2hlbiBhcHBsaWNhdGlvbiB3YW50IHRvIGFkZCBhY3Rpb24gdG8gdGhlIGNhcmRcbiAgICAgKiBpdCBtdXN0IGFsc28gcHJvdmlkZSBhIGljb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uSWNvbjogc3RyaW5nO1xuXG4gICAgLypcbiAgICAgKiBFbmFibGUgYW5kIGRpc2FibGVzIGhvdmVyIGVmZmVjdCBvbiB0b3Agb2YgdGhlIGNhcmRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhhc0hvdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHQgaWNvbiBuYW1lIGZvciB0aGUgaG92ZXIgb3ZlcmxheS4gVGhpcyBpY29ucyBzaG93cyB1cCBpbiB0aGUgbWlkZGxlIG92ZXIgdGhlIGNhcmRcbiAgICAgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgY2VudGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaG92ZXJJY29uOiBzdHJpbmcgPSAnaWNvbi1hZGQnO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU2VsZWN0aW9uIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2FyZCBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYWN0aW9uIGljb24gaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Ib3ZlckFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcXVlcnkgaXMgdXNlZCB0byBzYXZlIHRoZSBjb250ZW50IHJlZmVyZW5jZSB0byBib3R0b20gc2VjdGlvbiBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENhcmRab25lQm90dG9tQ29tcG9uZW50KVxuICAgIGJvdHRvbTogQ2FyZFpvbmVCb3R0b21Db21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGN1c3RvbSB0ZW1wbGF0ZSBmb3IgdGhlIGJvZHkgd2hpY2ggaXMgdW5kZXIgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNvbnRyb2wuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAVmlld0NoaWxkKCdob3ZlckRpdicpXG4gICAgaG92ZXJEaXY6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBVc3VhbGx5IHdoZW4gdGVtcGxhdGUgaXMgcHJvdmlkZWQgd2Ugd2FudCB0byB1c2UgaXQgYW5kIHJlcGxhY2UgaW50ZXJuYWwgb25lIGJ1dCBpbiB0aGlzXG4gICAgICogY2FzZSBpdCB3aWxsIGJlIGFsd2F5cyBjb25kaXRpb25hbCBhbmQgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNhbiBzd2l0Y2ggYmV0d2VlbiBkZWZhdWx0XG4gICAgICogdGVtcGxhdGUgd2l0aCB6b25lcyBhbmQgY3VzdG9tIG9uZSBwcm92aWRlZCBieSBkZXZlbG9wZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICB1c2VCb2R5VGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHNldHMgZGVmYXVsdCB2YWx1ZVxuICAgICAgICB0aGlzLndpZHRoID0gJzIwMnB4JztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTU0cHgnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gSWYgYXBwbGljYXRpb24gd2FudHMgdG8gdXNlIGFjdGlvbiBpdCBtdXN0IHByb3ZpZGUgYWN0aW9uSWNvblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmFjdGlvbkljb24pICYmIHRoaXMuaGFzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYWN0aW9uIGljb24nKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNob3dCb3R0b21TZWN0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib3R0b20pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogZmlyZXMgc2VsZWN0IGFuZCB1bnNlbGVjdCBldmVudC5cbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3QoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT25seSBmaXJlZCB3aGVuIGFjdGlvbiBpcyByZW5kZXJlZCBhbmQgdXNlciBjbGlja3Mgb24gY3VzdG9tIGFjdGlvbkljb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQWN0aW9uQ2xpY2soZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhc0FjdGlvbiAmJiAoIXRoaXMuc2VsZWN0ZWQgfHwgIXRoaXMuc2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpb24uZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCAgd2hlbiBob3ZlciBlZmZlY3QgaXMgb24gKyB1c2VyIGNsaWNrIG9uIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhvdmVyKGlzRW50ZXI6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaG92ZXJEaXYpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyRGl2Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGlzRW50ZXIgPyAwLjUgOiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGltcGxpY2l0IGNhcmQgdGVtcGxhdGUgd2l0aCBvdXIgem9uZXMgb3JcbiAgICAgKiB1c2VyIHByb3ZpZGVkIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93Qm9keVRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib2R5VGVtcGxhdGUpICAmJiB0aGlzLnVzZUJvZHlUZW1wbGF0ZTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIE1hcHMgb3VyIGludGVybmFsIGFsaWdubWVudCB2YWx1ZSB0byByZWFsIGNzcyB2YWx1ZXNcbiAqXG4gKi9cbmNvbnN0IFZBbGlnbk1hcCA9IHtcbiAgICAndG9wLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1jZW50ZXInOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnY2VudGVyLWxlZnQnOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICdjZW50ZXItcmlnaHQnOiAnY2VudGVyJyxcbiAgICAnYm90dG9tLWxlZnQnOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLXJpZ2h0JzogJ2ZsZXgtZW5kJ1xufTtcblxuXG5jb25zdCBIQWxpZ25NYXAgPSB7XG4gICAgJ3RvcC1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICd0b3AtY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2NlbnRlci1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdjZW50ZXItY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2JvdHRvbS1yaWdodCc6ICdmbGV4LWVuZCdcbn07XG5cblxuLyoqXG4gKiBUaXRsZSB6b25lIHByb3ZpZGVzIGEgY29udGVudCBwbGFjZWhvbGRlciBmb3IgdGhlIFRpdGxlIEFyZWEuIFRoaXMgem9uZSBpcyBhZGRpbmcgYWJpbGl0eVxuICogdG8gYWxpZ24gaXRzIGNvbnRlbnQgaW50byA5IGRpZmZlcmVudCBwb3NpdGlvbi5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIFRpdGxlIHpvbmUgd2l0aGluIDxhdy1jYXJkPiBhczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8YXctY2FyZCAgW3dpZHRoXT1cIicyMDJweCdcIiBbaGVpZ2h0XT1cIicxNTRweCdcIiBbaGFzSG92ZXJdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwiZmFsc2VcIiBbaGFzQWN0aW9uXT1cImZhbHNlXCJcbiAqICAgICAgICAgICAgICAgICAgKG9uSG92ZXJBY3Rpb24pPVwib25BY3Rpb24oNywgJGV2ZW50KVwiID5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImEtc3VwcGxpZXItdGFnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgIDwvYXctY2FyZC10aXRsZT5cbiAqXG4gKiAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqIERlZmF1bHQgYWxpZ25tZW50IGlzIHRvcC1sZWZ0XG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtdGl0bGVgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC10aXRsZSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBwcm9wZXJ0eSB3aGljaCBpcyB1c2VkIHRvIGFwcGx5IGZsZXggcHJvcGVydGllcyBmb3IgYWxpZ25pbmcgY29udGVudCB2ZXJ0aWNhbGx5XG4gICAgICogYXMgd2VsbCBhcyBob3Jpem9udGFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ246IENhcmRUaXRsZUFsaWdubWVudCA9ICd0b3AtbGVmdCc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWxlbTogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9IFZBbGlnbk1hcFt0aGlzLmFsaWduXTtcbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBIQWxpZ25NYXBbdGhpcy5hbGlnbl07XG4gICAgfVxufVxuXG5cbi8qKlxuICogTWFrZSBzdXJlIHdlIGRvbnQgYWNjZXB0IGFueSB1bnN1cHBvcnRlZCB2YWx1ZXMuIFRoZXNlIHZhbHVlcyBtYXBzIHRvIHRoZSBIQWxpZ25NYXAgYW5kXG4gKiBWQWxpZ25NYXAgaW4gb3JkZXIgdG8gZ2V0IHJlYWwgY3NzIHZhbHVlIGZvciB0aGUgZmxleCBhbGlnbm1lbnRcbiAqL1xuZXhwb3J0IHR5cGUgQ2FyZFRpdGxlQWxpZ25tZW50ID0gJ3RvcC1sZWZ0JyB8ICd0b3AtY2VudGVyJyB8ICd0b3AtcmlnaHQnIHwgJ2NlbnRlci1sZWZ0JyB8XG4gICAgJ2NlbnRlci1jZW50ZXInICB8ICdjZW50ZXItcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tY2VudGVyJyB8ICdib3R0b20tcmlnaHQnO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtDYXJkQ29tcG9uZW50LCBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudCwgQ2FyZFpvbmVUb3BDb21wb25lbnR9IGZyb20gJy4vY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtDYXJkWm9uZVRpdGxlQ29tcG9uZW50fSBmcm9tICcuL2NhcmQtdGl0bGUvY2FyZC10aXRsZS5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDYXJkQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRpdGxlQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRvcENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVCb3R0b21Db21wb25lbnRcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENhcmRDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVGl0bGVDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVG9wQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NhcmRNb2R1bGVcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQm9vbGVhbiwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiAgQ2hlY2tib3hUeXBlIGRlc2NyaWJlcyB3aGF0IHR5cGUgb2YgY2hlY2tib3ggaXMgdGhpczpcbiAqXG4gKiAtIEZvcm0gdHlwZTogdGhhdCBpcyB3cml0aW5nIGFuZCByZWFkaW5nIGEgdmFsdWUgZnJvbS90byBtb2RlbCBib3RoIHVzaW5nIEZvcm1Hcm91cCBhcyB3ZWxsXG4gKiAgICAgICAgICAgICAgYXMgbmdNb2RlbFxuICogLSBBY3Rpb24gdHlwZTogIG9ubHkgZmlyZXMgYWN0aW9uIGFuZCBkb2VzIG5vdCB3cml0ZSB2YWx1ZSB0byBtb2RlbC5cbiAqXG4gKlxuICovXG5leHBvcnQgdHlwZSBDaGVja2JveFR5cGUgPSAnZm9ybScgfCAnYWN0aW9uJztcblxuLyoqXG4gKlxuICogSW1wbGVtZW50cyBzdGFuZGFyZCBIVE1MIGNoZWNrYm94IG9uIHRvcCBvZiBQcmltZU5HLiBUaGVyZSBhcmUgMiB0eXBlcyBvZlxuICoge0BsaW5rIENoZWNrYm94Q29tcG9uZW50fTogZm9ybSBhbmQgYWN0aW9uIGNoZWNrYm94IGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqXG4gKlxuICogVXNhZ2U6IEJhc2ljIGV4YW1wbGUgaGF2aW5nIHJlZCBjaGVja2JveCBjaGVja2VkXG4gKlxuICogYGBgSFRNTFxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICA8L2F3LWNoZWNrYm94PlxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgPC9hdy1jaGVja2JveD5cbiAqXG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICpcbiAqXG4gKiAgIGNsYXNzIENCQmFzaWNXaXRoTmdNb2RlbENvbXBvbmVudFxuICogICB7XG4gKlxuICogICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICB7XG4gKiAgICAgICB9XG4gKiAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcyBwbGVhc2Ugc2VlIGEgcGxheWdyb3VuZCBvciB1bml0IHRlc3QuXG4gKlxuICovXG5leHBvcnQgY29uc3QgQ0JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNoZWNrYm94JyxcbiAgICB0ZW1wbGF0ZVVybDogJ2NoZWNrYm94LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnY2hlY2tib3guY29tcG9uZW50LnNjc3MnXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIENoZWNrYm94Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjaGVja2JveFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgY2hlY2tib3guIEZvcm0gYmFzZWQgdXBkYXRlcyBtb2RlbCBhbmQgQWN0aW9uIGJhc2VkIG9ubHkgZmlyZXMgY2xpY2sgZXZlbnRzXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IENoZWNrYm94VHlwZSA9ICdmb3JtJztcblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIGNoZWNrYm94XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGNsaWNrIGV2ZW50LlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFByaW1lTkcgaGFzIHRoaXMgdHlwZSBjYWxsZWQgYmluYXJ5IHdoaWNoIHdvcmtzIG9ubHkgd2l0aCBCb29sZWFuIG1lYW5pbmcgaXQgZG9lcyBub3QgYWRkIG9yXG4gICAgICogcmVtb3ZlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEluIG91ciBjYXNlIENoZWNrdHlwZSA9IEFjdGlvbiBpcyBhbHdheXMgYmluYXJ5IG9yIHdoZW4gdGhpcy52YWx1ZSBpcyBib29sZWFuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JpbmFyeTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgZm9yIGNoZWNrYm94XG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy5hY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDAgPyAnYWN0aW9uJyA6IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAodGhpcy5pc0Zvcm1UeXBlKCkpIHtcbiAgICAgICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNvbnRyb2wgZnJvbSBwYXJlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdmFsdWUgaXMgYm9vbGVhbiB3ZSBhcmUgZGVhbGluZyB3aXRoIFByaW1lTmcgQmluYXJ5IGNoZWNrYm94XG4gICAgICAgIC8vIHdoaWNoIG9ubHkgc2V0cyBUUlVFL0ZBTFNFIGFuZCBkb2VzIG5vdCBhZGQgb3IgcmVtb3ZlIHZhbHVlc1xuICAgICAgICB0aGlzLmlzQmluYXJ5ID0gaXNCb29sZWFuKHRoaXMudmFsdWUpO1xuXG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWyd2YWx1ZSddKSAmJlxuICAgICAgICAgICAgKGNoYW5nZXNbJ3ZhbHVlJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyd2YWx1ZSddLnByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gQ2hlY2tib3ggaXMgY2xpY2tlZCBhbmQgaXQgZWl0aGVyIGZpcmUgYWN0aW9uIG9yIHVwZGF0ZXMgdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxsIGlmIHdlIGFyZSB1c2luZyBGb3JtIENoZWNrYm94LiBUaGlzIGlzIHVzZWQgcmVtb3ZlIHNvbWUgb2YgdGhlIGJpbmRpbmdzIHRoYXQgYXJlIG5vdFxuICAgICAqIGFwcGxpY2FibGUgZm9yIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzRm9ybVR5cGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2Zvcm0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubW9kZWwgJiYgdGhpcy5pc0Zvcm1UeXBlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NoZWNrYm94Q29tcG9uZW50fSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQge0NoZWNrYm94TW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDaGVja2JveENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaGVja2JveENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaGVja0JveE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiAgQ2hlY2tib3ggbGlzdCBpcyBhIHdyYXBwZXIgY2xhc3MgYXJvdW5kICdDaGVja2JveCcgY29tcG9uZW50IHRvIHNpbXBseSBhc3NlbWJseSBvZiBtdWx0aSBjaG9pY2VcbiAqIGNvbXBvbmVudFxuICpcbiAqIEluIEFkZGl0aW9uIGl0IGFkZHMgYWJpbGl0eSB0byB3b3JrIHdpdGggY29tcGxleCBvYmplY3QuIFByaW1lTkcgY2hlY2tib3hlcyB3b3JrIG9ubHkgd2l0aFxuICogcHJpbWl0aXZlIHZhbHVlcy5cbiAqXG4gKiBAc2VlIHtAbGluayBjaGVjay1ib3gvY2hlY2stYm94LmNvbXBvbmVudC50c31cbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKlxuICogICAgQENvbXBvbmVudCh7XG4gKiAgICAgICBzZWxlY3RvcjogJ3Nob3dDaGVja0JveExpc3QnICxcbiAqICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgPGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCIgW3NlbGVjdGlvbnNdPVwic2VsZWN0ZWRWYWx1ZXNcIlxuICpcbiAqICAgICAgICAgICAgW25hbWVdPVwiJ215Q29sb3JzJ1wiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGlja1wiPlxuICogICAgICAgICAgIDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICAgICAgIGBcbiAqXG4gKiAgICAgICB9KVxuICogICAgICAgIGNsYXNzIE15U2hvd0NMQ29tcG9uZW50XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBjaGVja0JveExpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdyZWQnICwgJ3llbGxvdycgLCAnb3JhbmdlJyAsICd3aGl0ZScgLFxuICogICAgICdzaWx2ZXInICwgJ2JsYWNrJyAsXG4gKiAgICAgICAgICAgICdHcmVlbicgLCAnR3JheScgLCAnTmF2eScgLCAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICpcbiAqICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKlxuICpcbiAqICAgICAgICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICAgICAgICBvbkNCQ2xpY2sgKGV2ZW50KTogdm9pZFxuICogICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICB9XG4gKipcbiAqL1xuXG5cblxuXG5leHBvcnQgY29uc3QgQ0JfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tCb3hMaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNoZWNrYm94LWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnY2hlY2stYm94LWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydjaGVjay1ib3gtbGlzdC5jb21wb25lbnQuc2NzcyddLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja0JveExpc3RDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tCb3hMaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiB2YWx1ZXMgdXNlZCB0byByZW5kZXIgY2hlY2tib3hlcy4gRXZlbiB3ZSBoYXZlIGhlcmUgdHlwZSBhcyBBTlkgd2UgaW50ZXJuYWxseVxuICAgICAqIHN1cHBvcnQgb25seSBzdHJpbmcgYXQgdGhlIG1vbWVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqICBTZWxlY3Rpb25zIGFyZSBkZWZhdWx0IENIRUNLRUQgdmFsdWVzIHBhc3NlZC4gZS5nLiBXaGVuIHJlbmRlcmluZyBmaWVsZCBmYXZvcml0ZSBjb2xvcnM6XG4gICAgICogYmx1ZSwgcmVkLCB5ZWxsb3cgeW91IHdpbGwgcGFzcyBpbiBoZXJlIGJsdWUsIHJlZCwgdGhlbiBjaGVja2JveGVzIHdpdGggdmFsdWUgYmx1ZSwgcmVkIHdpbFxuICAgICAqIGJlIHJlbmRlcmVkIGFzIGNoZWNrIGFuZCB5ZWxsb3cgdW5jaGVja2VkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25zOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGV2ZW50IHdoZW4gY2hlY2tib3ggaXMgc2VsZWN0ZWQvY2xpY2tlZC4gRW1pdHMgY3VycmVudCBjbGlja2VkIGNoZWNrYm94ZWQuIG5vdCB0aGVcbiAgICAgKiBhY3R1YWxsIGludGVybmFsIG1vZGVsIHZhbHVlIGluIHRoaXMgY2FzZSBhcnJheSBvZiBjaG9pY2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIHNwZWNpYWwgZXhwcmVzc2lvbiB0byBmb3JtYXQgbGFiZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbFxuICAgICAqL1xuICAgIG1vZGVsOiBhbnkgPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLnNlbGVjdGlvbnMpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuc2VsZWN0aW9ucyk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRNb2RlbDogYW55W10gPSBbXTtcblxuICAgICAgICB0aGlzLm1vZGVsLmZvckVhY2goKGluZGV4OiBudW1iZXIpID0+IHVwZGF0ZWRNb2RlbC5wdXNoKHRoaXMubGlzdFtpbmRleF0pKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBpcyBleHRyYWN0ZWQgaW50byB0aGlzIG1ldGhvZCBzbyBpbiB0aGUgZnV0dXJlIHdlIGNhbiBwbGF5IG1vcmUgaG93IHdlIHdhbnQgdG8gZGlzcGxheVxuICAgICAqIHRoZSB2YWx1ZS4gU2luY2UgSSB3YW50IHRvIHN1cHBvcnQgZm9ybWF0dGVycyBmb3IgZWFjaCBjb21wb25lbnRzIHdlIG1pZ2h0IGhhdmUgYSBjaGFuY2UgdG9cbiAgICAgKiBkZWNpZGUgaG93IGxhYmVsIHdpbGwgbG9vayBsaWtlLlxuICAgICAqXG4gICAgICovXG4gICAgbGFiZWxWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiB0aGlzIHZlcnNpb24gb2YgY2hlY2tib3hlcyB3ZSBzdGlsbCBleHBlY3Qgb25seSBwcmltaXRpdmUgdHlwZXMuIEtlZXAgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICogaW4gZXh0cmEgbWV0aG9kIHNvIHdlIGNhbiB3b3JrIHdpdGggaXQgZXZlbiBub3cgd2UganVzdCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFja1xuICAgICAqL1xuICAgIHZhbHVlKGl0ZW06IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgZXZlbnQgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudCBhbmQgY29udmVydCBpbmRleGVkIG1vZGVsIHRvIG9yaWdpbmFsIG9iamVjdHNcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnlbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMubW9kZWwuZm9yRWFjaCgoaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdXBkYXRlZE1vZGVsLnB1c2godGhpcy5saXN0W2luZGV4XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGNvbXBsZXggb2JqZWN0IHN0b3JlIG9ubHkgSU5ERVhlcyBudW1iZXIgaW4gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW9kZWwoc291cmNlTGlzdDogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBzb3VyY2VMaXN0LmZvckVhY2goKGl0ZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5saXN0LmZpbmRJbmRleCgoZWxlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHMoaXRlbSwgZWxlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucHVzaChpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tb2RlbCkgJiYgaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IG5ld01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKG5ld01vZGVsKTtcblxuICAgICAgICAgICAgLy8gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hlY2tCb3hMaXN0Q29tcG9uZW50fSBmcm9tICcuLi9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDaGVja0JveExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZVxuICAgIF0sXG5cblxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2hlY2tCb3hMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hlY2tCb3hMaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBIeXBlcmxpbmsgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yLiBIeXBlcmxpbmsgc3VwcG9ydHMgYWxsIG9mIHRoZVxuICogbmF0aXZlIGxpbmsgZnVuY3Rpb25hbGl0eS4gSW4gYWRkaXRpb24sIGl0IHN1cHBvcnRzIG5hdmlnYXRpb24gdG8gY29tcG9uZW50cyB0aHJvdWdoIHRoZSBhY3Rpb25cbiAqIGJpbmRpbmcuXG4gKlxuICpcbiAqIGZvciBtb3JlIGluZm8gcGxlYXNlIHNlZSBjbGFzcyBEb2Mgb2YgdGhlOlxuICogIEBzZWUge0BsaW5rIGJ1dHRvbi9idXR0b24uY29tcG9uZW50LnRzfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICAgICA8YXctaHlwZXJsaW5rICBbdHlwZV09XCIndGV4dC9odG1sJ1wiIFtuYW1lXT1cIidsaW5rJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DbGlja2VkKCRldmVudClcIiBbdmFsdWVdPVwiY3VzdG9tZXJJZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtzaXplXT1cIidsYXJnZSdcIiA+bXkgbGluazwvYXctaHlwZXJsaW5rPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBjb21tYW5kOmJvb2xlYW47XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICAgICAgb25DbGlja2VkKGN1c3RvbWVySWQ6c3RyaW5nKSB7XG4gKiAgICAgICAgICAgaWYgKGN1c3RvbWVySWQpIHtcbiAqICAgICAgICAgICAgICAvLyBkaXNwbGF5IGN1c3RvbWVyIGRldGFpbHMgY29tcG9uZW50LlxuICogICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaHlwZXJsaW5rJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2h5cGVybGluay5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2h5cGVybGluay5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEh5cGVybGlua0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqICAgIFNwZWNpZmllcyB0aGUgbWVkaWEgdHlwZSBvZiB0aGUgbGlua2VkIGRvY3VtZW50LiBNaW1lIHR5cGVcbiAgICAgKiAgICBleDogW3RleHQvaHRtbCB8IHRleHQvY3N2IHwgaW1hZ2UvcG5nIHwgYXVkaW8vM2dwcCB8IC4uLi5dXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiB1cmwgZm9yIHRoaXMgaHlwZXJsaW5rLiBDYW4gYmUgdXNlZCB0byBuYXZpZ2F0ZSB0byBhIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhyZWY6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIHJlbCBmb3IgdGhpcyBoeXBlcmxpbmsuIFNwZWNpZnkgdGhlIHJlbGF0aW9uc2hpcCBvZiB0aGUgY3VycmVudCBkb2N1bWVudCBhbmQgbGlua2VkIGRvY3VtZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc2l6aW5nIGZvciB0aGlzIGxpbmsuIFtsYXJnZSwgbm9ybWFsLCBzbWFsbF0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaXplOiBMaW5rU2l6ZSA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgdGFyZ2V0IG9mIHRoZSBoeXBlcmxpbmsuIFtfYmxhbmsgfCBfc2VsZiB8IF9wYXJlbnQgfCBfdG9wIHwgZnJhbWVuYW1lIF1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhcmdldDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gYmUgc2VuZCB0byBzZXJ2ZXIgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIENTUyBjbGFzcyB0aGF0IHN0eWxlcyB0aGlzIGh5cGVybGluayBiYXNlZCBvbiBpbnB1dCAnc2l6ZSdcbiAgICAgKi9cbiAgICBsaW5rQ2xhc3M6IHN0cmluZyA9ICdsaW5rJztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBsaW5rIGNsYXNzIGJhc2VkIG9uIGlucHV0IHNpemUuXG4gICAgICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFyZ2UnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLWxnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm9ybWFsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1taWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstc20nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIEkgaGF2ZSBhbiBhY3Rpb24gdGFnLCBhbmQgbm8gaHJlZi4gV2UgYWRkIGRlZmF1bHQgc3R5bGluZyBhbmQgYmVoYXZpb3IuXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLWJoJztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEFjdGlvbiBjbGlja2VkLiBDYWxsIHBhcmVudCBhY3Rpb24uXG4gICAgICovXG4gICAgY2xpY2tlZChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogU3VwcG9ydGVkIExpbmsgU2l6ZVxuICovXG5leHBvcnQgdHlwZSBMaW5rU2l6ZSA9ICdsYXJnZScgfCAnbm9ybWFsJyB8ICdzbWFsbCc7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0h5cGVybGlua0NvbXBvbmVudH0gZnJvbSAnLi9oeXBlcmxpbmsuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0h5cGVybGlua01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHt1bmltcGxlbWVudGVkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNlbGVjdGlvbiBTdGF0ZSBmb3IgdGhlIGNob29zZXIgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjb211bmljYXRlIHdpdGggdGhlIHBhcmVudCBvYmplY3QgdXNpbmcgYVxuICogY2hvb3Nlci4gSWYgSSB3b3VsZCBoYXZlIHRvIG1hbmFnZSBvbmx5IHNpbmdsZSB2YWx1ZXMgd2l0aCBubyBhZGRpb25hbCBtZXRob2RzIGkgd291bGQgdXNlclxuICogZW1pdHRlcnMgdG8gZG8gdGhlIGpvYiwgYnV0IGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRoaXMgaW50ZXJmYWNlIChhYnN0cmFjdCBjbGFzcykgYmV0d2VlbiBhXG4gKiBjaG9vc2VyIGFuZCBhY3R1YWwgb2JqZWN0LlxuICpcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldCBzZWxlY3Rpb24gc3RhdGUgaXMgdXN1YWxseSB0cmlnZ2VyZWQgYnkgc2VsZWN0aW5nIGFuZCB1bnNlbGVjdGluZyBhIGl0ZW0gKGluIGNhc2Ugb2ZcbiAgICAgKiBtdWx0aXNlbGVjdCkgYW5kIGl0IHNob3VsZCB1cGRhdGUgaXRzIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIGVpdGhlciBzZXR0aW5ncy9hZGRpbmcgaXRlbSBvclxuICAgICAqIHJlbW92aW5nIGl0LlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gLiBOdWxsIGlmIGxhc3QgYWN0aW9uIHdhcyBhIGRlc2VsZWN0aW9uLiBVc3VhbGx5IHVzZWQgYnkgQ2hvb3NlclxuICAgICAqIG9yIENob29zZXJTdGF0ZSB0byBnZXQgY3V1cmVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBpdGVtIHNlbGVjdGlvbiBpdGVtcyBpcyBpbiB0aGUgc2VsZWN0ZWRPYmplY3RzXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChzZWxlY3Rpb246IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Nob29zZXJTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZSc7XG5pbXBvcnQge0RhdGFTb3VyY2V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5cbi8qKlxuICogQ2hvb3NlclN0YXRlIG1hbmFnZXMgY29tcGxldGUgbGlmZWN5Y2xlIGZvciB0aGUgQ2hvb3NlciBDb21wb25lbnQuIEl0IGtlZXBzIHRyYWNrIG9mIGN1cnJlbnRcbiAqIHNlbGVjdGlvbiBhcyB3ZWxsIGFzIGl0IGNhbiBicm9hZGNhc3QgYW55IHVwZGF0ZXMuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENob29zZXJTdGF0ZVxue1xuXG4gICAgLyoqXG4gICAgICogIENhbGxiYWNrIHRvIHRoZSBwYXJlbnQgb2JqZWN0IHRvIHN0b3JlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2VsZWN0aW9uU3RhdGU6IENob29zZXJTZWxlY3Rpb25TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIHRvZG86IFdlIGRvIG5vdCBuZWVkZWQgdGhpcyAhIVxuICAgICAqL1xuICAgIGN1cnJlbnRJdGVtOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIHBhdHRlcm4uIFVzZXIgbGF0ZXN0IGlucHV0IHRvIHRoZSBjaG9vc2VyIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgcGF0dGVybjogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYXN0IHN1Y2Nlc3NmdWxsIHBhdHRlcm4gdGhhdCByZXRyaWV2ZWQgc29tZSBkYXRhXG4gICAgICovXG4gICAgbGFzdEZ1bGxNYXRjaFBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBtYXRjaGVkIGl0ZW1zIHVzaW5nIENob29zZXJTZWxlY3Rpb25TdGF0ZVxuICAgICAqL1xuICAgIG1hdGNoZXM6IEFycmF5PGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbXVsdGlzZWxlY3QgY2hvb3NlclxuICAgICAqL1xuICAgIG11bHRpc2VsZWN0OiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIGNhbiBzZXQgbG9va3VwIGtleSB0byBuYXJyb3cgdGhlIHNlYXJjaC4gSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBvYmplY3RcbiAgICAgKiB5b3Ugc2hvdWxkIHNldCB0aGlzLlxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwS2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHByZXZpb3VzIGRpc3BsYXkgdmFsdWUgaXMgc2V0IHdoZW4gdGhlIGRpc3BsYXkgdmFsdWUgaXMgcmVuZGVyZWQgb24gdGhlIGNob29zZXIuIHdlIGNhY2hlXG4gICAgICogdGhlIFVJIHZhbHVlIHRvIGNvbXBhcmUgd2l0aCB0aGUgaW5ib3VuZCB2YWx1ZSBsYXRlciBpbnN0ZWFkIG9mIHRoZSB2YWx1ZSBmcm9tIHVuZGVybHlpbmdcbiAgICAgKiBvYmplY3QgYmVjYXVzZSBidXNpbmVzcyBsb2dpYyBsZXZlbCBjb2RlIGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgdW5kZXJseWluZyBvYmplY3QncyB2YWx1ZVxuICAgICAqXG4gICAgICogdG9kbzogZG8gSSBzdGlsbCBuZWVkIHRoaXM/XG4gICAgICovXG4gICAgcHJldkRpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlcmUgYXJlIGFueSB2YWxpZGF0aW9uIGxpa2UgZW50ZXJlZCB2YWx1ZSBkb2VzIG5vdCBtdWNoIHdpdGggdGhlIHNvdXJjZSBsaXN0LlxuICAgICAqXG4gICAgICovXG4gICAgaXNJbnZhbGlkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIGluZGljYXRlcyB0aGF0IHdlIHN0YXJ0ZWQgdG8gc29tZSBlZGl0aW5nIGUuZy4gc3RhcnRpbmcgdG8gdHlwZSBpbiBzb21ldGhpbmcgaW50byB0aGVcbiAgICAgKiBmaWx0ZXIsIG9yIHJlbW92aW5nIGFscmVhZHkgc2VsZWN0ZWQgaXRlbXNcbiAgICAgKi9cbiAgICBhZGRNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIHJlY2VudFNlbGVjdGVkRGlzcGxheWVkOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSB3ZSBkbyBub3Qgc2hvdyBhbGwgc2VsZWN0ZWQgaXRlbXMsIGJ1dCBtYXggbnVtYmVyIHRoYXQgaXNcbiAgICAgKiBkZWZpbmVkLiBVc2VyIGlzIGFibGUgdG8gdG9nZ2xlIHRvIGV4cGFuZCB0aGUgdmlldyB0byBzZWUgYWxsIHNlbGVjdGlvbnMgYW5kIGhpZGUgdGhlbSBhc1xuICAgICAqIHdlbGxcbiAgICAgKi9cbiAgICBzaG93QWxsUmVjZW50bHlTZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihjaG9vc2VyU2VsZWN0aW9uU3RhdGU/OiBDaG9vc2VyU2VsZWN0aW9uU3RhdGUsIGlzTXVsdGk6IGJvb2xlYW4gPSB0cnVlKVxuICAgIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gY2hvb3NlclNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm11bHRpc2VsZWN0ID0gaXNNdWx0aTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvblN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZSA9IG5ldyBEZWZhdWx0U2VsZWN0aW9uU3RhdGUodGhpcy5tdWx0aXNlbGVjdCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXQgd2lsbCBzZWxlY3QgYW5kIHBlcnNpc3QgYW4gaXRlbSB1c2luZyBDaG9vc2VyU2VsZWN0aW9uU3RhdGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFkZE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3RlZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0ZWRPYmplY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgIUxpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleChzZWxlY3RlZE9iamVjdHMsIGl0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3RlZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3RlZE9iamVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzZXIgc2VsZWN0aW9uIGlzIGxhcmdlIHdlIHVzZSB0aGlzIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBuZWVkIHRvIHNob3cgYWxsIHNlbGVjdGVkXG4gICAgICogaXRlbXMgb3Igb25seSBNYXhSZWNlbnRTZWxlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZUFsbFNlbGVjdGVkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQgPSAhdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVuZGVycyB1c2VyJ3Mgc2VsZWN0aW9uIHVuZGVyIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHJlY2VudFNlbGVjdGVkT2JqZWN0cygpOiBBcnJheSA8YW55PlxuICAgIHtcblxuICAgICAgICBpZiAoIXRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWNlbnRTZWxlY3RlZE9iamVjdHM6IGFueVtdID0gW107XG4gICAgICAgIHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQgPSAwO1xuICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3RzID0gdGhpcy5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgbGV0IHNpemUgPSBzZWxlY3RlZE9iamVjdHMubGVuZ3RoO1xuICAgICAgICBsZXQgbWF4Q291bnQgPSBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkO1xuICAgICAgICBpZiAoc2l6ZSA+IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQgJiYgIXRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG1heENvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG1heENvdW50ID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBzaXplIC0gMTsgaSA+PSAwICYmICh0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkIDwgbWF4Q291bnQpOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBzZWxlY3RlZE9iamVjdHNbaV07XG4gICAgICAgICAgICByZWNlbnRTZWxlY3RlZE9iamVjdHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY2VudFNlbGVjdGVkT2JqZWN0cztcbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXRlLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgfVxuXG5cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3Rpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb24sIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8qKlxuICogRHVtbXkgaW1wbGVtZW50YXRpb24gQ2hvb3NlclNlbGVjdGlvblN0YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U2VsZWN0aW9uU3RhdGUgZXh0ZW5kcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcbiAgICBwcml2YXRlIF9zZWxlY3RlZE9iamVjdDogYW55O1xuICAgIHByaXZhdGUgX3NlbGVjdGVkT2JqZWN0czogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG11bHRpU2VsZWN0OiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT2JqZWN0ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QgJiYgIUxpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9iamVjdHMoKS5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5zZWxlY3RlZE9iamVjdHMoKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkT2JqZWN0O1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLl9zZWxlY3RlZE9iamVjdHMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE9iamVjdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRPYmplY3RzO1xuICAgIH1cblxuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNTZWxlY3RlZChzZWxlY3Rpb24pO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhU291cmNlLCBEU0luaXRQYXJhbXN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFGaW5kZXIsIERhdGFGaW5kZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zdGF0ZSc7XG5pbXBvcnQge2Fzc2VydCwgaXNBcnJheSwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogQ29uY3JldGUgRGF0YVNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIENob29zZXIgY29tcG9uZW50LiBUaGVyZSBhcmUgdHdvIHdheXMgaG93IHRvIHVzZSBpdDpcbiAqXG4gKiAxKSBZb3UgY2FuIHVzZSBkZWZhdWx0IERhdGFTb3VyY2UgaW5qZWN0ZWQgaW5zaWRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBhbmQganVzdCBjYWxsXG4gKiBpbml0aWFsaXplIHRvIGNvbmZpZ3VyZSBpdCB3aXRoIGNvcnJlY3QgRGF0YVByb3ZpZGVyIGFuZCBEYXRhRmluZGVyOlxuICpcbiAqXG4gKiBgYGBcbiAqICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICogICAgICAgICAgICAgICBvYmo6IHRoaXMubGlzdCxcbiAqICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gKiAgICAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICogICAgICAgICAgIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIGFuZCB0aGVuIHlvdSBjYW4gdXNlIGl0IHRvIHNpbXBseSByZXRyaWV2ZSBkYXRhIG9yIHJ1biBxdWVyaWVzLlxuICpcbiAqIDIpIFlvdSB3aWxsIGluc3RhbnRpYXRlIHlvdXIgb3duIERhdGFTb3VyY2UgYW5kIHBhc3MgaXQgaW50byB0aGUgY29tcG9uZW50IHVzaW5nIFtkYXRhU291cmNlXVxuICogYmluZGluZ1xuICpcbiAqIGBgYFxuICpcbiAqICAgdGhpcy5kcyA9IG5ldyBDaG9vc2VyRGF0YVNvdXJjZSh0aGlzLmRhdGEsIHRoaXMuZmluZGVycyk7XG4gKiAgIHRoaXMuZHMuaW5pdCh7XG4gKiAgICAgICAgICAgICAgIG9iajogdGhpcy5saXN0LFxuICogICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAqICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENob29zZXJEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZVxue1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hpbmcgZGF0YVByb3ZpZGVycyBhbmQgZmluZGVyc1xuICAgICAqL1xuICAgIHByaXZhdGUgZGF0YVByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcbiAgICBwcml2YXRlIGRhdGFGaW5kZXI6IERhdGFGaW5kZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgb2JqZWN0IHRvIGtlZXAgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNob29zZXJcbiAgICAgKi9cbiAgICBzdGF0ZTogQ2hvb3NlclN0YXRlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0YVByb3ZpZGVyczogRGF0YVByb3ZpZGVycywgcHVibGljIGZpbmRlcnM6IERhdGFGaW5kZXJzKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZGF0YVByb3ZpZGVycywgZmluZGVycyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUbyBpbml0aWFsaXplIHRoaXMgRGF0YVNvdXJjZSB3aXRoIGN1cnJlbnQgRGF0YUZpbmRlciBhbmQgUHJvdmlkZXIgYXMgd2VsbCBhcyBzdGF0ZSB3ZSB1c2VcbiAgICAgKiBhbiBpbnRlcmZhY2UgRFNDaG9vc2VySW5pdFBhcmFtcyB0byBoYXZlIGFsbCBpbml0IHZhbHVlcyB0eXBlZCBjaGVja2VkXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhhcmdzKSB8fCBhcmdzLmxlbmd0aCAhPT0gMSAmJiAhaXNEU0Nob29zZXJJbml0UGFyYW1zKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIGluaXRpYWxpemUgRFMgd2l0aCAoRFNDaG9vc2VySW5pdFBhcmFtcyknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdDogRFNDaG9vc2VySW5pdFBhcmFtcyA9IGFyZ3NbMF07XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhUHJvdmlkZXIpID8gaW5pdC5kYXRhUHJvdmlkZXJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhUHJvdmlkZXJzLmZpbmQoaW5pdC5vYmopO1xuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IGlzUHJlc2VudChpbml0LmRhdGFGaW5kZXIpID8gaW5pdC5kYXRhRmluZGVyXG4gICAgICAgICAgICA6IHRoaXMuZmluZGVycy5maW5kKHRoaXMuZGF0YVByb3ZpZGVyLCBpbml0LnF1ZXJ5VHlwZSk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRhdGFQcm92aWRlcikgJiYgaXNQcmVzZW50KHRoaXMuZGF0YUZpbmRlciksXG4gICAgICAgICAgICAnRGF0YVNvdXJjZSBpbmNvcnJlY3RseSBpbml0aWFsaXplZC4gKERhdGFQcm92aWRlciwgRGF0YUZpbmRlcikgbWlzc2luZy4gJyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChpbml0LnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXQuc3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IENob29zZXJTdGF0ZShudWxsLCBpbml0Lm11bHRpc2VsZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5zdGF0ZS5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICB9XG5cblxuICAgIGZpbmQocGF0dGVybjogc3RyaW5nLCBtYXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuc3RhdGUubGFzdEZ1bGxNYXRjaFBhdHRlcm4gPSBwYXR0ZXJuO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnKicpIHsgLy8gcXVlcnkgZXZlcnl0aGluZ1xuICAgICAgICAgICAgcGF0dGVybiA9ICcnO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZGF0YUZpbmRlciBoYXMgZXhwZWN0ZWQgbG9va3VwIGtleVxuICAgICAgICBsZXQgb3JpZ0tleSA9IHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSB0aGlzLnN0YXRlLmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmZvckRhdGEodGhpcy5kYXRhUHJvdmlkZXIpLm1hdGNoPGFueT4ocGF0dGVybiwgbWF4KVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1hdGNoZXMgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5zdGF0ZS5tYXRjaGVzLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBvcmlnS2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG11bHRpc2VsZWN0IHRoaXMgbWV0aG9kIGNoZWNrcyBpZiB3ZSBuZWVkIHRvIHNob3cgU0hPVyBNT1JFIGxhYmVsIHVuZGVyIHRoZSBzZWxlY3RlZFxuICAgICAqIGl0ZW1zLiBXZSBkbyBub3Qgd2FudCBzaG93IGUuZy4gNTAgc2VsZWN0aW9uIHVuZGVyIHRoZSBjaG9vc2VyIHRoYXQgd291bGQgdGFrZSB1cCB3aG9sZVxuICAgICAqIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93TW9yZVNlbGVjdGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpLmxlbmd0aCA+PSBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkO1xuICAgIH1cblxuICAgIG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbnN0YW50PFQ+KCk6IFRbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbXM6IGFueVtdID0gdmFsdWU7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB0aGlzLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmFkZE1vZGUgPSBmYWxzZTtcblxuICAgIH1cblxuXG4gICAgZ2V0IGxvb2t1cEtleSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5O1xuICAgIH1cbn1cblxuLyogaXMgXCJpbml0XCIgdHlwZSBvZiBEU0Nob29zZXJJbml0UGFyYW1zIGludGVyZmFjZSA/ICovXG5leHBvcnQgZnVuY3Rpb24gaXNEU0Nob29zZXJJbml0UGFyYW1zKGluaXQ6IERTQ2hvb3NlckluaXRQYXJhbXMpOiBpbml0IGlzIERTQ2hvb3NlckluaXRQYXJhbXNcbntcbiAgICByZXR1cm4gaXNQcmVzZW50KGluaXQub2JqKSB8fCBpc1ByZXNlbnQoaW5pdC5xdWVyeVR5cGUpO1xufVxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERTQ2hvb3NlckluaXRQYXJhbXMgZXh0ZW5kcyBEU0luaXRQYXJhbXNcbntcbiAgICAvKipcbiAgICAgKiBDaG9vc2VyIHN0YXRlIGtlZXBpbmcgaW5mb3JtYXRpb24gd2hhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgLCByZXN1bHQgb2YgdGhlIGxhc3QgbWF0Y2hcbiAgICAgKi9cbiAgICBzdGF0ZT86IENob29zZXJTdGF0ZTtcbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QXV0b0NvbXBsZXRlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0Nob29zZXJEYXRhU291cmNlfSBmcm9tICcuL2Nob29zZXItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7Q2hvb3NlclN0YXRlLCBEZWZhdWx0U2VsZWN0aW9uU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zdGF0ZSc7XG5cblxuLyoqXG4gKiBUeXBlYWhlYWQgY2hvb3NlciB0aGF0IHN1cHBvcnRzIGJvdGggc2luZ2xlIGFuZCBtdWx0aS1zZWxlY3QuIE5vdCBsaWtlIERyb3Bkb3duLCB0aGlzIGNob29zZXJcbiAqIHJlcXVpcmVzIGxpdHRsZSBiaXQgZGlmZmVyZW50IHNldHVwLiBJdCByZXF1aXJlcyBhdCBtaW5pbXVtIEBJbnB1dCBkYXRhU291cmNlIG9yXG4gKiBkZXN0aW5hdGlvbkNsYXNzXG4gKlxuICpcbiAqIEJ5IGRlZmF1bHQgY2hvb3NlciBpcyBtdWx0aS1zZWxlY3QuIElmIHlvdSB3YW50IHNpbmdsZSBzZWxlY3QgdGhlbiB5b3UgbXVzdCBwcm92aWRlIG11bHRpLXNlbGVjdFxuICogd2l0aCBASW5wdXQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBJbiBzaW1wbGUgc2NlbmFyaW8geW91IGNhbiB1c2UgQ2hvb3NlciBsaWtlIHNvOlxuICpcbiAqXG4gKiBgYGBcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdjaG9vc2VyLWFwcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYDxhdy1jaG9vc2VyICBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIG5hbWU9XCJjb2xvclwiJ1xuICogICAgICAgICAgICAgICAgICAgICAgW2RhdGFTb3VyY2VdPVwiZHNcIj48L2F3LWNob29zZXI+YFxuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIE15Q2hvb3NlckFwcFxuICogIHtcbiAqXG4gKiAgICAgIGRzOiBDaG9vc2VyRGF0YVNvdXJjZTtcbiAqXG4gKiAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBEYXRhUHJvdmlkZXJzLCBwcml2YXRlIGZpbmRlcnM6IERhdGFGaW5kZXJzKXtcbiAqICAgICAgICAgIHRoaXMuZHMgPSBuZXcgQ2hvb3NlckRhdGFTb3VyY2UodGhpcy5kYXRhLCB0aGlzLmZpbmRlcnMpO1xuICpcbiAqICAgICAgIHRoaXMuZHMuaW5pdCh7XG4gKiAgICAgICAgICAgb2JqOiBbJ2JsdWUnLCAncmVkJywgJ3llbGxvdyddLCBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCwgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0cnVlXG4gKiAgICAgICB9KTtcbiAqXG4gKiAgICAgfVxuICogIH1cbiAqXG4gKiBgYGBgXG4gKiAgQWJvdmUgZXhhbXBsZSB3aWxsIHVzZSBwcm92aWRlZCBkYXRhU291cmNlIGFuZCByZW5kZXIgbXVsdGktc2VsZWN0IGNob29zZXIuIFdpdGggZGVmYXVsdFxuICogIGltcGxlbWVudGF0aW9uICBzZWxlY3RlZCB2YWx1ZXMgd2lsbCBhcHBlYXIgYXMgYSB0YWdzIHVuZGVyIHRoZSBpbnB1dCBib3hcbiAqXG4gKlxuICpcbiAqICogIyMjIEV4YW1wbGVcbiAqXG4gKiAgSW4gdGhpcyBleGFtcGxlIHdlIHByb3ZpZGUgY3VzdG9tIHRlbXBsYXRlIHRvIGNoYW5nZSB0aGUgd2F5IGhvdyBjaG9vc2VyJ3MgTWVudUl0ZW0gYXJlXG4gKiAgICAgcmVuZGVyZWQgYXMgd2VsbCBhcyB0ZW1wbGF0ZSBmb3IgdGhlIHNlbGVjdGlvbiBpdGVtIGxvb2tzIGxpa2VcbiAqXG4gKiBgYGBcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdjaG9vc2VyLWFwcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYDxhdy1jaG9vc2VyICBuYW1lPVwiY29tbW9kaXR5XCInIFtkYXRhU291cmNlXT1cImRzXCI+XG4gKlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlICNtZW51SXRlbSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgIFx0PHNwYW4+XG4gKiAgICAgICAgICAgICBcdFx0PGkgY2xhc3M9XCJmYSBmYS1lbnZpcmEgXCIgPjwvaT5cbiAqICAgICAgICAgICAgIFx0XHR7e2l0ZW19fVxuICogICAgICAgICAgICAgXHQ8L3NwYW4+XG4gKlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI3NlbGVjdGlvbkl0ZW0gbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICBcdDxzcGFuIGNsYXNzPVwidGFnIHRhZy1jaXJjbGVcIj5cbiAqICAgICAgICAgICAgIFx0XHRpdGVtOiB7e2l0ZW0gfX1cbiAqICAgICAgICAgICAgIFx0XHQ8aSBjbGFzcz1cImZhIGZhLWNsb3NlXCIgKGNsaWNrKT1cImNob29zZXIucmVtb3ZlVmFsdWUoaXRlbSlcIj48L2k+XG4gKiAgICAgICAgICAgICBcdDwvc3Bhbj5cbiAqXG4gKlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgPC9hdy1jaG9vc2VyPlxuICogICAgICBgXG4gKiAgICAgIHN0eWxlOiBbYFxuICogICAgICAgICAgICAgIC50YWctY2lyY2xlIHtcbiAqICAgICAgICAgICAgICBcdGJvcmRlci1yYWRpdXM6IDZyZW07XG4gKiAgICAgICAgICAgICAgXHRoZWlnaHQ6IDdyZW07XG4gKiAgICAgICAgICAgICAgXHRjb2xvcjogI2U4ZWVmMTtcbiAqICAgICAgICAgICAgICBcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoNTMsIDU2LCA1OCwgMC42Nyk7XG4gKiAgICAgICAgICAgICAgXHRsaW5lLWhlaWdodDogNnJlbTtcbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgIGBdXG4gKiAgfSlcbiAqXG4gKiBgYGBgXG4gKlxuICogIEluIGFib3ZlIGV4YW1wbGUgd2UgY2hhbmdlIGhvdyB0aGUgY2hvb3NlcidzIG1lbnUgaXRlbSBsb29rIGxpa2UgYXMgd2VsbCBhcyB3ZSBkZWZpbmUgY3VzdG9tXG4gKiAgICAgdGVtcGxhdGUgZm9yIHNlbGVjdGlvbiBpdGVtIHRvIHR1cm4gYWxsIHNlbGVjdGlvbiB0byBjaXJjbGVzIHdpdGggdGV4dCBpbiB0aGUgbWlkZGxlLlxuICpcbiAqXG4gKlxuICovXG5cbmV4cG9ydCBjb25zdCBDSE9PU0VSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaG9vc2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNob29zZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnY2hvb3Nlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2Nob29zZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0hPT1NFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG5cbn0pXG5leHBvcnQgY2xhc3MgQ2hvb3NlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0IHtcblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyID0gMTA7XG5cblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbkZvclNlYXJjaDogbnVtYmVyID0gMTtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHVzZWQgdG8gZm9ybWF0IGVhY2ggc2VsZWN0aW9uIGFuZCBzZWxlY3RlZCBvYmplY3QgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlVHJhbnNmb3JtZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG11bHRpc2VsZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpc2VsZWN0OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBDaG9vc2VyRGF0YVNvdXJjZSB3aWxsIGJlIGNyZWF0ZWQgYnV0IHRoZXJlIGlzIGEgb3B0aW9uIHRvIHNldFxuICAgICAqIGN1c3RvbSBvbmUgb24gYXBwbGljYXRpb24gbGV2ZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGFTb3VyY2U6IENob29zZXJEYXRhU291cmNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIHdhbnQgdG8gY2hhbmdlIHRoZSBwbGFjZSB3aGVyZSBzZWxlY3Rpb24gaXMgcmVuZGVyZWQgdXNlIHRoaXMgYXBwZW5kVG8gcHJvcGVydHlcbiAgICAgKiBhbmQgaXQgd2lsbCB1c2UgRE9NIG9wZXJhdGlvbiBhcHBlbmRDaGlsZCgpIHRvIG1vdmUgc2VsZWN0aW9uVmlldyB1bmRlciBkaWZmZXJlbnQgcGFyZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25BcHBlbmRUbzogRWxlbWVudFJlZjtcblxuXG4gICAgQElucHV0KClcbiAgICBkZWxheTogbnVtYmVyID0gMzAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgdHlwZSB0byByZW5kZXIuIERhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1vZGVsIHRvIGxpc3RlbiBmb3IgSW5wdXQgdmFsdWUgY2hhbmdlc1xuICAgICAqL1xuICAgIGludGVybmFsQ2hvb3Nlck1vZGVsOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIEVtYmVkZGVkIHRlbXBsYXRlIGRlZmluZWQgYnkgdXNlci4gSWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFueSB0ZW1wbGF0ZSB0aGVuIHdoZW4gcmVuZGVyaW5nXG4gICAgICogYW4gaXRlbSB3ZSBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBwcmltaXRpdmUgdHlwZXMgYW5kIGNhbGwgb24gZWFjaCBpdGVtIHRvU3RyaW5nKCksIGlmXG4gICAgICogd2UgYXJlIGRlYWxpbmcgd2l0aCBvYmplY3QsIHRoZW4gd2UgZXhwZWN0IHVzZXIgdG8gcHJvdmlkZSBhIHRlbXBsYXRlIGFuZCB0ZWxsIHRoZSBjaG9vc2VyXG4gICAgICogaG93IGl0ZW1zIHNob3VsZHMgYmUgaGFuZGxlZCBvciBhdCBsZWFzdCB2YWx1ZVRyYW5zZm9ybWVyIHNvIHdlIGtub3cgaG93IHRvIGNvbnZlcnQgdGhpc1xuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogRWFjaCBvYmplY3QgY2FuIHByb3ZpZGUgaXRzIG93biB0b1N0cmluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ21lbnVJdGVtJylcbiAgICBtZW51VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBDb250ZW50Q2hpbGQoJ3NlbGVjdGlvbkl0ZW0nKVxuICAgIHNlbGVjdGlvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnYXV0b0NvbXBwbGV0ZScpXG4gICAgYXV0b0NvbXBsZXRlQ29tcG9uZW50OiBBdXRvQ29tcGxldGU7XG5cbiAgICBAVmlld0NoaWxkKCdzZWxlY3Rpb25WaWV3JylcbiAgICBzZWxlY3Rpb25WaWV3RWxlbTogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgc2VsZWN0aW9uIGlzID4gbWF4IHNlbGVjdGlvbiwgdGhlbiBzaG93IGhpZGUgbGluay5cbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVMaW5rOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBlbGVtZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHJpdmF0ZSBfZGVmYXVsdERTOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnBsYWNlSG9sZGVyKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5wbGFjZUhvbGRlciA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLnBsYWNlSG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnBsYWNlSG9sZGVyID0gJ1NlYXJjaCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5oaWRlTGluayA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLmhpZGVTZWxlY3Rpb24nKTtcbiAgICAgICAgdGhpcy5oaWRlTGluayA9ICdIaWRlJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRhdGFTb3VyY2UpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuX2RlZmF1bHREUztcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbCkgJiYgaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodGhpcy5mb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG5cblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIFNlYXJjaCBpY29uIGluIGNhc2Ugb2YgbXVsdGlzZWxlY3QuXG4gICAgICogdG9kbzogT25jZSBQcmltZU5HIHdpbGwgcHJvdmlkZSBhIHRlbXBsYXRlIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IgcmVtb3ZlIGl0XG4gICAgICpcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbicpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoc2VhcmNoSW5wdXQpKSB7XG4gICAgICAgICAgICBsZXQgaWNvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSAnc2VhcmNoLWljb24tcmlnaHQgZmEgZmEtZncgZmEtc2VhcmNoJztcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25BcHBlbmRUbykgJiYgaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uVmlld0VsZW0pKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWxlbSA9IHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8gaW5zdGFuY2VvZiBFbGVtZW50UmVmID9cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvO1xuXG4gICAgICAgICAgICBwYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uVmlld0VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNoYW5nZSBjdXJyZW50IGJlaGF2aW9yIHNpbmNlIHdlIHdhbnQgdG8gc2hvdyBzZWxlY3Rpb24gdW5kZXIgdGhlIGNob29zZXIuIEtcbiAgICAgKlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZSAudWktYXV0b2NvbXBsZXRlLXRva2VuJyk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW5zKSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9rZW5zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiB2YWx1ZSBpcyBlbnRlcmVkIGludG8gc2VhcmNoIGJveCwgd2UgYXNrIG91ciBEYXRhU291cmNlIHRvIG1hdGNoIHRoaXMgcGF0dGVyblxuICAgICAqIGFnYWluc3QgZGF0YSByZXBvc2l0b3J5LiBJdCB3aWxsIHJldHJpZXZlIGFsbCBwb3NzaWJsZSBtYXRjaGVzIGxpbWl0ZWQgYnkgTWF4TGVuIGFuZCB0aGlzXG4gICAgICogaXMgYWdhaW4gZmlsdGVyZWQgc28gaXQgZG9lcyBub3QgaW5jbHVkZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogIHRoZSBtYXRjaGVkIHJlc3VsdGVkIGlzIHNhdmVkIGluIHRoZTogdGhpcy5kYXRhU291cmNlLnN0YXRlLm1hdGNoZXNcbiAgICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IG1heExlbiA9IHRoaXMubWF4TGVuZ3RoID8gdGhpcy5tYXhMZW5ndGggOiBDaG9vc2VyRGF0YVNvdXJjZS5NYXhMZW5ndGg7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5maW5kKHBhdHRlcm4sIG1heExlbik7XG5cblxuICAgICAgICAvLyBmaXg6IGZvciB0ZXN0czogSW4gdmVyc2lvbiA0IHdlIG5lZWQgdG8gZXhwbGljaXRseSBmb2N1cyBpbnB1dCBvdGhlcndpc2UgYXV0b2NvbXBsZXRlXG4gICAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBhbnkgcG9wdXAgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMuZW52LmluVGVzdCAmJiBpc1ByZXNlbnQodGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c0lucHV0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW52b2tlZCBieSBEcm9wZG93biBidXR0b24gaW4gY2FzZSBvZiBzaW5nbGUgc2VsZWN0IGFuZCBoZXJlIHdlIHdhbnQgdG8gaW52b2tlIG1hdGNoXG4gICAgICogdG8gcmV0cmlldmUgYWxsIHN1Z2dlc3Rpb25zIHdpdGhvdXQgYW55IGZpbHRlclxuICAgICAqXG4gICAgICovXG4gICAgb25Ecm9wZG93bkNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXRjaCgnKicpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goJyonKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENob29zZXIgc3RhdGUgaXMgdXBkYXRlZCAgd2l0aCB1c2VyIHNlbGVjdGlvbi4gUGxlYXNlIHNlZSB3cml0ZVZhbHVlLiBXaGVuIGRvIG5vdCBuZWVkXG4gICAgICogY2FsbCBhbnl0aGluZyBhZGRpdGlvbmFsIGFzIGludGVybmFsQ2hvb3Nlck1vZGVsIGFuZCB0aGlzLmNob29zZXJTdGF0ZS5zZWxlY3RlZE9iamVjdHMoKVxuICAgICAqIHNoYXJlcyB0aGUgc2FtZSByZWZlcmVuY2VzIHNvIGl0cyBpbXBvcnRhbnQgdGhhdCB3ZSBmaXJzdCBzYXZlIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoaXMuY2hvb3NlclN0YXRlLnNlbGVjdGVkT2JqZWN0cygpIGFuZCB0aGVuIGJhY2sgdG8gaW50ZXJuYWxDaG9vc2VyTW9kZWxcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuaW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlID1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlJdGVtKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVuc2VsZWN0IGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZVZhbHVlKGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzSW5wdXQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDb252ZXJ0IGEgb2JqZWN0IGlmIGFueSBpbnRvIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIHRvZG86IGltcGxlbWVudCBiZXR0ZXIgd2F5IGhvdyB0byB3b3JrIHdpdGggb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheUl0ZW0oaXRlbTogYW55KSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuY3VycmVudEl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UubG9va3VwS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5kYXRhU291cmNlLmxvb2t1cEtleV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBsYWJlbCB0aGF0IGlzIHNob3duIHVuZGVyIHRoZSBzZWxlY3RlZCBpdGVtIHdoZW4gdXNlciBzZWxlY3Rpb24gaXMgPlxuICAgICAqIE1heFJlY2VudFNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3JlU2VsZWN0U3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBtb3JlU2VsZWN0ZWQgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoIC1cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZERpc3BsYXllZDtcbiAgICAgICAgaWYgKG1vcmVTZWxlY3RlZCA8IDIgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUxpbms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vcmVTZWxlY3RlZH0gbW9yZSBzZWxlY3RlZC4uLmA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIG9mIG11bHRpc2VsZWN0ID0gZmFsc2UgY2hlY2sgaWYgd2Ugd2FudCB0byBzaG93IGEgc2VsZWN0ZWQgdmFsdWUgaW5zaWRlIHRoZSBpbnB1dFxuICAgICAqIGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBzaW5nbGVWYWx1ZVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlLnN0YXRlLmN1cnJlbnRJdGVtKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlO1xuICAgIH1cblxuICAgIGhhc01lbnVUZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1lbnVUZW1wbGF0ZSk7XG4gICAgfVxuXG5cbiAgICBoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblRlbXBsYXRlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICogQXMgd2UgYXJlIHVzaW5nIERhdGFTb3VyY2UgaW50ZXJuYWxseSBmb3IgWyhuZ01vZGVsKV0gY2FzZSB3ZSBuZWVkIHRvIGRlZmZlciBEYXRhU291cmNlXG4gICAgICogaW5pdGlhbGl6YXRpb24gb25jZSB3ZSBoYXZlIGEgdmFsdWUgYW5kIHdlIG9ubHkgYWNjZXB0IFtdXG4gICAgICpcbiAgICAgKlxuICAgICAqID8gU2hvdWxkIHdlIGRvIHNvbWUgZGVlcGVyIGNvbXBhcmlzaW9uP1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxTdGF0ZTogRGVmYXVsdFNlbGVjdGlvblN0YXRlID0gbmV3IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSh0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIGxldCBjaFN0YXRlOiBDaG9vc2VyU3RhdGUgPSBuZXcgQ2hvb3NlclN0YXRlKHNlbFN0YXRlLCB0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoY2hTdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG4gICAgfVxuXG4gICAgaW5pdERhdGFzb3VyY2UoY2hvb3NlclN0YXRlPzogQ2hvb3NlclN0YXRlKTogdm9pZCB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSxcbiAgICAgICAgICAgICdZb3UgbmVlZCB0byBwcm92aWRlIGRlc3RpbmF0aW9uQ2xhc3Mgb3IgY3VzdG9tIERhdGFTb3VyY2UnKTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICBvYmo6IHRoaXMuZGVzdGluYXRpb25DbGFzcyxcbiAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgbG9va3VwS2V5OiB0aGlzLmZpZWxkLFxuICAgICAgICAgICAgc3RhdGU6IGNob29zZXJTdGF0ZSxcbiAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBuZ09uSW5pdCBhbmQgV3JpdGUgdmFsdWUgdG8gcmVhZCBzdGF0ZSBmcm9tIENob29zZXJTdGF0ZSBhbmQgc2V0IGl0IHRvIGludGVybmFsXG4gICAgICogbmdNb2RlbCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0SW50ZXJuYWxNb2RlbCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaG9vc2VyQ29tcG9uZW50fSBmcm9tICcuL2Nob29zZXIuY29tcG9uZW50JztcbmltcG9ydCB7QXV0b0NvbXBsZXRlTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi4vaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hvb3Nlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtTZWxlY3RJdGVtfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqIEEgcG9wdXAgbGlrZSBjb21wb25lbnQgcmVuZGVyaW5nIGxpc3Qgb2YgdmFsdWVzIGFzLiBCYXNlZCBvbiBQcmltZU5HIGNvbXBvbmVudCBhbmQgb25lIG9mIHRoZVxuICogbWFpbiByZWFzb24gd2h5IHdlIG5lZWQgdG8gd3JhcCB0aGlzIGlzIHRvIGV4dGVuZCBpdHMgY2FwYWJpbGl0aWVzIHRvIGFjY2VwdCBhbG1vc3QgYW55XG4gKiBkYXRhIHR5cGUgd2l0aG91dCB1c2luZyBQcmltZW5zJ3Mgc3BlY2lmaWMgU2VsZWN0SXRlbSB0eXBlLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3Nob3dEcm9wRG93bicgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1kcm9wZG93biBbbGlzdF09XCJ0ZXN0SXRlbVNtYWxsXCJcbiAqICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPjwvYXctZHJvcGRvd24+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIE15RHJvcENvbXBvbmVudFxuICogIHtcbiAqICAgICAgdGVzdEl0ZW1TbWFsbDogc3RyaW5nW10gPSBbJ3ZpZXcnICwgJ2VkaXQnXTtcbiAqXG4gKiAgICAgIC8vIHdoZW4geW91IHN3aXRjaCBsaXN0IGJpbmRpbmcgdG8gcmVmZXJ0IHRvIGxhcmdlIGl0ZW0gZmlpbHRlciBhdXRvbWF0aWNhbGx5IGlzIHNob3duIGFuZFxuICogICAgIG1heCAxMCBpdGVtcyBhcmVcbiAqICAgICAgLy8gdmlzaWJsZVxuICogICAgICB0ZXN0SXRlbUxhcmdlOiBzdHJpbmdbXSA9IFsndmlldycgLCAnZWRpdCcgLCAnZnJhbmsnICwgJ2tvbGFyJyAsICdUaGUgU3VuJyAsICdEb2cnICxcbiAqICAgICAnQ29tcHV0ZXInICwgJ0EgRGVzaycgLFxuICogICAgICAnTXkgQ2FyJyAsICdQZW5jaWwnICwgJ1RoaXMgUGFnZScgLCAnWWVzdGVyZGF5JyAsICdNb25kYXknICwgJ1R1ZXNkYXknICwgJ0JNVyBSMTIwMCBHUycgLFxuICogICAgICdDemVjaCBSZXB1YmxpYycgLFxuICogICAgICAnTGFzdCBJdGVtJ107XG4gKlxuICpcbiAqICAgICAgaXRlbVNlbGVjdGVkOiBzdHJpbmcgPSAndmlldyc7XG4gKiAgICAgIGl0ZW1TZWxlY3RlZExnOiBzdHJpbmcgPSAnTW9uZGF5JztcbiAqXG4gKiAgICAgIG5vc2VsU3RyaW5nOiBzdHJpbmcgPSAnKG5vIHNlbGVjdGlvbiknO1xuICpcbiAqXG4gKiAgICAgIG9uU2VsZWN0aW9uIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgdGhpcy5pdGVtU2VsZWN0ZWQgPSBldmVudDtcbiAqXG4gKiAgICAgIH1cbiAqICB9XG4gKlxuICogIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBERF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcGRvd25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHJvcGRvd24nLFxuICAgIHRlbXBsYXRlVXJsOiAnZHJvcGRvd24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkcm9wZG93bi5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBERF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERyb3Bkb3duQ29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25Db21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgc3RhdGljIHJlYWRvbmx5IE1heE51bVNob3duID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBPcmRlcmVkIGxpc3Qgb2YgaXRlbXMgcmVuZGVyZWQgYXMgYSBwb3B1cCBtZW51XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEl0ZW1zIHdoaWNoIHdhcyBzZWxlY3RlZCBhcyBhIGRlZmF1bHQgdmFsdWUgb3IgYnkgdXNlZCBpbiB0aGUgcG9wdXAgbWVudS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlbmRlcmVkIGFzIGZpcnN0IHZhbHVlIGluIHRoZSBwb3B1cCB3aGljaCBsZXQgdGhlIHVzZXIgdG8gbWFrZSAnbm8gc2VsZWN0aW9uJyBmcm9tXG4gICAgICogYXZhaWxhYmxlIGxpc3Qgb2YgdmFsdWVzLiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSBhbmQgdXNlIG1ha2UgdGhpcyBzZWxlY3Rpb24gd2Ugc2F2ZSBhXG4gICAgICogTlVMTCB2YWx1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9TZWxlY3Rpb25TdHJpbmc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgaW50ZXJuYWwgbGlzdCB0aGF0IGhpZGVzIFByaW1lTkcgc3BlY2lmaWNzIHdoZXJlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIHNwZWNpYWxcbiAgICAgKiB0eXBlOiBTZWxlY3RJdGVtLiBPdXIgZXhwZWN0YXRpb24gaXMgdGhhdCB5b3UgbmVlZCB0byBiZSBhYmxlIHRvIHBhc3MgcmVndWxhciBzdHJpbmcgdmFsdWVzXG4gICAgICogb3IgZnVsbCBvYmplY3QgYW5kIG5vdCB0cnlpbmcgdG8gd3JhcCBpdCBpbnRvIGV4dHJhIGxheWVyLlxuICAgICAqXG4gICAgICovXG4gICAgaW50ZXJuYWxMaXN0OiBTZWxlY3RJdGVtW107XG5cblxuICAgIC8qKlxuICAgICAqIEVtYmVkZGVkIHRlbXBsYXRlIGRlZmluZWQgYnkgdXNlci4gSWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFueSB0ZW1wbGF0ZSBhbmQgd2hpbGUgcmVuZGVyaW5nXG4gICAgICogaXRlbSB3ZSBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBwcmltaXRpdmUgdHlwZXMgYW5kIGNhbGwgb24gZWFjaCBpdGVtIHRvU3RyaW5nKCksIGlmIHdlXG4gICAgICogYXJlIGRlYWxpbmcgd2l0aCBvYmplY3QsIHRoZW4gd2UgZXhwZWN0IHVzZXIgdG8gcHJvdmlkZSBhIHRlbXBsYXRlIGFuZCB0ZWxsIHRoZSBkcm9wZG93biBvZlxuICAgICAqIGVhY2ggaXRlbSBzaG91bGQgYmUgaGFuZGxlZFxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaXRlbVRlbXBsYXRlJylcbiAgICBpdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIHVzZWQgZm9yIGVtYmVkZGVkIHZlcnNpb24uXG4gICAgICovXG4gICAgbW9kZWw6IFNlbGVjdEl0ZW07XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9kbzogUHV0IGJhY2sgdGhlIHNjcm9sbGluZyBvcHRpb24gb25jZSB3ZSBkZWNpZGUgc28uIEN1cnJlbnRseSB0aGUgcmVxdWlyZW1lbnRzIGFyZVxuICAgICAqIHNob3cgb25seSAxMCBpdGVtcyBtYXgsIG5vIHNjcm9sbGluZy4gRnVuY3Rpb25hbGl0eSBjb21tZW50ZWQgb3V0IGNhbiBzaG93IHNjcm9sbGJhciB3aXRoXG4gICAgICogc2VhcmNoIGZpbHRlci5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gYSB2YWx1ZSB0byBQcmltZU5nIEZvcm1hdCwgd2UgYXJlIG5vdCByZWFsbHkgYmUgdXNpbmcgYSBsYWJlbCBmaWVsZCBvbmx5IGFcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gW107XG4gICAgICAgIC8vIGlmIChpc1ByZXNlbnQodGhpcy5ub1NlbGVjdGlvblN0cmluZykpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuaW50ZXJuYWxMaXN0LnB1c2goe1xuICAgICAgICAvLyAgICAgICAgIGxhYmVsOiB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5ub1NlbGVjdGlvblN0cmluZztcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiB0aGlzLmxpc3QubGVuZ3RoID49IERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0LnNsaWNlKDAsIERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duKS5tYXAoKGl0ZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiBpdGVtLnRvU3RyaW5nKCksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IHRoaXMubGlzdC5zbGljZSgwKS5tYXAoKGl0ZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiBpdGVtLnRvU3RyaW5nKCksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBoYXNFbWJlZGRlZFRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5pdGVtVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHByZXZlbnQgRW1wdHkgaXRlbSB0byBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICogdG9kbzogUmVwb3J0IHRoaXMgb24gUHJpbWVOZ1xuICAgICAqXG4gICAgICovXG4gICAgaXRlbUV4aXN0KGl0ZW06IGFueSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoaXRlbSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRyb3Bkb3duIGxpc3QgaXMgbW9yZSB0aGVuIGRlZmluZWQgY29uc3RhbnQgTWF4TnVtU2hvd24gKDEwKSBhdXRvbWF0aWNhbGx5IHNob3cgZmlsdGVyXG4gICAgICogaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBzaG93RmlsdGVyKClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gcmV0dXJuIGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIHRoaXMubGlzdC5sZW5ndGggPiBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZXMgaW50ZXJuYWwgbW9kZWxzIG9mIGN1cnJlbnQgc2VsZWN0aW9ucyBhbmQgdHJpZ2dlcnMgb25TZWxlY3Rpb24gZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSXRlbVNlbGVjdGlvbih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHZhbHVlLnZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodmFsdWUudmFsdWUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlJdGVtKGl0ZW06IGFueSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoaXRlbSkgPyBpdGVtLmxhYmVsIDogJ05vIFNlbGVjdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghZXF1YWxzKHZhbHVlLCB0aGlzLnNlbGVjdGlvbikpIHtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RHJvcGRvd25Db21wb25lbnR9IGZyb20gJy4vZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RHJvcGRvd25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Ryb3Bkb3duTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0N1cnJlbmN5UGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNCbGFuaywgaXNQcmVzZW50LCBWYWx1ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuLyoqXG4gKiBMaWdodHdlaWdodCBhbmQgY29uZmlndXJhYmxlIEN1cnJlbmN5IGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgbmcgYm9vdHN0cmFwIGRpcmVjdGl2ZS4gVGhpc1xuICogY29tcG9uZW50IGNvbWJpbmVzIGFuIGlucHV0IGFuZCBjdXJyZW5jeSBjb2RlIGRyb3Bkb3duLlxuICpcbiAqXG4gKiBmb3IgbW9yZSBpbmZvIHBsZWFzZSBzZWUgY2xhc3MgRG9jIG9mIHRoZTpcbiAqICBAc2VlIHtAbGluayBjdXJyZW5jeS9jdXJyZW5jeS5jb21wb25lbnQudHN9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdhbW91bnQnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICA8YXctY3VycmVuY3kgW21vbmV5XT1cInByaWNlXCIgW2N1cnJlbmNpZXNdPVwiY3VycmVuY2llc1wiIFtuYW1lXT1cIidjdXJyZW5jeSdcIj5cbiAqICAgICAgPC9hdy1jdXJyZW5jeT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgYW1vdW50OiBudW1iZXIgPSAxMDAwO1xuICogICAgICAgIGN1cnJlbmNpZXM6IHN0cmluZ1tdID0gWydVU0QnLCAnQ05ZJywgJ0FVRCcsICdFVVInLCAnR0JQJ107XG4gKiAgICAgICAgY3VycmVuY3lDb2RlOiBzdHJpbmcgPSB0aGlzLmN1cnJlbmNpZXNbMF07XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuXG5leHBvcnQgY29uc3QgQ1VSUkVOQ1lfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1cnJlbmN5Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWN1cnJlbmN5JyxcbiAgICB0ZW1wbGF0ZVVybDogJ2N1cnJlbmN5LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnY3VycmVuY3kuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ1VSUkVOQ1lfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXJyZW5jeUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIEN1cnJlbmN5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBNb25leSBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdmFsdWUsIGxvY2FsZSwgY3VycmVuY3kgY29kZS5cbiAgICAgKiBJZiB0aGlzIG9iamVjdCBpcyBzZXQsIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1vbmV5OiBNb25leTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdXNlciB0byBjaGFuZ2UgTW9uZXkncyBjdXJyZW5jeSBjb2RlIGFuZCBzdGlsbFxuICAgICAqIGFsbG93IHVzZXIgdG8gZWRpdCBNb25leSdzIGFtb3VudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlYWRvbmx5Q3VycmVuY3lDb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVuY3kgdGhhdCdzIHNlbGVjdGVkIGZvciB0aGlzIGN1cnJlbmN5IGZpZWxkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVuY3lTZWxlY3Rpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB1c2VkIHRvIGZvcm1hdCB0aGUgbW9uZXkgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwcmVjaXNpb246IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY3VycmVuY2llcyB0aGF0IHRoaXMgY3VycmVuY3kgd2lkZ2V0IHN1cHBvcnQuIFRoZSBmb3JtYXQgZm9yIGVhY2ggZW50cnkgc2hvdWxkIGJlXG4gICAgICogW2N1cnJlbmN5LWNvZGUgLSBkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBfY3VycmVuY2llczogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXR0ZWQgY3VycmVuY3kgdmFsdWUuIFVzZXMgYW5ndWxhciBjdXJyZW5jeVBpcGUgdG8gZm9ybWF0IGJhc2VkIG9uIGNvdW50cnkgY29kZS5cbiAgICAgKi9cbiAgICBkaXNwbGF5VmFsdWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW5jeSBwaXBlIGlzIHVzZWQgdG8gZm9ybWF0IG91ciBtb25leSBvYmplY3QuXG4gICAgICovXG4gICAgY3VycmVuY3lQaXBlOiBDdXJyZW5jeVBpcGU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW5jaWVzLlxuICAgICAgICB0aGlzLmluaXRDdXJyZW5jaWVzKCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW5jeVBpcGUgPSBuZXcgQ3VycmVuY3lQaXBlKGVudi5sb2NhbGUpO1xuXG4gICAgICAgIGVudi5vbkxvY2FsZUNoYW5nZS5zdWJzY3JpYmUoKGxvY2FsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5UGlwZSA9IG5ldyBDdXJyZW5jeVBpcGUobG9jYWxlKTtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb25leS5hbW91bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5tb25leSk7XG5cbiAgICAgICAgdGhpcy5pbml0Q3VycmVuY2llcygpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY3VycmVuY3lTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5fY3VycmVuY2llc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlYWR5IHRoZSBtb25leSBmaWVsZCBpZiBpdCBleGlzdHMuIGFuZCBvdmVycmlkZSB0aGUgZXhpc3RpbmcgdmFsdWVzLlxuICAgICAgICBpZiAodGhpcy5tb25leSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMubW9uZXkuY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vbmV5ID0gbmV3IE1vbmV5KG51bGwsIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgaW5pdEN1cnJlbmNpZXMoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW5jaWVzIHx8IHRoaXMuX2N1cnJlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW5jaWVzID0gWydVU0QnLCAnQ05ZJywgJ0FVRCcsICdFVVInLCAnR0JQJ107XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgdGhlIHJlYWwgdmFsdWUgd2hlbiB0aGUgdXNlciBjbGlja3MgaW4gdGhlIGN1cnJlbmN5IHdpZGdldC4gVGhlbiBoZSBjYW4gbW9kaWZ5IHRoZVxuICAgICAqIHZhbHVlIHdpdGhvdXQgc2VlaW5nIHRoZSBmb3JtYXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsXG4gICAgICovXG4gICAgb25Gb2N1cyhlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5KSAmJiBpc1ByZXNlbnQodGhpcy5tb25leS5hbW91bnQpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMubW9uZXkuYW1vdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5IHRoZSBmb3JtYXR0ZWQgY3VycmVuY3kgdmFsdWUgd2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheS5cbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBvbkJsdXIoZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubW9uZXkgPSB0aGlzLm1vbmV5LmNsb25lKHthbW91bnQ6IE51bWJlcihlbC52YWx1ZSl9KTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9uZXkpO1xuICAgIH1cblxuICAgIG9uU2VsZWN0aW9uKGN1cnJlbmN5OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gY3VycmVuY3k7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeSh0aGlzLm1vbmV5LmFtb3VudCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdpbGwgY2hlY2sgdG8gc2VlIGlmIGN1cnJlbmN5IGlzIGEgdmFsaWQgbnVtYmVyIGJlZm9yZSBmb3JtYXR0aW5nLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1hdEN1cnJlbmN5KHZhbDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoIXZhbCB8fCB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZSA9ICdVU0QnO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW5jeVNlbGVjdGlvbikge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuY3VycmVuY3lTZWxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbmV5ID0gdGhpcy5tb25leS5jbG9uZSh7Y3VycmVuY3k6IHRoaXMuY3VycmVuY3lTZWxlY3Rpb259KTtcblxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgcHJlY2lzaW9uIGlzIDIuIEZvciBleGFtcGxlLCAxMC4yMyBVU0QuXG4gICAgICAgIGxldCBkaWdpdHMgPSAnMS4wLTInO1xuICAgICAgICAvLyBJZiBwcmVjaXNpb24gaXMgcHJlc2VudCwgdXNlIGl0IGZvciBmb3JtYXQgdGhlIG1vbmV5IHZhbHVlIGZvciBkaXNwbGF5LlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgZGlnaXRzID0gJzEuMC0nICsgdGhpcy5wcmVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lQaXBlLnRyYW5zZm9ybSh2YWwsIGNvZGUsICdzeW1ib2wnLCBkaWdpdHMpO1xuICAgIH1cblxuICAgIGdldE1vbmV5Q3VycmVuY3koKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRpc3BsYXlWYWx1ZSkgJiYgdGhpcy5kaXNwbGF5VmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGN1cnJlbmNpZXMoKTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW5jaWVzO1xuICAgIH1cblxuICAgIHNldCBjdXJyZW5jaWVzKHZhbHVlOiBhbnlbXSlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW5jaWVzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIE1vbmV5KSAmJiAhZXF1YWxzKHZhbHVlLCB0aGlzLm1vbmV5KSkge1xuICAgICAgICAgICAgdGhpcy5tb25leSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5LmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLm1vbmV5LmN1cnJlbmN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb25leSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogTW9uZXkgb2JqZWN0IGlzIHJlcHJlc2VudGVkIGFzIGEgdmFsdWUsIGxvY2FsZSwgYW5kIGN1cnJlbmN5Q29kZVxuICovXG5leHBvcnQgY2xhc3MgTW9uZXkgaW1wbGVtZW50cyBWYWx1ZVxue1xuICAgIHVuaXF1ZU5hbWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBhbW91bnQ6IG51bWJlciA9IDAsIHB1YmxpYyByZWFkb25seSBjdXJyZW5jeTogc3RyaW5nID0gJ1VTRCcsXG4gICAgICAgICAgICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsZTogc3RyaW5nID0gJ2VuX1VTJylcbiAgICB7XG4gICAgfVxuXG5cbiAgICBnZXRUeXBlcygpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IE51bWJlcixcbiAgICAgICAgICAgIGN1cnJlbmN5OiBTdHJpbmcsXG4gICAgICAgICAgICBsb2NhbGU6IFN0cmluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzTmFtZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiAnTW9uZXknO1xuICAgIH1cblxuICAgICRwcm90bygpOiBNb25leVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25leSgxLCAnMjMnLCAnMzMnKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmFtb3VudCArICcsIGxvY2FsZTogJyArIHRoaXMubG9jYWxlICsgJywgY29kZTogICcgKyB0aGlzLmN1cnJlbmN5O1xuICAgIH1cblxuXG4gICAgY2xvbmUoZGF0YTogeyBhbW91bnQ/OiBudW1iZXIsIGN1cnJlbmN5Pzogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcgfSA9IHt9KTogTW9uZXlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgTW9uZXkoXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5hbW91bnQpID8gZGF0YS5hbW91bnQgOiB0aGlzLmFtb3VudCxcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmN1cnJlbmN5KSA/IGRhdGEuY3VycmVuY3kgOiB0aGlzLmN1cnJlbmN5LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEubG9jYWxlKSA/IGRhdGEubG9jYWxlIDogdGhpcy5sb2NhbGVcbiAgICAgICAgKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZSwgQ3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEcm9wZG93bk1vZHVsZSwgSW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtDdXJyZW5jeUNvbXBvbmVudH0gZnJvbSAnLi9jdXJyZW5jeS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FXRHJvcGRvd25Nb2R1bGV9IGZyb20gJy4uL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbQ3VycmVuY3lQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBBV0N1cnJlbmN5TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNEYXRlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogTGlnaHR3ZWlnaHQgYW5kIGNvbmZpZ3VyYWJsZSBEYXRlIGFuZCBUaW1lIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcHJpbWVuZy4gVGhpc1xuICogY29tcG9uZW50IGNvbWJpbmVzIGJvdGggZGF0ZSBwaWNrZXIgYXMgd2VsbCBhcyB0aW1lIHBpY2tlclxuICpcbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215VGltZXInICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgIFtuYW1lXT1cIidkdWVEYXRlJ1wiPlxuICogICAgPC9hdy1kYXRlLXRpbWU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVRpbW1lckNvbXBvbmV0XG4gKiAgICB7XG4gKlxuICogICAgICAgIGRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICpcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRGdWxsWWVhcigyMDE2ICwgMTAgLCAzKTtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEhvdXJzKDEwICwgMTAgLCAxMCk7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgeW91IHdpbGwgc2VlIGRhdGUgZmllbGQgYW5kIHRpbWUgZmllbGQgaXMgaGlkZGVuIHRvIHNob3cgYm90aCB5b3UganVzdCBkbyBmb2xsb3dpbmc6XG4gKlxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXlUaW1lcicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgIFtzaG93VGltZV09XCJzaG93VGltZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiICBbbmFtZV09XCInYmJkZCdcIj5cbiAqICAgIDwvYXctZGF0ZS10aW1lPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlUaW1tZXJDb21wb25ldFxuICogICAge1xuICogICAgICAgIGRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICogICAgICAgIHNob3dUaW1lID0gdHJ1ZTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRGdWxsWWVhcigyMDE2ICwgMTAgLCAzKTtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEhvdXJzKDEwICwgMTAgLCAxMCk7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICovXG5cblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlQW5kVGltZUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGF0ZS10aW1lJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2RhdGUtYW5kLXRpbWUuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkYXRlLWFuZC10aW1lLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIERBVEVUSU1FX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUFuZFRpbWVDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBEYXRlQW5kVGltZUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyByZWFkb25seSBOZ1RpbWUxMjogc3RyaW5nID0gJ2hoOm1tIGEnO1xuICAgIHN0YXRpYyByZWFkb25seSBOZ1RpbWUyNDogc3RyaW5nID0gJ0hILm1tIGEnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlIHVzZWQgdG8gc2V0IHRoZSBkYXRlIGFuZCB0aW1lIHBpY2tlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IERhdGU7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGRhdGUgZm9ybWF0IHBhdHRlcm4gdXNlZCBpZiBub25lIGlzIHBhc3NlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXRQYXR0ZXJuOiBzdHJpbmcgPSAnbW0vZGQveXknO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIHdvcmthcm91bmQgYXMgZm9ybWF0dGVycyBpbiB0aGUgcHJpbWVORyBhbmQgYW5ndWxhciBhcmUgZGlmZmVyZW50IHNvIHVudGlsIGl0c1xuICAgICAqIGZpeGVkIHdlIG5lZWQgdG8ga2VlcCB0aGlzIGV4dHJhIHBhdHRlcm4uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXRQYXR0ZXJuTkc6IHN0cmluZyA9ICdNTS9kZC95eSc7XG5cblxuICAgIC8qKlxuICAgICAqIFNob3dzIGFuZCBoaWRlcyBuYXZpZ2F0aW9uIGJhciB3aXRoIHllYXIgYW5kIG1vbnRocyBzZWxlY3Rpb25zXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93TmF2aWdhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBZZWFyIHJhbmdlIGRpc3BsYXllZCBmb3IgdGhlIGRyb3AgZG93bi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHllYXJSYW5nZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYW5kIGhpZGVzIG5hdmlnYXRpb24gYmFyIHdpdGggeWVhciBhbmQgbW9udGhzIHNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dJY29uOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aW1lcGlja2VyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VGltZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgRGF0ZVBpY2tlci4gRXZlbiB3ZSBjYW4gaGlkZSBpdC4gaXQgc2hvdWxkIGJlIGZvciBtb3N0IG9mIHRoZSBjYXNlIGFsd2F5c1xuICAgICAqIHRydWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dEYXRlOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyB0aGUgZGF0ZSBwaWNrZXIgd2hhdCBmb3JtYXQgaXQgc2hvdWxkIHVzZSB3aGVuIHByZXNlbnRpbmcgdGltZS4gV2hlbiBob3VyRm9ybWF0IGlzIDEyLFxuICAgICAqIGl0IHNob3dzIHRoZSBBTSwgUE1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaG91ckZvcm1hdDogc3RyaW5nID0gJzI0JztcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGV2ZW50IHdoZW4gc3BlY2lmaWMgZGF0ZSBpcyBjbGlja2VkIGluc2lkZSBEYXRlUGlja2VyXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkYXRlIHRvIGhpZ2hsaWdodCBvbiBmaXJzdCBvcGVuaW5nIGlmIHRoZSBmaWVsZCBpcyBibGFuay5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlZmF1bHREYXRlOiBEYXRlID0gbmV3IERhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2YgRGF0ZXRpbWUgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIERhdGVBbmRUaW1lIGZvcm1hdE5hbWUgaXMgbm90IHByb3BhZ2F0ZWRcbiAgICAgKiB0byBEYXRlIGZpZWxkLlxuICAgICAqL1xuICAgIGZvcm1hdE5hbWVXaXRoVGltZTogc3RyaW5nO1xuXG5cbiAgICBpMThuOiBhbnk7XG4gICAgdGltZVBsYWNlSG9sZGVyOiBzdHJpbmcgPSAnaGg6c3MnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB0byBkYXRlVGltZSBwYXR0ZXJuIHdoaWNoIGlzIGRlZmluZWQgaW4gcmVzb3VyY2UgZmlsZXNcbiAgICAgICAgaWYgKHRoaXMuaG91ckZvcm1hdCAhPT0gJzEyJyAmJiB0aGlzLmhvdXJGb3JtYXQgIT09ICcyNCcpIHtcbiAgICAgICAgICAgIHRoaXMuaG91ckZvcm1hdCA9ICcyNCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbWVQbGFjZUhvbGRlciA9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgIGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUxMn1gIDogYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTI0fWA7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUoKHZhbDogRGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xuXG4gICAgICAgIHRoaXMuZW52Lm9uTG9jYWxlQ2hhbmdlLnN1YnNjcmliZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIHJlZmFjdG9yIHRoaXMgYXMgdGhpcyByZWFsbHkgZ2V0IGNvbXBsaWNhdGVkIHRyeWluZyB0byBjb3ZlciB1c2VjYXNlIHdpdGggdGltZVxuICAgICAqIGFuZCBkYXRlIGFuZCBldmVyeSBmb3JtYXQgd2UgaGF2ZS4gV2Ugc2hvdWxkIHByb2JhYmx5IGhhdmUgc2VwYXJhdGUgcGF0dGVybnMgZm9yXG4gICAgICogZGF0ZXMgb25seSBhbmQgZGF0ZSArIHRpbWVcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRUcmFuc2xhdGlvbnMoKSB7XG5cbiAgICAgICAgdGhpcy5mb3JtYXROYW1lV2l0aFRpbWUgPSB0aGlzLmZvcm1hdFBhdHRlcm47XG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXR0ZXJuTkcgPSB0aGlzLmZvcm1hdFBhdHRlcm4gKz0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgICAgIGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUxMn1gIDogYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTI0fWA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dUaW1lKSB7XG4gICAgICAgICAgICBsZXQgdGltZVN0YXJ0cyA9IHRoaXMuZm9ybWF0UGF0dGVybi5pbmRleE9mKCdoJyk7XG4gICAgICAgICAgICBpZiAodGltZVN0YXJ0cyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdE5hbWVXaXRoVGltZSA9IHRoaXMuZm9ybWF0UGF0dGVybi5zdWJzdHJpbmcoMCwgdGltZVN0YXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBhdHRlcm5ORyArPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5pMThuID0ge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWs6IDAsXG4gICAgICAgICAgICBkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsXG4gICAgICAgICAgICAgICAgJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICAgICAgZGF5TmFtZXNNaW46IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddLFxuICAgICAgICAgICAgbW9udGhOYW1lczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JyxcbiAgICAgICAgICAgICAgICAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLFxuICAgICAgICAgICAgICAgICdOb3YnLCAnRGVjJ11cbiAgICAgICAgfTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBkYXRlcyBjaGFuZ2VzLiBIZXJlIHdlIHVwZGF0ZSAgdGhpcy52YWx1ZSAtID4gZGF0ZSBhbmQgYWxzbyB1cGRhdGUgdmFsdWUgaW5zaWRlXG4gICAgICogZm9ybUNvbnRyb2xsZXJcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRGF0ZUNoYW5nZShldmVudDogYW55KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBzb21lIGVycm9yID9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsdWUgPSBpc0RhdGUoZXZlbnQpID8gZXZlbnQgOiBuZXcgRGF0ZShldmVudCk7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnZhbHVlLCB7b25seVNlbGY6IGZhbHNlLCBlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2FsZW5kYXJNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RhdGVBbmRUaW1lQ29tcG9uZW50fSBmcm9tICcuL2RhdGUtYW5kLXRpbWUuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEYXRlQW5kVGltZUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdEYXRlQW5kVGltZU1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRpYWxvZyBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERpYWxvZ0NvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGlhbG9nLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEaWFsb2dIZWFkZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGlhbG9nIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGlhbG9nQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2ctZm9vdGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtNb2RhbENvbnRhaW5lcn0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLWNvbnRhaW5lcic7XG5pbXBvcnQge0RpYWxvZ0hlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0Zvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogRGlhbG9nIENvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHRoZSBsb29rIGFuZCBmZWVsIGZvciBhIG1vZGFsIGRpYWxvZy4gVGhpcyBjb21wb25lbnQgaGFzIHRocmVlXG4gKiBzZWN0aW9uczogaGVhZGVyLCBib2R5LCBhbmQgZm9vdGVyLiBJdCBjYW4gYmUgdXNlZCBieSBpdHNlbGYgb3IgZXh0ZW5kZWQuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxEaWFsb2dDb21wb25lbnQ+KSwgc2VydmljZS5jbG9zZSgpXG4gKlxuICogVXNhZ2U6XG4gKiAgICAxLiAgVXNpbmcgRGlhbG9nIGRpcmVjdGx5IHRvIGRpc3BsYXkgYSBtb2RhbCBwb3B1cC4gVGhpcyB1c2FnZSBpcyBhIHF1aWNrIHdheSB0byBzaG93IGFcbiAqIG1lc3NhZ2UgdG8gdGhlIHVzZXIuXG4gKlxuICogICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxEaWFsb2dDb21wb25lbnQ+KCBEaWFsb2dDb21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBQb3B1cCBUaXRsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdNeSBQb3B1cCBCb2R5J1xuICogICAgICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZyBbKHZpc2libGUpXT1cImRpc3BsYXlcIiBbbW9kYWxdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25PcGVuKT1cIm9wZW5BY3Rpb24oKVwiIChvbkNsb3NlKT1cImNsb3NlQWN0aW9uKClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2ctaGVhZGVyPkRpYWxvZyBIZWFkZXI8L2F3LWRpYWxvZy1oZWFkZXI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlhbG9nIEJvZHk6IENyZWF0aW5nIGEgZGlhbG9nIHVzaW5nIHRoZSBkaWFsb2cgY29tcG9uZW50XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nLWZvb3Rlcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjbG9zZSgpXCI+T0s8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2ctZm9vdGVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm9wZW4oKVwiPk9wZW4gRGlhbG9nPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBkaWFsb2dBY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW4oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gKiAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW5BY3Rpb24oKSAge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZ0FjdGlvbiA9IFwib3BlblwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGlhbG9nJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2RpYWxvZy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2RpYWxvZy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0NvbXBvbmVudCBleHRlbmRzIE1vZGFsQ29udGFpbmVyXG57XG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIHRoZSBEaWFsb2cuICBpZiB0aXRsZSBhbmQgJ1RpdGxlVGVtcGxhdGUnIGFyZSBib3RoIHNldCwgdGl0bGVUZW1wbGF0ZSB0YWtlc1xuICAgICAqIHByZWNlZGVuY2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQm9keSBzZWN0aW9uIGZvciBEaWFsb2cuIENhbGxlciBzaG91bGQgdXNlIGVpdGhlciB0aGUgYm9keSBzdHJpbmcsIG9yIGNvbnRlbnQgcHJvamVjdGlvblxuICAgICAqIHRvIGFkZCB2YWx1ZXMgdG8gdGhlIGRpYWxvZy4gSWYgYm90aCBhcmUgdXNlZCwgdGhleSB3aWxsIGJvdGggc2hvdyB1cC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBzdXBwb3J0IHR3byB3YXkgZGF0YSBiaW5kaW5nIG9uIHZpc2libGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiB3aGV0aGVyIHRoaXMgZGlhbG9nIGJsb2NrcyB0aGUgcmVzdCBvZiB0aGUgcGFnZSBvciBub3Qgd2hlbiBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtb2RhbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZXJlJ3MgYW4geCBhdCB0aGUgdG9wIHJpZ2h0IHRoYXQgbWFrZXMgdGhlIGRpYWxvZyBjbG9zYWJsZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZGlhbG9nLiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBkaWFsb2cgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgZGlhbG9nIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGNvbXBvbmVudC4gVXN1YWxseSBjb250YWlucyB0aGUgdGl0bGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChEaWFsb2dIZWFkZXJDb21wb25lbnQpIGhlYWRlcjogRGlhbG9nSGVhZGVyQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRGlhbG9nIGZvb3Rlci4gVXN1YWxseSBjb250YWlucyBidXR0b25zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChEaWFsb2dGb290ZXJDb21wb25lbnQpIGZvb3RlcjogRGlhbG9nRm9vdGVyQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGlzIGRpYWxvZy5cbiAgICAgKi9cbiAgICBvcGVuKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcblxuICAgICAgICAvLyB2aXNpYmxlIGlzIGEgMi13YXkgYmluZGluZyB2YXJpYWJsZS5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIGRpYWxvZ1xuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuXG4gICAgICAgIC8vIEltcG9ydGFudCB0byBtYWtlIHN1cmUgY2hhbmdlIGlzIHNldCBvbiBwYXJlbnQgYmluZGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFyaWFibGUgYW5kIGRpYWxvZyBvcGVuL2Nsb3NlIHN0YXRlIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2Ygc3luYyBhbmQgd2Ugd291bGRuJ3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIGRpYWxvZyBoYXZlIGhlYWRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0hlYWRlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuaGVhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgZGlhbG9nIGhhdmUgZm9vdGVyLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzRm9vdGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mb290ZXIpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7RGlhbG9nQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dIZWFkZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dGb290ZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWZvb3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ01vZHVsZX0gZnJvbSAncHJpbWVuZy9kaWFsb2cnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEaWFsb2dNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIFNraXBTZWxmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEVudmlyb25tZW50LFxuICAgIGVxdWFscyxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNBcnJheSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQcmVzZW50LFxuICAgIExpc3RXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDaG9vc2VyU2VsZWN0aW9uU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zdGF0ZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtDaG9vc2VyRGF0YVNvdXJjZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLWRhdGEtc291cmNlJztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuXG5cbi8qKlxuICogQ29udmVuaWVudCB3cmFwcGVyIGNsYXNzIGFyb3VuZCBjb250cm9scyBzdWNoIGFzIHJhZGlvYnV0dG9ucywgZHJvcGRvd24sIGNoZWNrYm94ZXMsXG4gKiBDaG9vc2VyLiBUaGUgdHlwZSBvZiB0aGUgY2hvb3NlciBtYXkgYmUgZGV0ZXJtaW5lZCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluXG4gKiB0aGUgZGF0YSBzb3VyY2UgbGlzdCwgb3IgY2FuIGJlIHNwZWNpZmllZCBleHBsaWNpdGx5IHZpYSB0aGUgXCJ0eXBlXCIgYmluZGluZy5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1nZW5lcmljLWNob29zZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gR2VuZXJpY0Nob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE9yZGVyZWQgbGlzdCBvZiBpdGVtcyBhc3NpZ25hYmxlIHRvIHRoZSBrZXkgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRoaXMgY29udHJvbCBpcyBiZWluZyBhc3NpZ25lZCB0by5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IGZpZWxkIHBhdGggdGhpcyBjb250cm9sIGlzIGJlaW5nIGFzc2lnbmVkIHRvLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAga2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIGluIHBsYWNlIG9mIExJU1QgYmluZGluZyB0byByZXRyaWV2ZSBhIGxpc3QgYmFzZWQgb24gdGhlIENob2ljZVNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiByZXRyaWV2aW5nIGNob2ljZVNvdXJjZSBieSBkZXN0aW5hdGlvbiBjbGFzcyBhbmQgdGhpcyBhcmUgZXh0cmEgcGFyYW1zIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBuYXJyb3cgdGhlIG1hdGNoaW5nIG9yIHRvIHBhc3MgcGFyYW1ldGVycyBpbnRvIENob2ljZVNvdXJjZSBwcm92aWRlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hvaWNlUHJvdmlkZXJQYXJhbXM6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqICBJcyB0aGlzIGEgTGlzdCBwcm9wZXJ0eSwgb3IgYSB0by1vbmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBzdHlsZSBvZiBjaG9vc2VyIHRvIHVzZSAoUmFkaW8sIENoZWNrYm94LCBEcm9wZG93biwgQ2hvb3NlcilcbiAgICAgKiAgRGVmYXVsdHMgYmFzZWQgb24gY2FyZGluYWxpdHkgb2YgdGhlIGxpc3QgYW5kIHdoZXRoZXIgaXQncyBtdWx0aVNlbGVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgY3VzdG9tIGtleS4gaW4gb3JkZXIgdG8gbWFrZSB0aGlzIHdvcmsgd2UgbmVlZCB0byBpbnRyb2R1Y2UgY3VzdG9tIDx0ZW1wbGF0ZXM+IGZvclxuICAgICAqIGFsbCB0aGlzIGNob29zZXIgdHlwZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlLZXk6IHN0cmluZztcblxuICAgIC8vIC8qKlxuICAgIC8vICAqICBTaG91bGQgd2UgYXR0ZW1wdCBhIG1hdGNoIGFzIHRoZXkgdHlwZSAoYWdhaW5zdCB0aGUgZnVsbCBsaXN0KVxuICAgIC8vICAqL1xuICAgIC8vIEBJbnB1dCgpXG4gICAgLy8gYWxsb3dGdWxsTWF0Y2hPbklucHV0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlbmRlcmVkIGFzIGZpcnN0IHZhbHVlIGluIHRoZSBkcm9wZG93biB3aGljaCBsZXQgdGhlIHVzZXIgdG8gbWFrZSAnbm8gc2VsZWN0aW9uJ1xuICAgICAqIGZyb20gYXZhaWxhYmxlIGxpc3Qgb2YgdmFsdWVzLiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSBhbmQgdXNlIG1ha2UgdGhpcyBzZWxlY3Rpb24gd2VcbiAgICAgKiBzYXZlIGEgTlVMTCB2YWx1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9TZWxlY3Rpb25TdHJpbmc6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBDaG9vc2VyIHdvcmtzIGRpcmVjdGx5IHdpdGggb2JqZWN0IGFuZCBpdHMgcmVmZXJlbmNlcyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhpc1xuICAgICAqIGtleXBhdGggdG8gYmUgYWJsZSB0byBzZXQvZ2V0IHZhbHVlIGZyb20gdGFyZ2V0IG9yIHBhcmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBrZXlQYXRoOiBGaWVsZFBhdGg7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHB1YmxpYyBkYXRhU291cmNlOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm9iamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gKDxhbnk+dGhpcy5fdmlld0NvbnRhaW5lci5pbmplY3Rvcikudmlldy5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5UGF0aCA9IG5ldyBGaWVsZFBhdGgodGhpcy5rZXkpO1xuICAgICAgICBsZXQgZGVmYXVsdERhdGFQcm92aWRlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICBkZWZhdWx0RGF0YVByb3ZpZGVyID0gdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlcnMuZmluZCh0aGlzLmxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFQcm92aWRlciA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXJzLmZpbmQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcm9qZWN0ZWRTaXplID0gZGVmYXVsdERhdGFQcm92aWRlci5leHBlY3RlZENvdW50KHRoaXMuY2hvaWNlUHJvdmlkZXJQYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXRUeXBlKHByb2plY3RlZFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdDaG9vc2VyJykge1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiBkZWZhdWx0RGF0YVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cEtleTogdGhpcy5kaXNwbGF5S2V5LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBuZXcgQ2hvb3NlclN0YXRlKG5ldyBHQ0Nob29zZXJTdGF0ZSh0aGlzKSwgdGhpcy5tdWx0aXNlbGVjdCksXG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBkbyB3ZSBuZWVkIHRvIHJlYWQgdGhpcyB2YWx1ZSBpbiBhc3luYz9cbiAgICAgICAgICAgIHRoaXMubGlzdCA9IGRlZmF1bHREYXRhUHJvdmlkZXIuZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubm9TZWxlY3Rpb25TdHJpbmcgPSB0aGlzLmkxOG4uaW5zdGFudCgnV2lkZ2V0cy5nY2hvb3Nlci5ub1NlbFN0cmluZycpO1xuICAgICAgICAgICAgdGhpcy5ub1NlbGVjdGlvblN0cmluZyA9ICdTZWxlY3QgYSBJdGVtJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBASW5wdXQgdHlwZSBpcyBub3QgcGFzc2VkIHdlIHRyeSB0byBndWVzcyBhbmQgc2VsZWN0IHRoZSBiZXN0IHR5cGUgZm9yIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0VHlwZShwcm9qZWN0ZWRTaXplOiBudW1iZXIpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IChwcm9qZWN0ZWRTaXplIDw9IDAgfHwgcHJvamVjdGVkU2l6ZSA+IDgpID8gJ0Nob29zZXInIDogJ0NoZWNrYm94JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKHByb2plY3RlZFNpemUgPD0gMCB8fCBwcm9qZWN0ZWRTaXplID4gMjApID8gJ0Nob29zZXInXG4gICAgICAgICAgICAgICAgICAgIDogKHByb2plY3RlZFNpemUgPCA2KSA/ICdSYWRpbycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Ryb3Bkb3duJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBjZXJ0YWluIHByb3BlcnRpZXMgd2hpY2ggYXJlIHJlcXVpcmVkIGJ5IHRoaXMgY29tcG9uZW50LiBBcyBhbHJlYWR5IG1lbnRpb25lZFxuICAgICAqIGFib3ZlIEdlbmVyaWNDaG9vc2VyIHdvcmtzIHdpdGggcmVmZXJlbmNlcyBhbmQgdGhlZm9yZSB0d28ga2V5IHByb3BlcnRpZXMgYXJlIG9iamVjdCBhbmQga2V5XG4gICAgICogc28gd2UgY2FuIGFjY2VzcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVJlcXVpcmVkKClcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGEgb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBhIGtleSBiaW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5saXN0KSAmJiBpc0JsYW5rKHRoaXMuZGVzdGluYXRpb25DbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBoYXZpbmcgZWl0aGVyIGxpc3Qgb2YgdmFsdWVzIG9yIGRlc3RpbmF0aW9uQ2xhc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlKSAmJlxuICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gJ1JhZGlvJyAmJiB0aGlzLnR5cGUgIT09ICdDaGVja2JveCcgJiYgdGhpcy50eXBlICE9PSAnRHJvcGRvd24nICYmXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICE9PSAnQ2hvb3NlcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIEdlbmVyaWNDaG9vc2VyICAtIGludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kaXNwbGF5S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5S2V5ID0gJ3RvU3RyaW5nJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGRpc3BsYXlpbmcgdmFsdWUgYm90aCBmcm9tIHByaW1pdGl2ZSB0eXBlIGFzIHdlbGwgY29tcGxleCBvYmplY3QuIElmIHlvdSB3YW50IHRvXG4gICAgICogY29udHJvbCBob3cgaXRlbSBpcyBkaXNwbGF5ZWQgeW91IGNhbiBwcm92aWRlIGRpc3BsYXkga2V5LCB3aGljaCBpcyBjYW4gYmUgYSAgbWV0aG9kIG9yXG4gICAgICogcHJvcGVydHkgb2YgdGhlIG9iamVjdCB5b3UgYXJlIGRpc3BsYXlpbmcuXG4gICAgICpcbiAgICAgKiBUb2RvOiB0aGluayBhYm91dCBmb3JtYXR0ZXJzIGFzIHdlbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGlzcGxheUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSwgdGhpcy5kaXNwbGF5S2V5KTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgUmV0cmlldmUgYSBjdXJyZW50IHZhbHVlIGZyb20gdGhlIHBhcmVudC90YXJnZXQgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5UGF0aC5nZXRGaWVsZFZhbHVlKHRoaXMub2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgc2V0IHZhbHVlIGJhY2sgdG8gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHNlbGVjdGlvbih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5rZXlQYXRoLnNldEZpZWxkVmFsdWUodGhpcy5vYmplY3QsIHZhbHVlKTtcbiAgICB9XG5cblxuICAgIG9uU2VsZWN0aW9uKHZhbHVlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KCk7XG5cbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJpY0Nob29zZXIgaW1wbGVtZW50YXRpb24gb2YgdGhlIENob29zZXJTZWxlY3Rpb25TdGF0ZSB3aGljaCBpcyB1c2VkIHdoZW4gVHlwZSA9IENob29zZXIuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgR0NDaG9vc2VyU3RhdGUgZXh0ZW5kcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ0Nob29zZXI6IEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRoaXMuaXNTZWxlY3RlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gaW1wbGVtZW50IHNtYXJ0ZXIgYW5kIG1vcmUgZ2VuZXJpYyB3YXkgaG93IHdlIHVzZSBpdCBpbiBqYXZhXG4gICAgICAgICAgICAvLyBSZWxhdGlvbnNoaXBGaWVsZC5hZGRUbyhfb2JqZWN0LCBfa2V5UGF0aCwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgbGV0IG11bHRpUmVsOiBBcnJheTxhbnk+ID0gdGhpcy5nQ2hvb3Nlci5rZXlQYXRoLmdldEZpZWxkVmFsdWUodGhpcy5nQ2hvb3Nlci5vYmplY3QpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsobXVsdGlSZWwpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlSZWwgPSBbXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobXVsdGlSZWwpICYmICFpc0FycmF5KG11bHRpUmVsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSSBjYW4gbm90IHN0b3JlIG11bHRpc2VsZWN0IHZhbHVlIGludG8gbm9uLWFycmF5IG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlbC5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb24gPSBtdWx0aVJlbDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KG11bHRpUmVsLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgbGV0IG9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICAgICAgcmV0dXJuIChpc0JsYW5rKG9iamVjdHMpIHx8IExpc3RXcmFwcGVyLmlzRW1wdHkob2JqZWN0cykpID8gbnVsbCA6IExpc3RXcmFwcGVyLmxhc3QoXG4gICAgICAgICAgICAgICAgb2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQmxhbmsoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQXJyYXkoc2VsZWN0aW9uKSkgPyBzZWxlY3Rpb24gOiBbc2VsZWN0aW9uXTtcbiAgICB9XG5cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgodGhpcy5zZWxlY3RlZE9iamVjdHMoKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyVmFsdWUgPSB0aGlzLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBlcXVhbHMoY3VyVmFsdWUsIHNlbGVjdGlvbik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBmb3IgUmFkaW9CdXR0b24gY29tcG9uZW50IHByb3ZpZGluZyBjb252ZW5pZW50IHdheSB0byB0byByZW5kZXIgUmFkaW9CdXR0b24gR3JvdXBzXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYFxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnZ2VuZGVyLXNlbGVjdG9yJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiTGlzdFZhbHVlc1wiIFtsYXlvdXRdPVwibGF5b3V0XCJcbiAqICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGVkVmFsdWVcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICogICAgICBgXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBHZW5kZXJTZWxlY3RvckNvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICByYkxpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydtYWxlJyAsICdmZW1hbGUnICwgJ290aGVyJ107XG4gKiAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBzdHJpbmcgPSAnb3RoZXInO1xuICogICAgICAgICAgbGF5b3V0OiBzdHJpbmcgPSAnc3RhY2tlZCc7XG4gKlxuICpcbiAqICAgICAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgICAgICB9XG4gKlxuICogICAgICB9XG4gKlxuICogYGBgXG4gKi9cblxuXG5leHBvcnQgY29uc3QgUkJfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJhZGlvYnV0dG9uLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAncmFkaW8tYnV0dG9uLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydyYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBSQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBMSXN0IG9mIHZhbHVlcyB1c2VkIHRvIHJlbmRlciB0aGUgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyB3aGljaCByYWRpbyBidXR0b25zIGlzIHNlbGVjdGVkIHdoZW4gcmVuZGVyZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWFsIGV4cHJlc3Npb24gdG8gZm9ybWF0IGxhYmVsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbEZvcm1hdHRlcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyBhbiBldmVudCB3aGVuIHJhZGlvIGJ1dHRvbiBpcyBzZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1vZGVsIHRvIGxpc3RlbiBmb3IgcmFkaW8gdmFsdWUgY2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIGlzIGV4dHJhY3RlZCBpbnRvIGEgbWV0aG9kIHNvIGluIHRoZSBmdXR1cmUgd2UgY2FuIHBsYXkgaG93IHdlIHdhbnQgdG8gZGlzcGxheSB0aGVcbiAgICAgKiB2YWx1ZS4gU2luY2UgSSB3YW50IHRvIHN1cHBvcnQgZm9ybWF0dGVycyBmb3IgZWFjaCBjb21wb25lbnRzIHdlIG1pZ2h0IGhhdmUgYSBjaGFuY2UgdG9cbiAgICAgKiBkZWNpZGUgaG93IHRoZSBsYWJlbCB3aWxsIGxvb2sgbGlrZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGxhYmVsVmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGFiZWxGb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvcm1hdHRlcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyB2ZXJzaW9uIG9mIGNoZWNrYm94ZXMgd2Ugc3RpbGwgZXhwZWN0IG9ubHkgcHJpbWl0aXZlIHR5cGVzLiBLZWVwIHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAqIGluIGV4dHJhIG1ldGhvZCBzbyB3ZSBjYW4gd29yayB3aXRoIGl0IGV2ZW4gbm93IHdlIGp1c3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2tcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgdmFsdWUoaXRlbTogYW55KTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT24gTkdNb2RlbCBjaGFuZ2UgcmV0cmlldmUgYWN0dWFsIHJlY29yZCBiYXNlZCBvbiB0aGUgSU5ERVggYW5kIHByb3BhZ2F0ZSBpdCB0byBib3RoXG4gICAgICogbmdNb2RlbCBhcyB3ZWxsIGFzIEZvcm1Hcm91cC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnkgPSB0aGlzLmxpc3RbdGhpcy5tb2RlbF07XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggY29tcGxleCBvYmplY3Qgc3RvcmUgb25seSBJTkRFWCBudW1iZXIgaW4gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW9kZWwoc291Y2VJdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxpc3QuZmluZEluZGV4KChlbGVtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VjZUl0ZW0gPT09IGVsZW07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsID0gaW5kZXggPT09IC0xID8gMCA6IGluZGV4O1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnkgPSB0aGlzLmxpc3RbdGhpcy5tb2RlbF07XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChuZXdNb2RlbCk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEhUTUwgcmFkaW8gYnV0dG9uIG9uIHRvcCBvZiBQcmltZU5HIHdpdGggYXJpYmEgc3R5bGluZ1xuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogMS4gQmFzaWMgdXNhZ2UgdXNpbmcgbmdNb2RlbCBwcmUtc2VsZWN0ZWQgZmlyc3QgcmFkaW9cbiAqXG4gKiAgYGBgdHNcbiAqXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdkZW1vLWNvbXAnLFxuICogICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCIncmVkJ1wiIFtsYWJlbF09XCInUmVkJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCInYmx1ZSdcIiBbbGFiZWxdPVwiJ0JsdWUnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICBgXG4gKiAgICAgIH0pKlxuICogICAgICBjbGFzcyBCYXNpY1dpdGhOZ01vZGVsQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIG1vZGVsOiBzdHJpbmdbXSA9IFsncmVkJ107XG4gKlxuICogICAgICAgICAgY29uc3RydWN0b3IoKVxuICogICAgICAgICAge1xuICogICAgICAgICAgfVxuICogICAgICB9XG4gKlxuICogIGBgYFxuICpcbiAqXG4gKiAyLiBCYXNpYyB1c2FnZSB3aXRoIGZvcm1Hcm91cFxuICpcbiAqXG4gKiBgYGB0c1xuICogICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgc2VsZWN0b3I6ICdkZW1vLWNvbXAnLFxuICogICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZW52LmN1cnJlbnRGb3JtXCI+XG4gKiAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3IyJ1wiIFt2YWx1ZV09XCIncmVkJ1wiIFtsYWJlbF09XCInUmVkJ1wiXG4gKiAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3IyJ1wiIFt2YWx1ZV09XCInYmx1ZSdcIiBbbGFiZWxdPVwiJ0JsdWUnXCJcbiAqICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICAgIGBcbiAqICAgICAgIH0pXG4gKiAgICAgICBjbGFzcyBCYXNpY1dpdGhGb3JtR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbiAqICAgICAgIHtcbiAqICAgICAgICAgICBtb2RlbDogc3RyaW5nID0gJ2JsdWUnO1xuICpcbiAqICAgICAgICAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICBuZ09uSW5pdCgpOiB2b2lkXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgICB0aGlzLmVudi5jdXJyZW50Rm9ybSA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICogICAgICAgICAgICAgICB0aGlzLmVudi5jdXJyZW50Rm9ybS5yZWdpc3RlckNvbnRyb2woJ2NvbG9yMicsIG5ldyBGb3JtQ29udHJvbCh0aGlzLm1vZGVsKSk7XG4gKiAgICAgICAgICAgfVxuICpcbiAqXG4gKiAgICAgICAgICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgIHRoaXMubW9kZWxTZXQgPSBldmVudDtcbiAqICAgICAgICAgICB9XG4gKlxuICogICAgICAgfVxuICogIGBgYGBcbiAqXG4gKlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBSQUJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJhZGlvYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3JhZGlvLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3JhZGlvLWJ1dHRvbi5jb21wb25lbnQuc2NzcyddLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYWRpb1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgYSByYWRpb1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBjbGljayBldmVudCB3aXRoIGN1cnJyZW50IHNlbGVjdGVkIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIHRvIGNvbXVuaWNhdGUgd2l0aCBwcmltZU5nIFJhZGlvXG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IgKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0ICgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByYWRpbyBpcyBjbGlja2VkLiBOb3QgdXNpbmcgUHJpbWVORyBjbGljayBldmVudCBhcyBpdCBpcyBmaXJlZCBiZWZvcmVcbiAgICAgKiB0aGUgbW9kZWwgaXMgY2hhbmdlZC4gVGhlcmVmb3JlIG5lZWQgdG8gbGlzdGVuIG9uIChuZ01vZGVsQ2hhbmdlKVxuICAgICAqXG4gICAgICovXG4gICAgb25Nb2RlbENoYW5nZSAobmV3VmFsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UmFkaW9CdXR0b25Db21wb25lbnR9IGZyb20gJy4vcmFkaW8tYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmFkaW9CdXR0b25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTGlzdENvbXBvbmVudH0gZnJvbSAnLi9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7R2VuZXJpY0Nob29zZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hMaXN0TW9kdWxlfSBmcm9tICcuLi9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Nob29zZXJNb2R1bGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtFbnRpdHksIGlzQmxhbmssIGlzRW50aXR5LCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge091dGxpbmVGb3JDb21wb25lbnQsIE91dGxpbmVOb2RlfSBmcm9tICcuL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cbi8qKlxuICogT3V0bGluZVN0YXRlIGlzIHRoZSBrZXkgZ2x1aW5nIHBhcnQgZm9yIHRoZSBPdXRsaW5lRm9yIGFuZCBPdXRsaW5lQ29udHJvbGxlciBjb21wb25lbnRzLiBJdFxuICogaG9sZHMgYWxsIGltcG9ydGFudCBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgb3V0bGluZSB0cmVlIGFuZCBtYW5hZ2VzIGV4cGFuc2lvbiBzdGF0ZXMgaW4gZm9ybVxuICogb2Ygc28gY2FsbGVkIGV4cGFuc2lvblBhdGggYW5kIGV4cGFuc2lvblN0YXRlc1xuICpcbiAqIFdlIG5lZWQgdG8gaGF2ZSBhIHdheSBob3cgdG8gd29yayB3aXRoIGdlbmVyaWMgZGF0YSBzdHJ1Y3R1cmUgaW4gb3JkZXIgbm90IHRvIGhvbGQgVUkgc3BlY2lmaWNcbiAqIGluZm9ybWF0aW9uIG9uIHRoZSBkb21haW4gb2JqZWN0IG1vZGVsIGp1c3QgbGlrZSB3ZSBoYWQgaXQgYmVmb3JlLCB3aGVyZSB3ZSBoYWQgYW4gaW50ZXJmYWNlXG4gKiBjYWxsZWQgT3V0bGluZU5vZGUsIHdpdGggZmllbGRzIChleHBhbmRlZCwgc2VsZWN0ZWQsIGV0Yy4uIClcbiAqXG4gKlxuICogYGV4cGFuc2lvblBhdGhgOiBIb2xkcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgYW5kIGV4cGFuZGVkIG5vZGVzLiBUaGlzIGlzIGZpbGxlZCBieVxuICogT3V0bGluZUNvbnRyb2xsZXIuXG4gKlxuICpcbiAqIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggRW50aXR5IG9yIGFueXRoaW5nIHRoYXQgaGFzIGlkZW50aXR5IHRoZW4gd2UgaGF2ZSBlYXNpZXIgc2l0dWF0aW9uIGFzIHdlXG4gKiBjYW4gYXNrIGZvciBJRCBhbmQgaXQgaXMgbW9yZSBlZmZpY2llbnQgZm9yIHNlcmlhbGl6YXRpb25cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE91dGxpbmVTdGF0ZVxue1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZXhwYW5kZWQgbm9kZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgX2V4cGFuc2lvblBhdGg6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBgYWxsb3dTZWxlY3Rpb25gIGlzIGVuYWJsZWQgb24gT3V0bGluZUNvbnRyb2wgaXQgc2F2ZWQgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gdG8gYmVcbiAgICAgKiBhYmxlIGxhdGVyIG9uIGFwcGx5IHNvbWUgc3R5bGluZyBhbmQgYnJvYWRjYXN0IHRoaXMgc2VsZWN0aW9uIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzZWxlY3RlZEl0ZW06IGFueTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWFwcyBvYmplY3QgcmVmZXJlbmNlIHRvIGJvb2xlYW4gdmFsdWVzLCB3aGVyZSBUUlVFIG1lYW5zIEVYUEFOREVELCBGQUxTRSBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBvdXRsaW5lIGlzIHJlbmRlcmVkIGZvciBmaXJzdCB0aW1lIG9yIHJlLXJlbmRlcmVkIGFuZCB3ZSBzZXQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlXG4gICAgICogZXhwYW5zaW9uU3RhdGVzLiBUaGlzIHdheSB3ZSBjYW4gcHJldHR5IGVhc2lseSBleGVjdXRlIENvbGxhcHNlQWxsLCBFeHBhbmRBbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWRBbGw6IGJvb2xlYW4gPSBmYWxzZTsgLy8gY29sbGFwc2VkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhvbGRzIGN1cnJlbnQgbGV2ZWwgZHVyaW5nIHRyZWUgbm9kZSByZW5kZXJpbmcgc28gd2UgY2FuIGFwcGx5IGNvcnJlY3QgaW5kZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRMZXZlbDogbnVtYmVyID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGR1cmluZyBhIHRvZ2dsZSBhY3Rpb24gdG8gcmVjb3JkIGN1cnJlbnQgc2VsZWN0aW9uIHBhdGguXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50UGF0aDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIEdsb2JhbGx5IHNoYXJlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIGNvbGxhcHNlQWxsIGFuZCBleHBhbmRBbGwgd2UgYXJlIHVzaW5nIHNpbXBsZSBtZWNoYW5pc20gd2hlcmUgd2UgY2xlYW4gdXAgYWxsXG4gICAgICogc2VsZWN0aW9uIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGV4cGFuZCBzdGF0ZSwgdGhpcyB3aGV5IGlzRXhwYW5kIG1ldGhvZCByZXR1cm5zIHRoZSBzYW1lXG4gICAgICogc3RhdGUgZm9yIGFsbCBpdGVtc1xuICAgICAqL1xuICAgIGNvbGxhcHNlQWxsICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvcikgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG5cbiAgICAgICAgICAgIC8vIGZvciB0aGlzIGNhc2Ugd2UgY29sbGFwc2UgYWxsIGJ1dCByb290IG5vZGVzXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmxpc3QuZm9yRWFjaCgoaXRlbTogT3V0bGluZU5vZGUpID0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKGl0ZW0uY2hpbGRyZW4gfHwgW10sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOb2Rlcyh0aGlzLm91dGxpbmVGb3IubGlzdCB8fCBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cGFuZEFsbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpICYmXG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2Rlcyh0aGlzLm91dGxpbmVGb3IubGlzdCwgdHJ1ZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkQWxsID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGdldCBleHBhbnNpb25QYXRoICgpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvblBhdGggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uUGF0aDtcbiAgICB9XG5cblxuICAgIHNldCBleHBhbnNpb25QYXRoICh2YWx1ZTogYW55W10pXG4gICAge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoLmZvckVhY2goKGl0ZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB0b2dnbGVFeHBhbnNpb24gKGN1cnJlbnRQYXRoOiBhbnlbXSwgY2hpbGRyZW4/OiBhbnlbXSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgbGV0IGl0ZW1DaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSAhdGhpcy5pc0V4cGFuZGVkKGl0ZW0pO1xuICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKGl0ZW0sIG5ld1N0YXRlKTtcblxuICAgICAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVMYXN0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXMoaXRlbUNoaWxkcmVuLCBuZXdTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEV4cGFuc2lvblBhdGgoY3VycmVudFBhdGgpO1xuICAgIH1cblxuICAgIHVwZGF0ZU5vZGVzIChub2RlczogYW55W10sIG5ld1N0YXRlOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5vdXRsaW5lRm9yLmNoaWxkcmVuRm9ySXRlbShjaGlsZCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW1zKSAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlcyhpdGVtcywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShjaGlsZCwgbmV3U3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRFeHBhbnNpb25TdGF0ZSAoaXRlbTogYW55LCBpc0V4cGFuZGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gRXZlbiBmb3IgdHJlZSBtb2RlIGZvcm1hdCBzYXZlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gdXNlIGl0IGxhdGVyIG9uIGluIGNhc2Ugb2JqZWN0XG4gICAgICAgIC8vIHJlZmVyZW5jZXMgZ2V0cyBtZWVzZWQgdXBcbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvciAmJlxuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgICg8T3V0bGluZU5vZGU+aXRlbSkuaXNFeHBhbmRlZCA9IGlzRXhwYW5kZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgICAgICBpZiAoaXNFeHBhbmRlZCA9PT0gdGhpcy5pc0V4cGFuZGVkQWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIChpc0V4cGFuZGVkKSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBpbXByb3ZlIHN0YXRlIHBlcnNpc3RpbmcgbGV0cyBjaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIE9iamVjdCB0aGF0IGhhcyBJZGVudGl0eVxuICAgICAqIHNvIHdlIGNhbiBleHRyYWN0IGFuIElEIG90aGVyd2lzZSB1c2Ugb2JqZWN0IHRvIGNvbXBhcmUgYnkgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXRlbVRvS2V5IChpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBpc0VudGl0eShpdGVtKSA/ICg8RW50aXR5Pml0ZW0pLmlkZW50aXR5KCkgOiBpdGVtO1xuICAgIH1cblxuXG4gICAgc2V0RXhwYW5zaW9uUGF0aCAoaXRlbXM6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25QYXRoID0gaXRlbXM7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgobm9kZTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKG5vZGUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkIChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvcikgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxPdXRsaW5lTm9kZT5pdGVtKS5pc0V4cGFuZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cGFuc2lvblN0YXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRXhwYW5kZWRBbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbnNpb25TdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthbmltYXRlLCBBbmltYXRpb25CdWlsZGVyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXJ9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBJZGVudGl0eSwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4vb3V0bGluZS1zdGF0ZSc7XG5cblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSByZXByZXNlbnQgY29uY3JldGUgdHJlZSBzdHJ1Y3R1cmUgZm9yIHRoZSBvdXRsaW5lIHRyZWUgbW9kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE91dGxpbmVOb2RlIGV4dGVuZHMgSWRlbnRpdHlcbntcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgcGFyZW50OiBPdXRsaW5lTm9kZTtcblxuICAgIC8qKlxuICAgICAqIE5vZGUncyBjaGlsZHJlbi4gRXZlbiBpdHMgYSBmaWVsZCBpdCBjYW4gYmUgaW1wbGVtZW50ZWQgbGF6aWx5IHVzaW5nIGdldHRlciB3aGVyZSBhIHRhcmdldFxuICAgICAqIG9iamVjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhpcyBhcyBhIHB1YmxpYyBmaWVsZCBidXQgYSBnZXR0ZXIgd2l0aCBjb250cm9sIG92ZXIgdGhlXG4gICAgICogcmV0cmlldmVkIGxpc3RcbiAgICAgKi9cbiAgICBjaGlsZHJlbjogT3V0bGluZU5vZGVbXTtcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBzdGF0ZXMgZm9yIG91dGxpbmUgTm9kZVxuICAgICAqXG4gICAgICogaXNFeHBhbmRlZDogYm9vbGVhbjs9IG1vdmluZyBvdXQgYXMgdGhpcyBpcyBtYW5hZ2VkIGJ5IGV4cGFuc2lvbnN0YXRlLlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQ6IGJvb2xlYW47XG4gICAgaXNTZWxlY3RlZDogYm9vbGVhbjtcbiAgICBpc01hdGNoPzogYm9vbGVhbjtcbiAgICByZWFkb25seT86IGJvb2xlYW47XG4gICAgdHlwZT86IHN0cmluZztcbiAgICBkcmFnZ2FibGU/OiBib29sZWFuO1xuICAgIGRyb3BwYWJsZT86IGJvb2xlYW47XG4gICAgdmlzaWJsZT86IGJvb2xlYW47XG5cbn1cblxuXG4vKipcbiAqXG4gKiBDaGVja3MgdHlwZSBmb3IgT3V0bGluZU5vZGVcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc091dGxpbmVOb2RlKG5vZGU6IGFueSk6IG5vZGUgaXMgT3V0bGluZU5vZGVcbntcbiAgICByZXR1cm4gaXNQcmVzZW50KG5vZGUpICYmIGlzUHJlc2VudCgoPE91dGxpbmVOb2RlPm5vZGUpKVxuICAgICAgICAmJiBpc1ByZXNlbnQoKDxPdXRsaW5lTm9kZT5ub2RlKS5wYXJlbnQpXG4gICAgICAgICYmIGlzUHJlc2VudCgoPE91dGxpbmVOb2RlPm5vZGUpLmNoaWxkcmVuKTtcbn1cblxuXG4vKipcbiAqIEN1cnJlbnRseSBvdXRsaW5lIHN1cHBvcnRzIG9ubHkgdHdvIG1vZGVzIGZyZWUsIHdoZXJlIGFwcGxpY2F0aW9uIGlzIHJlc3BvbnNpYmxlIHRvIHJldHJpZXZlXG4gKiBjaGlsZHJlbiBmb3IgZWFjaCBub2RlIGFuZCB0cmVlIHdpdGggYWJvdmUgT3V0bGluZU5vZGUgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCB0eXBlIE1vZGVsRm9ybWF0ID0gJ2ZyZWUnIHwgJ3RyZWUnO1xuXG5cbi8qKlxuICpcbiAqIE91dGxpbmVGb3JDb21wb25lbnQgaXMgbGlrZSBuZ0ZvciwgYnV0IGZvciBoaWVyYXJjaGljYWwgKG91dGxpbmUvdHJlZSkgc3RydWN0dXJlcyAtLSBpLmUuIGluXG4gKiB0aG9zZSBjYXNlcyB3aGVyZSBhbiBpdGVtIG1heSBoYXZlIGNoaWxkcmVuLlxuICpcbiAqXG4gKiBJdCB1c2VzIG91dGxpbmUgYDxhdy1vdXRsaW5lLWNvbnRyb2w+YCB0byBwcm92aWRlIGV4cGFuZGluZyBmdW5jdGlvbmFsaXR5LCBpbmRlbnRhdGlvblxuICogYW5kIG90aGVyIHRoaW5ncy5cbiAqXG4gKlxuICogVGhpcyBjb21wb25lbnQgaGFzIG1pbmltYWwgc3R5bGluZyB0byBtYWtlIHN1cmUgaXQgY2FuIGJlIGNoYW5nZWQgZWFzaWx5LlxuICpcbiAqICMjIyBFeGFtcGxlIHJlbmRlcmluZyB0cmVlIHNlY3Rpb24sIHdoZXJlIGJhc2VkIG9uIHRoZSB0eXBlIHdlIGZvcm1hdCB0aGUgb3V0IHBsdXNcbiAqIGZvciB0aGUgbWFpbiByb290IHNlY3Rpb24gd2UgYWx3YXlzIHJlbmRlciBsaXR0bGUgcG9wdXAgbWVudS5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1vdXRsaW5lLWZvciBbbGlzdF09XCJsaXN0XCIgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCI+XG4gKlxuICogICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICpcbiAqICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXktc2VjdGlvblwiPlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3V0bGluZVwiPlxuICogICAgICAgICAgICAgICAgICAgPGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJpdGVtLnR5cGVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ3RleHQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXMtcGFyYWdyYWZcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nU3dpdGNoRGVmYXVsdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbHRlcnNcIiAqbmdJZj1cIml0ZW0udHlwZSA9PT0gJ3NlY3Rpb24nXCIgPlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZpbHRlciBJdGVtcydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8YXctbGlzdCBbbGlzdF09XCJmaWx0ZXJJdGVtc1wiIFtib3JkZXJsZXNzXT1cInRydWVcIj48L2F3LWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICA8L2Rpdj5cbiAqICAgICA8L25nLXRlbXBsYXRlPmBcbiAqICAgPC9hdy1vdXRsaW5lLWZvcj5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogV2UgY2FuIHVzZSBpdCBhbHNvIGluIGVtYmVkZGVkIG1vZGUgd2hlcmUgd2UgdXNlIHRoZSBgYXdPdXRsaW5lRm9yYCBkaXJlY3RpdmVcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYGBcbiAqICA8dGFibGUgIGNsYXNzPVwidHJlZS10YWJsZVwiID5cbiAqICAgICAgPHRoZWFkPlxuICogICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cbiAqICAgICAgICAgICAgICA8dGg+VHlwZTwvdGg+XG4gKiAgICAgICAgICA8L3RyPlxuICogICAgICA8L3RoZWFkPlxuICogICAgICA8dGJvZHkgI29vbzIgYXdPdXRsaW5lRm9yIFtsaXN0XT1cImxpc3RcIlxuICogICAgICAgICAgICAgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCJcbiAqICAgICAgICAgICAgIGNsYXNzPVwib3V0bGluZS10YWJsZVwiXG4gKiAgICAgID5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIml0ZW0tbmFtZSBvdXRsaW5lLWFuaW1hdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgPGRpdj48YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD48L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiaXRlbS10eXBlIG91dGxpbmUtYW5pbWF0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pnt7aXRlbS50eXBlfX08L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICA8L3RyPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC90Ym9keT5cbiAqICA8L3RhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqIEkgd2FzIHRoaW5raW5nIG1heWJlIGZvciBmaXJzdCB0aW1lIHdlIGRvbid0IG5lZWQgdGhlIHNhbWUgYW5pbWF0aW9uIGxpa2UgZXhwYW5kaW5nIGFuZFxuICogY29sbGFwc2luZy4gTWF5YmUgd2UgbmVlZCBmYWRlLWluLiBJbiBzdWNoIGNhc2UgSSB3b3VsZCBwcm9iYWJseSBhcHBseSBAc2VjdGlvbiBhbmltIG9ubHlcbiAqIG9uIGl0ZW1zIHdoZXJlIGxldmVsID4gMCAoaW4gdGhlIHRlbXBsYXRlIEkga2VlcCBsZXZlbHMpIGFuZCBpZiBsZXZlbCA9PSAwIHRoZW4gSSB3b3VsZFxuICogZXhlY3V0ZSB0aGUgc2FtZSByZW5kZXJpbmcganVzdCB3aXRob3V0IFtAc2VjdGlvbl1cbiAqXG4gKlxuICogVG9kbzogVGhpbmsgYWJvdXQgaG93IHRvIGRvIGFuaW1hdGlvbiBmb3IgdGhlIHRhYmxlIGNhc2UuIE11c3QgYWxzbyB3cml0ZSB1bml0ZXN0IC0gZHVlIHRvXG4gKiBBcmliYUxpdmUgYWdncmVzc2l2ZSBzY2hlZHVsZSB3ZSBhcmUgc2tpcHBpbmcgdGhlbSBmb3Igbm93XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtZm9yLCBbYXdPdXRsaW5lRm9yXScsXG4gICAgdGVtcGxhdGVVcmw6ICdvdXRsaW5lLWZvci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ291dGxpbmUtZm9yLmNvbXBvbmVudC5zY3NzJ10sXG5cbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ3NlY3Rpb24nLCBbXG4gICAgICAgICAgICBzdGF0ZSgnKicsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnKicsXG4gICAgICAgICAgICAgICAgJ29wYWNpdHknOiAnMSdcblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgc3RhdGUoJ3ZvaWQnLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcwJyxcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6ICcwJyxcbiAgICAgICAgICAgICAgICAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nXG5cbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIGFuaW1hdGUoJzIwMG1zIGVhc2Utb3V0JykpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgYW5pbWF0ZSgnMjAwbXMgZWFzZS1pbicpKVxuICAgICAgICBdKSxcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE91dGxpbmVGb3JDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGl0ZW1zIHRoYXQgbmVlZHMgdG8gYmUgcmVuZGVyZWQuIEl0IGRvZXMgbm90IGhhdmUgdG8gaW4gaGllcmFyY2hpY2FsIG9yZGVyIG9yIHdlXG4gICAgICogbGVhdmUgaXQgdXAgdG8gdGhlIGFwcGxpY2F0aW9uIHRvIGRlY2lkZSBhYm91dCB0aGUgc3RydWN0dXJlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdD86IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgY29tcG9uZW50IG5vdCB0byByZW5kZXIgZXhwYW5zaW9uIGNvbnRyb2wsIGluIHN1Y2ggY2FzZSB3ZSBleHBhbmRBbGwgYXMgYVxuICAgICAqIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0V4cGFuc2lvbkNvbnRyb2w6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIG1ldGhvZCBwcm92aWRlZCBieSBhcHBsaWNhdGlvbiB0byByZXRyaWV2ZSBsaXN0IG9mIGNoaWxkcmVuIGZvciBjdXJyZW50IGl0ZW0uIElmXG4gICAgICogY2hpbGRyZW4gaXMgdW5kZWZpbmVkIHRoZW4sIGRlZmF1bHQgJ2NoaWxkcmVuJyBmaWVsZCBpcyB1c2VkIDxjdXJyZW50SXRlbT4uY2hpbGRyZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNoaWxkcmVuOiAodmFsdWU6IGFueSkgPT4gYW55W107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE9wdGlvbiB0byBjb25kaXRpb25hbGx5IHJlbmRlciBvbmx5IGl0ZW1zIHRoYXQgYXJlIHNhdGlzZnlpbmcgZmlsdGVyIGNvbmRpdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmaWx0ZXJPdXQ6ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbGwgdHJlZSBub2Rlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQWxsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqICBNYW5hZ2VzIHRoZSBzdGF0ZSBmb3IgdGhlIE91dGxpbmUgY29tcG9uZW50LiBMYXRlciBvbiB3ZSBjYW4gcHJvdmlkZSBlYXNpZXIgd2UgaG93IHRvXG4gICAgICogIGluaXRpYWxpemUgYW5kIHNldCBzZWxlY3Rpb25QYXRocyBhbmQgc2VsZWN0aW9uU3RhdGVzIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0YXRlOiBPdXRsaW5lU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldCBpbmRlbnRhdGlvbiBzaXplIHRvIGJlIHVzZWQgZm9yIGVhY2ggbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyID0gMjU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgdGVtcGxhdGUgaXMgb3V0c2lkZSBvZiB0aGUgb3V0bGluZUZvclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXh0ZXJuYWxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGN1cnJlbnQgb2JqZWN0IHVzaW5nIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0OiBhbnk7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElkZW50aWZpZXMgY3VycmVudCBtb2RlbCBtb2RlLlxuICAgICAqXG4gICAgICogV2UgcmVjb2duaXplIHR3byBtb2RlczpcbiAgICAgKlxuICAgICAqIEZyZWUgLSBBcHBsaWNhdGlvbiBuZWVkcyB0byBpbXBsZW1lbnQgYSBjaGlsZHJlbiBtZXRob2QgdG8gcmV0cmlldmUgYSBsaXN0IG9mIGNoaWxkcmVuIGZvclxuICAgICAqIGVhY2ggbm9kZSBhbmQgZm9ybWF0IGlzIHByZXR0eSBtdWNoIHVwdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIFRyZWUgLSB0aGlzIGlzIG1vcmUgcmVzdHJpY3RpdmUgd2hlcmUgd2UgaGF2ZSBjb25jcmV0ZSBkYXRhIHN0cnVjdHVyZVxuICAgICAqIGludGVyZmFjZSB0aGF0IG5lZWRzIHRvIGJlIGZvbGxlZFxuICAgICAqXG4gICAgICogdG9kbzogaW5zdGVhZCBvZiBwYXNzaW5nIGZvcm1hdCBiaW5kaW5nIHRyeSB0byBsb29rIGludG8gdGhlIGxpc3QgdG8gc2VlIHdoYXQgdHlwZSBzb1xuICAgICAqIHdlIGRvbnQgbWFrZSBpdCBtYW5kYXRvcnlcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9ybWF0OiBNb2RlbEZvcm1hdCA9ICdmcmVlJztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIHRvIHB1c2ggY3VycmVudCBzZWxlY3RlZCBJdGVtIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25JdGVtU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IE91dGxpbmVDb250cm9sIHdoZW4gbm9kZSBpcyBleHBhbmRlZCBvciBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uRXhwYW5kQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcGxhdGUgdG8gdXNlIG9uIGFwcGxpY2F0aW9uIGxldmVsIHRvIHJlbmRlciBpbmRpdmlkdWFsIGl0ZW1zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnb3V0bGluZScpXG4gICAgY29udHJvbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAVmlld0NoaWxkKCdyZW5kZXJlZEl0ZW0nKVxuICAgIG91dGxpbmVJdGVtOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbHNcbiAgICAgKlxuICAgICAqIGN1cnJlbnRJdGVtIGFuZCBwYXJlbnRJdGVtIGFyZSB1c2VkIHRvIGNhcHR1cmUgY3VycmVudCBwcm9jZXNzZWQgaXRlbSBvZiBuZ0Zvci4gVGhpcyBpc1xuICAgICAqIHNldCBieSBkaXJlY3RpdmUgYEluaXROZXN0aW5nRGlyZWN0aXZlYFxuICAgICAqXG4gICAgICogYW5pbWF0aW9uSW5Qcm9ncmVzczogdXNlZCBieSBhbmltYXRpb24gZW5naW5lIHRvIG1ha2Ugc3VyZSB3ZSBkb250IGRvIGFueSBhY3Rpb25zIHdoaWxlXG4gICAgICogYW5pbWF0aW9uIGlzIGluIHRoZSBwcm9ncmVzc1xuICAgICAqXG4gICAgICogZW1iZWRkZWQ6IEluZGljYXRlcyB0aGF0IHdlIGFyZSB1c2luZyBkaXJlY3RpdmUgc28gaXQgd2lsbCBub3QgaGF2ZSBkZWZhdWx0IGNvbXBvbmVudFxuICAgICAqIHdyYXBwZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRJdGVtOiBhbnk7XG4gICAgcGFyZW50SXRlbTogYW55O1xuICAgIGFuaW1hdGlvbkluUHJvZ3Jlc3M6IGJvb2xlYW47XG4gICAgZW1iZWRkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZsYWcgdGhhdCB0ZWxscyB1cyB0aGF0IGNvbXBvbmVudCBpcyBmdWxseSByZW5kZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgdmlld0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBidWlsZGVyOiBBbmltYXRpb25CdWlsZGVyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IE91dGxpbmVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub3V0bGluZUZvciA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5leHBhbmRBbGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0V4cGFuc2lvbkNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuaXNFeHBhbmRlZEFsbCA9IHRoaXMuZXhwYW5kQWxsO1xuXG4gICAgICAgIC8vIGluIGNhc2Ugd2Ugd2FudCB0byByZW5kZXIgY29udGVudCBvZiB0cmVlIG91dHNpZGUgb2Ygb3V0bGluZUZvclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZXh0ZXJuYWxUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFRlbXBsYXRlID0gdGhpcy5leHRlcm5hbFRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWJlZGRlZCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXdvdXRsaW5lZm9yJyk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgfVxuXG4gICAgaXNUcmVlTW9kZWxGb3JtYXQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0ID09PSAndHJlZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0ZW1wbGF0ZSBhbmQgT3V0bGluZUNvbnRyb2wgdG8gaWRlbnRpZnkgd2hpY2ggaXRlbSBpcyBleHBhbmRlZCBhbmQgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkKGl0ZW06IGFueSwgY3VycmVudExldmVsOiBudW1iZXIgPSAtMSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPT09IDAgJiYgdGhpcy5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBvdmVycmlkZS9yZXNldCBmb3Igcm9vdCBub2Rlc1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgICAgICg8T3V0bGluZU5vZGU+aXRlbSkuaXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2luY2Ugd2UgaGF2ZSBjdXJyZW50bHkgdHdvIHdheXMgaG93IHRvIHBhc3MgY2hpbGRyZW4gaXRlbXMgd2UgbmVlZCBoYXZlIHRoaXMgbWV0aG9kIHRvXG4gICAgICogdW5pZnkgdGhlIHdheSBob3cgd2UgYWNjZXNzIGl0LiBJZiB3ZSBwYXNzIGBjaGlsZHJlbmAgYmluZGluZyB3ZSB1c2UgdGhpcyBpbnN0ZWFkLCBvdGhlcndpc2VcbiAgICAgKiB3ZSBleHBlY3QgY3VycmVudCBvYmplY3QgdG8gaGF2ZSBgY2hpbGRyZW5gIGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGlsZHJlbkZvckl0ZW0oaXRlbTogYW55KTogYW55W11cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoPE91dGxpbmVOb2RlPml0ZW0pLmNoaWxkcmVuIHx8IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2hpbGRyZW4oaXRlbSkgPyB0aGlzLmRvR2V0Q2hpbGRyZW4oaXRlbSkgOiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBpdGVtIGhhcyBhIGNoaWxkcmVuIGFuZCBuZWVkcyB0byBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgaGFzQ2hpbGRyZW4oaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gKDxPdXRsaW5lTm9kZT5pdGVtKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc0JsYW5rKHRoaXMuY2hpbGRyZW4pICYmIGlzQmxhbmsoaXRlbS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ01pc3NpbmcgW2NoaWxkcmVuXSBtZXRob2QgYmluZGluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9HZXRDaGlsZHJlbihpdGVtKS5sZW5ndGggPiAwO1xuXG4gICAgfVxuXG4gICAgZG9HZXRDaGlsZHJlbihpdGVtOiBhbnkpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYXBwbHkodGhpcy5jb250ZXh0LCBbaXRlbV0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFVzZXMgdGhlIGBPdXRsaW5lU3RhdGVgIHRvIHRvZ2dsZSBzdGF0ZSBvZiBjdXJyZW50IHNlbGVjdGlvblBhdGguIFRoZSBgc2VsZWN0aW9uUGF0aGAgaXNcbiAgICAgKiAgcHV0IHRvZ2V0aGVyIGluc2lkZSBgT3V0bGluZUNvbnRyb2xgIHdoZXJlIHdlIGl0ZXJhdGUgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QgYW5kIGFkZFxuICAgICAqICBlYWNoIGl0ZW0gdG8gdGhlIGBjdXJyZW50UGF0aGAgYXJyYXkuIFRoaXMgd2F5IHdlIGNvbGxlY3QgbGlzdCBvZiBpdGVtIHJlcHJlc2VudGluZyBjdXJyZW50XG4gICAgICogIGN1cnJlbnQgZXhwYW5zaW9uUGF0aC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlRXhwYW5zaW9uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGJhY2t1cCBwcm9jZWR1cmUgaW4gY2FzZSBvbkFuaW1hdGlvbkRvbmUgZmFpbHNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25JblByb2dyZXNzKSB7IC8vIGNoYW5nZSBvbmx5IGlmIGl0cyBmYWlsc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtID0gTGlzdFdyYXBwZXIubGFzdCh0aGlzLnN0YXRlLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS50b2dnbGVFeHBhbnNpb24odGhpcy5zdGF0ZS5jdXJyZW50UGF0aCwgdGhpcy5jaGlsZHJlbkZvckl0ZW0oY3VycmVudEl0ZW0pKTtcblxuICAgICAgICBpZiAodGhpcy5lbWJlZGRlZCkge1xuICAgICAgICAgICAgLy8gdGhpcy5hbmltYXRlRW1iZWRkZWRJdGVtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgYW5pbS4gY2FsbGJhY2sgdGhhdCBzZXRzIGJhY2sgdGhlIGZsYWcgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHRyaWdnZXIgYW5pbWF0aW9uc1xuICAgICAqIHdoZW4gb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAqXG4gICAgICovXG4gICAgb25BbmltYXRpb25Eb25lKGV2ZW50OiBFdmVudClcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgaW5kZW50YXRpb24gdXNlZCB0byBzaGlmdCB0aGUgbmVzdGVkIHNlY3Rpb24gdG8gdGhlIHJpZ2h0IG9yIGxhdGVyIG9uIHRvIHRoZVxuICAgICAqIGxlZnQgd2hlbiBSVEwgaXMgc3VwcG9ydGVkXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluZGVudGF0aW9uKGN1cnJlbnRMZXZlbDogbnVtYmVyKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgY3VycmVudExldmVsID4gMCkge1xuICAgICAgICAgICAgY3VycmVudExldmVsIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGN1cnJlbnRMZXZlbCA9PT0gMCAmJiB0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSlcbiAgICAgICAgICAgID8gMCA6ICh0aGlzLmluZGVudGF0aW9uUGVyTGV2ZWwgKiBjdXJyZW50TGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdCBhbGwgcm93cyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LCB0aGVyZSBjYW4gYmUgYSBjYXNlIHdoZXJlIHlvdSBkb250IHdhbnQgdG8gcmVuZGVyIGl0ZW1zXG4gICAgICogdXNpbmcgb3V0bGluZS4gZS5nLiBEYXRhdGFibGUgd2l0aCBkZXRhaWwgcm93LlxuICAgICAqL1xuICAgIGlzVmlzaWJsZShpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmlsdGVyT3V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmZpbHRlck91dChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIFNpbmNlIHdlIGNhbiBub3QgZGlyZWN0bHkgc2V0IGAqbmdUZW1wbGF0ZU91dGxldGAgY29udGV4dCB2YXJpYWJsZXMgdG8gdGhlIHR5cGVzY3JpcHQgY2xhc3Mgd2VcbiAqIHVzZSB0aGlzIGRpcmVjdGl2ZSB0byBkbyB0aGUgSm9iXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpbml0TmVzdGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIEluaXROZXN0aW5nRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICBASW5wdXQoKVxuICAgIHNldExldmVsOiBudW1iZXI7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0Q3VycnJlbnRJdGVtOiBhbnk7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0UGFyZW50SXRlbTogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG91dGxpbmU6IE91dGxpbmVGb3JDb21wb25lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNldExldmVsKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lLnN0YXRlLmN1cnJlbnRMZXZlbCA9IHRoaXMuc2V0TGV2ZWw7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZXRDdXJycmVudEl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuY3VycmVudEl0ZW0gPSB0aGlzLnNldEN1cnJyZW50SXRlbTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZS5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRsaW5lLmN1cnJlbnRJdGVtWyckJHBhcmVudEl0ZW0nXVxuICAgICAgICAgICAgICAgICAgICA9ICg8T3V0bGluZU5vZGU+dGhpcy5zZXRDdXJycmVudEl0ZW0pLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vdXRsaW5lLmlzVHJlZU1vZGVsRm9ybWF0KCkgJiYgaXNQcmVzZW50KHRoaXMuc2V0UGFyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbVsnJCRwYXJlbnRJdGVtJ10gPSB0aGlzLnNldFBhcmVudEl0ZW07XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZUZvckNvbXBvbmVudH0gZnJvbSAnLi4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lLXN0YXRlJztcblxuXG4vKipcbiAqIE91dGxpbmVDb250cm9sQ29tcG9uZW50IHJlbmRlcnMgdGhlIGluZGVudGF0aW9uLCBhcnJvdywgYW5kIHRleHQgZm9yIGEgbm9kZSBpbiBhbiBvdXRsaW5lLlxuICogSXQgc2hvdWxkIGJlIHVzZWQgZWl0aGVyIGluIHRoZSBib2R5IG9mIGFuIE91dGxpbmVGb3IgY29tcG9uZW50LCBvciBpbnNpZGUgZGF0YXRhYmxlXG4gKlxuICpcbiAqICMjVXNhZ2UgaW5zaWRlIGJvZHk6XG4gKlxuICogIEhlcmUgeW91IGNhbiBzZWUgdGhhdCB3ZSBuZWVkIHRvIHdyYXAgb3V0IGNvbnRlbnQgaW5zaWRlIG5nLXRlbXBsYXRlIHdoaWNoIHdpbGwgcHVzaCB1c1xuICogIGdpdmUgdXMgY3VycmVudCBpdGVtIGl0ZW0gYW5kIHRoZW4gd2UgY2FuIHBsYWNlIE91dGxpbmVDb250cm9sQ29tcG9uZW50IHRvIGNvbnRyb2xcbiAqICB0aGUgdHJlZS5cbiAqXG4gKiBgYGBcbiAqICA8YXctb3V0bGluZS1mb3IyICNvb28gW2xpc3RdPVwibGlzdFwiIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiPlxuICpcbiAqICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICogICAgICAgICAgPGRpdiBjbGFzcz1cIm15LXNlY3Rpb25cIj5cbiAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3V0bGluZVwiPlxuICogICAgICAgICAgICAgICAgICA8YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgPC9kaXY+KlxuICogICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9hdy1vdXRsaW5lLWZvcjI+XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vdXRsaW5lLWNvbnRyb2wnLFxuICAgIHRlbXBsYXRlVXJsOiAnb3V0bGluZS1jb250cm9sLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnb3V0bGluZS1jb250cm9sLmNvbXBvbmVudC5zY3NzJ10sXG59KVxuZXhwb3J0IGNsYXNzIE91dGxpbmVDb250cm9sQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgSWYgVFJVRSBpdCBjaGFuZ2VzIHRoZSBiZWhhdmlvciBvZiB0aGUgb3V0bGluZSBub2RlIHRleHQgd2hpY2ggY2xpY2sgaXMgdHJpZ2dlcmVkXG4gICAgICogIGl0IHNlbGVjdHMgdGhlIGl0ZW0gYW5kIGJyb2FkY2FzdCB0aGUgYG9uSXRlbVNlbGVjdGVkYCBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGxvd1NlbGVjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBhbGxvd0VkaXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgYWN0aW9uIHdoZW4gb3V0bGluZSBpdGVtIGlzIGV4cGFuZGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBpdGVtIHVzZWQgZm9yIHRoaXMgYE91dGxpbmVDb250cm9sYFxuICAgICAqXG4gICAgICovXG4gICAgaXRlbTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBpbmRlbnRhdGlvbiB1c2VkIHRvIHNoaWZ0IHRoZSBuZXN0ZWQgc2VjdGlvbiB0byB0aGUgbGVmdC4gVGhpcyBpcyB1c2VkIGZvclxuICAgICAqIGVtYmVkZGVkIG1vZGUgZS5nLiB0cmVlIHRhYmxlIHdoZXJlIHdlIGNhbm5vdCBpbmRlbnQgcGFyZW50XG4gICAgICovXG4gICAgaW5kZW50YXRpb246IG51bWJlcjtcblxuXG4gICAgaXNSb290SXRlbTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBvdXRsaW5lU3RhdGU6IE91dGxpbmVTdGF0ZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZUNvbnRyb2xDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByaXZhdGUgcGFyZW50Q29udHJvbDogT3V0bGluZUNvbnRyb2xDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVGb3JDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHB1YmxpYyBvdXRsaW5lRm9yOiBPdXRsaW5lRm9yQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5wcmVwYXJlQ29udHJvbCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXZSBkb250IHNob3cgZXhwYW5zaW9uIGljb25zIHdoZW4gdGhlcmUgbm8gY2hpbGRyZW5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0V4cGFuc2lvbkNvbnRyb2woKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5oYXNDaGlsZHJlbih0aGlzLml0ZW0pICYmIHRoaXMub3V0bGluZUZvci5zaG93RXhwYW5zaW9uQ29udHJvbDtcbiAgICB9XG5cblxuICAgIGlzU2VsZWN0ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5zdGF0ZS5zZWxlY3RlZEl0ZW0gPT09IHRoaXMuaXRlbTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVTdHlsZUNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V4cGFuc2lvbkNvbnRyb2woKSB8fFxuICAgICAgICAgICAgKHRoaXMub3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgaXNCbGFuayh0aGlzLml0ZW0uJCRwYXJlbnRJdGVtKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaXNFeHBhbmRlZCh0aGlzLml0ZW0pID8gJ2ljb24tc2xpbS1hcnJvdy1kb3duJ1xuICAgICAgICAgICAgICAgIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLmlzRXhwYW5kZWQodGhpcy5pdGVtKVxuICAgICAgICAgICAgICAgID8gJ2ljb24tc2xpbS1hcnJvdy1yaWdodCBvdXRsaW5lLWljb24tZXhwYW5kZWQnIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYW5kIGV4cGFuZHMgY3VycmVudCBub2RlXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb24oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50UGF0aCA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudFBhdGggPSB0aGlzLml0ZW07XG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50UGF0aC51bnNoaWZ0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gY3VycmVudFBhdGguJCRwYXJlbnRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnRvZ2dsZUV4cGFuc2lvbigpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGl0ZW06IHRoaXMuaXRlbSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuaXNFeHBhbmRlZCh0aGlzLml0ZW0pXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQocGF5bG9hZCk7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5vbkV4cGFuZENoYW5nZS5lbWl0KHBheWxvYWQpO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHNlbGVjdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuc2VsZWN0ZWRJdGVtID0gdGhpcy5pdGVtO1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iub25JdGVtU2VsZWN0ZWQuZW1pdCh0aGlzLml0ZW0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJlcGFyZUNvbnRyb2woKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5vdXRsaW5lRm9yKSAmJiBpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IgPSB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpLCAnTWlzc2luZyBvdXRsaW5lRm9yIGNvbXBvbmVudCcpO1xuICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudExldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9ICh0aGlzLm91dGxpbmVGb3IuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW0gPSB0aGlzLm91dGxpbmVGb3IuY3VycmVudEl0ZW07XG4gICAgICAgIHRoaXMuaXNSb290SXRlbSA9IGlzQmxhbmsodGhpcy5pdGVtLiQkcGFyZW50SXRlbSk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0luaXROZXN0aW5nRGlyZWN0aXZlLCBPdXRsaW5lRm9yQ29tcG9uZW50fSBmcm9tICcuL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge091dGxpbmVDb250cm9sQ29tcG9uZW50fSBmcm9tICcuL291dGxpbmUtY29udHJvbC9vdXRsaW5lLWNvbnRyb2wuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT3V0bGluZUZvckNvbXBvbmVudCxcbiAgICAgICAgT3V0bGluZUNvbnRyb2xDb21wb25lbnQsXG4gICAgICAgIEluaXROZXN0aW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPdXRsaW5lRm9yQ29tcG9uZW50LFxuICAgICAgICBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdPdXRsaW5lRm9yTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cblxuLyoqXG4gKiBSZW5kZXJzIGh0bWwgdGV4dCBhcmVhIGNvbXBvbmVudFxuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnbXlOb3RlJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogJzxhdy10ZXh0LWFyZWEgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbYXV0b1Jlc2l6ZV09XCJhdXRvUmVzaXplXCIgPlxuICogICAgICAgICAgICAgIDwvYXctdGV4dC1hcmVhPidcbiAqICAgICAgfSlcbiAqICAgICAgZXhwb3J0IGNsYXNzIE15Tm90ZUNvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSByZWFsbHkgbG9uZyB0ZXh0JztcbiAqICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlO1xuICogICAgICB9XG4gKlxuICogYGBgXG4gKiAgTm90ZTogaWYgeW91IGFyZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgRm9ybVRhYmxlIHBsZWFzZSBwcm92aWRlIHlvdXIgb3duIEZvcm1Hcm91cFxuICovXG5cbmV4cG9ydCBjb25zdCBURVhUQVJFQV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctdGV4dC1hcmVhJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RleHQtYXJlYS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3RleHQtYXJlYS5jb21wb25lbnQuc2NzcyddLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVGV4dEFyZWFDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHN0b3JlIGFuZCByZWFkIHVzZXIgaW5wdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVmaWZpZXMgdmlzaWJsZSBudW1iZXIgb2YgbGluZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd3M6IG51bWJlciA9IDI7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB2aXNpYmxlIHdpZHRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2x1bW5zOiBudW1iZXIgPSAyMDtcblxuXG4gICAgLyoqXG4gICAgICogd2hlbiB0aGlzIG9wdGlvbiBpcyBUUlVFIGFuZCB1c2VyIHN0YXJ0cyB0eXBpbmcgaXQgd2lsbCBtYXhpbWl6ZSB0ZXh0YXJlYSdzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGF1dG9SZXNpemU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwge29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5wdXRUZXh0YXJlYU1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7VGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4vdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXVGV4dEFyZWFNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBQYWdlLU5vdGlmaWNhdGlvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGEgbm90aWZpY2F0aW9uIHN5c3RlbSBmb3IgdGhlIHVzZXIgcmVnYXJkaW5nXG4gKiB0aGUgY3VycmVudCBvYmplY3QgaGUncyB3b3JraW5nIG9uLiBUeXBpY2FsIG5vdGlmaWNhdGlvbiBhcmU6XG4gKiAgICAgIFN1Y2Nlc3MgLSBzYXZlZC5cbiAqICAgICAgV2FybmluZyAtIFNvdXJjaW5nIHJlcXVlc3QgcmVxdWlyZXMgMyBzdXBwbGllcnMuXG4gKiAgICAgIEVycm9yICAgLSBjYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXIsIGNoZWNrIGludGVybmV0IGNvbm5lY3Rpb24uXG4gKlxuICpcbiAqXG4gKiBVc2FnZSAxOiAgQXMgcGFydCBvZiBwYWdlIHdyYXBwZXIuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdNeVBhZ2UnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8YXctb2JqZWN0LXBhZ2Utd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwiTXlQYWdlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwiTXlUeXBlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKiAgICAgICAgICAgICBwYWdlIGNvbnRlbnRcbiAqICAgICAgICAgIGBcbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2VyLXdyYXBwZXI+XG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBwYWdlTm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIFVzYWdlIDI6IGRpcmVjdGx5IGludG8gdGhlIHBhZ2UuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxhdy1oZWFkZXI+PC9hdy1oZWFkZXI+XG4gKiAgICAgICAgUGFnZSBIZWFkZXJcbiAqXG4gKiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImhhc05vdGlmaWNhdGlvbnMoKVwiPlxuICogICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdS1ub3BhZGRpbmdcIj5cbiAqICAgICAgICAgICAgPGF3LXBhZ2Utbm90aWZpY2F0aW9uIFtub3RpZmljYXRpb25dPVwibm90aWZpY2F0aW9uXCI+PC9hdy1wYWdlLW5vdGlmaWNhdGlvbj5cbiAqICAgICAgICAgIDwvZGl2PlxuICogICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICA8YXctZm9vdGVyPjwvYXctZm9vdGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgbm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuaW5nXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLW5vdGlmaWNhdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6ICdwYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEFueSBpbmZvLCBFcnJvciwgb3IgV2FybiBmb3IgdGhpcyBwYWdlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBub3RpZmljYXRpb25DbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgbm90aWZpY2F0aW9uLSR7dGhpcy5ub3RpZmljYXRpb24udHlwZX1gO1xuICAgIH1cblxuICAgIG5vdGlmaWNhdGlvbkljb24oKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYGFyaWJhLWljb24gaWNvbi0ke3RoaXMubm90aWZpY2F0aW9uLnR5cGV9YDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBQYWdlIE5vdGlmaWNhdGlvbiBhcmUgbWVzc2FnZXMgZm9yIHRoaXMgcGFnZSBvbmx5LiBJdCBkaXNwbGF5cyBpbiB0aGUgY2VudGVyIG9mIHRoZSBwYWdlXG4gKiByaWdodCB1bmRlciBwYWdlIHRpdGxlLiBUeXBpY2FsIHBhZ2Ugbm90aWZpY2F0aW9ucyBhcmUgJ3NhdmUgY29uZmlybWF0aW9uJyxcbiAqICdlcnJvciBkdXJpbmcgc3VibWl0Jywgd2FybmluZ3Mgb2YgZmllbGQgcmVxdWlyZW1lbnRzLCBldGMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlTm90aWZpY2F0aW9uXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGU6IFBhZ2VOb3RpZmljYXRpb25UeXBlLCBwdWJsaWMgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgZGVzY3JpcHRpb246IHN0cmluZywgcHVibGljIGNvbnRlbnRUbXBsPzogVGVtcGxhdGVSZWY8YW55PilcbiAgICB7XG4gICAgfVxuXG4gICAgaGFzVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRlbnRUbXBsKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnLCB0aXRsZTogJyArIHRoaXMudGl0bGUgKyAnLCBkZXNjcmlwdGlvbjogICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZU5vdGlmaWNhdGlvblR5cGUgPSAnc3VjY2VzcycgfCAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50fSBmcm9tICcuL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcblxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYWdlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VJbml0aWFsaXplZFxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0aXRsZTogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZUluaXRpYWxpemllZCh0aXRsZTogJHt0aGlzLnRpdGxlfSlgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgcGFnZSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGFnZURlc3Ryb3llZFxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0aXRsZTogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZURlc3Ryb3llZCh0aXRsZTogJHt0aGlzLnRpdGxlfSlgO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZUV2ZW50ID0gUGFnZUluaXRpYWxpemVkIHwgUGFnZURlc3Ryb3llZDtcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1BhZ2VEZXN0cm95ZWQsIFBhZ2VFdmVudCwgUGFnZUluaXRpYWxpemVkfSBmcm9tICcuL3BhZ2UtZXZlbnRzJztcblxuLyoqXG4gKiBQYWdlIExpZmVDeWNsZSBTZXJ2aWNlIG1vbml0b3JzIGFsbCBwYWdlIGluaXRpYWxpemF0aW9uIGFuZCBkZXN0cnVjdGlvbnMuXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gaGVscCB0aGUgYXBwbGljYXRpb24gbW9uaXRvciBwYWdlIGxpZmVjeWNsZSwgc3Vic2NyaWJlXG4gKiB0byBsaWZlY3ljbGUgZXZlbnRzIGFuZCBleGVjdXRlIGFjdGlvbnMgc3VjaCBhcyB1c2VyIGFuYWx5dGljcy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAxLiAgSW5qZWN0IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlIGludG8geW91ciBjb25zdHJ1Y3RvclxuICpcbiAqICAgIGNvbnN0cnVjdG9yKHBhZ2VMaWZlY3ljbGU6UGFnZUxpZmVDeWNsZVNlcnZpY2UpIHtcbiAqICAgICAgICBwYWdlTGlmZWN5Y2xlLnBhZ2VFdmVudHMuc3Vic2NyaWJlKGV2ZW50OkV2ZW50ID0+IHtcbiAqICAgICAgICAgICAgaWYoZXZlbnQgaW5zdGFuY2VvZiBQYWdlSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgICAgICAgfVxuICogICAgICAgICAgICAvLyBQYWdlRGVzdHJveWVkXG4gKlxuICogICAgICAgIH0pO1xuICogICAgIH1cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlXG57XG5cbiAgICAvKipcbiAgICAgKiBQYWdlIGV2ZW50IHF1ZXVlIHdoZW4gYWxsIHBhZ2UgbGlmZWN5Y2xlIGV2ZW50czogaW5pdCwgZGVzdHJveSBhcmUgZW1pdHRlZC5cbiAgICAgKiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGVzZSBldmVudHMuXG4gICAgICovXG4gICAgcHVibGljIHBhZ2VFdmVudHM6IFN1YmplY3Q8UGFnZUV2ZW50PiA9IG5ldyBTdWJqZWN0PFBhZ2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhZ2UgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIHBhZ2VUaXRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhZ2VJbml0KHBhZ2VUaXRsZTogc3RyaW5nKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlRXZlbnRzLm5leHQobmV3IFBhZ2VJbml0aWFsaXplZChwYWdlVGl0bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHdoZW4gcGFnZSBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICAgKiBAcGFyYW0gdGl0bGVcbiAgICAgKi9cbiAgICBwdWJsaWMgb25QYWdlRGVzdHJveShwYWdlVGl0bGU6IHN0cmluZyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucGFnZUV2ZW50cy5uZXh0KG5ldyBQYWdlRGVzdHJveWVkKHBhZ2VUaXRsZSkpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlTGlmZUN5Y2xlU2VydmljZX0gZnJvbSAnLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IHBhZ2UgdHlwZXMgaW4gYW4gYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIFBhZ2VUeXBlIHtcbiAgICBJbml0LCAgICAgICAgIC8vIEluaXQgUGFnZSB0eXBlXG4gICAgTG9naW4sICAgICAgICAvLyBMb2dpbiBQYWdlXG4gICAgT2JqZWN0LCAgICAgICAvLyBPYmplY3QgZGV0YWlsIHBhZ2VcbiAgICBMaXN0LCAgICAgICAgIC8vIExpc3QgUGFnZVxuICAgIE1hc3RlckRldGFpbCwgLy8gTWFzdGVyRGV0YWlsXG4gICAgRGFzaGJvYXJkLCAgICAvLyBEYXNoYm9hcmQgcGFnZVxuICAgIE1vZGFsICAgICAgICAgLy8gTW9kYWwgcGFnZSwgaXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYmUgYSBwb3B1cCwgb3Igc3RhbmRhbG9uZSBwYWdlLlxufVxuXG4vKiogUGxhY2Vob2xkZXIgbm93LiBUaGUgRXJyb3IgTWFuYWdlciBoYW5kbGVzIGFsbCB0aGUgZXJyb3JzIG9uIHRoZSBwYWdlLlxuICogIEl0IGlzIGluaXRpYWxpemVkIGZvciBldmVyeSBwYWdlLiBQYWdlIGVycm9ycywgd2FybmluZywgaW5mbyBnb2VzIHRocm91Z2hcbiAqICB0aGUgZXJyb3IgTWFuYWdlciBhbmQgdGhlIHJlc3VsdCBtZXNzYWdlIGlzIGRpc3BsYXllZCBvbiB0aGUgcGFnZSBub3RpZmljYXRpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlclxue1xuXG59XG5cbi8qKlxuICogIFBhZ2Ugd3JhcHBlciBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHBhZ2VzLiBUaGUgaWRlYSBpcyB0aGF0IHRoZXJlIGFyZSBkaWZmZXJlbnQgcGFnZSB0eXBlc1xuICogIGluIGFuIEFwcGxpY2F0aW9uLiBBIExpc3QgUGFnZSByZW5kZXJzIGEgbGlzdCBvZiBvYmplY3RzLCBleDogY3VzdG9tZXJzLCByZXF1ZXN0cywgUE8uICBBbmRcbiAqICBhIG9iamVjdCBwYWdlIHdpbGwgcmVuZGVyIG9uZSBvYmplY3QgaW4gZGV0YWlsLlxuICpcbiAqICBUaGV5IHNoYXJlIGNvbW1vbiBhdHRyaWJ1dGVzIHN1Y2ggYXMgcGFnZSB0eXBlIGFuZCBwYWdlIGlkLlxuICpcbiAqICBBcmliYSBQYWdlIGhhdmUgYSBsaWZlIGN5Y2xlLiBXaGVuIHBhZ2Ugc3RhcnRzIHVwLCBpdCdzIGluaXRpYWxpemVkLiBBbmQgd2hlbiB0aGUgcGFnZSBpc1xuICogIGRlc3Ryb3llZCwgaXQnbGwgYmUgY29tcGxldGUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYWdlV3JhcHBlciBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBXaGF0IHR5cGUgb2YgcGFnZSB0aGlzIGlzLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhZ2VUeXBlOiBQYWdlVHlwZSA9IFBhZ2VUeXBlLkluaXQ7XG5cbiAgICAvKipcbiAgICAgKiBQYWdlIElkLiBVc2VkIHdoZW4gcGFnZXMgYXJlIHN0b3JlZCBpbiBtYXAuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEhhbmRsaW5nIGFsbCB0aGUgZXJyb3Igb24gYSBwYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBlcnJvck1hbmFnZXI6IEVycm9yTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRoYXQgdGhpcyBwYWdlIHdyYXBwZXIgaGFzIGJlZW4gd3JhcHBlZCBieSBhbm90aGVyIHBhZ2Ugd3JhcHBlci5cbiAgICAgKiBJbiB0aGlzIGNhc2UsIHdlIHdvdWxkbid0IGRpc3BsYXkgaGVhZGVyIGFuZCBmb290ZXIgYW5kIG90aGVyIHBhZ2Ugd3JhcHBlciBjb21wb25lbnRzXG4gICAgICovXG4gICAgYWxyZWFkeUluUGFnZVdyYXBwZXI6IGJvb2xlYW47XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwYWdlVHlwZTogUGFnZVR5cGUsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFnZUxpZmVjeWNsZVNlcnZpY2U6IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgdGhpcy5wYWdlVHlwZSA9IHBhZ2VUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCBzdWJjbGFzcyBuZWVkcyB0byBnZW5lcmF0ZWQgYSBwYWdlIGlkZW50aWZpZXIuXG4gICAgICogSXQgZm9sbG93cyB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAgICogICAgdHlwZV90aXRsZV9pZFxuICAgICAqXG4gICAgICogICAgUkZRX1NvdXJjaW5nUmVxdWVzdF8xMjNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZW5lcmF0ZVBhZ2VJZCgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJZCBmb3IgdGhpcyBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGdldElkKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuZ2VuZXJhdGVQYWdlSWQoKTtcbiAgICB9XG5cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudCwgUm91dGluZ1NlcnZpY2V9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTaWRlbmF2Q29tcG9uZW50fSBmcm9tICcuLi9zaWRlbmF2L3NpZGVuYXYuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIEhlYWRlciBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IgZm9yIGFuIEFyaWJhIHBhZ2UuXG4gKiBIZWFkZXIgaW5jbHVkZXMgYSBtZW51LCB1c2VyIHByb2ZpbGUsIGFuZCBhbGVydHMuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICA8YXctcGFnZS1oZWFkZXIgW3Nob3dCYWNrQWN0aW9uXT1cInRydWVcIiB1c2VyTmFtZT1cIkNoYWQgTm9sbFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttZW51SXRlbXNdPVwibWVudUl0ZW1zXCIgW25vdGlmaWNhdGlvbnNdPVwidXNlck5vdGlmaWNhdGlvbnNcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWNlbnRlclwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5hdmJhci1icmFuZFwiIHRhYmluZGV4PVwiMFwiIGhyZWY9XCIvXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwibmF2YmFyLWxvZ29cIiBzcmM9XCIuL2ltYWdlcy9TQVBfQXJpYmFfREIucG5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9XCJHbyB0byBob21lcGFnZVwiIGRhdGEtcGluLW5vcGluPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICA8L2F3LXBhZ2UtaGVhZGVyPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKiAgICAgIG1lbnVJdGVtczogUGFnZU1lbnVJdGVtW10gPSBbbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1ob21lJywgJ0hvbWUnLCAnL3BsYXkvJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWV4cGVuc2UtcmVwb3J0JywgJ1JlcG9ydHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLXNhbGVzLW9yZGVyJywgJ1B1cmNoYXNlIE9yZGVyJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWFjY291bnQnLCAnQWNjb3VudHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyldO1xuICpcbiAqICAgICB1c2VyTm90aWZpY2F0aW9uczogVXNlck5vdGlmaWNhdGlvbltdID0gW1xuICogICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tZXhwZW5zZS1yZXBvcnQnLCAnRXhwZW5zZSByZXBvcnQgRVhQNDUzIGhhcyBiZWVuIGFwcHJvdmVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpLFxuICogICAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1zYWxlcy1vcmRlcicsICdTYWxlcyBPcmRlciBTTzEyMzQgaGFzIGJlZW4gY3JlYXRlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKSxcbiAqICAgICAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1hY2NvdW50JywgJ1N1cHBsaWVyIGFjY291bnQgU0ExMjM0IGhhcyBiZWVuIHVwZGF0ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKVxuICogICAgICAgIF07XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1oZWFkZXInLFxuICAgIHRlbXBsYXRlVXJsOiAncGFnZS1oZWFkZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydwYWdlLWhlYWRlci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIG1lbnUgZW50cmllcy4gVGhlIHBhZ2UgbWVudSBpY29uIHdpbGwgb25seSBkaXNwbGF5IHdoZW4gdGhpcyBsaXN0IGlzIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1lbnVJdGVtczogUGFnZU1lbnVJdGVtW107XG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIHVzZXIgbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb25zOiBVc2VyTm90aWZpY2F0aW9uW107XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgdGhlIHVzZXIgbm90aWZpY2F0aW9uIGljb24gYmUgaGlkZGVuLiBEZWZhdWx0IGl0IHRvIHNob3cgdGhlIGljb24gZXZlblxuICAgICAqIGlmIHRoZXJlJ3Mgbm8gbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZU5vdGlmaWNhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGJhY2sgbGluayB0aGF0IG5hdmlnYXRlcyB1c2VyIHRvIHRoZSBwcmV2aW91cyBwYWdlIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dCYWNrQWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxvZ2dlZCBpbiB1c2VyIG5hbWUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VyTmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpZGVtZW51XG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnc2lkZW1lbnUnKVxuICAgIHNpZGVuYXY6IFNpZGVuYXZDb21wb25lbnQ7XG5cbiAgICBzaG93Tm90aWZpY2F0aW9uUGFuZWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcm91dGluZzogUm91dGluZ1NlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgYmFja0FjdGlvbigpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJvdXRpbmcuZ29CYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG8gaSBoYXZlIGFueSBtZW51IGl0ZW1zLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzTWVudUl0ZW1zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5tZW51SXRlbXMgJiYgdGhpcy5tZW51SXRlbXMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBzaWRlIG5hdmlnYXRpb24gbWVudS5cbiAgICAgKi9cbiAgICBzaG93SGlkZU1lbnUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaWRlbmF2LnRvZ2dsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvIEkgaGF2ZSBhbnkgbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc05vdGlmaWNhdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm5vdGlmaWNhdGlvbnMpICYmIHRoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZ2dsaW5nIHdoZWF0aGVyIG5vdGlmaWNhdGlvbiBwYW5lbCBpcyBkaXNwbGF5ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHRvZ2dsZU5vdGlmaWNhdGlvblBhbmVsKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvblBhbmVsID0gIXRoaXMuc2hvd05vdGlmaWNhdGlvblBhbmVsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYWdlTWVudUl0ZW0gcmVwcmVzZW50cyBhbiBpdGVtIGluIHRoZSBwYWdlIG1lbnUgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgUGFnZU1lbnVJdGVtXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGljb24gICAgLSBJY29uIG9mIHRoaXMgbWVudSBpdGVtLlxuICAgICAqIEBwYXJhbSBsYWJlbCAgIC0gbGFiZWwgb2YgdGhpcyBpdGVtLlxuICAgICAqIEBwYXJhbSBsaW5rICAgIC0gbGluayB0byB0aGUgZGVzdGluYXRpb24gd2hlbiB1c2VyIGNsaWNrcyBvbiBpdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvbjogc3RyaW5nLCBwdWJsaWMgbGFiZWw6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgbGluazogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZU1lbnVJdGVtOiAobGFiZWwsICR7dGhpcy5sYWJlbH0pYDtcbiAgICB9XG59XG5cbi8qKlxuICogbm90aWZpY2F0aW9uIGZvciB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlci5cbiAqIEV4OiAgUFIyMDQ5IGhhcyBiZWVuIGFwcHJvdmVkLlxuICogICAgICBPcmRlciBQTzUxOCByZWNlaXZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJOb3RpZmljYXRpb25cbntcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpY29uICAgLSBhbGVydCBub3RpZmljYXRpb24gaWNvblxuICAgICAqIEBwYXJhbSBsYWJlbCAgLSBhbGVydCBub3RpZmljYXRpb24gbGFiZWxcbiAgICAgKiBAcGFyYW0gbGluayAgIC0gbGlua1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpY29uOiBzdHJpbmcsIHB1YmxpYyBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBsaW5rOiBzdHJpbmcpXG4gICAge1xuXG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VVc2VyTm90aWZpY2F0aW9uOiAobGFiZWwsICR7dGhpcy5sYWJlbH0pYDtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogRm9vdGVyIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvci5cbiAqIFRoaXMgZm9vdGVyIGNvbXBvbmVudCBzZWxmIGNvbnRhaW5lZC5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgICAgICA8YXctcGFnZS1mb290ZXI+XG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWZvb3Rlci1sb2dvXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImltYWdlcy9hcmliYV9sb2dvX3doaXRlX2JrZ2QucG5nXCI+XG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXItdXNlci1pbmZvXCI+XG4gKiAgICAgICAgICAgICAgICAgICBDaGFkIE5vbGwgKGNub2xsKSBsYXN0IHZpc2l0IHt7bGFzdF92aXNpdGVkIHwgZGF0ZTonTU0vZGQveXl5eSBoOm1tYScgfX1cbiAgKiAgICAgICAgICAgICAgICAgICB8IEJ1eWVyIE9yZ2FuaXphdGlvblxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYWdlLWZvb3Rlci1jb3B5cmlnaHRcIiAjY29weXJpZ2h0PlxuICogICAgICAgICAgICAgICAgICAgPHA+w4LCqSAyMDIww6LCgMKTMjAyOCBUaGUgRnV0dXJlLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQ8L3A+XG4gKiAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtZm9vdGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtZm9vdGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3BhZ2UtZm9vdGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsncGFnZS1mb290ZXIuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlRm9vdGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIGNvcHlyaWdodCBjb250ZW50XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnY29weXJpZ2h0JykgY29weXJpZ2h0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBzaG93IGRlZmF1bHQgY29weXJpZ2h0LiBJZiBjb3B5cmlnaHQgaXMgcGFzc2VkIGluLCB0aGVuIHNob3cgdGhlIHBhc3NlZCBpbiBvbmUuXG4gICAgICovXG4gICAgc2hvd0RlZmF1bHRDb3B5cmlnaHQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd0RlZmF1bHRDb3B5cmlnaHQgPSAhaXNQcmVzZW50KHRoaXMuY29weXJpZ2h0KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4uLy4uLy4uL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlVHlwZSwgUGFnZVdyYXBwZXJ9IGZyb20gJy4uL3BhZ2Utd3JhcHBlcic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb259IGZyb20gJy4uLy4uL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7UGFnZUhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogT2JqZWN0IFBhZ2UgV3JhcHBlciBDb21wb25lbnQgcmVuZGVycyBhbnkgb2JqZWN0IGluc3RhbmNlIGluIGRldGFpbC4gSXQgaGFzIGEgdW5pZm9ybSBsYXlvdXQsXG4gKiBIZWFkZXIsIFBhZ2UgdGl0bGUsIFBhZ2Ugbm90aWZpY2F0aW9uLCBhY3Rpb25zLCBjb250ZW50LCBhbmQgRm9vdGVyLlxuICpcbiAqXG4gKiAgVXNhZ2U6XG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdSRlhQYWdlJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGF3LW9iamVjdC1wYWdlLXdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInJmeEVudGl0eS5oZWFkZXJJbmZvLnRpdGxlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwicmZ4RW50aXR5LmhlYWRlckluZm8uZXZlbnRUeXBlU3RyaW5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKlxuICpcbiAqICAgICAgICAgICA8YXctcGFnZS1hY3Rpb25zPlxuICogICAgICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIidzdWJtaXQnXCIgW25hbWVdPVwiJ2VkaXQnXCIgW3ZhbHVlXT1cImVkaXRcIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCI+XG4gKiAgICAgICAgICAgICAgICAgICBFZGl0XG4gKiAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInYnV0dG9uJ1wiIFtuYW1lXT1cIidjYW5jZWwnXCIgW3ZhbHVlXT1cImNhbmNlbFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiPlxuICogICAgICAgICAgICAgICAgICBDYW5jZWxcbiAqICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWFjdGlvbnM+XG4gKlxuICogICAgICAgICAgIDxhdy1wYWdlLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlNvdXJjaW5nIHJlcXVlc3QgaW5mb1wiIChvblN0YXRlQ2hhbmdlZCk9XCJvblN0YXRlQ2hhbmdlKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8bS1jb250ZXh0IFtvYmplY3RdPVwicmZ4RW50aXR5LmhlYWRlckluZm9cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ9XCJJbnNwZWN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlHcm91cD1cIkhlYWRlckdlbmVyYWxcIlxuICogICAgICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICAgICAgICAgICAgIDxtLWluY2x1ZGUtY29tcG9uZW50PjwvbS1pbmNsdWRlLWNvbXBvbmVudD5cbiAqICAgICAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICpcbiAqICAgICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtY29udGVudD5cbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2Utd3JhcHBlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgUkZYUGFnZVxuICogICAge1xuICogICAgICAgLy8gVG8ga2VlcCB0cmFjayB3aGF0IHNlY3Rpb24gaXMgZWRpdGFibGUgYW5kIHdoaWNoIHJlYWQgb25seVxuICogICAgICAgZWRpdGFiaWxpdHlTdGF0ZTogRWRpdGFiaWxpdHlTdGF0ZTtcbiAqXG4gKiAgICAgICAvLyBDdXJyZW50IFJGWCBldmVudFxuICogICAgICAgcmZ4RW50aXR5OiBSZnhFdmVudEVudGl0eTtcbiAqXG4gKiAgICAgICAvLyBOb3RpZmljYXRpb25zXG4gKiAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW9iamVjdC1wYWdlLXdyYXBwZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ29iamVjdC1wYWdlLXdyYXBwZXIuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCBleHRlbmRzIFBhZ2VXcmFwcGVyIGltcGxlbWVudHMgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBwYWdlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCBiZWluZyByZW5kZXJlZCAtIEV2ZW50LCBXb3Jrc3BhY2UsIGNvbnRyYWN0LCBldGMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RUeXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBsYWJlbCBmb3IgdGhlIG9iamVjdCBzdGF0dXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0dXNMYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QncyBzdGF0dXMuIEZvciBleGFtcGxlLCBkcmFmdCwgcGVuZGluZyBzZWxlY3Rpb24sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0dXM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsLiBTb21lIG9iamVjdCBoYXMgc3RhdGVzLiBGb3IgZXhhbXBsZTogUkZ4T2JqZWN0IGhhcyBSZXNvbHZlLCBSZXZpZXcsIEdldCBRdW90ZS5cbiAgICAgKiBPYmplY3Qgc3RhdGVzIHdpbGwgYXBwZWFyIG9uIHRoZSBwYWdlIHdoZW4gdGhleSBhcmUgcHJlc2VudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXRlczogc3RyaW5nW107XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gU3RlcHBlciBpcyB1c2VkIHRoaXMgaWRlbnRpZmllcyBjdXJyZW50IHNldCBzdGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0YXRlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEhlYWRlciBpcyBhIGNvbXBvbmVudCB0eXBlIHRvIGJlIHJlbmRlcmVkIGFzIGEgcGFnZSBIZWFkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgJ2RlZmF1bHQnIHZhbHVlIGlzIHRoZSBjb21wb25lbnQvd2lkZ2V0L0hlYWRlckNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGVhZGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHJ1ZSBpZiBwYWdlIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgaGVhZGVyLiBOZWVkIHRvIHNldCB0byB0cnVlIGV2ZW4gbm8gaGVhZGVyXG4gICAgICogb2JqZWN0IGlzIHBhc3NlZCBpbi4gT3RoZXJ3aXNlLCBhIGRlZmF1bHQgSGVhZGVyIGNvbXBvbmVudCB3aWxsIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZUhlYWRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRm9vdGVyIENvbXBvbmVudCBpcyB0aGUgcGFnZSBmb290ZXIuXG4gICAgICogY2FuIGJlIG92ZXJyaWRlbiBidXQgdGhlIGRlZmF1bHQgdmFsdWUgaXMgY29tcG9lbmVudC93aWRnZXQvRm9vdGVyQ29tcG9uZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9vdGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHJ1ZSBpZiBwYWdlIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgZm9vdGVyLiBOZWVkIHRvIHNldCB0byB0cnVlIGV2ZW4gbm8gZm9vdGVyXG4gICAgICogb2JqZWN0IGlzIHBhc3NlZCBpbi4gT3RoZXJ3aXNlLCBhIGRlZmF1bHQgRm9vdGVyIGNvbXBvbmVudCB3aWxsIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZUZvb3RlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBwYWdlIGFjdGlvbnMgKHBhZ2UgYnV0dG9ucylcbiAgICAgKiAgICd0b3AnIDogICAgcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgdGhlIHRvcCBvZiB0aGUgcGFnZSwgYmVsb3cgdGhlIHRpdGxlLCB0byB0aGUgcmlnaHQuXG4gICAgICogICAnYm90dG9tJyA6IHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UsIGFib3ZlIHRoZSBmb290ZXIuXG4gICAgICogICAnYm90aCcgICA6IHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IGJvdGggdG9wIGFuZCBib3R0b20uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhZ2VBY3Rpb25Qb3NpdGlvbjogc3RyaW5nID0gJ3RvcCc7XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmxhZyBpcyBkcml2ZW4gYnkgcGFnZUFjdGlvblBvc2l0aW9uLiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyB0b3AuXG4gICAgICogVmFsdWUgaXMgdHJ1ZSBmb3IgYm90aCAndG9wJyBhbmQgJ2JvdGgnIG9mIHBhZ2VBY3Rpb25Qb3NpdGlvbi5cbiAgICAgKi9cbiAgICBoYXNUb3BQYWdlQWN0aW9uczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgaXMgZHJpdmVuIGJ5IHBhZ2VBY3Rpb24gcG9zaXRpb24uXG4gICAgICogVmFsdWUgaXMgdHJ1ZSBmb3IgYm90aCAnYm90dG9tJyBhbmQgJ2JvdGgnIG9mIHBhZ2VBY3Rpb25Qb3NpdGlvbi5cbiAgICAgKi9cbiAgICBoYXNCb3R0b21QYWdlQWN0aW9uczogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyBhIHAgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgncGFnZUFjdGlvbnMnKVxuICAgIGFjdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEFueSBTdWNjZXNzLCBJbmZvLCBFcnJvciwgb3IgV2FybiBmb3IgdGhpcyBwYWdlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uczogUGFnZU5vdGlmaWNhdGlvbltdO1xuXG5cbiAgICBvYmplY3RTdGF0ZUluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSwgcGFnZUxpZmVjeWNsZVNlcnZpY2U6IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBQYWdlVHlwZS5PYmplY3QsIGNvbXBvbmVudFJlZ2lzdHJ5LCBwYWdlTGlmZWN5Y2xlU2VydmljZSk7XG5cbiAgICAgICAgLy8gU2V0dGluZyBEZWZhdWx0IGhlYWRlciBjb21wb25lbnRcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBQYWdlSGVhZGVyQ29tcG9uZW50O1xuICAgICAgICB0aGlzLmZvb3RlciA9IFBhZ2VGb290ZXJDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB1bmlxdWUgSWQgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgZ2VuZXJhdGVQYWdlSWQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RUeXBlICsgJ18nICsgdGhpcy50aXRsZSArICh0aGlzLmlkKSA/ICgnXycgKyB0aGlzLmlkKSA6ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgbXkgcGFnZSBoYXZlIHBhZ2Ugbm90aWZpY2F0aW9uP1xuICAgICAqXG4gICAgICovXG4gICAgaGFzTm90aWZpY2F0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMubm90aWZpY2F0aW9ucyAmJiB0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgaGFzT2JqZWN0U3RhdGVzKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5vYmplY3RTdGF0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgbXkgbG9jYWwgY29tcG9uZW50c1xuICAgICAqL1xuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gTmV3IENvbXBvbmVudCB0eXBlcyB0aGF0IGFyZSB1c2VkIGluIGMtaW5jbHVkZS1jb21wb25lbnRcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyVHlwZSh0aGlzLmhlYWRlci5uYW1lLCB0aGlzLmhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgQ29tcG9uZW50IHR5cGVzIHRoYXQgYXJlIHVzZWQgaW4gYy1pbmNsdWRlLWNvbXBvbmVudFxuICAgICAgICBpZiAodGhpcy5mb290ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJUeXBlKHRoaXMuZm9vdGVyLm5hbWUsIHRoaXMuZm9vdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBub3RpZnkgc3Vic2NyaWJlcnMgb2YgdGhlIHBhZ2UgbGlmZWN5Y2xlIHNlcnZpY2UgICovXG4gICAgICAgIHRoaXMucGFnZUxpZmVjeWNsZVNlcnZpY2Uub25QYWdlSW5pdCh0aGlzLnRpdGxlKTtcblxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBwYWdlIGFjdGlvbiBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMucGFnZUFjdGlvblBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdGhpcy5oYXNUb3BQYWdlQWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYXNCb3R0b21QYWdlQWN0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhZ2VBY3Rpb25Qb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzVG9wUGFnZUFjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXNCb3R0b21QYWdlQWN0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub2JqZWN0U3RhdGVzKSAmJiB0aGlzLm9iamVjdFN0YXRlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAmJiBpc1ByZXNlbnQodGhpcy5jdXJyZW50U3RhdGUpKSB7XG5cbiAgICAgICAgICAgIHRoaXMub2JqZWN0U3RhdGVJbmRleCA9IHRoaXMub2JqZWN0U3RhdGVzLmluZGV4T2YodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWydjdXJyZW50U3RhdGUnXSkgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snY3VycmVudFN0YXRlJ10ucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gd2UgZG9udCBuZWVkIHRvIGNoZWNrIGlmIG9iamVjdFN0YXRlcyBleGlzdHNcbiAgICAgICAgICAgIHRoaXMub2JqZWN0U3RhdGVJbmRleCA9IHRoaXMub2JqZWN0U3RhdGVzLmluZGV4T2YodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VMaWZlY3ljbGVTZXJ2aWNlLm9uUGFnZURlc3Ryb3kodGhpcy50aXRsZSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFnZSBhY3Rpb25zIGlzIGEgd3JhcHBlciBmb3IgYWxsIHBhZ2UgYWN0aW9ucywgYnV0dG9ucywgbGlua3MsIG1lbnVzIHRoYXQgaW50ZXJhY3RzIGl0IHdpdGggdGhlXG4gKiBwYWdlLiBUaGUgd3JhcHBlciB1c2UgdGhlIGFiaWxpdHkgdG8gcG9zaXRpb24gaXQgYXMgbmVlZGVkLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtYWN0aW9ucycsXG4gICAgdGVtcGxhdGVVcmw6ICdwYWdlLWFjdGlvbnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydwYWdlLWFjdGlvbnMuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlQWN0aW9uc0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFnZSBjb250ZW50IGlzIGEgd3JhcHBlciBmb3IgcGFnZSBjb250ZW50LlxuICogQ3VycmVudGx5LCBpdCdzIHByZXR0eSBiYXJlLCBidXQgYXMgd2UgYWRkIG1vcmUgaW50ZXJhY3Rpb25zIG9uIHRoZSBwYWdlLCBsaWtlIGEgc2lkZSBiYXIsXG4gKiB0aGUgcGFnZSBjb250ZW50IGFyZWEgd2lsbCBsaWtlbHkgZ2V0IGFmZmVjdGVkLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtY29udGVudCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICBzdHlsZXM6IFsnOmhvc3Qge3dpZHRoOiAxMDAlOyBwYWRkaW5nOiAwIC41ZW07fSddXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VDb250ZW50Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuXG5jb25zdCBTVEVQUEVSX0NPTVBMRVRFRF9TVEVQX0NPTE9SID0gJyM1OGI5NTcnO1xuY29uc3QgU1RFUFBFUl9DVVJSRU5UX1NURVBfQ09MT1IgPSAnIzAwNzZDQic7XG5jb25zdCBTVEVQUEVSX1JFTUFJTklOR19TVEVQX0NPTE9SID0gJyNEN0Q3RDcnO1xuXG4vKipcbiAqIFN0ZXBwZXIgY29tcG9uZW50IGRpc3BsYXlzIGEgbGlzdCBvZiBzdGVwcyBmb3IgdXNlciB0byBmb2xsb3cuIEl0IGNhbiBiZSB1c2VkIGFzIGEgY2hlY2tsaXN0XG4gKiB0byBpbmRpY2F0ZSBjb21wbGV0ZWQsIGN1cnJlbnQgYW5kIHJlbWFpbmluZyBpdGVtcy4gSXQgY291bGQgYmUgYWxzbyBiZSB1c2VkIHRvIGluZGljYXRlXG4gKiB0aGUgc3RhdGUgb2YgYW4gZG9jdW1lbnQsIGNyZWF0ZWQsIHN1Ym1pdHRlZCwgYXBwcm92ZWQsIGV0Yy4uLlxuICpcbiAqXG4gKiBVc2FnZTpcbiAqICAgMS4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS4gcHJvdmlkZSBhIGxpc3Qgb2Ygc3RlcHMgYW5kIHRoZSBjdXJyZW50IHN0ZXAuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgIDxhdy1zdGVwcGVyIFtzdGVwc109XCJzdGVwc1wiIFtjdXJyZW50U3RlcF09XCJjdXJyZW50U3RlcFwiPjwvYXctc3RlcHBlcj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBzdGVwczogc3RyaW5nW10gPSBbJ01vbml0b3InLCAnQWRkIFN1cHBsaWVyJywgJ0dldCBRdW90ZSddO1xuICogICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqICAgICAgIH1cbiAqXG4gKiAgIDIuICBPdmVycmlkZSB0aGUgZGVmYXVsdCBjb2xvcnMuXG4gKlxuICogICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cInN0ZXBzXCIgW3N0ZXBDb2xvckN1cnJlbnRdPVwiJyNmZjk5MDAnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdGVwQ29sb3JSZW1haW5pbmddPVwiJyNDQzAwMDAnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdGVwQ29sb3JDb21wbGV0ZWRdPVwiJyM5N2E4MjInXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50U3RlcF09XCJjdXJyZW50U3RlcFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1zdGVwcGVyPlxuICogICAgICAgICAgICAgICAgICBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3RlcHBlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdzdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnc3RlcHBlci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFN0ZXBwZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogUmVxdWlyZWRcbiAgICAgKiBBcnJheSBvZiBzdGVwcy4gT3JkZXIgb2YgdGhlIHN0ZXBzIHNob3VsZCBiZSBpbiBhcnJheSBvcmRlci5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBzOiBzdHJpbmdbXTtcblxuXG4gICAgLyoqXG4gICAgICogc3BlY2lmeSB0aGUgY29sb3JzIGFzc29jaWF0ZWQgd2l0aCBzdGVwcyBhYm92ZS4gVGhlIG51bWJlciBvZiBjb2xvcnNcbiAgICAgKiBhbmQgbnVtYmVyIG9mIHN0ZXBzIG11c3QgbWF0Y2guXG4gICAgICogT3B0aW9uYWw6LCBpZiBlbXB0eSwgZGVmYXVsdCBjb2xvcnMgb3IgY29sb3JzIGZyb20gc3RlcENvbG9yIGlucHV0cyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2xvcnM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgdmFyaWFibGUgdG8gaW5kaWNhdGUgd2hldGhlciB0byB1c2UgdGhlIGNvbG9ycyBhcnJheSBvciBub3QuXG4gICAgICovXG4gICAgYlVzZUNvbG9yQXJyYXk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIGNvbXBsZXRlZCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yQ29tcGxldGVkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiBjdXJyZW50IHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JDdXJyZW50OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiByZW1haW5pbmcgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvclJlbWFpbmluZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RlcCB0aGF0J3Mgb24uIElmIG5vdCBwcm92aWRlZCBkZWZhdWx0IHRvIHRoZSBmaXJzdCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVkIHRoZSB3aWR0aCBvZiBjb25uZWN0b3JzIGJldHdlZW4gc3RlcHMuIFRoZSBjYWxjdWxhdGlvbnMgaXMgc29cbiAgICAgKiB0aGF0IHRoZSBzdGVwcyBhcmUgc3ByZWFkIG91dCBldmVubHkuXG4gICAgICovXG4gICAgY29ubmVjdG9yV2lkdGg6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgLy8gSW5pdGlhbCBjb2xvciBmb3IgdGhlIGRpZmZlcmVudCBzdGFnZXMgb2Ygc3RlcHMuXG4gICAgICAgIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkID0gU1RFUFBFUl9DT01QTEVURURfU1RFUF9DT0xPUjtcbiAgICAgICAgdGhpcy5zdGVwQ29sb3JDdXJyZW50ID0gU1RFUFBFUl9DVVJSRU5UX1NURVBfQ09MT1I7XG4gICAgICAgIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nID0gU1RFUFBFUl9SRU1BSU5JTkdfU1RFUF9DT0xPUjtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbm5lY3RvciB3aWR0aCBiYXNlZCBvbiBob3cgbWFueSBzdGVwc1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RlcHMpICYmIHRoaXMuc3RlcHMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAvLyAoMTAwJSAtIDIwJSAoc2lkZSBtYXJnaW5zKSkgLyAoTnVtT2ZTdGVwcyAtMSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yV2lkdGggPSBNYXRoLmNlaWwoODAgLyAodGhpcy5zdGVwcy5sZW5ndGggLSAxKSkgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoZSBjb2xvciBhcnJheSBpZiBpdCdzIGRlZmluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY29sb3JzKSkge1xuXG4gICAgICAgICAgICB0aGlzLmJVc2VDb2xvckFycmF5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JzLmxlbmd0aCAhPT0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSBzdGVwcyBhbmQgY29sb3JzIGRvbid0IG1hdGNoOlxuICAgICAgICAgICAgICAgICAgKHN0ZXBzLmxlbmd0aCA9ICR7dGhpcy5zdGVwcy5sZW5ndGh9KSwgKGNvbG9ycy5sZW5ndGggPSAke3RoaXMuY29sb3JzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRpbmcgdGhlIGNvbG9yIG9mIHRoZSBzdGVwIGZvciB0aGUgY3VycmVudCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcENvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ3VycmVudDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JSZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdG9yIGNvbG9ycyBhcmUgZHJpdmVuIGJ5IHRoZSBzdGVwIGNvbG9ycy5cbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbm5lY3RvckNvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RlcC5cbiAgICAgKi9cbiAgICBuZXh0U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmlvdXMgc3RlcC5cbiAgICAgKi9cbiAgICBwcmV2U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwLS07XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBSZW5kZXJzIGh0bWwgc3RlcCBjb21wb25lbnRcbiAqXG4gKiAgKiBVc2FnZTpcbiAqICAgICAgIFN0cmFpZ2h0IGZvcndhcmQgdG8gdXNlLiBCdXQgbW9zdGx5IGl0IHdvdWxkIGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc3RlcHBlciBjb21wb25lbnQuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXAgW3RpdGxlXT1cInN0ZXBcIiBbY29sb3JdPVwiY29sb3JcIj48L2F3LXN0ZXA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAqL1xuXG4gICAgLy8gRGVmYXVsdCBjb2xvciBmb3IgdGhpcyBzdGVwLlxuY29uc3QgREVGQVVMVF9DT0xPUiA9ICcjNThiOTU3JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3N0ZXAuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydzdGVwLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU3RlcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciBvZiBzdGVwIGljb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2xvcjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogdGl0bGUgYXBwZWFycyB1bmRlciB0aGUgc3RlcCBncmFwaGljcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBERUZBVUxUX0NPTE9SO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTdGVwcGVyQ29tcG9uZW50fSBmcm9tICcuL3N0ZXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7U3RlcENvbXBvbmVudH0gZnJvbSAnLi9zdGVwL3N0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN0ZXBDb21wb25lbnQsXG4gICAgICAgIFN0ZXBwZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1N0ZXBwZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7UGFnZU1lbnVJdGVtfSBmcm9tICcuLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiAgVGhpcyBpcyBhIHRlbXBvcmFyeSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHBhZ2UgaGVhZGVyIGNvbXBvbmVudC5cbiAqICBXaGVuIHRoZSByZWFsIGltcGxlbWVudGF0aW9uIG9mIHNpZGUgbWVudSBpcyBkb25lLCBQYWdlSGVhZGVyQ29tcG9uZW50IHdpbGxcbiAqICBiZSBzd2FwZWQgdG8gdXNlIGl0LlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zaWRlbmF2JyxcbiAgICB0ZW1wbGF0ZVVybDogJ3NpZGVuYXYuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydzaWRlbmF2LmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU2lkZW5hdkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGl0ZW1zOiBQYWdlTWVudUl0ZW1bXTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBiYWNrIGxpbmsgdGhhdCBuYXZpZ2F0ZXMgdXNlciB0byB0aGUgcHJldmlvdXMgcGFnZSB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93OiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBnZXRTaWRlbmF2Q2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICAvLyBPbmx5IHNob3cgaWYgSSBoYXZlIGl0ZW1zXG4gICAgICAgIHJldHVybiAodGhpcy5zaG93ICYmIHRoaXMuaXRlbXMpID8gJ3NpZGVuYXYgc2lkZW5hdi1hY3RpdmUnIDogJ3NpZGVuYXYnO1xuICAgIH1cblxuICAgIG9wZW4oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudH0gZnJvbSAnLi9vYmplY3QtcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUFjdGlvbnNDb21wb25lbnR9IGZyb20gJy4vcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlQ29udGVudENvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWNvbnRlbnQvcGFnZS1jb250ZW50LmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VGb290ZXJDb21wb25lbnR9IGZyb20gJy4vcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0ZXBwZXJNb2R1bGV9IGZyb20gJy4uL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtTaWRlbmF2Q29tcG9uZW50fSBmcm9tICcuL3NpZGVuYXYvc2lkZW5hdi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGV9IGZyb20gJy4uL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLm1vZHVsZSc7XG5pbXBvcnQge1JvdXRlck1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgU2lkZW5hdkNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUm91dGVyTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFNpZGVuYXZDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBBV1BhZ2VXcmFwcGVyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogUmljaFRleHRBcmVhIGNvbXBvbmVudCByZXByZXNlbnRzIGEgdGV4dCBlZGl0b3Igd2hpY2ggYWxsb3dzIHVzZXJzIHRvIGZvcm1hdCB0ZXh0IGlucHV0LlxuICogVGhlIGVkaXRvcidzIHRvb2xiYXIgaXMgcHJlLWNvbmZpZ3VyZWQgdG8gY29udGFpbiBmdW5jdGlvbmFsaXRpZXMgdGhhdCBhcmUgaW4gb3VyIGRlc2lnbi5cbiAqIEBzZWUge0BsaW5rIGVkaXRvci9lZGl0b3IuY29tcG9uZW50Lmh0bWx9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZngtZXZlbnQnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgIDwhLS0gQmFzaWMgVXNhZ2UuIC0tPlxuICogICAgICAgIDxhdy1yaWNodGV4dGFyZWEgW25hbWVdPVwiJ2Rlc2NyaXB0aW9uJ1wiIFt2YWx1ZV09XCJkZXNjcmlwdGlvblwiIHBsYWNlSG9sZGVyPVwicHV0XG4gKiAgICAgICAgZGVzY3JpcHRpb25cIj5cbiAqICAgICAgICA8L2F3LXJpY2h0ZXh0YXJlYT5cbiAqXG4gKiAgICAgICAgPCEtLSBFZGl0b3Igd2l0aCBGdWxsIGZ1bmN0aW9uYWxpdHkgLS0+XG4gKiAgICAgIDxhdy1yaWNodGV4dGFyZWEgW25hbWVdPVwiJ2NvbW1lbnQnXCIgW3R5cGVdPVwiZWRpdG9yVHlwZVwiIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gKiAgICAgIHBsYWNlSG9sZGVyPVwiaG9sZCB0aGlzXCI+XG4gKiAgICAgIDwvYXctcmljaHRleHRhcmVhPlxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gKlxuICogICAgICAgIGVkaXRvclR5cGU6RWRpdG9yVHlwZSA9IEVkaXRvclR5cGUuRnVsbDtcbiAqICAgICAgICB2YWx1ZTpTdHJpbmc7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiB0ZXh0IGVkaXRvci4gVGhleSBhcmUgcHJlY29uZmlndXJlZCB3aXRoXG4gKiBmdW5jdGlvbmFsaXR5IGJhc2VkIG9uIHR5cGUuIFVzZSBjdXN0b20gdG8gYWRkIHlvdXIgb3duIHRvb2xiYXIgbWVudS5cbiAqL1xuZXhwb3J0IGVudW0gRWRpdG9yVHlwZSB7XG4gICAgRGVmYXVsdCwgICAgLy8gRGVmYXVsdCBFZGl0b3Igc3VwcG9ydHMgTWluaW1hbCBzZXQgb2YgZnVuY3Rpb25hbGl0eVxuICAgIC8vIFsgYm9sZCB8IGl0YWxpYyB8IHVuZGVybGluZSB8IG9yZGVyZWQgfCBidWxsZXQgfCBhbGlnbm1lbnRdXG4gICAgRnVsbCwgICAgICAgLy8gVGhlIGZ1bGwgbGlzdCBvZiBmdW5jdGlvbmFsaXR5LFxuICAgIFRleHRGb3JtYXQsIC8vIEZ1bmN0aW9uYWxpdGllcyB0aGF0IGFmZmVjdHMgdGV4dCBmb3JtYXR0aW5nLlxuICAgIEN1c3RvbSAgICAgLy8gQ3VzdG9tIHRvb2xiYXIuXG59XG5cblxuZXhwb3J0IGNvbnN0IEVESVRPUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmljaFRleHRBcmVhQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJpY2h0ZXh0YXJlYScsXG4gICAgdGVtcGxhdGVVcmw6ICdyaWNoLXRleHQtYXJlYS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3JpY2gtdGV4dC1hcmVhLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEVESVRPUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJpY2hUZXh0QXJlYUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIFJpY2hUZXh0QXJlYUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgZWRpdG9yLiAgU2VlIEVkaXRvclR5cGUgZm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogRWRpdG9yVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzYXZlIGFuZCByZWFkIHdoZW4gcmVuZGVyaW5nIGFuZCB1cGRhdGluZyB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIGVkaXRvclR5cGUgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiB0aGlzIGNvbXBvbmVudHMgdGVtcGxhdGUuXG4gICAgICovXG4gICAgRWRpdG9yVHlwZTogYW55ID0gRWRpdG9yVHlwZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBFZGl0b3JUeXBlLkRlZmF1bHQ7XG4gICAgICAgIHRoaXMuc3R5bGVDbGFzcyA9ICdkZWZhdWx0LWVkaXRvcic7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0VkaXRvck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtSaWNoVGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4uL3JpY2gtdGV4dC1hcmVhL3JpY2gtdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmljaFRleHRBcmVhTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FjY29yZGlvblRhYn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBBbGxvdyBkZXZlbG9wZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCBhY3Rpb25zLiBNdXN0IGhhdmUgdGhpcyBkZWNsYXJlZCBiZWZvcmUgY2xhc3Mgd2hlbiB3ZVxuICogd2FudCB0byBoYXZlIHRoaXMgZGVjbGFyYXRpb24gaW5zaWRlIHRoZSBzYW1lIGZpbGUuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2VjdGlvbi1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD4gYCxcbn0pXG5leHBvcnQgY2xhc3MgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbntcblxufVxuXG5cbi8qKlxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBhIHNlY3Rpb24gb2YgdGhlIHBhZ2UuIEl0J3MgYW4gb3V0bGluZSBib3ggdGhhdFxuICogaGFzIHRoZSBhYmlsaXR5IHRvIGV4cGFuZCBhbmQgaGlkZSBpdHMgY29udGVudC5cbiAqXG4gKiBgYGB0c1xuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZngtZGV0YWlscycgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJTb3VyY2luZyByZXF1ZXN0IGluZm9cIiAob25FZGl0KT1cIm9uU3RhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICogICAgICAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgPG0tY29udGV4dCBbb2JqZWN0XT1cInJmeEVudGl0eS5oZWFkZXJJbmZvXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dD1cIkluc3BlY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHVpR3JvdXA9XCJIZWFkZXJHZW5lcmFsXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8bS1pbmNsdWRlLWNvbXBvbmVudD48L20taW5jbHVkZS1jb21wb25lbnQ+XG4gKiAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKlxuICogICAgICAgICAgIDxhdy1zZWN0aW9uICNzdXBwbGllclNlY3Rpb24gdGl0bGU9XCJTZWxlY3RlZCBzdXBwbGllcnNcIiAob25PcGVuKT1cIm9uT3BlbigpXCJcbiAgICogICAgICAgICAgICAgICAgW29wZW5lZF09XCJmYWxzZVwiPlxuICogICAgICAgICAgICAgICA8c3VwcGxpZXItcHJvZmlsZS1jYXJkPjwvc3VwcGxpZXItcHJvZmlsZS1jYXJkPlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiAgICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJSRlEgRGV0YWlsc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb249XCJSZXZpZXcgYW5kIHVwZGF0ZSBpbmZvcm1hdGlvbiBmb3Igc3VwcGxpZXJzIHRvIHJlc3BvbmQuXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZUNsb3NlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgIDxhdy1zdWJzZWN0aW9uIHRpdGxlPVwiRXZlbnQgdGltZWxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXRhYmxlIFt1c2VGaXZlWm9uZV09XCJmYWxzZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1N0YXJ0IERhdGUnXCIgW25hbWVdPVwiJ3N0YXJ0RGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaGlnaGxpZ2h0Um93XT1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0TmFtZT1cImRhdGVUaW1lXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJzdGFydERhdGVcIiBbdmFsdWVdPVwicmZ4RW50aXR5LmNyZWF0ZWRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Nob3dUaW1lXT1cInRydWVcIj48L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXRhYmxlPlxuICogICAgICAgICAgICAgICA8L2F3LXN1YnNlY3Rpb24+XG4gKiAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IGFsc28gc3VwcG9ydHMgZWRpdGFiaWxpdHkgbW9kZXMgYW5kIGlmIGVuYWJsZWQgaXQgd2lsbCByZW5kZXIgYWN0aW9uIGJ1dHRvbnNcbiAqIGluIHRoZSBmb290ZXIuIERldmVsb3BlciBjYW4gYWxzbyBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIGFuZCBwcm92aWRlIGN1c3RvbSBhY3Rpb25zLlxuICpcbiAqXG4gKiBlLmc6XG4gKlxuICogYGBgXG4gKiAgICAgIDxhdy1zZWN0aW9uIFt0aXRsZV09XCJ0aXRsZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25DYW5jZWxBY3Rpb24pPVwic29tZUhhbmRsZXIxKCRldmVudClcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvblNhdmVBY3Rpb24pPVwic29tZUhhbmRsZXIyKCRldmVudClcIiA+XG4gKiAgICAgICAgICAgICAgc2VjdGlvbiBjb250ZW50XG4gKlxuICpcbiAqICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqIGBgYFxuICpcbiAqIG9yIGN1c3RvbSBhY3Rpb24gYnV0dG9uczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICAgICAgIDxhdy1zZWN0aW9uLWFjdGlvbnM+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uID5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvblRlc3QxXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdXR0b25UZXN0MlxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgPC9hdy1zZWN0aW9uLWFjdGlvbnM+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFRoZXJlIGFyZSB0d28gZWRpdCBtb2Rlc1xuICogICMgRGVmYXVsdFxuICogICAgICBSZW5kZXJzIGFjdGlvbiBidXR0b25zIGluIHRoZSBmb290ZXJzIGFuZCBlbWl0IGFjdGlvbnMgdG8gdGhlIGFwcGxpY2F0aW9uXG4gKlxuICogICMgRXh0ZXJuYWxcbiAqICAgICBObyBhY3Rpb24gYnV0dG9ucyBhcmUgc2hvd24gaW4gdGhlIGZvb3RlciBhbmQgYmVoYXZpb3IgaXMgaGFuZGxlZCBieSBhcHBsaWNhdGlvbi4gT25seSBldmVudFxuICogICAgIGlzIGVtaXRlZC5cbiAqXG4gKlxuICogIGUuZzpcbiAqXG4gKiAgYGBgdHNcbiAqXG4gKiAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiVXNlciBJbmZvcm1hdGlvblwiIChvbkVkaXQpPVwib25BZGRTb21ldGhpbmcoJGV2ZW50KVwiXG4gKiAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCIgW2VkaXRNb2RlXT1cIidleHRlcm5hbCdcIiA+XG4gKiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICBDb250ZW50XG4gKiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LXNlY3Rpb24+XG4gKlxuICogIGBgYFxuICpcbiAqIE5vdGU6IFdoZW4gdXNpbmcgZWRpdGluZyBtb2RlIHlvdSBoYXZlIHRvIGNhbGwgYXQgdGhlIGVuZCBvZiB0aGUgZWRpdGluZyBjeWNsZSBtZXRob2RcbiAqIGBjb21wbGV0ZUVkaXRpbmcoKWAgdG8gY29tbWl0IGVkaXRpbmcgd2hpY2ggY2hhbmdlcyBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgU2VjdGlvbi5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zZWN0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3NlY3Rpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydzZWN0aW9uLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU2VjdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHNlY3Rpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhpcyBzZWN0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGlzIHNlY3Rpb24gYmUgb3BlbmVkIGF0IHRoZSBzdGFydC4gRGVmYXVsdCBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvcGVuZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNlY3Rpb24gY2FuIGJlIGNsb3NlZCBvciBub3QuXG4gICAgICoqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZUNsb3NlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2VjdGlvbiBpcyBpbiBFZGl0U3RhdGUgb3Igbm90LlxuICAgICAqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCB3ZSBzaG93IFwiQ2FuY2VsIC8gU2F2ZVwiIGJ1dHRvbiBkZXZlbG9wZXIgbmVlZHMgdXNlIHRoaXMgYmluZGluZ1xuICAgICAqIHRvIGNvbnRyb2wgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdFN0YXRlOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgRWRpdGluZyBtb2RlLiBUZWxscyB0aGUgY29tcG9uZW50cyBpZiBpdHMgaXRzIGRlZmF1bHQgYmVoYXZpb3Igb3IgZHJpdmVuIGJ5XG4gICAgICogYXBwbGljYXRpb24gdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiB7QHNlZSBFZGl0TW9kZX1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdE1vZGU6IEVkaXRNb2RlID0gJ2RlZmF1bHQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXZlbG9wZXIgY2FuIHByb3ZpZGUgY3VzdG9tIEVkaXQgYWN0aW9uIGljb24gdGhhdCB3aWxsIGFwcGVhciBpbiB0aGUgcmlnaHQgdG9wIGNvcm5lclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uSWNvbjogc3RyaW5nID0gJ2ljb24tZWRpdCc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgZnVsbHkgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgZnVsbHkgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRWRpdCBzdGF0ZSB0byBicm9hZGNhc3Qgc3RhdGUgb2YgY3VycmVudCBzZWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25FZGl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCBkZWZhdWx0IGJ1dHRvbnMgYXJlIHJlbmRlcmVkIG9uIGNsaWNrIGJyb2FkY2FzdCBDYW5jZWwgYWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWxBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIGRlZmF1bHQgYnV0dG9ucyBhcmUgcmVuZGVyZWQgb24gY2xpY2sgYnJvYWRjYXN0IFNhdmUgYWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TYXZlQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgQE91dHB1dCgpXG4gICAgb25FZGl0aW5nQ29tcGxldGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgdmFyaWFibGUgb24gd2hldGhlciB0aGlzIHNlY3Rpb24gaXMgZXhwYW5kZWQgb3Igbm90LlxuICAgICAqIERpZmZlcnMgZnJvbSAnb3BlbmVkJy4gb3BlbmVkIGlzIGFuIGlucHV0IHBhcmFtZXRlciBhbmQgaXQgZG9lc24ndCB0cmFja1xuICAgICAqIGN1cnJlbnQgc2VjdGlvbiBleHBhbmRlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBleHBhbmRlZDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIGFjY29yZGlvblRhYlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2FjY29yZGlvblRhYicpXG4gICAgcHJpdmF0ZSBhY2NvcmRpb25UYWI6IEFjY29yZGlvblRhYjtcblxuXG4gICAgLyoqXG4gICAgICogU2F2ZSByZWZlcmVuY2UgdG8gZGV2ZWxvcGVyJ3MgZGVmaW5lZCBhY3Rpb25zIHNvIGlmIHdlIGNhbiBoaWRlIGRlZmF1bHQgb25lc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoU2VjdGlvbkFjdGlvbnNDb21wb25lbnQpXG4gICAgY3VzdG9tQWN0aW9uczogU2VjdGlvbkFjdGlvbnNDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgLy8gSWYgSSBoYXZlIG5vdCBoZWFkZXIsIHRoZW4gSSBjYW4ndCBjbG9zZSB0aGUgc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhZGVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIEkgY2FuJ3QgY2xvc2UgdGhlIHNlY3Rpb24sIHRoZW4gaXQgc2hvdWxkIGRlZmF1bHQgb3Blbi5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGV4cGFuZGVkIHN0YXRlLlxuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdGhpcy5vcGVuZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9uJ3QgZGlzcGxheSBoZWFkZXIgYXJlYSBpZiBJIGRvbid0IGhhdmUgdGl0bGUgYW5kIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0hlYWRlckRpc3BsYXllZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudCh0aGlzLnRpdGxlKSB8fCBpc1ByZXNlbnQodGhpcy5kZXNjcmlwdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENzcyBDbGFzcyB0aGF0IGNvbnRyb2wgdGhlIGxvb2sgYW5kIGZlZWwgZm9yIHNlY3Rpb24gY29tcG9uZW50LlxuICAgICAqL1xuICAgIGFDbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5pc0hlYWRlckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlY3Rpb24tbm8taGVhZGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBpbnRyb2R1Y2VkIGJ1dHRvbnMgYW5kIGVkaXRTdGF0ZSB0aGUgZGVjaXNpb24gb24gd2hlbiB0byBleGl0IGVkaXRpbmcgbW9kZVxuICAgICAqIHNob3VsZCBiZSBvbiB0aGUgZGV2ZWxvcGVyIHVzaW5nIHRoaXMgY29tcG9uZW50IHRoZXJlZm9yZSBvbmx5IHN0YXJ0RWRpdGluZ1xuICAgICAqXG4gICAgICovXG4gICAgb25FZGl0QWN0aW9uKCRldmVudDogYW55KTogdm9pZFxuICAgIHtcblxuICAgICAgICAvLyB3aGVuIGluIGVkaXRpbmcgbWFrZSBzdXJlIHdlIGRvbnQgc3dpdGNoIHN0YXRlIGFzIHRoZXJlIGNhbiBiZSBzb21lIEZvcm0gZXJyb3JzXG4gICAgICAgIC8vIHdoaWNoIG5lZWRzIHRvIGJlIGhhbmRsZWQgYnkgZGV2ZWxvcGVyIGFuZCBvbmx5IHRoZW4gY2hhbmdlIHRoZSBlZGl0U3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U3RhdGUgPSAhdGhpcy5lZGl0U3RhdGU7XG4gICAgICAgICAgICBsZXQgc3RhdGU6IHN0cmluZyA9ICh0aGlzLmVkaXRTdGF0ZSkgPyAnaW5FZGl0JyA6ICdub3RJbkVkaXQnO1xuXG4gICAgICAgICAgICB0aGlzLm9uRWRpdC5lbWl0KHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgb3JpZ2luYWwgZXZlbnQgZnJvbSBidWJibGluZyB1cC4gQmVjYXVzZSB0aGUgZWRpdCBpY29uIGlzIGluc2lkZVxuICAgICAgICAvLyB0aGUgaGVhZGVyLiBJZiB0aGUgY2xpY2sgZXZlbiBpcyBidWJibGVkIHVwLCB0aGlzIGV2ZW50IHdpbGwgY2F1c2UgdGhlIHNlY3Rpb24gdG9cbiAgICAgICAgLy8gZXhwYW5kIG9yIGNvbGxhcHNlLlxuICAgICAgICBpZiAoaXNQcmVzZW50KCRldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgICRldmVudC5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICRldmVudC5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzRGVzY3JpcHRpb24oKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoaXMgc2VjdGlvbiwgaWYgaXQncyBhbHJlYWR5IG9wZW4sIHdpbGwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBvcGVuKGV2ZW50PzogYW55KTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uVGFiLnRvZ2dsZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGlzIHNlY3Rpb24sIGlmIGl0J3MgYWxyZWFkeSBjbG9zZSwgd2lsbCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIGNsb3NlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvcmRpb25UYWIudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhY2NvcmRpb24gaXMgb3BlbmVkXG4gICAgICpcbiAgICAgKi9cbiAgICBvblNlY3Rpb25PcGVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgnb3BlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhY2NvcmRpb24gaXMgY2xvc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBvblNlY3Rpb25DbG9zZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgdXMgaWYgd2UgbmVlZCB0byByZW5kZXIgYXBwbGljYXRpb24gZGVmaW5lZCBjdXN0b20gYWN0aW9uc1xuICAgICAqXG4gICAgICovXG4gICAgaGFzQ3VzdG9tQWN0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY3VzdG9tQWN0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgZWRpdGluZyBzdGF0ZSBiYWNrIHRvIG5vbi1lZGl0YWJsZVxuICAgICAqL1xuICAgIGNvbXBsZXRlRWRpdGluZygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmVkaXRTdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uRWRpdGluZ0NvbXBsZXRlLmVtaXQodGhpcy5lZGl0U3RhdGUpO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdWJzZWN0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJzdWJzZWN0aW9uLXRpdGxlXCI+e3t0aXRsZX19PC9oND5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgICBgLFxuICAgIHN0eWxlczogWycuc3Vic2VjdGlvbi10aXRsZSB7Y29sb3I6ICMzNjM2MzY7IH0nXVxufSlcbmV4cG9ydCBjbGFzcyBTdWJTZWN0aW9uQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBzdWIgc2VjdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcbn1cblxuXG4vKipcbiAqIERlZmluZXMgZWRpdGluZyBtb2RlcyBmb3IgdGhlIFNlY3Rpb25zLiBEZWZhdWx0IG1lYW5zIHdlIHNob3cgY2FuY2VsIC8gc2F2ZSBidXR0b25zIGFuZCBoaWRlXG4gKiBlZGl0IGljb25zIHdoZW4gaW4gZWRpdGluZy4gZXh0ZXJuYWwgaXMgZHJpdmVuIGJ5IGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIEVkaXRNb2RlID0gJ2RlZmF1bHQnIHwgJ2V4dGVybmFsJztcblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBcmliYUNvcmVNb2R1bGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FjY29yZGlvbk1vZHVsZSwgU2hhcmVkTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtTZWN0aW9uQWN0aW9uc0NvbXBvbmVudCwgU2VjdGlvbkNvbXBvbmVudCwgU3ViU2VjdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9zZWN0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuLi9oeXBlcmxpbmsvaHlwZXJsaW5rLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgICAgIEFyaWJhQ29yZU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBTaGFyZWRNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1NlY3Rpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIElucHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QVdEYXRhVGFibGV9IGZyb20gJy4uL2F3LWRhdGF0YWJsZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7Qm9vbGVhbldyYXBwZXIsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5leHBvcnQgdHlwZSBEVEhBbGlnbm1lbnQgPSAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCc7XG5cblxuLyoqXG4gKiBEVENvbHVtbiByZXByZXNlbnQgc2luZ2xlIGNvbHVtbiBpbmNsdWRpbmcgaGVhZGVyIGFuZCBpdHMgYm9keS4gRWFjaCBjb2x1bW4gaGFzIGl0cyBvd25cbiAqIHJlbmRlcmVyVGVtcGxhdGUgd2hpY2ggYSBlbnRyeSB0byB0aGlzIGNvbXBvbmVudC5cbiAqXG4gKiBLZWVwaW5nIHRoaXMgc2VwYXJhdGUgZnJvbSB0aGUgZGF0YXRhYmxlIHdoZXJlIERUIGlzIG5vdCByZWFsbHkgYXdhcmUgd2hhdCBpdCBpcyByZW5kZXJpbmcsXG4gKiBpdCBhbGxvd3MgdXMgbW9yZSBmbGV4aWJpbGl0eSBpbiB0ZXJtcyBvZiBkaWZmZXJlbnQgdHlwZSBvZiBjb2x1bW4gaW5oZXJpdGluZyBmcm9tIHRoaXNcbiAqIG9uZS4uIFN1Y2ggYXM6XG4gKiAgRFRSb3dEZXRhaWwgIGNvbHVtblxuICogIERUU2luZ2xlU2VsZWN0aW9uIGNvbHVtblxuICogIERUTXVsdGlTZWxlY3Rpb24gY29sdW1uXG4gKlxuICogVGhpcyB3YXkgd2UgZG9uJ3QgZG8gSUYvVEhFTi9FTFNFIGluc2lkZSB0aGUgZGF0YXRhYmxlIGFuZCB0cnlpbmcgdG8gY3JlYXRlIGRpZmZlcmVudCBjYXNlcy5cbiAqXG4gKiAgVGhlbiBsYXRlciBvbiB0aGlzIHdpbGwgbGV0IHVzIGNyZWF0ZSBhZGRpdGlvbmFsIGxvZ2ljIGZvciB0aGUgcGl2b3RhbCBsYXlvdXQuIEJlY2F1c2UgRFRcbiAqICBkb2VzIGtub3cgYW55dGhpbmcgYWJvdXQgdGhlIHR5cGUgb2YgdGhlIGNvbHVtbiBzbyB3aGF0ZXZlciBpcyBhZGRlZCB0byB0aGUgRFQuY29sdW1ucyBpdFxuICogIHdpbGwgYmUgcmVuZGVyZWQuXG4gKlxuICpcbiAqICBDb2x1bW5zIGNhbiBiZSBhbHNvIGZyb3plbiBtZWFuaW5nIGlmIHRoZSBjb250ZW50IG92ZXJmbG93cyB0aGV5IGRvbnQgc2Nyb2xsLiBUbyBtYWtlIHRoZVxuICogIGNvbHVtbiBmcm96ZW4gd2UgbmVlZCB0byB1c2UgW2Zyb3plbl0gYmluZGluZyBhbmQgc2UgaXQgdG8gVFJVRSBwbHVzIGl0IHJlcXVpcmVzIGEgW3dpZHRoXVxuICogIGJpbmRpbmcgdG8gYmUgc2V0IChpbiBweCkuXG4gKiAgV2UgbmVlZCB0aGlzIHRvIGJlIGFibGUgdG8gcHJvcGVybHkgcG9zaXRpb24gdGhlIHNlY29uZCB0YWJsZSB3aGljaCBpcyBjaGFuZ2VkIHRvIGFic29sdXRlXG4gKiAgcG9zaXRpb25pbmcuXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtY29sdW1uMicsXG4gICAgdGVtcGxhdGVVcmw6ICdkdC1jb2x1bW4uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkdC1jb2x1bW4uY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRDb2x1bW4yQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcbiAgICAvKipcbiAgICAgKiBDb2x1bW4gaGVhZGVyIGxhYmVsLlxuICAgICAqXG4gICAgICogT3IgeW91IGNhbiB1c2UgaGVhZGVyVGVtcGxhdGUgdG8gZGVmaW5lIHlvdXIgb3duIHRlbXBsYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBmaWVsZCBuYW1lIHRvIHJlYWQgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBrZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2VsbCBhbGlnbm1lbnQuIEl0IGluc2VydHMgcmVndWxhciBhbGlnbiBhdHRyaWJ1dGUgdG8gdGhlIHRhYmxlIGNlbGxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ246IERUSEFsaWdubWVudCA9ICdsZWZ0JztcblxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGR5bmFtaWMgY2xhc3MgYmFzZWQgb24gZGF0YSBhbmQgdGhlbiBpdHMgYWRkZWQgdG8gdGhlIHRhYmxlIGNlbGwgVERcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHlDbGFzc0ZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJZiBmYWxzZSBhcHBsaWVzIGR0LWlzLWhpZGRlbiBzdHlsZSB0aGF0IGhpZGVzIHRoZSBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNvbHVtbiBhcyBzb3J0YWJsZSB3aGljaCBtZWFucyBzb3J0aW5nIGljb24gaXMgYWRkZWQgdG8gdGhlIGhlYWRlciB3aXRoIHNwZWNpYWxcbiAgICAgKiBzb3J0aW5nIGhhbmRsaW5nXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzb3J0YWJsZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogU29ydGluZyBkaXJlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc29ydE9yZGVyaW5nOiBzdHJpbmcgPSAnZGVzY2VuZGluZyc7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgdGVtcGxhdGUgaWYgd2hldGhlciB0byByZW5kZXIgYSBsYWJlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Q29sdW1uTGFiZWw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1N1YkhlYWRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0YXRpYyBjbGFzcyB0aGF0IGlzIGFkZGVkIHRvIHRoZSBUSCBpbnRvIHRoZSBoZWFkZXIuIEl0IGRvZXMgbm90IHJlbHkgb24gZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWFkZXJTdHlsZUNsYXNzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0YXRpYyBjbGFzcyB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0ZCBpbnRvIHRoZSBib2R5LiBJdCBkb2VzIG5vdCByZWx5IG9uIGRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keVN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB0b2dldGhlciB3aXRoIGNlbGwgc2VsZWN0aW9uTW9kZSB0byB0ZWxsIHdoaWNoIGNvbHVtbiBpcyBzZWxlY3RhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFVzZSBnbG9iYWxseSBkZWZpbmVkIEhFQURFUiB0ZW1wbGF0ZSBmb3IgY3VycmVudCBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlR2xvYmFsSGVhZGVyOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFVzZSBnbG9iYWxseSBkZWZpbmVkIFN1YkhlYWRlciB0ZW1wbGF0ZSBmb3IgY3VycmVudCBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlR2xvYmFsU3ViSGVhZGVyOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFVzZSBnbG9iYWxseSBkZWZpbmVkIGJvZHkgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlR2xvYmFsQm9keTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBjb2x1bW4gaXMgZGF0YSBjb2x1bW4gIC0gaWYgaXQgaXMgcmVuZGVyaW5nIGRhdGEgb3IganVzdCBhIGxhYmVsIG9yIHNvbWVcbiAgICAgKiBjb250cm9sXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGltcG9ydGFudCB3aGVuIGNhbGN1bGF0aW5nIGEgY29sdW1uIHNwYW4gYW5kIHdlIG5lZWQgdG8ga25vdyB3aGljaCBjb2x1bW5zIGFyZSBvclxuICAgICAqIHdpbGwgYmUganVzdCBmb3Igc2VsZWN0aW9uIGNvbnRyb2xzIGFuZCB3aGljaCBob2xkcyBkYXRhXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc0RhdGFDb2x1bW46IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyBjb2x1bW4gdGhhdCB3aWxsIG5vdCBzY3JvbGwgaG9yaXpvbnRhbGx5IHdpdGggb3RoZXIgY29sdW1ucy4gQ29sdW1uIGlzXG4gICAgICogZnJvemVuLlxuICAgICAqXG4gICAgICogRm9yIHN1Y2ggY29sdW1ucyB0aGF0IGFyZSBtYXJrZWQgYXMgZnJvemVuIGJpbmRpbmcgW3dpZHRoXSBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZnJvemVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBNYXggV2lkdGggZm9yIHRoZSBURC4gRXZlbiBURCBkb2VzIG5vdCBzdXBwb3J0IHdlIGNhbGN1bGF0ZSB0aGUgY29udGVudCB3aWR0aFxuICAgICAqIGZvciBlYWNoIGNlbGwgYW5kIHRoZW4gZGVjaWRlIGlmIHdlIG5lZWQgdG8gZW5sYXJnZSB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogQEV4cGVyaW1hbnRhbCBiaW5kaW5nIHRoYXQgaXMgY3VycmVudGx5IHdvcmtpbmcgaWYgdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGwgaXMgaW5saW5lXG4gICAgICogZWxlbWVudCB3aGVyZSB3ZSBjYW4gY29udHJvbCB3aGl0ZXNwYWNlIHdyYXBwaW5nIGluIG9yZGVyIHRvIGZpbmQgb3V0IHRoZSByZWFsIHdpZHRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhXaWR0aDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaW5XaWR0aCBvbiB0aGUgY2VsbC4gQWdhaW4ganVzdCBsaWtlIG1heFdpZHRoIGNzcyBwcm9wZXJseSBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAgICogdGhlIHRhYmxlIHNvIHRoZXJlIGlzIGEgd29ya2Fyb3VuZCB3aGVyZSB3ZSBjcmVhdGUgYWRkaXRpb25hbCByb3cgdGhhdCBzZXRzIHBhZGRpbmcgcmlnaHRcbiAgICAgKiBhbmQgdGhpcyB3aWxsIHByZXZlbnQgdGhlIGNvbHVtbiB0byBjb2xsYXBzZSB1bmRlciBzcGVjaWZpZWQgd2lkdGhcbiAgICAgKlxuICAgICAqIHRvZG86IHN0aWxsIFRCRFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluV2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE1haW4gcmVuZGVyaW5nIHRlbXBsYXRlIHVzZWQgYnkgZGF0YXRhYmxlIHRvIHJlbmRlciBlYWNoIGNvbHVtbi5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdyZW5kZXJpbmdUZW1wbGF0ZScpXG4gICAgcmVuZGVyZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBoZWFkZXIgdGVtcGxhdGUuIEl0IHdpbGwgb3ZlcnJpZGUgcHJvdmlkZWQgbGFiZWxcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdoZWFkZXInKVxuICAgIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHN1YkhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdzdWJIZWFkZXInKVxuICAgIHN1YkhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGJvZHkgdGVtcGxhdGUgdGhhdCB3aWxsIG92ZXJyaWRlIHJlYWQgdmFsdWUgZnJvbSB0aGUgW2tleV0gYmluZGluZ1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JvZHknKVxuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuLi5cbiAgICAgKi9cbiAgICBzb3J0T3JkZXI6IG51bWJlcjtcbiAgICBtYXhXaWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIG1pbldpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgd2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICB3aWRlc3RDZWxsOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIERhdGF0YWJsZSBJbXBsZW1lbnRhdGlvbnNcbiAgICAgKi9cbiAgICBkdDogQVdEYXRhVGFibGU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5rZXkpICYmIGlzQmxhbmsodGhpcy5sYWJlbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBiaW5kaW5nOiAnICtcbiAgICAgICAgICAgICAgICAnW2tleV0gb3IgW2xhYmVsXSBiaW5kaW5ncyBtdXN0IGJlIHVzZWQgYXQgbWluaW11bScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gYmUgYWJsZSB0byBwb3NpdGlvbiBzZWNvbmQgRFQgd2UgcmVxdWlyZSBbd2lkdGhdIHRvIGJlIHNldCBhcyB3ZWxsXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiAmJiBpc0JsYW5rKHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYmluZGluZyBbd2lkdGhdOiAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBbZnJvemVuXT10cnVlIHRoZW4gW3dpZHRoXSBiaW5kaW5nIG5lZWRzIHRvIGJlIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gbmVlZCB0byBkZWZmZXIgdGhpcyBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIG90aGVyd2lzZSBJIGdldFxuICAgICAgICAvLyB2YWx1ZSB3YXMgY2hhbmdlZCBhZnRlciBpdCB3YXMgY2hlY2tlZCBlcnJvclxuICAgICAgICAvLyBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIC8vIHtcblxuICAgICAgICAvLyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gY2VsbCBzZWxlY3Rpb25Nb2RlIGlzIGVuYWJsZWQgdGhpcyBtZXRob2QgaXMgdHJpZ2dlcmVkIHdoZW4gd2UgY2xpY2sgb24gaGVhZGVyLlxuICAgICAqIEl0IGRlbGVnYXRlcyB0aGUgY2FsbCB0byB0aGUgRFQgd2hlcmUgaXQgdG9nZ2xlcyBjdXJyZW50bHkgc2VsZWN0ZWQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZUhlYWRlckNsaWNrKGV2ZW50OiBhbnksIGVsZW1lbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyU2VsZWN0YWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmR0Lm9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVG9kbzogSW1wbGVtZW50IG91ciBvd24gc29ydGluZyBtZWNoYW5pc20gb25jZSB3ZSBleHRyYWN0IHRoZSBzb3J0aW5nIGxvZ2ljIHRvIGl0cyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnQoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC11LXNvcnRhYmxlJykgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtY29sLXRpdGxlJykgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtY29sLXNvcnRhYmxlLWljb24nKSlcbiAgICAgICAge1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5kdC5zb3J0Q29sdW1uLmtleSA9PT0gdGhpcy5rZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuc29ydE9yZGVyICogLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXJpbmcgPSB0aGlzLmR0LnNvcnRPcmRlcmluZ0Zvck51bWJlcih0aGlzLnNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5zb3J0Q29sdW1uID0gdGhpcztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLnNvcnRLZXkgPSB0aGlzLmtleTtcbiAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5zb3J0T3JkZXIgPSB0aGlzLmR0LnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLnNvcnRPcmRlcmluZyk7XG5cbiAgICAgICAgICAgIHRoaXMuZHQuc29ydFNpbmdsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHQudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBzdHlsZSBjbGFzcyBiYXNlZCBvbiBkYXRhXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGR5bmFtaWNCb2R5Q2xhc3MoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGR5bkNsYXNzID0gaXNQcmVzZW50KHRoaXMuYm9keUNsYXNzRm4pXG4gICAgICAgICAgICA/IHRoaXMuYm9keUNsYXNzRm4uYXBwbHkodGhpcy5kdC5jb250ZXh0LCBbdGhpcywgaXRlbV0pIDogJyc7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmJvZHlTdHlsZUNsYXNzKSkge1xuICAgICAgICAgICAgZHluQ2xhc3MgKz0gJyAnICsgdGhpcy5ib2R5U3R5bGVDbGFzcztcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICBkeW5DbGFzcyArPSAnICcgKyB0aGlzLnN0eWxlQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHluQ2xhc3M7XG4gICAgfVxuXG5cbiAgICBpc1Jvd1NlbGVjdGFibGUoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LmlzUm93U2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR0LmlzUm93U2VsZWN0YWJsZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc0NlbGxTZWxlY3RhYmxlKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LnNlbGVjdGlvbk1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLmlzUm93U2VsZWN0YWJsZShpdGVtKSAmJiB0aGlzLnNlbGVjdGFibGU7XG5cbiAgICB9XG5cblxuICAgIGlzSGVhZGVyU2VsZWN0YWJsZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5zZWxlY3Rpb25Nb2RlID09PSAnY2VsbCcgJiYgdGhpcy5zZWxlY3RhYmxlO1xuXG4gICAgfVxuXG5cbiAgICBnZXRTb3J0T3JkZXIoKVxuICAgIHtcbiAgICAgICAgbGV0IG9yZGVyID0gMDtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5rZXkgPT09IHRoaXMuZHQuc29ydENvbHVtbi5rZXkpIHtcbiAgICAgICAgICAgIG9yZGVyID0gdGhpcy5kdC5zb3J0Q29sdW1uLnNvcnRPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgaXNTb3J0ZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmR0LnNvcnRDb2x1bW4pICYmIHRoaXMua2V5ID09PSB0aGlzLmR0LnNvcnRDb2x1bW4ua2V5O1xuICAgIH1cblxuICAgIGluaXRpYWxpemUodGFibGU6IEFXRGF0YVRhYmxlKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kdCA9IHRhYmxlO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5pbml0aWFsU29ydEtleSkgJiYgdGhpcy5kdC5pbml0aWFsU29ydEtleSA9PT0gdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXIgPSB0aGlzLmR0LnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLmR0LmluaXRpYWxTb3J0T3JkZXIpO1xuICAgICAgICAgICAgdGhpcy5kdC5zb3J0Q29sdW1uID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYm9keVRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbEJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVRlbXBsYXRlID0gdGhpcy5kdC5ib2R5VGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmhlYWRlclRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbEhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuZHQuaGVhZGVyVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN1YkhlYWRlclRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbFN1YkhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zdWJIZWFkZXJUZW1wbGF0ZSA9IHRoaXMuZHQuc3ViSGVhZGVyVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmJvZHlDbGFzc0ZuKSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5Q2xhc3NGbiA9IHRoaXMuZHQuYm9keUNsYXNzRm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFdpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgdGhpcy5taW5XaWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy5taW5XaWR0aCk7XG4gICAgICAgIHRoaXMud2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMud2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSB2aWV3IGluaXQgY3ljbGUgZnJvbSB0aGUgZHQubmdBZnRlclZpZXdDaGVja2VkLlxuICAgICAqXG4gICAgICogSW4gY2FzZSB3ZSB1c2UgTWF4V2lkdGggZGlyZWN0aXZlIHdlIHNldCBuZXcgd2lkdGggb25jZSBmb3IgYWxsIGNvbHVtc25cbiAgICAgKi9cbiAgICBwb3N0SW5pdGlhbGl6ZShteUluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBjb2xJbmRleCA9IG15SW5kZXggKyAxO1xuICAgICAgICBsZXQgdGFibGU7XG5cbiAgICAgICAgaWYgKHRoaXMuZHQuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICB0YWJsZSA9ICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbFxuICAgICAgICAgICAgICAgIC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LWZyb3plbiB0YWJsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFibGUgPSAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodGhpcy53aWRlc3RDZWxsID4gMCkge1xuICAgICAgICAgICAgbGV0IGFsbCA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyIHRoOm50aC1jaGlsZCgnICsgY29sSW5kZXggKyAnKSwgJyArXG4gICAgICAgICAgICAgICAgJ3RyIHRkOm50aC1jaGlsZCgnICsgY29sSW5kZXggKyAnKScpLmZvckVhY2goKG5vZGU6IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gdGhpcy53aWRlc3RDZWxsICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBZb3UgZWl0aGVyIHVzZSB0aGlzIGJpbmRpbmcgZGlyZWN0bHkgYW5kIHNheSBpdHMgZGF0YWNvbHVtbiBvciB3aGVuIHRoZXJlIGlzIGEgW2tleV1cbiAgICAgKiBiaWRpbmcgd2Uga25vdyBpdCByZWZlcnMgdG8gc29tZSBmaWVsZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzVmFsdWVDb2x1bW4oKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQodGhpcy5pc0RhdGFDb2x1bW4pICYmIEJvb2xlYW5XcmFwcGVyLmlzVHJ1ZSh0aGlzLmlzRGF0YUNvbHVtbikpIHx8XG4gICAgICAgICAgICBpc1ByZXNlbnQodGhpcy5rZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgYXJlIGluIG91dGxpbmUgbW9kZSAgd2UgbmVlZCB0byBhbHNvIGluZGVuZCBlYWNoIHNlbGVjdGlvbiBjb250cm9sIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogaW5kZW50IC0gMSA+IG9ubHkgb2Zmc2V0IHdpdGhcbiAgICAgKiBpbmRlbnRcbiAgICAgKi9cbiAgICBpbmRlbnRGb3JDb250cm9sKGNlbGw6IGFueSwgbGV2ZWw6IG51bWJlcik6IGFueVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZHQuaXNPdXRsaW5lKCkgJiYgbGV2ZWwgPiAwICYmIGNlbGwub2Zmc2V0V2lkdGggPiAwXG4gICAgICAgICAgICAmJiBpc1ByZXNlbnQoY2VsbC5uZXh0RWxlbWVudFNpYmxpbmcpKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGxldCBvdXRsaW5lTm9kZVBhZGRpbmcgPVxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoY2VsbC5uZXh0RWxlbWVudFNpYmxpbmcpLnBhZGRpbmdMZWZ0KSB8fCAwO1xuXG4gICAgICAgICAgICAvLyAxc3QgbGV2ZWwgaXMgcHVzaGVkIGFzIHJvb3RcbiAgICAgICAgICAgIGlmICh0aGlzLmR0LnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobGV2ZWwgPT09IDEpID8gbnVsbCA6ICh0aGlzLmR0LmluZGVudGF0aW9uUGVyTGV2ZWwgKiBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgLSBvdXRsaW5lTm9kZVBhZGRpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5kdC5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpICsgb3V0bGluZU5vZGVQYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgd2lkdGhUb1B4KHdpZHRoOiBzdHJpbmcpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGxldCBweDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh3aWR0aCkpIHtcbiAgICAgICAgICAgIGlmICh3aWR0aC5pbmRleE9mKCclJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9uUGMgPSBwYXJzZUZsb2F0KHdpZHRoKSAvIDEwMDtcbiAgICAgICAgICAgICAgICBweCA9IG5vblBjICogKDxEYXRhdGFibGUyQ29tcG9uZW50PnRoaXMuZHQpLmVsLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB4ID0gcGFyc2VGbG9hdCh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHg7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBkYXRhdGFibGUgaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBEYXRhVGFibGVDb21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWhlYWRlcjInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgRFRIZWFkZXJDb21wb25lbnQyXG57XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdEYXRhVGFibGV9IGZyb20gJy4uLy4uL2F3LWRhdGF0YWJsZSc7XG5cblxuLyoqXG4gKlxuICogQ3VzdG9tIGNvbHVtbiBpbXBsZW1lbnRhdGlvbiB0byByZW5kZXIgZGV0YWlsIHJvdyBzcGFuaW5nIGl0cyBjb2x1bW4gYWNyb3NzIHdob2xlIHRhYmxlIHdpZHRoLlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtZGV0YWlsLWNvbHVtbicsXG4gICAgdGVtcGxhdGVVcmw6ICdkdC1kZXRhaWwtcm93LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZHQtZGV0YWlsLXJvdy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVERldGFpbFJvd0NvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXJyZW50IHZpc2liaWxpdHkgZm9yIGN1cnJlbnQgZGF0YSByb3cgdXNpbmcgbWV0aG9kIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Zpc2libGVGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogdGVsbHMgaWYgd2UgbmVlZCB0byByZW5kZXIgYSBsaW5lIGJldHdlZW4gaXRlbSByb3cgYW5kIGl0cyBkZXRhaWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1Jvd0xpbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8ganVzdCB0byBnZXQgYXJvdW5kIHRoZSBjaGVjayBpbiBwYXJlbnQgY2xhc3NcbiAgICAgICAgdGhpcy5rZXkgPSAnJztcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdlIG5lZWQgdG8ga2VlcCBzb21lIGxlYWRpbmcgVERzXG4gICAgICpcbiAgICAgKi9cbiAgICB2aXNpYmxlTGVhZGluZ0NvbHMoKTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5udW1iZXJPZkNvbHNCZWZvcmVEYXRhIC0gKHRoaXMuZHQuaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCkgPyAxIDogMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHdlIGNhbiBzaG93IGRldGFpbCByb3cvY29sdW1uIHVzaW5nIGVpdGhlciBbaXNWaXNpYmxlXSBvciBbaXNWaXNpYmxlRm5dIGJpbmRpbmdzLlxuICAgICAqIEhlcmUgY2FuIGhvb2sgb24gYXBwbGljYXRpb24gbGV2ZWwgY3VzdG9tIG1ldGhvZCB0byBkZWNpZGUgaWYgY3VycmVudCBpdGVtIGhhcyBkZXRhaWwgcm93XG4gICAgICogb3Igbm90XG4gICAgICpcbiAgICAgKiBPciB3ZSBjYW4gdXNlIGlzVmlzaWJsZT10cnVlIHRvIHRlbGwgYWxsIHJvdyBoYXZlIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dEZXRhaWxSb3coaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaXNWaXNpYmxlRm4pKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZUZuLmFwcGx5KHRoaXMuZHQuY29udGV4dCwgW3RoaXMsIGl0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGl6ZSh0YWJsZTogQVdEYXRhVGFibGUpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKHRhYmxlKTtcblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICF0aGlzLmR0LmlzT3V0bGluZSgpIHx8ICF0aGlzLmR0LnBpdm90YWxMYXlvdXQ7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtZGV0YWlsLWNvbHVtbi1leHBhbmQnLFxuICAgIHRlbXBsYXRlVXJsOiAnZHQtZGV0YWlsLXJvdy1leHBhbmRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyB3ZSBkb250IHdhbnQgdG8gc2hvdyB0aGUgcm93L2NvbHVtbiB1bmxlc3MgYXBwbGljYXRpb24gc2F5cyBzb1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBqdXN0IHRvIGdldCBhcm91bmQgdGhlIGNoZWNrIGluIHBhcmVudCBjbGFzc1xuICAgICAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUudG9nZ2xlKGl0ZW0pO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVTdHlsZUNsYXNzKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChpdGVtKSA/XG4gICAgICAgICAgICAnaWNvbi1zbGltLWFycm93LWRvd24nIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cblxuXG5pbXBvcnQge1RlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U2VsZWN0aW9uTW9kZX0gZnJvbSAnLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7RGV0YWlsUm93RXhwYW5zaW9uU3RhdGUsIERUMkRhdGFTb3VyY2V9IGZyb20gJy4vZGF0YXRhYmxlMi1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZSc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcblxuXG5leHBvcnQgY29uc3QgRHJhZ0V2ZW50czogc3RyaW5nW10gPSBbJ21vdXNlZG93bicsICdkcmFnc3RhcnQnLCAnZHJhZ292ZXInLCAnZHJhZ2VudGVyJywgJ2RyYWdsZWF2ZScsXG4gICAgJ2Ryb3AnLCAnZHJhZ2VuZCddO1xuXG5leHBvcnQgZW51bSBEcmFnRGlyZWN0aW9uXG57XG4gICAgTm9uZSA9ICdub25lJyxcbiAgICBVcCA9ICdkdC1kcmFnLXJvdy10b3AnLFxuICAgIERvd24gPSAnZHQtZHJhZy1yb3ctYm90dG9tJyxcbiAgICBNaWRkbGUgPSAnZHQtZHJhZy1yb3ctYm90aCdcbn1cblxuXG5leHBvcnQgZW51bSBEcm9wUG9zaXRpb25cbntcbiAgICBCZWZvcmUgPSAnYmVmb3JlJyxcbiAgICBBZnRlciA9ICdhZnRlcicsXG4gICAgSW50byA9ICdpbnRvJ1xufVxuXG5cbi8qKlxuICogQWJzdHJhY3QgdHlwZSB0aGF0IGlzIHNoYXJhYmxlIGFtb25nIGRlcGVuZGFudCBEVCBvYmplY3Qgc3VjaCBhcyBDb2x1bW5zLCBEYXRhU291cmNlcyxcbiAqIERpcmVjdGl2ZXMgdG8gYmUgYWJsZSB0byBjb21tdW5pY2F0ZSBiYWNrIHRvIHRoZSBkYXRhdGFibGUgbWFpbmx5IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBV0RhdGFUYWJsZVxue1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBwYXNzIHlvdXIgb3duIGRhdGFzb3VyY2UgdG8gb3ZlcnJpZGUgZGVmYXVsdCBvbmUuIEFsc28gd2hlbiBkYXRhU291cmNlIGlzXG4gICAgICogdXNlZCB0aGUgZGVzdGluYXRpb25DbGFzcyBvciBsaXN0IGFyZSBpZ25vcmVkXG4gICAgICovXG4gICAgZGF0YVNvdXJjZTogRFQyRGF0YVNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgb3V0bGluZSBzdGF0ZXMgZm9yIERhdGF0YWJsZXMgdXNpbmcgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2UgaGF2ZSBkZXRhaWwgcm93IHJlbWVtYmVyIGl0cyBleHBhbnNpb24gc3RhdGVcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTogRGV0YWlsUm93RXhwYW5zaW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGNvbHVtbiBpcyB1c2VkIGFzIGZpcnN0IGZvciBzb3J0aW5nXG4gICAgICovXG4gICAgaW5pdGlhbFNvcnRLZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEFsbG93IHRvIGNoYW5nZSBzb3J0aW5nIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGluaXRpYWxTb3J0T3JkZXI6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgRFQgaWYgd2Ugc3VwcG9ydCBjZWxsIHNlbGVjdGlvbiBvciByb3cgYmFzZWQgc2VsZWN0aW9uIHdoaWNoIGlzIHJlZ3VsYXIgRFQuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBzaW5nbGUgb3IgbXVsdGlzZWxlY3Rpb24gc2hvdyBjb250cm9sc1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHdhbnQgdG8gcmVuZGVyIG9uZSBzZWxlY3Rpb24gY29udHJvbCBpbiB0aGUgaGVhZGVyIHRvIHNlbGVjdCBhbGwgdGhlXG4gICAgICogcm93cy4gQXBwbGljYWJsZSBmb3IgbXVsdGlzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTZWxlY3RBbGw6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSBpZiByb3cgb3IgY2VsbCBpcyBzZWxlY3RhYmxlIGJhc2VkIG9uIGRhdGFcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGFibGU6IChpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIEVhY2ggRFRDb2x1bW4gaGF2ZSBoYXZlIGl0cyBvd24gdGVtcGxhdGUgdG8gcHJvdmlkZSBjb250ZW50IGZvciBoZWFkZXIsIHN1YmhlYWRlciBhbmRcbiAgICAgKiBib2R5IGJ1dCBpZiB0aG9zZSB0ZW1wbGF0ZSBhcmUgaWRlbnRpY2FsIHRoZXJlIHdvdWxkIGJlIHRvbyBtdWNoIGR1cGxpY2F0ZSBjb2RlIHRvIHJlcGxpY2F0ZVxuICAgICAqIGZvciBlYWNoIGNvbHVtbiB0aGUgc2FtZS4gVGhlcmVmb3JlIHdlIGhhdmUgdGhlc2UgZ2xvYmFsIHRlbXBsYXRlcyB0aGF0IHlvdSBjYW4gZGVjbGFyZVxuICAgICAqIG9uIERUIGxldmVsIChub3QgdW5kZXIgY29sdW1ucykgYW5kIGNvbnRlbnQgb2YgdGhlc2UgdGVtcGxhdGUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIGNvbHVtblxuICAgICAqXG4gICAgICogWW91IGNhbiBtaXggdGhlbSBhcyB3ZWxsLiBZb3UgY2FuIGhhdmUgZ2xvYmFsIHRlbXBsYXRlcyBhcyB3ZWxsIGFzIHRlbXBsYXRlIG9uIHRoZSBDb2x1bW5cbiAgICAgKiBsZXZlbCB3aGljaCB3b3VsZCBvdmVycmlkZSB0aGUgZ2xvYmFsIG9uZVxuICAgICAqXG4gICAgICovXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIHN1YkhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVuZGVyIGEgc3ViSGVhZGVyIHRlbXBsYXRlIGlmIHByZXNlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGdsb2JhbCBzdHlsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBib3VuZCB0byB0YWJsZSBhbmQgcmVhZCBieSBlYWNoIGNvbHVtbi5cbiAgICAgKiBUaGUgc2FtZSB5b3UgY2FuIHNlZSBvbiB0aGUgRFRDb2x1bW5cbiAgICAgKi9cbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBpbXBvcnRhbnQgd2hlbiB3ZSBleGVjdXRlIGFueSBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCBpbiBhcyBpbnB1dC4gV2UgbmVlZCB0b1xuICAgICAqIGdpdmUgb3B0aW9uIHRvIGJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgY29udGV4dCAodGhpcykgb2YgdGhlIGNvZGUgdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb250ZXh0OiBhbnk7XG5cbiAgICAvLyBPdXRsaW5lIG5lZWRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgb3V0bGluZUZvciBzZWN0aW9uIG9uIHRoZSBuZXcgbGluZSBhbmQgMm5kIGxldmVsIGNoaWxkIG1ha2UgaXQgcm9vdCBmb3IgdGhpc1xuICAgICAqIHNlY3Rpb25cbiAgICAgKi9cbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGNoYW5nZSBkZWZhdWx0IGluZGVudGF0aW9uIGZvciB0aGUgb3V0bGluZSBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBhY3RpdmUgYXBwbGllcyBzcGVjaWFsIHN0eWxlcyB0byB0aGUgRFQuIExhdGVyIG9uIG9uY2UgcGl2b3QgaXMgaW1wbGVtZW50ZWQgdGhpcyB3aWxsXG4gICAgICogYWxzbyBhZGQgYWRkaXRpb25hbCBiZWhhdmlvciB0byB0aGUgRFRcbiAgICAgKlxuICAgICAqL1xuICAgIHBpdm90YWxMYXlvdXQ6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gc29ydGluZyBpcyBlbmFibGVkIHRoaXMgaXMgY3VycmVudCBhY3RpdmUgY29sdW1uIGJlaW5nIHNvcnRlZC5cbiAgICAgKlxuICAgICAqICAtIHdlIGRvbnQgc3VwcG9ydCBtdWx0aXBsZSBjb2x1bW4gc29ydGluZ1xuICAgICAqL1xuICAgIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBhdy1kdC1kZXRhaWwtY29sdW1uIGlmIHByZXNlbnQgZGV0YWlsIHJvdyBpcyByZW5kZXJlZCBmb3Igc3BlY2lmaWVkXG4gICAgICogaXRlbXNcbiAgICAgKi9cbiAgICByb3dEZXRhaWxDb2x1bW46IERURGV0YWlsUm93Q29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3BhbmluZyBjYWxjdWxhdGlvbiBvciBmb3IgdGhlIGRldGFpbCByb3cgdG8gaWRlbnRpZnkgY29ycmVjdCBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqIHRvIHNwYW4sIHdoZW4gdGhleSBhcmUgc29tZSBub24tZGF0YSBjb2x1bW4gKGV4cGFuc2lvbiBjb250cm9sLCBzaW5nbGUvbXVsdGkgc2VsZWN0aW9uKVxuICAgICAqL1xuICAgIG51bWJlck9mQ29sc0JlZm9yZURhdGE6IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogIHdoYXQgaXMgdGhlIGluZGV4IG9mIGZpcnN0IGRhdGEgY29sdW1uc1xuICAgICAqL1xuICAgIHN0YXJ0T2ZGaXJzdERhdGFDb2x1bW46IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gaW4gY2VsbCBzZWxlY3Rpb24gbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBjb2x1bW4gd2hlIGhlYWRlciBpcyBzZWxlY3RlZC4gQ3VycmVudCB3ZSBhc3N1bWUgdGhlIG9ubHkgb25lIGhlYWRlciBjYW4gYmVcbiAgICAgKiBzZWxlY3RlZCBhdCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQpOiB2b2lkO1xuXG5cbiAgICBvbkhhbmRsZVJvd0NsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSGFuZGxlcyByb3cgc2VsZWN0aW9uIGxvZ2ljIHdoZXJlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluc2lkZSB0aGUgc2VsZWN0ZWQgaXRlbXMsIHRoZW5cbiAgICAgKiBpdHMgcmVtb3ZlZCBvdGhlcndpc2UgaXRzIGFkZGVkLlxuICAgICAqXG4gICAgICogVG9kbzogU3luYyAmIHJlZmFjdG9yIHRoaXMgd2l0aCBkdC5vbkNlbGxTZWxlY3Rpb25DaGFuZ2UgLSBwcmV0dHkgc2ltaWxhciBjb2RlXG4gICAgICpcbiAgICAgKiBXZSB3YW50IHRvIGhhdmUgcm93VG9nZ2xlIGFzIHdlbGwgYXMgd2Ugd2lsbCBoYXZlIHJvd1NlbGVjdCBvciBzb21ldGhpZ24gc2ltaWxhciB0b1xuICAgICAqIGlkZW50aWZ5IHdlIGFyZSBkZWFsaW5nIHdpdGggbXVsdGlzZWxlY3QgYW5kIHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBvblJvd1RvZ2dsZShldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgcm93IHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93U2VsZWN0KGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBvdXRsaW5lICh0cmVlKSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3aGVuIHdlIHNlbGVjdCBzb21lIHJvb3QgaXRlbSBpdFxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIHNlbGVjdCBhbGwgaXRzIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEp1c3QgbGlrZSBmb3Igb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbiB0aGUgc2FtZSBiZWhhdmlvciBuZWVkcyB0byBiZSBhcHBsaWVkIGZvclxuICAgICAqIHRvd2FyZHMgdXAuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsbGVkIGJ5IEQmRCByb3cgZGlyZWN0aXZlIHRvIHVwZGF0ZSB0aGlzIFREIHRoYXQgcm93IHJlb3JkZXJpbmcgbmVlZHMgdG8gaGFwcGVuLiBXZVxuICAgICAqIHJlY2VpdmUgYW4gSU5ERVggb2Ygcm93IHdlIGFyZSBkcmFnZ2luZyBhbmQgbmV3IGRyb3AgcG9zaXRpb24sIHBsdXMgaW5mb3JtYXRpb24gaWYgaXRcbiAgICAgKiBuZWVkcyB0byBiZSBkcm9wcGVkIGJlZm9yZSBuZXcgcm93IHBvc2l0aW9uIG9yIGFmdGVyLlxuICAgICAqXG4gICAgICovXG4gICAgb25EbkRSb3dEcm9wKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBkZXRhaWwgcm93IGlzIGNvbWJpbmVkIHdpdGggb3V0bGluZSBjb250cm9sIHdlIG5lZWQgbWFrZSBzdXJlIHRoYXQgd2UgbWFpbnRhaW4gdGhlXG4gICAgICogY29ycmVjdCBzdGF0ZSBmb3IgaXRlbXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqIEluIHRoaXMgc3BlY2lmaWMgY2FzZSB0aGUgZGV0YWlsIHJvdyBkb2VzIG5vdCBoYXZlIGl0cyBvd24gZXhwYW5kZXIgYnV0IHV0aWxpemluZyB0aGVcbiAgICAgKiBvdXRsaW5lQ29udHJvbFxuICAgICAqL1xuICAgIG9uT3V0bGluZUV4cGFuZENoYW5nZShldmVudDogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBmb3Igc2luZ2xlIGNvbHVtbiBzb3J0aW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRTaW5nbGUoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGF0YSBjaGFuZ2VzLCBlaXRoZXIgdGhleSBhcmUgbGF6aWx5IGZldGNoZWQgb3IgQElucHV0IExJU1QgaXMgdXBkYXRlZCB3ZSBuZWVkXG4gICAgICogcmVzb3J0IG91dCBkYXRhIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGUgYW5kIHVwZGF0ZSBpbnRlcm5hbCBsaXN0IGRhdGFUb1JlbmRlciBzbyBuZXdcbiAgICAgKiBkYXRhIGNhbiByZS1yZW5kZXJlZCArIHRyaWdnZXJzIGV2ZW50IHZhbHVlQ2hhbmdlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbmdlKCk6IHZvaWQ7XG5cbiAgICB1cGRhdGVEYXRhVG9SZW5kZXIoZGF0YXNvdXJjZT86IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvciB1bnNlbGVjdCBhbGwgcm93cy4gVXNlZCBieSBoZWFkZXIgY2hlY2tib3hcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUFsbENvbHVtbnMoZXZlbnQ6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBNb3JlIGxpa2UgdXRpbGl0eSBtZXRob2RzIHRvIHRyYW5zbGF0ZSBzdHJpbmc8LS0+bnVtYmVyIHZhbHVlIGZvciBzb3J0aW5nXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgdXNlZCBvbmx5IGJ5IERUQ29sdW1uLiBXZSBtaWdodCB3YW50IHRvIG1vdmUgdGhpcyBpdHMgb3duIGNvbXBvbmVudCBmb3JcbiAgICAgKiBoZWFkZXJTb3J0IGFuZCBvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgc29ydE9yZGVyaW5nRm9yU3RyaW5nKGRpcmVjdGlvbjogc3RyaW5nKTogbnVtYmVyO1xuXG4gICAgc29ydE9yZGVyaW5nRm9yTnVtYmVyKGRpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nO1xuXG4gICAgdmlzaWJsZUNvbHVtbnMoKTogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cbiAgICBoYXNGcm96ZW5Db2x1bW5zKCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBmdW5jdGlvbmFsaXR5IGZvciB0aGUgc2luZ2xlL211bHRpc2VsZWN0IGZ1bmN0aW9uYWxpdHkgd2hlcmUgd2UgbmVlZCB0byB0cmFjayBpZlxuICAgICAqIHdlIHN1cHBvcnQgc2VsZWN0aW9uIHBsdXMgaG93IG1hbnkgY29sdW1uIGl0IG9jY3VwaWVzIGFuZCBpZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xzIGFyZVxuICAgICAqIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAqL1xuICAgIGhhc0ludmlzaWJsZVNlbGVjdGlvbkNvbHVtbigpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBsYWNlaG9sZGVyIHRvIGlkZW50aWZ5IGlmIHRoZXkgYXJlIG5vbi12YWx1ZSBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogVG8gY29tcGFyZSB0aGUgZGF0YSBpZiB3ZSB1c2UgZGVlcCBvYmplY3QgZXF1YWxpdHkgYW5kIHRoaXMgaXMgdXNlZCB3aXRoaW4gdGhpcyBjbGFzcyBhc1xuICAgICAqIHdlbGwgYXMgZnJvbSB0aGUgRFRDb2x1bW4gdG8gY29uZGl0aW9uYWxseSBhZGQgY2xhc3Mgd2hpY2ggc2VsZWN0IHRoZSBjZWxsXG4gICAgICpcbiAgICAgKiBXZSBtaWdodCB3YW50IHRvIGNoYW5nZSB0byBjaGVjayBvbmx5IGEga2V5IG9mIHRoZSBvYmplY3Qgc29tZSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBpc0hlYWRlclNlbGVjdGVkKGl0ZW06IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpYyBjZWxsIGlzIHNlbGVjdGVkLiBXZSBuZWVkIHR3byBwb2ludHMgdG8gaWRlbnRpZnkgaWYgY2VsbCBpcyBzZWxlY3RlZFxuICAgICAqIHRoZSBhY3R1YWwgSXRlbSB0aGF0IGNvdWxkIHJlcHJlc2VudCB3aG9sZSByb3cgYW5kIENvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgaXNCb2R5Q2VsbFNlbGVjdGVkKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogIENoZWNrIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGFtb25nIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkKGl0ZW06IGFueSk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gW2NoaWxkcmVuXSBiaW5kaW5nIGlzIHByZXNlbnQgdGhlbiBpdCBtZWFucyB3ZSBuZWVkIHRvIHJlbmRlciBpdCBhcyBhIHRyZWVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzT3V0bGluZSgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRoZSBjaGVja2JveCB0byBlaXRoZXIgc2VsZWN0ZWQgYW5kIG5vdCBzZWxlY3RlZCBkZXBlbmRlZCBvbiBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpOiBib29sZWFuO1xuXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5EaXNhYmxlZCgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZXMgYXJlIGZpZWxkIHBhdGggdXRpbGl0eSBjbGFzcyB0byByZXRyaWV2ZSBkYXRhIGZyb20gb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShkYXRhOiBhbnksIGZpZWxkOiBzdHJpbmcpOiBhbnk7XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgRW50aXR5LFxuICAgIGlzQmxhbmssXG4gICAgaXNFbnRpdHksXG4gICAgaXNQcmVzZW50LFxuICAgIGlzU3RyaW5nLFxuICAgIExpc3RXcmFwcGVyLFxuICAgIE1hcFdyYXBwZXJcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEYXRhU291cmNlLCBEU0luaXRQYXJhbXN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdEYXRhVGFibGUsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi9hdy1kYXRhdGFibGUnO1xuXG5cbi8qKlxuICogQ29uY3JldGUgRGF0YVNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgRGF0YXRhYmxlIHdoaWNoIGRlZmluZXMgc3RhdGUgYW5kIGNvbHVtbiBkZWZpbml0aW9uIHRoYXRcbiAqIGNhbiBwcm9ncmFtbWF0aWNhbGx5IG1vZGlmeSByZW5kZXJlZCBjb2x1bW5zIChpZiBwcm92aWRlZCkgYW5kIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuZFxuICogYW5kIGRlbGV0aW5nIHJlY29yZHM7XG4gKlxuICogQWxsIG9wZXJhdGlvbnMgZGVhbGluZyB3aXRoIGRhdGEgdXNlIE9ic2VydmFibGU8VD4gYW5kIGluc3RhbnQoKSBtZXRob2QgdG8gcmV0cmlldmUgY3VycmVudFxuICogc3RhdGUgaXMgbm90IGltcGxlbWVudGVkLlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBEVDJEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZVxue1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMaW1pdCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIGRhdGFQcm92aWRlcnMgYW5kIGZpbmRlcnNcbiAgICAgKi9cbiAgICBkYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuICAgIGRhdGFGaW5kZXI6IERhdGFGaW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZGF0YXRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IERhdGF0YWJsZTJTdGF0ZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGRlYnVnVGltZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgb2JqZWN0IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbnRpdHk6IEVudGl0eURlZjI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHB1YmxpYyBmaW5kZXJzPzogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgICAgICBzdXBlcihkYXRhUHJvdmlkZXJzLCBmaW5kZXJzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgpO1xuXG4gICAgICAgIHRoaXMuZGVidWdUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG5cbiAgICBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoYXJncykgfHwgYXJncy5sZW5ndGggIT09IDEgJiYgIWlzRFRJbml0UGFyYW1zKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIGluaXRpYWxpemUgRFMgd2l0aCAoRFNDaG9vc2VySW5pdFBhcmFtcyknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdDogRFREU0luaXRQYXJhbXMgPSBhcmdzWzBdO1xuXG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBvciBmaW5kIGJlc3QgbWF0Y2ggZm9yIGRhdGFQcm92aWRlclxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IGlzUHJlc2VudChpbml0LmRhdGFQcm92aWRlcikgPyBpbml0LmRhdGFQcm92aWRlclxuICAgICAgICAgICAgOiB0aGlzLmRhdGFQcm92aWRlcnMuZmluZChpbml0Lm9iaik7XG5cbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIG9yIGZpbmQgYmVzdCBtYXRjaCBmb3IgZGF0YUZpbmRlclxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhRmluZGVyKSA/IGluaXQuZGF0YUZpbmRlclxuICAgICAgICAgICAgOiB0aGlzLmZpbmRlcnMuZmluZCh0aGlzLmRhdGFQcm92aWRlciwgaW5pdC5xdWVyeVR5cGUpO1xuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kYXRhUHJvdmlkZXIpICYmIGlzUHJlc2VudCh0aGlzLmRhdGFGaW5kZXIpLFxuICAgICAgICAgICAgJ0RhdGFTb3VyY2UgaW5jb3JyZWN0bHkgaW5pdGlhbGl6ZWQuIChEYXRhUHJvdmlkZXIsIERhdGFGaW5kZXIpIG1pc3NpbmcuICcpO1xuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICAgICAgaWYgKGlzQmxhbmsoaW5pdC5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gaW5pdC5zdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXN5bmMgZmV0Y2ggZGF0YSByZXF1ZXN0IGFuZCByZXN1bHQgaXMgZ2l2ZW4gYmFjayB1c2luZyBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoKHdpdGhQYXJhbXM/OiBEYXRhdGFibGUyU3RhdGUpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh3aXRoUGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gbmV3IE1hcCgpLnNldCgnb2Zmc2V0Jywgd2l0aFBhcmFtcy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgLnNldCgnbGltaXQnLCB3aXRoUGFyYW1zLmxpbWl0KVxuICAgICAgICAgICAgICAgIC5zZXQoJ29yZGVyYnknLCB3aXRoUGFyYW1zLnNvcnRLZXkpXG4gICAgICAgICAgICAgICAgLnNldCgnc2VsZWN0b3InLCB3aXRoUGFyYW1zLnNvcnRPcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5mZXRjaChwYXJhbXMpLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHdpdGhQYXJhbXMub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmNyRGF0YSA9IFsuLi50aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpLCAuLi5yZXN1bHRdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoaW5jckRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVzZXMgdGhpcyBtZXRob2QgdG8gb3BlbiB1cCBjb250aW51b3VzIHN0cmVhbSB0byBsaXN0ZW4gZm9yIGFueSBjaGFuZ2VzIHdoaWNoXG4gICAgICogbmVlZCB0byBiZSByZWZsZWN0ZWQgb24gdGhlIFVJLlxuICAgICAqXG4gICAgICogRG9udCBmb3JnZXQgdG8gdW5zdWJzY3JpYmUgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSWYgQ1JVRCBpcyBlbmFibGVkIHdlIGRlbGVnYXRlIGNhbGxzIHRvIERhdGFQcm92aWRlciB0aGF0IGlzIHJlc3BvbnNpYmxlIHRvIHRlbGwgdGhlXG4gICAgICogZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzIHRoYXQgYXJlIG5ldyBkYXRhLiBJZiBub3QgZW5hYmxlZCB3ZSBoYXZlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aGljaCB3b3JrcyB3aXRoIGxvY2FsIGFycmF5XG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqZWN0OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kYXRhUHJvdmlkZXIuY2FuQ1JVRCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5pbnNlcnQob2JqZWN0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YS5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMuZGF0YVByb3ZpZGVyLm9mZlNjcmVlbkRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGVhc2Ugc2VlIHtAbGluayBpbnNlcnR9IG1ldGhvZFxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlKG9iamVjdDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3ZpZGVyLmNhbkNSVUQoKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIucmVtb3ZlKG9iamVjdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YSwgb2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQodGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byBEYXRhRmluZGVyIHdoaWNoIGNhbiBhY2NlcHQgZWl0aGVyIHBsYWluIHN0cmluZyBvciBNYXAuXG4gICAgICpcbiAgICAgKiBUbyBiZSBhYmxlIHRvIHByb3ZpZGUgY29ycmVjdCBpbnB1dCB3ZSBuZWVkIHRvIGFzayBEYXRhRmluZGVyIGlmIGl0IHN1cHBvcnRzIEZ1bGxUZXh0IGxpa2VcbiAgICAgKiB0eXBlIHF1ZXJ5IG9yIFByZWRpY2F0ZS4gSW4gY2FzZSBvZiBQcmVkaWNhdGUgd2UgYnVpbGQgdGhlIE1hcCB3aXRoIGRpZmZlcmVudCBrZXkvdmFsdWVcbiAgICAgKiBwYWlyc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBmaW5kKHBhdHRlcm4/OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXR0ZXJuKSB8fCBwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZWQgZW1wdHkgc3RyaW5nIHJldHVybiBvcmdpbmFsIGxpc3RcbiAgICAgICAgICAgIHRoaXMuZmV0Y2godGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoUGFyYW06IGFueSA9IHBhdHRlcm47XG4gICAgICAgIGlmICh0aGlzLmRhdGFGaW5kZXIuYWNjZXB0cyh0aGlzLmRhdGFQcm92aWRlciwgUXVlcnlUeXBlLlByZWRpY2F0ZSkpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtID0gbmV3IE1hcCgpLnNldCgncXVlcnknLCBwYXR0ZXJuKS5zZXQoJ2xpbWl0JywgRFQyRGF0YVNvdXJjZS5NYXhMaW1pdCk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnb3JkZXJieScsIHRoaXMuc3RhdGUuc29ydEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnc2VsZWN0b3InLCB0aGlzLnN0YXRlLnNvcnRPcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQoaXNTdHJpbmcocGF0dGVybiksICdDYW5ub3QgcGFzcyBub24tc3RyaW5nIHZhbHVlIHRvIEZ1bGxUZXh0IEZpbmRlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLm1hdGNoPGFueT4oc2VhcmNoUGFyYW0pLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGF0YSBzb3VyY2UgZGVsZWdhdGVzIHRoZSByZXNwb25zaWJpbGl0eSB0byB0aGUgZ2l2ZW4gZGF0YSBwcm92aWRlciB3aGljaCBuZWVkcyB0byBpbXBsZW1lbnRcbiAgICAgKiBzcGVjaWZpYyBzb3J0aW5nIG1lY2hhbmlzbVxuICAgICAqXG4gICAgICogVG9kbzogRXh0ZW5kIHRvIHNvcnQgYnkgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqXG4gICAgICovXG4gICAgc29ydChrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkpIHx8IHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gc29ydE9yZGVyO1xuICAgICAgICB0aGlzLmZldGNoKHRoaXMuc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUGVyc2lzdCBkYiBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlU3RhdGUob2Zmc2V0OiBudW1iZXIsIHNvcnRGaWVsZDogc3RyaW5nLCBzT3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gc09yZGVyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXNodWZmbGVzIGN1cnJlbnQgYXJyYXkgYmFzZWQgb24gbmV3IHJvdyBEJkQgcmVzdWx0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGlmIHdlIG1vdmUgaXRlbSBmcm9tIGJvdHRvbSBvciBmcm9tIHRoZSB0b3AgYW5kIHRoZW4gYWNjb3JkaW5nbHlcbiAgICAgKiBoaWdobGlnaHRpbmcgYSBzcGFjZSBiZXR3ZWVuIHJvd3MuIFdlIG5lZWQgdG8gcmVmbGVjdCB0aGlzIGluIGhlcmUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMTpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBpdCBkb3duIHNvIHRoYXQgeW91IGNhbiBzZWUgYSBkcm9wcGluZyBsaW5lXG4gICAgICogYmV0d2VlbiByb3cgd2l0aCBpbmRleCAyIC0gM1xuICAgICAqXG4gICAgICogMi4gSW4gdGhpcyBjYXNlIHNwbGljZSgpIHN0YXJ0cyBmcm9tIHBvc2l0aW9uIDIgYW5kIGluc2VydCBhbGwgZWxlbWVudHMgYWZ0ZXIgMlxuICAgICAqICAgICAgc3BsaWNlKHN0YXJ0OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiBUW107XG4gICAgICpcbiAgICAgKiAzLiBubyBuZWVkIHRvIHVwZGF0ZSBuZXdQb3NcbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMjpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBhbGwgdGhlIHdheSBkb3duIG9mIHRoZSBEVCBhbmQgbm93IG1vdmUgdGhlXG4gICAgICogcm93IHRvd2FyZCBUT1AgYW5kIHNwYWNlIGJldHdlZW4gcm93cyB3aXRoIGluZGV4IDIgLSAzIGlzIGhpZ2hsaWdodGVkIGFnYWluLlxuICAgICAqXG4gICAgICogMi4gSGVyZSBpcyB0aGUgZGlmZmVyZW5jZSwgYmVmb3JlIHdlIGhpZ2hsaWdodGVkIHJvdyAjMiB3aXRoIGxpbmUgYXQgdGhlIGJvdHRvbSwgbm93XG4gICAgICogaXQgc2VlbXMgdGhlIHNhbWUgYnV0IGl0cyBoaWdobGlnaHRlZCByb3cgIzMgd2l0aCBsaW5lIGF0IHRoZSBUT1AuXG4gICAgICpcbiAgICAgKiAqIFRoaXMgaXMgdGhlIHJlYXNvbiB3aGV5IHdlIG5lZWQgdG8gZG8gbmV3UG9zIC09IDEgb3IgbmV3UG9zICs9IDE7IGRlcGVuZGluZyBvdXIgZGlyZWN0aW9uXG4gICAgICogd2hlcmUgd2hlcmUgdGhlIGxpbmUgYmV0d2VlbiByb3dzIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IGNvbXBsaWNhdGVkIGNhbGN1bGF0aW9uIHRyeWluZyB0byBmaW5kIG91dCBpZiB3ZSBhcmUgb24gb25lIGhhbGYgb2YgdGhlIHJvd1xuICAgICAqIG9yIHNlY29uZCBoYWxmIGFuZCBiYXNlZCBvbiB0aGlzIHRyeSB0byBhcHBseSBjZXJ0YWluIHN0eWxlLiBUaGlzIHdvdWxkIG5vdCBnaXZlIHNvIG11Y2hcbiAgICAgKiBzcGFjZSBpZiB3ZSB3YW50IGRyb3Agcm93IGludG8gdGhlIHJvdy4gQW5kIHRoZSBjYWxjdWxhdGlvbiB3aXRoIGNvb3JkaW5hdGVzIHdvdWRsIGJlIHRvb1xuICAgICAqIGNvbXBsaWNhdGVkLlxuICAgICAqXG4gICAgICogV2Ugc2ltcGx5IHJlbWVtYmVyIHRoZSBkaXJlY3Rpb24gd2UgYXJlIG1vdmluZyBhbmQgYmFzZWQgb24gdGhpcyB3ZSBhcHBseSBzdHlsZSB0b1xuICAgICAqIHRvIGNyZWF0ZSBhIGxpbmUgYXQgdGhlIFRPUCBpZiB3ZSBhcmUgZ29pbmcgdXB3YXJkcyBvciBib3R0b20gb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW9yZGVyUm93cyhvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgYXJyYXkgPSB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkuc2xpY2UoKTtcblxuICAgICAgICAvLyB0YWtlIHNvbWV0aGluZyBmcm9tIHRvcCBhbmQgZHJhZyZkcm9wIHVuZGVyXG4gICAgICAgIGlmIChuZXdQb3MgPiBvcmlnUG9zICYmIGRyb3BQb3MgPT09IERyb3BQb3NpdGlvbi5CZWZvcmUgJiYgbmV3UG9zIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXdQb3MgLT0gMTtcblxuICAgICAgICAgICAgLy8gdGFrZSBzb21ldGhpbmcgZnJvbSBib3R0b20gYW5kIGRyYWcmZHJvcCBhYm92ZVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IG9yaWdQb3MgJiYgZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyICYmIG5ld1BvcyA+PSAwKSB7XG4gICAgICAgICAgICBuZXdQb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5LnNwbGljZShuZXdQb3MsIDAsIC4uLmFycmF5LnNwbGljZShvcmlnUG9zLCAxKVswXSk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoYXJyYXkpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEVudGl0eSBkZWZpbml0aW9uIHRvIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBwcm9ncmFtbWF0aWNhbGx5IGNvbHVtbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlEZWYyXG57XG4gICAgcHJvcGVydHlLZXlzOiBzdHJpbmdbXTtcblxuICAgIGRlZmF1bHRGb3JtYXR0ZXI6IChrZXk6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgZGlzcGxheVN0cmluZ0ZvcktleTogKGtleTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgICBkZWZhdWx0QWxpZ25tZW50Rm9yS2V5OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbn1cblxuLyoqXG4gKiBLZWVwcyBjdXJyZW50IGRhdGF0YWJsZSBzdGF0ZSB0aGUgc3RhdGUgd2hpY2ggZHJpdmVycyB0aGUgd2F5IHdoaWxlIGZldGNoaW5nIHRoZSBkYXRhIGFzIHdlbGxcbiAqIGVuY2Fwc3VsYXRlIHNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgbmVlZHMgdG8gYmUgcGVyc2lzdGV0IGluIG9yZGVyIHRvIHJlY292ZXIgYSBzdGF0ZSBhZnRlciBlLmcuXG4gKiBicm93c2VyIHJlZnJlc2hcbiAqXG4gKlxuICogdG9kbzogQ3JlYXRlIG1ldGhvZHMgdG8gY29udmVydCB0aGlzIHN0YXRlIGZyb20gYW5kIHRvIEpTT04gZm9yIGVhc2llciBzZXJpYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhdGFibGUyU3RhdGVcbntcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFzY2VuZGluZyA9IDE7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEZXNjZW5kaW5nID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIGZvciBwYWdpbmcgYW5kIGZldGNoaW5nXG4gICAgICovXG4gICAgb2Zmc2V0OiBudW1iZXIgPSAwO1xuICAgIGxpbWl0OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyBkZWZhdWx0IHZhbHVlIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgTiBudW1iZXIgb2Ygcm93cyBpbiBub24tZnVsbHNjcmVlblxuICAgICAqIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlMaW1pdDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc29ydGluZyBmaWVsZFxuICAgICAqL1xuICAgIHNvcnRLZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNvcnRpbmcgb3JkZXIgb2YgdGhlIHNvcnQgZmllbGQuIERhdGFUYWJsZSBzdXBwb3J0IHNvcnRpbmcgZm9yIG11bHRpcGxlIGNvbHVtbiBidXQgd2VcbiAgICAgKiBkb250IHBlcnNpc3QgaXQgbm93LiBNYXliZSBpbiB0aGUgZnV0dXJlXG4gICAgICovXG4gICAgc29ydE9yZGVyOiBudW1iZXIgPSBEYXRhdGFibGUyU3RhdGUuQXNjZW5kaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIHVzaW5nIGdsb2JhbCBmaWx0ZXIgZm9yIGN1cnJlbnQgZGF0YXRhYmxlIHRoZW4gc2F2ZSBpdCBoZXJlXG4gICAgICovXG4gICAgY3VycmVudFNlYXJjaFF1ZXJ5OiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaWYgYW55IHByZXNlbGVjdGVkIGZpbHRlclxuICAgICAqL1xuICAgIGN1cnJlbnRGaWx0ZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudCBjdXJyZW50IHNlbGVjdGlvbiBkZXBlbmRpbmcgb24gc2VsZWN0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBDdXJyZW50IHNlbGVjdGlvbiB1c2VkIGJvdGggZm9yIHJvdyBzZWxlY3Rpb24gYW5kIGNlbGwgc2VsZWN0aW9uLiBSb3cgc2VsZWN0aW9uIGlzIHVzZWQgd2hlblxuICAgICAqIFNpbmdsZVNlbGVjdCBhbmQgTXVsdGlTZWxlY3Qgb25jZSB3ZSBpbXBsZW1lbnQgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGlvbjogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGhlYWRlciBzZWxlY3Rpb24gaXMgZW5hYmxlZCBpdCBjYXB0dXJlcyBjdXJyZW50bHkgc2VsZWN0ZWQgY29sdW1uXG4gICAgICovXG4gICAgaGVhZGVyU2VsZWN0aW9uOiBEVENvbHVtbjJDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEhvbGRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG91dGxpbmUgdHJlZSBpZiB1c2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBvdXRsaW5lU3RhdGU/OiBNYXA8YW55LCBib29sZWFuPjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEhvbGRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRldGFpbCByb3dzIGlmIHVzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlPzogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZVN0YXRlID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKG9mZnNldDogbnVtYmVyID0gMCwgbGltaXQ6IG51bWJlciA9IDE1LCBkaXNwbGF5TGltaXQ6IG51bWJlciA9IDUsXG4gICAgICAgICAgICAgICAgICBzb3J0RmllbGQ6IHN0cmluZyA9ICcnLCBzT3JkZXI6IG51bWJlciA9IDAsIHNlYXJjaFF1ZXJ5Pzogc3RyaW5nLCBmaWx0ZXI/OiBhbnksXG4gICAgICAgICAgICAgICAgICBvdXRsaW5lU3RhdGU6IE1hcDxhbnksIGJvb2xlYW4+ID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCksXG4gICAgICAgICAgICAgICAgICBkZXRhaWxSb3dTdGF0ZTogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSk6IERhdGF0YWJsZTJTdGF0ZVxuICAgIHtcbiAgICAgICAgbGV0IHMgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIHMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHMuZGlzcGxheUxpbWl0ID0gZGlzcGxheUxpbWl0O1xuICAgICAgICBzLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHMuc29ydE9yZGVyID0gc09yZGVyO1xuICAgICAgICBzLmN1cnJlbnRTZWFyY2hRdWVyeSA9IHNlYXJjaFF1ZXJ5O1xuICAgICAgICBzLmN1cnJlbnRGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHMub3V0bGluZVN0YXRlID0gb3V0bGluZVN0YXRlO1xuICAgICAgICBzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gZGV0YWlsUm93U3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21KU09OKGRhdGE6IHN0cmluZyk6IERhdGF0YWJsZTJTdGF0ZVxuICAgIHtcbiAgICAgICAgbGV0IHN0YXRlOiBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgbGV0IGRzID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICBkcy5vZmZzZXQgPSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGRzLmxpbWl0ID0gc3RhdGUubGltaXQ7XG4gICAgICAgIGRzLmRpc3BsYXlMaW1pdCA9IHN0YXRlLmRpc3BsYXlMaW1pdDtcbiAgICAgICAgZHMuc29ydEtleSA9IHN0YXRlLnNvcnRLZXk7XG4gICAgICAgIGRzLnNvcnRPcmRlciA9IHN0YXRlLnNvcnRPcmRlcjtcbiAgICAgICAgZHMuY3VycmVudFNlYXJjaFF1ZXJ5ID0gc3RhdGUuY3VycmVudFNlYXJjaFF1ZXJ5O1xuICAgICAgICBkcy5vdXRsaW5lU3RhdGUgPSBNYXBXcmFwcGVyLmNyZWF0ZUZyb21BbnlNYXA8Ym9vbGVhbj4oc3RhdGUub3V0bGluZVN0YXRlKTtcbiAgICAgICAgZHMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBNYXBXcmFwcGVyLmNyZWF0ZUZyb21BbnlNYXA8Ym9vbGVhbj4oc3RhdGUuZGV0YWlsUm93RXhwYW5kU3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBkcztcbiAgICB9XG5cblxuICAgIHN0YXRpYyB0b0pTT04oZGF0YTogRGF0YXRhYmxlMlN0YXRlKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgdG9Db252ZXJ0OiBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiBkYXRhLm9mZnNldCxcbiAgICAgICAgICAgIGxpbWl0OiBkYXRhLmxpbWl0LFxuICAgICAgICAgICAgZGlzcGxheUxpbWl0OiBkYXRhLmRpc3BsYXlMaW1pdCxcbiAgICAgICAgICAgIHNvcnRLZXk6IGRhdGEuc29ydEtleSxcbiAgICAgICAgICAgIHNvcnRPcmRlcjogZGF0YS5zb3J0T3JkZXIsXG4gICAgICAgICAgICBjdXJyZW50U2VhcmNoUXVlcnk6IGRhdGEuY3VycmVudFNlYXJjaFF1ZXJ5LFxuICAgICAgICAgICAgb3V0bGluZVN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEub3V0bGluZVN0YXRlKSxcbiAgICAgICAgICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEuZGV0YWlsUm93RXhwYW5kU3RhdGUpXG5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRvQ29udmVydCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUaGlzIG5lZWRzIHRvIGdvIHRvIERURGF0YVNvdXJjZSB0byBrZWVwIGFuZCBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBkZXRhaWwgcm93LiBUaGUgaWRlYSBpc1xuICogc2ltcGxlIHdlIGhhdmUgYSBtYXAgaG9sZGluZyBpdGVtIHJlZmVyZW5jZSBhcyBhIGtleSBhbmQgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZVxuICogZGV0YWlsIHJvdyBpcyB2aXNpYmxlXG4gKlxuICogVG9kbzogbW92ZSB0aGlzIG91dCB0byBEU1xuICovXG5leHBvcnQgY2xhc3MgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGVcbntcblxuICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZHQ6IEFXRGF0YVRhYmxlKVxuICAgIHtcbiAgICB9XG5cbiAgICBnZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZXhwYW5zaW9uU3RhdGVzKTtcbiAgICB9XG5cbiAgICBzZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCh2YWx1ZTogYm9vbGVhbilcbiAgICB7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlKGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSB0aGlzLmV4cGFuc2lvblN0YXRlcztcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb2xsYXBzZSBwYXJlbnQgb2YgcGFyZW50IHdoaWxlIGRldGFpbCByb3cgaXMgZXhwYW5kZWRcbiAgICAgICAgaWYgKHRoaXMuZHQuaXNPdXRsaW5lKCkgJiYgIXRoaXMuZHQub3V0bGluZVN0YXRlLmlzRXhwYW5kZWQoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNPdXRsaW5lRXhwYW5kZWQgPSB0aGlzLmR0LmlzT3V0bGluZSgpID8gdGhpcy5kdC5vdXRsaW5lU3RhdGUuaXNFeHBhbmRlZChrZXkpIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChrZXkpICYmIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXRlbVRvS2V5KGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzRW50aXR5KGl0ZW0pID8gKDxFbnRpdHk+aXRlbSkuaWRlbnRpdHkoKSA6IGl0ZW07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXJcbntcbiAgICBvZmZzZXQ6IG51bWJlcjtcbiAgICBsaW1pdDogbnVtYmVyO1xuICAgIGRpc3BsYXlMaW1pdDogbnVtYmVyO1xuICAgIHNvcnRLZXk6IHN0cmluZztcbiAgICBzb3J0T3JkZXI6IG51bWJlcjtcbiAgICBjdXJyZW50U2VhcmNoUXVlcnk6IHN0cmluZztcbiAgICBjdXJyZW50RmlsdGVyPzogYW55O1xuICAgIG91dGxpbmVTdGF0ZTogYW55O1xuICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBhbnk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRFRJbml0UGFyYW1zKGluaXQ6IERURFNJbml0UGFyYW1zKTogaW5pdCBpcyBEVERTSW5pdFBhcmFtc1xue1xuICAgIHJldHVybiBpc1ByZXNlbnQoaW5pdC5vYmopIHx8IGlzUHJlc2VudChpbml0LnF1ZXJ5VHlwZSkgfHwgaXNQcmVzZW50KGluaXQuZW50aXR5KTtcbn1cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEVERTSW5pdFBhcmFtcyBleHRlbmRzIERTSW5pdFBhcmFtc1xue1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGRlZmluaXRpb24gZm9yIHRoZSBkYXRhXG4gICAgICovXG4gICAgZW50aXR5PzogRW50aXR5RGVmMjtcblxuICAgIHN0YXRlPzogRGF0YXRhYmxlMlN0YXRlO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogQ29sdW1uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgTXVsdGlzZWxlY3Rpb24gd2hlcmUgd2Ugc2hvdyBjaGVja2JveCBjb250cm9sXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1tdWx0aS1zZWxlY3QtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkdC1tdWx0aS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBEVENvbHVtbjJDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy53aWR0aCA9ICc0NXB4JztcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogQ29sdW1uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgU2luZ2xlU2VsZWN0IHdoZXJlIHdlIHNob3cgY2hlY2tib3ggY29udHJvbFxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlVXJsOiAnZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkdC1zaW5nbGUtc2VsZWN0LWNvbHVtbi5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqICBAb3JpZ2luYWwtbGljZW5zZVxuICogIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IFByaW1lVGVrXG4gKlxuICogIENyZWRpdDogRGVyaXZlZCBhbmQgZXh0ZW5kZWQgZnJvbSBQcmltZS1uZyBkYXRhYmxlIHdoZXJlIHdlIG5lZWRlZCBtb3JlIG1vZHVsYXIgc29sdXRpb24uXG4gKiAgV2UgcmV1c2VkIHRoZSBjb3JlIHN0cnVjdHVyZSBhbmQgbGF5b3V0IGJ1dCBoYWQgdG8gcmVmYWN0b3IgYm90aCBjb2RlIGFuZCB0ZW1wbGF0ZSB0byBtYXRjaCBvdXJcbiAqICBuZWVkcy4gTW9yZSBpbiB0aGUgZGVzY3JpcHRpb25cbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbmplY3QsXG4gICAgSW5qZWN0b3IsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JqZWN0VXRpbHN9IGZyb20gJ3ByaW1lbmcvY29tcG9uZW50cy91dGlscy9vYmplY3R1dGlscyc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2lzT3V0bGluZU5vZGUsIE91dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZS9pbmRleCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgQm9vbGVhbldyYXBwZXIsXG4gICAgRW52aXJvbm1lbnQsXG4gICAgZXF1YWxzLFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0JsYW5rLFxuICAgIGlzUHJlc2VudCxcbiAgICBMaXN0V3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QVdEYXRhVGFibGUsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi9hdy1kYXRhdGFibGUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YXRhYmxlMlN0YXRlLCBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSwgRFQyRGF0YVNvdXJjZX0gZnJvbSAnLi9kYXRhdGFibGUyLWRhdGEtc291cmNlJztcbmltcG9ydCB7XG4gICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGVsRm9ybWF0fSBmcm9tICcuLi9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdtdWx0aScgfCAnc2luZ2xlJyB8ICdjZWxsJyB8ICdub25lJztcblxuLyoqXG4gKiBEVCBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIHRoZSBkYXRhIGdyaWQgdGhhdCBzaG93cyB0YWJ1bGFyIGRhdGEuIEV2ZW4gdGhlIGJhc2ljXG4gKiBzdHJ1Y3R1cmUgaXMgYmFzZWQgb24gUHJpbWVORyBkYXRhdGFibGUgaXRzIGNvbXBsZXRlbHkgcmVmYWN0b3JlZCBpbnRvIHNtYWxsZXIgcGllY2VzIHRoYXRcbiAqIGFsbG93cyBtb3JlIGV4dGVuc2liaWxpdHkgYW5kIHRyeWluZyB0byBzdGF5IGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGV4aXN0aW5nIEFXTCBpbXBsZW1lbnRhdGlvblxuICpcbiAqIFRoZXJlIGFyZSAzIG1haW4gcGllY2VzOlxuICpcbiAqICBUYWJsZSBXcmFwcGVyIC0gZm9jdXNlcyBvbiB0aGUgb3V0ZXIgc3RydWN0dXJlLiBDb250YWluZXIgd2l0aCBiYXNpYyBkYXRhYmxlIGxheW91dCBwbHVzXG4gKiAgY29udGFpbnMgYW55IGFkZGl0aW9uYWwgcGFuZWxzIHRoYXQgZGF0YXRhYmxlIG5lZWRzIHN1Y2ggYXMgb3VyIG5ldyBjb25jZXB0IGhvdyBlZGl0aW5nIHdpbGxcbiAqICB3b3JrIC0gc2xpZGluZyBwYW5lbCBmcm9tIHRoZSBib3R0b21cbiAqXG4gKiAgRGF0YXRhYmxlIENvbHVtbiAtIEluc3RlYWQgb2YgcmVuZGVyaW5nIGV2ZXJ5dGhpbmcgaW5zaWRlIERUIEkgc3BsaXQgdGhlIHBhcnQgdGhhdCByZW5kZXJzXG4gKiAgY29sdW1uIGludG8gc2VwYXJhdGUgY29tcG9uZW50LiBUaGlzIHdheSBjb21wb25lbnQgY29sdW1uIGhhcyBpdHMgb3duIHJlbmRlcmVyIHRlbXBsYXRlIHdoaWNoXG4gKiAgY2FuIHJlbmRlciBib3RoIGhlYWRlciBhbmQgZGF0YSBjZWxscy5cbiAqICBMYXRlciBvbiBEVENvbHVtbiBpcyB0aGVuIGV4dGVuZGVkIHRvIHN1cHBvcnQgb3RoZXIgYWRkaXRpb25hbCBjb2x1bW4gdHlwZXNcbiAqICBTaW5nbGVTZWxlY3Rpb25Db2x1bW4sIE11bHRpU2VsZWN0aW9uQ29sdW1uLCBib3RoIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbnRyb2xzLlxuICpcbiAqIFRvIHN1cHBvcnQgcGl2b3RhbCBsYXlvdXQgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgZm9yIG90aGVyIGFkZGl0aW9uYWwgY29sdW1ucyB0aGF0IGltcGxlbWVudHMgdGhlaXJcbiAqIG93biByZW5kZXJpbmcgdGVtcGxhdGVzXG4gKlxuICogRGF0YXRhYmxlIC0gVGhlIG1haW4gY29tcG9uZW50IHRoYXQgaXMgb25seSBmb2N1cyBvbiBoZWFkZXIgYW5kIGJvZHkgcmVuZGVyaW5nIGFuZCBiYXNhZWQgb24gdGhlXG4gKiBjb2x1bW4gdHlwZSBpdCB3aWxsIHJlbmRlciB0aGUgY29ycmVjdCB0ZW1wbGF0ZVxuICogY29sdW1uIHR5cGUgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlY3QgdGVtcGxhdGVcbiAqXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRhdGF0YWJsZTInLFxuICAgIHRlbXBsYXRlVXJsOiAnZGF0YXRhYmxlMi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2RhdGF0YWJsZTIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgT2JqZWN0VXRpbHMsXG4gICAgICAgIE91dGxpbmVTdGF0ZSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogRFQyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX0sXG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG5cbn0pXG5leHBvcnQgY2xhc3MgRGF0YXRhYmxlMkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBV0RhdGFUYWJsZSwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiAgTGlzdCBvZiBpdGVtcyB0byBzaG93IGluIHRoZSBkYXRhdGFibGUuXG4gICAgICpcbiAgICAgKiAgdG9kbzogaW1wbGVtZW50IHRoZSBzYW1lIERhdGFzb3VyY2UgYW5kIGxhenkgbG9hZGluZyBqdXN0IGxpa2UgSSBkaWQgaXQgZm9yIGRhdGF0YWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBlbnRpdHkgZm9yIHdoaWNoIERhdGFQcm92aWRlciB3aWxsIGJlIGxvYWRlZC4gWW91IGNhbiBlaXRoZXIgcGFzcyBsaXN0IG9mIGl0ZW1zXG4gICAgICogb3IgdXNlIHRoaXMgZGVzdGluYXRpb25DbGFzcy4gTm90IGJvdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBUYWJsZVdyYXBwZXIgdG8gYWRkIHVzZXIgZGVmaW5lZCBjbGFzIGludG8gdGhlIHRhYmxlIHRhZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YWJsZVN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Jvd1NlbGVjdGFibGU6IChpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqICBIaWRlcyBvciBzaG93cyB0YWJsZSBoZWFkaW5nIHdoZXJlIHdlIGhhdmUgZmlsdGVycyBhbmQgdG9vbHMgbWVudXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUYWJsZUhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwaXZvdGFsTGF5b3V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dDogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbml0aWFsU29ydE9yZGVyOiBzdHJpbmcgPSAnZGVzY2VuZGluZyc7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluaXRpYWxTb3J0S2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gRFQgaXMgbG9hZGVkIGluIHRoZSBwYWdlIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmdWxsIHNjcmVlbiAoZnVsbCBwYWdlIG1vZGUpLCB0aGlzXG4gICAgICogaXMgaHRlIG51bWJlciBvZiBsaW5lcyB0aGF0IERUIHdpbGwgc2hvd1xuICAgICAqXG4gICAgICogdG9kbzogY29tZSB1cCB3aXRoIGJldHRlciBuYW1lXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5Um93U2l6ZTogbnVtYmVyID0gMTA7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHBhZ2luZyBvbiBsYXp5IGxvYWRpbmcgdXNpbmcgaW5maW5pdGUgc2Nyb2xsZXIgdG8gc2V0IGluaXRpYWwgZmV0Y2ggbGltaXQgc2l6ZVxuICAgICAqXG4gICAgICogdG9kbzogY29tZSB1cCB3aXRoIGJldHRlciBuYW1lICEhIVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYWdlU2l6ZTogbnVtYmVyID0gMTU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGF0YVNvdXJjZTogRFQyRGF0YVNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgbWVzc2FnZSB3aGVuIHRoZXJlIGFyZSBubyBkYXRhIC5cbiAgICAgKlxuICAgICAqIHRvZG86IFVzZSBpMThuIHZhbHVlIGFuZCBjcmVhdGUgcmVzb3VyY2UgZmlsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1wdHlNZXNzYWdlOiBzdHJpbmcgPSAnTm8gcmVjb3JkcyBmb3VuZCc7XG5cblxuICAgIC8qKlxuICAgICAqIERldmVsb3BlciBjYW4gcHJvdmlkZSBjdXN0b20gdHJhY2tCeSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBpdGVyYXRlIG92ZXIgdGhlXG4gICAgICogcmVjb3Jkc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93VHJhY2tCeTogKGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSkgPT4gYW55O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIGFkZHMgY3VzdG9tIGhvdmVyaW5nIGNsYXNzIHRvIHRoZSB0Ym9keVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93SG92ZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBzaG93IGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICpcbiAgICAgKiBUb2RvOiByZW5hbWUgdG8gc2hvd0xvYWRpbmdcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxvYWRpbmc6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdGlvbk1vZGUgPSAnbm9uZSc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbiBwcm92aWRlIGN1c3RvbSBpY29uLiBUaGVzZSBpY29ucyBhcmUgbm90IGFuaW1hdGVkIGRpdnMsIHdlIHVzZWQgY3NzXG4gICAgICogdHJhbnNmb3JtYXRpb24gdG8gcm90YXRlIHRoZW0uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxvYWRpbmdJY29uOiBzdHJpbmcgPSAnaWNvbi1zeW5jaHJvbml6ZSc7XG5cblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgaW5kZW50IGNhbiBiZSBhZGRlZCB3aGVuIHJlbmRlcmluZyBkZXRhaWwgcm93XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnREZXRhaWxSb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXIgPSAyNTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIFN1YkhlYWRlciBpcyB1c2VkIHRvIHNob3cgc3VtbWFyeSBjb2x1bW5zLCB3aGljaCBpbiBvdXIgVVggaXMgc2hvd24gYXQgdGhlIHRvcCBqdXN0IHVuZGVyXG4gICAgICogIHRoZSByZWd1bGFyIHRhYmxlIGhlYWRlclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgT3V0bGluZUZvciAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICpcbiAgICAgKiBOb3QgdXNlZCB3aGVuIFtvdXRsaW5lRm9ybWF0XT1cIid0cnVlZSdcIlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogV2UgbWlnaHQgaGF2ZSB0aGlzIGNvbmRpdGlvbmFsIGFzIHRoaXMgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdmFsdWUsIHNvIHRoZSBzYW1lXG4gICAgICogYXMgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dFeHBhbnNpb25Db250cm9sOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQWxsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIE91dGxpbmVGb3IgIC0gZm9ybWF0IC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG91dGxpbmVGb3JtYXQ6IE1vZGVsRm9ybWF0ID0gJ2ZyZWUnO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgb3IgaGlkZSBleHBhbnNpb24gY29udHJvbCBmb3Igcm93IGRldGFpbCBjb2x1bW5zLiBFeHBhbnNpb24gY29udHJvbCBtYWtlcyBzZW5zZSBmb3JcbiAgICAgKiBzaW1wbGUgdGFibGUsIHdoZW4gdXNpbmcgdGhpcyBpbnNpZGUgb3V0bGluZSAodHJlZSB0YWJsZSksIGl0cyBkcml2ZW4gYnkgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93RGV0YWlsRXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U2VsZWN0QWxsOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIGdsb2JhbCBzZWFyY2ggdGVybSBpbnB1dCBmaWVsZCBpbiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93R2xvYmFsU2VhcmNoOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBmcm96ZW4gY29sdW1uIGFyZSB1c2luZyB3ZSBjYW4gc3BlY2lmeSBvbiBnbG9iYWwgbGV2ZWwgdG90YWwgd2lkdGggb2YgdGhlIHRhYmxlIHRoZVxuICAgICAqIG92ZXJmbG93aW5nIGNvbnRlbnQgb3Igd2lkdGggZm9yIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2Nyb2xsV2lkdGg6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyByb3cgcmVvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGV2ZW50IHRoYXQgc29ydGluZyBpcyBlbmFibGVkIGZvciBjb2x1bW4gYW5kIHdlIHRyaWdnZXIgc29ydGluZ1xuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Tb3J0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gc2VsZWN0aW9uIG1vZGUgaXQgdHJpZ2dlcnMgZXZlblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Sb3dDbGljazogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbXVsdGkgb3Igc2luZ2xlIHNlbGVjdGlvbiBtb2RlIGlzIGVuYWJsZWQgaXQgd2lsbCB0cmlnZ2VyIGV2ZW50IHdoZW4gY2hlY2tib3ggb3JcbiAgICAgKiByYWRpbyBidXR0b25zIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbXBsZW1lbnQgU2luZ2xlU2VsZWN0aW9uRFRDb2x1bW4sIE11bHRpU2VsZWN0aW9uRFRDb2x1bW4gd2l0aCB0aGVpciByZW5kZXJlcnNcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2VsbCBib2R5IHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2VsbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNlbGwgaGVhZGVyIHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSGVhZGVyU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgQENvbnRlbnRDaGlsZChEVEhlYWRlckNvbXBvbmVudDIpXG4gICAgaGVhZGVyOiBEVEhlYWRlckNvbXBvbmVudDI7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIHRlbXBsYXRlIHRoYXQgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHNob3cgd2hlbiB0aGVyZSBhcmVcbiAgICAgKiBubyBkYXRhIGluIHRoZSBkYXRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbm9EYXRhVGVtcGwnKVxuICAgIGVtcHR5TWVzc2FnZVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEhlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdFN1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEJvZHknKVxuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyRmlsdGVyJylcbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgdXNlZCBEVENvbHVtbiBpbnNpZGUgZGF0YXRhYmxlIGFuZCB0aGVuIHRoZXkgYXJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZSB0b1xuICAgICAqIGl0ZXJhdGUgb3ZlciBhbmQgdXNlIGl0cyByZW5kZXJlclRlbXBsYXRlLlxuICAgICAqXG4gICAgICogV2hlbiB3ZSB3aWxsIGJlIGRlZmluaW5nIG5ldyBjb2x1bW5zIGl0cyBpbXBvcnRhbnQgdGhhdCBpdCBjYW4gYWxzbyBtYXRjaCBhbGwgdGhlXG4gICAgICogaW5oZXJpdGVkIG9uZXMuIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGRlZmluZSBhIHByb3ZpZGVyIHRob3NlIHRob3NlIGNvbHVtbnMgdG8gcG9pbnRcbiAgICAgKiB0byB0aGUgRFRDb2x1bW5Db21wb25lbnRcbiAgICAgKlxuICAgICAqIGUuZy46XG4gICAgICpcbiAgICAgKiB7cHJvdmlkZTogRFRDb2x1bW5Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERldGFpbFJvd0NvbHVtbil9XG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKERUQ29sdW1uMkNvbXBvbmVudClcbiAgICBjb2xzUXVlcnk6IFF1ZXJ5TGlzdDxEVENvbHVtbjJDb21wb25lbnQ+O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERURGV0YWlsUm93Q29tcG9uZW50KVxuICAgIHJvd0RldGFpbENvbHVtbjogRFREZXRhaWxSb3dDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgd2hlbiBpdGVtcyBpbiB0aGUgbGlzdCBhcmUgdXBkYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgICBjbGFzc0xpc3Q6IHN0cmluZyA9ICd3LWRhdGF0YWJsZSAnO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3IgaW50ZXJuYWwgdXNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRhdGFzZXQgdGhhdCBpcyBiZWluZyByZW5kZXJlZC4gU2V0IGZyb20gdGhlIFtsaXN0XSBiaW5kaW5nIG9yIGJ5IGxhenkgbG9hZCBmcm9tXG4gICAgICogZGF0YXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBkYXRhVG9SZW5kZXI6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2UgY29udmVydCBRdWVyeUxpc3Q8RFRDb2x1bW4yQ29tcG9uZW50PiB0byB0aGlzIGFycmF5IGZvciBlYXNpZXIgbWFuaXB1bGF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbnM6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNlY29uZGFyeSBsaXN0IG9mIGNvbHVtbnMgd2hpY2ggaXMgdXNlZCBpbiBjYXNlIHdlIGhhdmUgaGF2ZSBlbmFibGVkXG4gICAgICogZnJvemVuIGNvbHVtbnMuIENvbHVtbnMgdGhhdCBhcmUgbWFya2VkIGFzIGZyb3plbiBuZWVkcyB0byBiZSBwbGFjZWQgaW50byBzZXBhcmF0ZSBhcnJheVxuICAgICAqIHRvIGJlIHJlbmRlcmVkIHdheSB0aGFuIHJlZ3VsYXIgY29sdW1ucyB3aGljaCBhcmUgc3RvcmVkIGluIHRoZSBjb2x1bW5zIGFycmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBmcm96ZW5Db2x1bW5zOiBEVENvbHVtbjJDb21wb25lbnRbXTtcblxuXG4gICAgLyoqXG4gICAgICogIEluZGljYXRlcyB0aGF0IGNvbHVtbnMgd2VyZSBpbml0aWFsZWQgQWxzbyB1c2VkIHdoZW4gd2UgaGlkZSBhbmQgc2hvdyBjb2x1bW4gdG8gdHJpZ2dlclxuICAgICAqICBjaGFuZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uc0NoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgcHVibGljIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGNvbHNRdWVyeSBhbmQgaXRzIGNoYW5nZXMgc28gd2UgY2FuIGxhdGVyIG9uIHJlbGVhc2UgdGhlIHN1YnNjcmlwdGlvblxuICAgICAqL1xuICAgIGNvbHVtbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5zaW9uU3RhdGU6IERldGFpbFJvd0V4cGFuc2lvblN0YXRlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBudW1iZXJPZkNvbHNCZWZvcmVEYXRhOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBzdGFydE9mRmlyc3REYXRhQ29sdW1uOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWN0aW9uIGZvciBwcm9ncmFtbWF0aWNhbGx5IGluc3RhbnRpYXRlZCBjb2x1bW5zIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBsaXN0IGlmIGFkZGl0aW9uYWxcbiAgICAgKiBzcGFuIG9yIGxvZ2ljIGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGEgbmV3IGNvbHVtbiBpbnRvIGNvbHVtbnMgYXJyYXkgbGlrZSBleHBhbmRvIGNvbHVtbiBmb3IgZGV0YWlsXG4gICAgICogcm93LCBvciBTaW5nbGVTZWxlY3QsIE11bHRpU2VsZWN0IGNvbHVtbiB3aGVuIHNlbGVjdGlvbiBpcyBlbmFibGVkIHdlIG5lZWQgdG8gdXNlXG4gICAgICogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGluc3RhbnRpYXRlIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgcm93RGV0YWlsRXhwYW5kQ29sdW1uOiBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50O1xuICAgIHByaXZhdGUgbXVsdGlTZWxlY3RDb2x1bW46IERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQ7XG4gICAgcHJpdmF0ZSBzaW5nbGVTZWxlY3RDb2x1bW46IERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEluIGNhc2Ugb2Ygb3V0bGluZSB0YWJsZSB3ZSBhcmUgaW5qZWN0IE91dGxpbmVTdGF0ZSB3aGljaCBpcyBwcm92aWRlZCBpbiB0aGUgRFQgY29tcG9uZW50XG4gICAgICogZGVmaW5pdGlvbi4gVGhpcyBpcyB1c2VkIGJ5IG5lc3RlZCBvdXRsaW5lRm9yIGNvbXBvbmVudCBpdCBzZXQgaXRzZWxmIGFzIHJlZmVyZW5jZSBhbmRcbiAgICAgKiBpbml0aWFsaXplIHRoZSBzdGF0ZSBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlciBvbiBpbnNpZGUgT3V0bGluZUNvbnRyb2xcbiAgICAgKlxuICAgICAqXG4gICAgICogRWFjaCBEYXRhdGFibGUgaXMgcHJlLWRlZmF1bHRlZCB3aXRoIGl0cyBvd24gdmVyc2lvbiBvZiBEYXRhU291cmNlIHNvIGFsbCB0aGUgb2JzZXJ2ZXJzXG4gICAgICogaW5zaWRlIGFyZSB1bmlxdWUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHByaXZhdGUgX2RlZmF1bHREUzogRFQyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGUsXG4gICAgICAgICAgICAgICAgcHVibGljIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fZGVmYXVsdERTO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIHN0YXRlIG91dCB0byBhcHBsaWNhdGlvbi4gQ2FuIGJlIHVzZSBhcyB0d28gd2F5IGJpbmRpbmdzXG4gICAgICpcbiAgICAgKiBbKHN0YXRlKV09ZHRTdGF0ZShzKVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RhdGUoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnN0YXRlO1xuICAgIH1cblxuICAgIHNldCBzdGF0ZSh2YWw6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZSA9IHZhbDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGJpbmRpbmdzIFtsaXN0XSBhbmQgW2Rlc3RpbmF0aW9uQ2xhc3NdIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUgPSBuZXcgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGUodGhpcyk7XG5cbiAgICAgICAgLy8gaW5pdCBkZWZhdWx0IGNvbHVtbnNcbiAgICAgICAgdGhpcy5yb3dEZXRhaWxFeHBhbmRDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuXG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdENvbHVtbiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGRhdGEgYXJlIG5vdCBkZWZlcnJlZCBhbmQgd2UgZ2V0IGxpc3QgZGlyZWN0bHkgdGhlbiBpdCBjcmVhdGVzIERTLiBJZlxuICAgICAgICAgKiBuZ09uQ2hhbmdlcyBpcyBjYWxsZWQgZmlyc3Qgd2UgcHJvcGVybHkgaW5pdCBEUyBhbmQgY2xlYW4gdGhpcy5saXN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgfHwgaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW5jZSB3ZSB3b3JrIHdpdGggcmVmZXJlbmNlcyBsZXQncyBwYXNzIGNyZWF0ZWQgbWFwIGluc2lkZSBvdXIgc3RhdGVcbiAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUuZXhwYW5zaW9uU3RhdGVzID0gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkYXRhIGFycml2ZXMgbGF0ZXIgbWF5YmUgZHVlIHRvIFJFU1QgQVBJIGxhdGVuY3ksIGluaXRpYWxpemUgRFMgb25seSB3aGVuIHdlIGhhdmUgYVxuICAgICAqIGRhdGEsIG90aGVyd2lzZSBpZiBkYXRhIGNoYW5nZWQgdGhydSB0aGUgYmluZGluZ3MganVzdCB0cmlnZ2VyIGRhdGFDaGFuZ2UgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoY2hhbmdlc1snbGlzdCddICYmIGlzUHJlc2VudChjaGFuZ2VzWydsaXN0J10uY3VycmVudFZhbHVlKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZClcbiAgICAgICAge1xuXG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dCh0aGlzLmxpc3QpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKVxuICAgIHtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaW5pdCBhIHN0YXRlIHdoZW4gZGV0YWlsIGNvbHVtbiBpcyBwcmVzZW50XG4gICAgICAgIC8vIHRvZG86IG1vdmUgdGhpcyBpbml0aWFsaXphdGlvbiB0byBkYXRhc291cmNlXG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCA9IGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbik7XG5cbiAgICAgICAgdGhpcy5pbml0Q29sdW1ucygpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24gPSB0aGlzLmNvbHNRdWVyeS5jaGFuZ2VzLnN1YnNjcmliZShfID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpXG4gICAge1xuICAgICAgICAvLyBhc3NpZ24gaXQgcHJvZ3JhbWF0aWNhbGx5IGFzIHdlIHdhbnQgdG8gaGF2ZSBhIGNvbnRleHQgZm9yIHRoZSBmaWx0ZXJcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiYgaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmZpbHRlck91dCA9IHRoaXMuc2tpcE91dGxpbmVJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmNoYW5nZURldGVjdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvci5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc0NoYW5nZWQgJiYgdGhpcy5lbC5uYXRpdmVFbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXkgZW50cnkgbWV0aG9kIHRoYXQgaW5pdGlhbGl6ZWQgb3VyIGNvbHVtbnMuIExhdGVyIG9uIHdoZW4gd2Ugd2lsbCBzdXBwb3J0IHNlbGVjdGlvbiBhbmRcbiAgICAgKiBtdWx0aXNlbGVjdGlvbiB3ZSB3aWxsIHByb2dyYW1tYXRpY2FsbHkgaW5zdGFudGlhdGUgU2luZ2xlU2VsZWN0aW9uLCBNdWx0aVNlbGVjdGlvbiBjb2x1bW5cbiAgICAgKiBjb21wb25lbnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCBzbyB0aGV5IGNhbiBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIHNvIHRoZSBpZGVhIGhlcmUgaXM6XG4gICAgICpcbiAgICAgKiBXaGVuIERUIGNvbXBvbmVudCBpbml0aWFsaXplIGFuZCB3ZSBhcmUgaW4gZWRpdGluZyBtb2RlIGFuZCB3ZSBzdXBwb3J0IFNpbmdsZS9NdWx0aSBzZWxlY3Rpb25cbiAgICAgKiB3ZSB3aWxsIHVzZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gY3JlYXRlIGNvbXBvbmVudCBhbmQgYWRkIGl0IGFzIGZpcnN0IGl0ZW0gdG8gdGhlIGxpc3RcbiAgICAgKiBhbmQgdGhlbiBpdCB3aWxsIGJlIHJlbmRlcmVkIGp1c3QgbGlrZSBhbnl0aGlnbiBlbHNlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdENvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERldGFpbENvbHVtbkV4cGFuc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb2x1bW4uaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRoaXMubXVsdGlTZWxlY3RDb2x1bW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0Q29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnNpbmdsZVNlbGVjdENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGV4cGFuc2lvbiBjb2x1bW4gd2hlbiBkZXRhaWwgcm93IGlzIGVuYWJsZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgJiYgIXRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnJvd0RldGFpbEV4cGFuZENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbHNRdWVyeVxuICAgICAgICAgICAgLmZpbHRlcigoY29sMTogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiAhY29sMS5mcm96ZW4pXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdEZyb3plbkNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5pbml0Q29sdW1uSW5mbygpO1xuICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjdXJyZW50IGNvbHVtbiBpcyBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW50ZXJuYWxDb2x1bW4oY29sOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gY29sIGluc3RhbmNlb2YgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IERhdGFzb3VyY2UgYmFzZWQgb24gcGFzc2VkIHZhbHVlcy4gSXQgdHJpZXMgdG8gaW5pdGlhbGl6ZSBEUyBmb3IgZmlyc3QgdGltZVxuICAgICAqIGluc2lkZSB0aGUgbmdJbml0IGJ1dCBpbiBjYXNlIERhdGEgYXJyaXZlcyBsYXRlciBtYXliZSBkdWUgdG8gc29tZSBSRVNUIEFQSSBjYWxscyB0aGlzXG4gICAgICogY2FuIGJlIHRyaWdnZXJlZCBhbHNvIGZyb20gbmdPbkNoYW5nZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RGF0YXNvdXJjZShpbml0aWFsaXplOiBib29sZWFuID0gdHJ1ZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgwLCB0aGlzLnBhZ2VTaXplLCB0aGlzLmRpc3BsYXlSb3dTaXplLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFNvcnRLZXksIHRoaXMuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuaW5pdGlhbFNvcnRPcmRlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW1pdCA9IHRoaXMuc3RhdGUuZGlzcGxheUxpbWl0ID0gdGhpcy5kaXNwbGF5Um93U2l6ZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbml0aWFsU29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSB0aGlzLmluaXRpYWxTb3J0S2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gdGhpcy5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5pbml0aWFsU29ydE9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsaXplKSB7XG5cbiAgICAgICAgICAgIGxldCBxVHlwZSA9ICh0aGlzLmlzT3V0bGluZSgpICYmIHRoaXMub3V0bGluZUZvcm1hdCA9PT0gJ3RyZWUnKSA/XG4gICAgICAgICAgICAgICAgUXVlcnlUeXBlLkZ1bGxUZXh0T3V0bGluZSA6IFF1ZXJ5VHlwZS5GdWxsVGV4dDtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICAgICAgICAgICAgICAgIG9iajogaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgPyB0aGlzLmRlc3RpbmF0aW9uQ2xhc3MgOiB0aGlzLmxpc3QsXG4gICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBxVHlwZSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLnN0YXRlKTtcblxuICAgICAgICAvLyByZXNldCBsaXN0IHRvIG1ha2Ugc3VyZSBpdCBjb21lcyBmcm9tIERhdGFQcm92aWRlciwgd2UgdXNlIGxpc3QgIHRvIGluaXRpYWxpemVcbiAgICAgICAgdGhpcy5saXN0ID0gbnVsbDtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBFTlRSWSBwb2ludCBmb3IgdGhlIERBVEEgQ0hBTkdFUy4gQWxsIGFkZGl0aW9uLCBlZGl0cywgZGVsZXRpb24gZW5kcyB1cFxuICAgICAgICAvLyBoZXJlLiBXZSBkb250IHdvcmsgZGlyZWN0bHkgd2l0aCBMSVNULiBBbnkgY2hhbmdlIGlzIHJlYWN0aXZlIGFuZCBoZXJlIGlzIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5vcGVuKCkuc3Vic2NyaWJlKChkYXRhOiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRldGFpbFJvdyBjb2x1bW4gaXMgcHJlc2VudCB3ZSBpbml0aWFsaXplIGEgc3RhdGUgaG9sZGluZyBpbmZvcm1hdGlvbiB3aGljaCBpdGVtIGlzXG4gICAgICogZXhwYW5kZWQuXG4gICAgICpcbiAgICAgKiB0b2RvOiBUaGlzIGlzIHRlbXBvcmFyeSBoZXJlIGFuZCBvbmNlIHdlIHN1cG9ydCBsYXp5IGxvYWRpbmcgbW92ZSB0aGlzIHRvIGRhdGFzb3VyY2UuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSBmb3Igb3V0bGluZSB0cmVlIHRhYmxlIHdlIG5lZWQgdG8gY29ubmVjdCBhIHN0YXRlIGZyb20gb3V0bGluZSB3aXRoIGEgc3RhdGUgaW5cbiAgICAgKiBoZXJlIGFzIHdlIGFyZSB1c2luZyBvdXRsaW5lIGNvbnRyb2wgdG8gZXhwYW5kIGFuZCBjb2xsYXBzZSBpdGVtc1xuICAgICAqL1xuICAgIGluaXREZXRhaWxDb2x1bW5FeHBhbnNpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikpIHtcbiAgICAgICAgICAgIHRoaXMucm93RGV0YWlsQ29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkID0gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJlxuICAgICAgICAgICAgQm9vbGVhbldyYXBwZXIuaXNUcnVlKHRoaXMuc2hvd1Jvd0RldGFpbEV4cGFuc2lvbkNvbnRyb2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGV4ZWN1dGVkIGFmdGVyIHdlIGluaXRpYWxpemUgYWxsIHRoZSBjb2x1bW5zIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBjb3JyZWN0XG4gICAgICogbnVtYmVycyB1c2VkIGZvciBpbmRlbnRhdGlvbiB3aGlsZSByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbHVtbnMgYXMgd2VsbCBhcyBkZXRhaWwgcm93IGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBIZXJlIHdlIG5lZWQgdG8gYmUgYXdhcmUgaG93IG1hbnkgY29sdW1ucyB0byBzcGFuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0Q29sdW1uSW5mbygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGEgPSAwO1xuXG4gICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjb2wuaXNWYWx1ZUNvbHVtbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmluZGVudERldGFpbFJvdykge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0T2ZGaXJzdERhdGFDb2x1bW4gPSB0aGlzLmNvbHVtbnMubGVuZ3RoIC0gdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdjZWxsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb29rdXBLZXkgPSB7XG4gICAgICAgICAgICBjb2w6IGNvbHVtbi5rZXkgfHwgY29sdW1uLmxhYmVsLFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5KTtcbiAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkID0gZm91bmRJbmRleCAhPT0gLTE7XG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW2xvb2t1cEtleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNlbGxDaGFuZ2UuZW1pdCh0aGlzLnN0YXRlLnNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhlYWRlclNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGVyU2VsZWN0ZWQoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBjb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uSGVhZGVyU2VsZWN0aW9uLmVtaXQodGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIG9uSGFuZGxlUm93Q2xpY2tlZChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBzcGVjaWFsIGFsdCBrZXkgbW9kaWZpZXIuIFdoZW4gdXNlZCB3aXRoIHJvd3MgaXQgaW5kaWNhdGVzIHRoZXJlIGlzIGEgRCZEIGVuYWJsZWRcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgdGhpcy5vblJvd1RvZ2dsZShldmVudCwgaXRlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLm9uUm93U2VsZWN0KGV2ZW50LCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dUb2dnbGUoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHJvd1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiYgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKTtcbiAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkID0gZm91bmRJbmRleCAhPT0gLTE7XG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb3IgdGhlIG91dGxpbmUgZ28gdXAgYW5kIGRvd24gdGhlIHN5bmMgd2l0aCB0cmVlaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMub0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW2l0ZW1dO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc091dGxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Sb3dTZWxlY3Rpb25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBpc1NlbGVjdGVkOiByb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIGl0ZW06IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dTZWxlY3QoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBpdGVtO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLm9uUm93U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY2hpbGRyZW5Gb3JOb2RlID0gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtjdXJyZW50SXRlbV0pIHx8IFtdO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbkZvck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgaXMgc2VsZWN0ZWQgY3VycmVudGx5IHRoZW4gdG9nZ2xlIHRvIG90aGVyIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNoZWNraW5nIGFsbCBmcm9tIHJvb3QsIGRlc2VsZWN0IGNoaWxkcmVuIGFuZCBhZGQgYWxsXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgLi4uY2hpbGRyZW5Gb3JOb2RlXTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWFjaCBjaGlsZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBmb3VuZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBzYW1lIGZvciBjaGlsZHJlbiBvZiBjaGlsZHJlblxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGNoaWxkLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5Gb3JOb2RlID0gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtwYXJlbnRdKSB8fCBbXTtcblxuICAgICAgICAgICAgbGV0IGFsbFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdGVkID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgY2hpbGQpICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiBhbGxTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50SW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBwYXJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG5EUm93RHJvcChvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdEcm9wcGluZyByb3cgIzogJywgb3JpZ1BvcyArICcgJyArIGRyb3BQb3MgKyAnIHJvdyAjOiAnICsgbmV3UG9zKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yZW9yZGVyUm93cyhvcmlnUG9zLCBuZXdQb3MsIGRyb3BQb3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk91dGxpbmVFeHBhbmRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpdGVtID0gZXZlbnQuaXRlbTtcblxuICAgICAgICAvLyBXZSBkb250IHJlYWxseSBuZWVkIHRvIHN0b3JlIGEgc3RhdGUgZm9ybSBvdXRsaW5lIGxvY2FsbHkgYXMgd2UgYXJlIHVzaW5nIHRoZSBzYW1lIG9iamVjdFxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgLy8gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGUgPSB0aGlzLm91dGxpbmVTdGF0ZS5leHBhbnNpb25TdGF0ZXM7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0U2luZ2xlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5zb3J0Q29sdW1uKSkge1xuXG4gICAgICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuc29ydENvbHVtbi5rZXkpLCAnSW52YWxpZCBjb2x1bW4gdG8gc29ydCcpO1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnQodGhpcy5zb3J0Q29sdW1uLmtleSwgdGhpcy5zb3J0Q29sdW1uLnNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIHRoaXMub25Tb3J0LmVtaXQoe1xuICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLnNvcnRDb2x1bW4ua2V5LFxuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLnNvcnRDb2x1bW4uc29ydE9yZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5nZSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zb3J0S2V5IHx8IHRoaXMuc29ydENvbHVtbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNvcnRDb2x1bW4gJiYgdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Q29sdW1uID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9PiBjb2wua2V5ID09PSB0aGlzLnN0YXRlLnNvcnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMubGlzdCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRGF0YVRvUmVuZGVyKGRhdGFzb3VyY2U/OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IGRhdGFzb3VyY2UgfHwgdGhpcy5saXN0O1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY2hpbGRyZW4pICYmIGlzUHJlc2VudCh0aGlzLmRhdGFUb1JlbmRlcilcbiAgICAgICAgICAgICYmIHRoaXMuZGF0YVRvUmVuZGVyLmxlbmd0aCA+IDAgJiYgaXNPdXRsaW5lTm9kZSh0aGlzLmRhdGFUb1JlbmRlclswXSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvcm1hdCA9ICd0cmVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIHJlc2V0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc29ydENvbHVtbiA9IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgaXNIZWFkZXJTZWxlY3RlZChpdGVtOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2xNYXRjaGVkID0gaXRlbS5rZXkgfHwgaXRlbS5sYWJlbDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2wgPSB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbi5rZXkgfHwgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24ubGFiZWw7XG4gICAgICAgIHJldHVybiBjb2xNYXRjaGVkID09PSBjdXJyZW50Q29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JvZHlDZWxsU2VsZWN0ZWQoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBsb29rdXBLZXkgPSB7XG4gICAgICAgICAgICBjb2w6IGNvbHVtbi5rZXkgfHwgY29sdW1uLmxhYmVsLFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pICE9PSAtMTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBkYXRhIHRvIHJlbmRlciBVc2VkIGluc2lkZSB0ZW1wbGF0ZSB0byB0ZWxsIGlmIHdlIHNob3VsZCB1c2UgdGhlIE5vRGF0YSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNFbXB0eSgpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNCbGFuayh0aGlzLmRhdGFUb1JlbmRlcikgfHwgKHRoaXMuZGF0YVRvUmVuZGVyLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuXG4gICAgaGFzRnJvemVuQ29sdW1ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZnJvemVuQ29sdW1ucykgJiYgdGhpcy5mcm96ZW5Db2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiAhdGhpcy5zaG93U2VsZWN0aW9uQ29sdW1uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdub25lJyAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdjZWxsJztcbiAgICB9XG5cbiAgICB2aXNpYmxlQ29sdW1ucygpOiBEVENvbHVtbjJDb21wb25lbnRbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucyA/IHRoaXMuY29sdW1ucy5maWx0ZXIoYyA9PiBjLmlzVmlzaWJsZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRPcmRlcmluZ0ZvclN0cmluZyhkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAnZGVzY2VuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBsb2cgYmFkIGtleVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBzb3J0T3JkZXJpbmdGb3JOdW1iZXIoZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogbG9nIGJhZCBrZXlcbiAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlQWxsQ29sdW1ucyhldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtcyA9IHRoaXMuZGF0YVRvUmVuZGVyIHx8IFtdO1xuICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0Lmxlbmd0aCA+PSBjdXJyZW50SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLmN1cnJlbnRJdGVtc107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50SXRlbXMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZE9iamVjdC5sZW5ndGggPj0gY3VycmVudEl0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpc1RvZ2dsZUFsbENvbHVtbkRpc2FibGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcblxuICAgICAgICByZXR1cm4gY3VycmVudEl0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgYnkgdGVtcGxhdGUgdG8gZGVjaWRlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIERldGFpbFJvdyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byBoYXZlXG4gICAgICogRGV0YWlsUm93IENvbnRlbnRDaGlsZCBhbmQgdXNpbmcgRGV0YWlsUm93IGNvbXBvbmVudCBbaXNWaXNpYmxlRm5dIGZ1bmN0aW9uIGJpbmRpbmcgd2VcbiAgICAgKiBjaGVjayBpZiB0aGUgaXRlbSB0aGF0IGlzIGFib3V0IHRvIGJlIHJlbmRlcmVkIGlzIGVsaWdpYmxlIGZvciBkZXRhaWwgcm93XG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93RGV0YWlsQ29sdW1uKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKSAmJiB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNPdXRsaW5lKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jaGlsZHJlbikgfHwgdGhpcy5vdXRsaW5lRm9ybWF0ID09PSAndHJlZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBkZXRhaWwgY29sdW1uIChkZXRhaWwgcm93KSBhbmQgb3V0bGluZSBhbGwgdG9nZXRoZXIgd2UgbmVlZCBoYXZlIGFcbiAgICAgKiBtZWNoYW5pc20gdG8gdGVsbCB0byB0aGUgb3V0bGluZSBcImRvbid0IHJlbmRlciB0aGUgbmV4dCBsZXZlbCBvZiBpdGVtc1wiIGFuZCB1c2UgZGV0YWlsIHJvdy5cbiAgICAgKiBTbyBjZXJ0YWluIGl0ZW0gdHlwZSBuZWVkcyB0byBiZSBza2lwcGVkLlxuICAgICAqXG4gICAgICogVGhlIHdheSB3ZSBza2lwIHRob3NlIGl0ZW0gaXMgd2UgdXNlIGlzVmlzaWJsZUZuIGNvbmRpdGlvbiBvZiB0aGUgZGV0YWlsIHJvdyBhbmQgbG9vayBhaGVhZFxuICAgICAqIGlmIHdlIHNob3VsZCBza2lwIG5leHQgbGV2ZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBza2lwT3V0bGluZUl0ZW0oaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoZGF0YTogYW55LCBmaWVsZDogc3RyaW5nKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YSwgZmllbGQpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGF0IHdlIGFsc28gaW5jbHVkZSBwcm9ncmFtbWF0aWMgY29sdW1uIGlmIHByZXNlbnQuIE1vdmUgdGhlbSB0byB0aGUgY29ycmVjdFxuICAgICAqIGFycmF5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRGcm96ZW5Db2x1bW5zKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY29sc1F1ZXJ5XG4gICAgICAgICAgICAuZmlsdGVyKChjb2wxOiBEVENvbHVtbjJDb21wb25lbnQpID0+IGNvbDEuZnJvemVuKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbC5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucy5wdXNoKGNvbCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmZyb3plbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZmluZCBsYXN0IGluZGV4IG9mIGNvbHVtbiB0aGF0IGlzIGludGVybmFsIC8gcHJvZ3JhbW1hdGljXG5cbiAgICAgICAgICAgIGxldCBsYXN0SW54ID0gdGhpcy5jb2x1bW5zLnNsaWNlKClcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLmZpbmRJbmRleCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IHRoaXMuaXNJbnRlcm5hbENvbHVtbihjb2wpKTtcblxuICAgICAgICAgICAgaWYgKGxhc3RJbnggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMuY29sdW1ucy5sZW5ndGggLSAxIC0gbGFzdElueDtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJuYWxDb2xzID0gdGhpcy5jb2x1bW5zLnNwbGljZSgwLCBpZHggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMgPSBbLi4uaW50ZXJuYWxDb2xzLCAuLi50aGlzLmZyb3plbkNvbHVtbnNdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBoYXNWYWxpZENvbHMgPSB0aGlzLmNvbHVtbnNcbiAgICAgICAgICAgICAgICAuZmluZEluZGV4KChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gaXNCbGFuayhjb2wud2lkdGgpKSA9PT0gLTE7XG5cbiAgICAgICAgICAgIGFzc2VydChoYXNWYWxpZENvbHMgfHwgaXNQcmVzZW50KHRoaXMuc2Nyb2xsV2lkdGgpLFxuICAgICAgICAgICAgICAgICdXaGVuIHVzaW5nIFtmcm96ZW5dIGJpbmRpbmcgeW91IG5lZWQgc3BlY2lmeSBbd2lkdGhdIGZvciBlYWNoICcgK1xuICAgICAgICAgICAgICAgICdjb2x1bW4gb3IgW3Njcm9sbFdpZHRoXSBvbiBkYXRhdGFibGUhJyk7XG5cblxuICAgICAgICAgICAgYXNzZXJ0KGlzQmxhbmsodGhpcy5yb3dEZXRhaWxDb2x1bW4pLFxuICAgICAgICAgICAgICAgICdZb3UgY2Fubm90IGNvbWJpbmUgYXctZHQtZGV0YWlsLWNvbHVtbiB3aXRoIGZyb3plbiBjb2x1bW5zIScpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1cnJlbnQgaW1tdXRhYmxlIGxpc3QgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi4gTmVlZCB0byB3cmFwIGl0IHdpdGhcbiAgICAgKiBzZXRUaW1lb3V0IGFzIHRoZSBjaGFuZ2UgY2FuIGVhc2lseSBjb21lIGFmdGVyIHZpZXcgY2hlY2tlZCBhbmQgdGhpcyB3b3VsZCByZXN1bHQgc29tZSBlcnJvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlTGlzdChuZXdMaXN0OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhblVzZUZvckRldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJlxuICAgICAgICAgICAgKDxEVERldGFpbFJvd0NvbXBvbmVudD50aGlzLnJvd0RldGFpbENvbHVtbikuc2hvd0RldGFpbFJvdyhpdGVtKTtcbiAgICB9XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBQTEFURk9STV9JRCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtvZiwgU3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc3dpdGNoTWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge2lzUGxhdGZvcm1Ccm93c2VyfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBQbGVhc2Ugc2VlIGRhdGF0YWJsZSBmb3IgbW9yZSBkZXRhaWwgZGVzY3JpcHRpb24uIEJ1dCB0aGUgbWFpbiBnb2FsIG9mIHRoaXMgd3JhcHBlciB0byByZW1vdmVcbiAqIGFsbCB0aGUgY29tbW9uIHN1cnJvdW5kaW5nIHBhcnRzIGFyb3VuZCB0aGUgZGF0YXRhYmxlIGFuZCBtYWtlIHN1cmUgRFQgY2FuIGZvY3VzIG9ubHkgYWN0dWFsXG4gKiBoZWFkZXIgYW5kIGJvZHkgc3RydWN0dXJlXG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB3cmFwcGVyIGFsc28gcHJvdmlkZXMgc29tZSBjb2RlIGZvciB0aGUgc2xpZGluZyB1cCBwYW5lbCBjb250YWluaW5nXG4gKiBidXR0b25zIGFuZCBvdGhlciBhY3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGR1cmluZyBlZGl0aW5nXG4gKlxuICpcbiAqIFRvZG86IEV4dHJhY3QgdGhlIGV4cGFuZCBsb2dpYyBvdXQgaW50byBzb21lIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgb3IganVzdCBhIGNsYXNzXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LXdyYXBwZXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGFibGUtd3JhcHBlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3RhYmxlLXdyYXBwZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCBieSBmdWxsIHNjcmVlbiBkaXYgb3ZlcmxheSB0byBjcmVhdGUgZXhwYW5kaW5nIGVmZmVjdCB3aGljaCBuZWVkcyB0byBoYXZlXG4gICAgICogbGl0dGxlIHRlbnQ7XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yRnJvbTogc3RyaW5nID0gJyNmM2YzZjMnO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0aGF0IGlzIHVzZWQgdG8gc2V0IGFmdGVyIHdlIGFyZSBpbiB0aGUgZnVsbCBzY3JlZW4gc28gb3VyIG92ZXJsYXkgZGl2IGhpZGUgZXZlcnl0aGluZ1xuICAgICAqIG9uIHRoZSBwYWdlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yVG86IHN0cmluZyA9ICcjRkZGRkZGJztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUYWJsZSBoZWFkaW5nIGFyZWEgb2ZmZXJzIGRldmVsb3BlciB0byBjb21wbGV0ZWx5IG92ZXJyaWRlIHRoZSB0b3AgYmFyIHdoZXJlIHdlIGhhdmUgZmlsdGVyc1xuICAgICAqIGFuZCBvdGhlcnMgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRpbmdBcmVhJylcbiAgICBoZWFkaW5nOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRhYmxlIGhlYWRlcnMgYW5kIHdyYXBzIHRoZW0gd2l0aGluIHRoZWFkIHRhZ1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlclJvd3MnKVxuICAgIGhlYWRlclJvd3M6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgYm9keVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JvZHlSb3dzJylcbiAgICBib2R5Um93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgaGVhZGluZyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byByZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHByaW1lTkcgc28gZmFyIGl0IGlzIHVzaW5nXG4gICAgICogcC1mb290ZXJcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdmb290ZXJBcmVhJylcbiAgICBmb290ZXI6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIERpdiB1c2VkIHRvIG1ha2UgdGhlIGZ1bGwgc2NyZWVuIGV4cGFuc2lvbiBlZmZlY3RcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkdEZ1bGxTY3JlZW5PdmVybGF5JylcbiAgICBkdEZ1bGxTY3JlZW5PdmVybGF5OiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gaW5maXRlIHNjcm9sbC4gV2UgYXJlIHVzaW5nIHRoaXMgdG8gdHJpZ2dlciBsb2FkaW5nIGZpbmlzaCBldmVudCBzbyB3ZSBjYW5cbiAgICAgKiBoaWRlIGxvYWRpbmcgYW5pbWF0aW9uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaW5maW5pdGVTY3JvbGwnKVxuICAgIGluZmluaXRlU2Nyb2xsOiBJbmZpbml0ZVNjcm9sbENvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gZGVib3VuY2UgdGhlIHR5cGluZyB3ZSBuZWVkIHRvIHVzZSBzdWJqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hUZXJtcyA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuXG4gICAgLyoqXG4gICAgICogIFNwZWNpZmllcyBpZiB3ZSBhcmUgaW4gdmlld2luZy9lZGl0aW5nIG1vZGUgdGhhdCBjYW4gYnJvd3NlIHdob2xlIGRhdGFzZXQgbGF6aWx5XG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Z1bGxTY3JlZW5Nb2RlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSBjYW4gc3VwcG9ydCBmdWxsIHNjcmVlbiBtb2RlIC0gb25seSBhdmFpbGFibGUgZm9yIHRoZSBicm93c2VyXG4gICAgICpcbiAgICAgKi9cbiAgICBzdXBwb3J0RnVsbFNjcmVlbjogYm9vbGVhbiA9IHRydWU7XG4gICAgcXVlcnlTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBsb2FkaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogIFNhdmVzIG9yaWdpbmFsIGJvdW5kaW5nIHJlY3QgY29vcmRpbmF0ZXMgYmVmb3JlIHdlIGV4cGFuZCB0aGUgRFQgdG8gZnVsbCBzY3JlZW5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHRCb3VuZGluZ0NsaWVudFJlY3Q6IGFueTtcbiAgICAvKipcbiAgICAgKiBSZW1lbWJlcnMgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSB3ZSBzd2l0Y2ggdG8gZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgb3JpZ2luYWxTY3JvbGxQb3NpdGlvbjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRoaXNFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZG9tVXRpbHM6IERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHVibGljIGR0OiBEYXRhdGFibGUyQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5xdWVyeVN1YnNjcmlwdGlvbiA9IHRoaXMuc2VhcmNoVGVybXMucGlwZShcbiAgICAgICAgICAgIC8vIHdhaXQgMzAwbXMgYWZ0ZXIgZWFjaCBrZXlzdHJva2UgYmVmb3JlIGNvbnNpZGVyaW5nIHRoZSB0ZXJtXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMzAwKSxcblxuICAgICAgICAgICAgLy8gaWdub3JlIG5ldyB0ZXJtIGlmIHNhbWUgYXMgcHJldmlvdXMgdGVybVxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcblxuICAgICAgICAgICAgc3dpdGNoTWFwKCh0ZXJtOiBzdHJpbmcpID0+IG9mKHRlcm0pKVxuICAgICAgICApLnN1YnNjcmliZSgodGVybTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRlcm0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZpbmQodGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubG9hZGluZ1N1YiA9IHRoaXMuZHQudmFsdWVDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRhdGE6IGFueSkgPT4gdGhpcy5sb2FkaW5nRmluaXNoZWQoKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb2x1bW5zIG1hcmtlZCBhcyBmcm96ZW4gYW5kIHJldHJpZXZlIGEgd2lkdGggc28gd2UgY2FuIHVwZGF0ZVxuICAgICAqIHBhcmVudCBkaXZcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUZyb3plbldpZHRoKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5kdC5mcm96ZW5Db2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29sLm1heFdpZHRoUHggPiAwKSB7XG4gICAgICAgICAgICAgICAgZldpZHRoICs9IGNvbC53aWRlc3RDZWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmV2lkdGggKz0gcGFyc2VJbnQoY29sLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZXaWR0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaGF2aW5nIHR3byBzZXBhcmF0ZSB0YWJsZXMgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCByb3dzIG9mIHRoZSB0YWJsZXMgYXJlIGFsaWduZWQuXG4gICAgICpcbiAgICAgKiBUaGVyZWZvcmUgdGhpcyBtZXRob2QgdGFrZXMgZmlyc3QgY29sdW1uIGZyb20gZWFjaCB0YWJsZSByZWFkIHRoZSBoZWlnaHQgb2YgdGhlIHJvd3MgYW5kIHNldFxuICAgICAqIHRoZSBtYXggaGVpZ2h0IHRvIGJvdGggcm93cy5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYWxpZ25UYWJsZXNIZWlnaHRzKGZyb3plblZpZXc6IGFueSwgdW5Gcm96ZW5WaWV3OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KGZyb3plblZpZXcpICYmIGlzUHJlc2VudChmcm96ZW5WaWV3KSxcbiAgICAgICAgICAgICdDYW50IGFsaWduIHRhYmxlIHZpZXdzIGFzIG9uZSBvZiB0aGUgdmlldyBpcyB1bmRlZmluZWQnKTtcblxuICAgICAgICBsZXQgZnJvemVuUm93czogYW55W10gPSBmcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG4gICAgICAgIGxldCB1bkZyb3plblJvd3M6IGFueVtdID0gdW5Gcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG5cbiAgICAgICAgYXNzZXJ0KGZyb3plblJvd3MubGVuZ3RoID09PSB1bkZyb3plblJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgJ0Zyb3plbiBDb2x1bW46IFR3byB0YWJsZXMgZG9lcyBub3QgbXVjaCEnKTtcblxuICAgICAgICBBcnJheS5mcm9tKGZyb3plblJvd3MpLmZvckVhY2goKGZyb3plbjogYW55LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaCA9IE1hdGgubWF4KGZyb3plbi5vZmZzZXRIZWlnaHQsIHVuRnJvemVuUm93c1tpbmRleF0ub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZyb3plbi5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgICAgIHVuRnJvemVuUm93c1tpbmRleF0uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmluaXRGdWxsU2NyZWVuKCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGxldCBmcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LWZyb3plbicpO1xuICAgICAgICAgICAgbGV0IHVuRnJvemVuVmlldyA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtYm9keS11bmZyb3plbicpO1xuXG4gICAgICAgICAgICBsZXQgZnJvemVuV2lkdGggPSB0aGlzLmNhbGN1bGF0ZUZyb3plbldpZHRoKCk7XG5cbiAgICAgICAgICAgIGZyb3plblZpZXcuc3R5bGUud2lkdGggPSBmcm96ZW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHVuRnJvemVuVmlldykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGJvcmRlciBhbmQgY3JlYXRlIGluZGVudCBlZmZlY3QgYnkgaGF2aW5nIDFweCB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS5sZWZ0ID0gKGZyb3plbldpZHRoICsgMikgKyAncHgnO1xuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS53aWR0aCA9IHVuRnJvemVuVmlldy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC0gZnJvemVuVmlldy5vZmZzZXRXaWR0aCArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduVGFibGVzSGVpZ2h0cyhmcm96ZW5WaWV3LCB1bkZyb3plblZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucXVlcnlTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubG9hZGluZ1N1YikpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGVUxMIFNDUkVFTiBNT0RFIG1ldGhvZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBmdWxsc2NyZWVuIGZ1bmN0aW9uYWxpdHkgaXMgZW5hYmxlZCB0aGlzIG1ldGhvZCBzd2l0Y2hlcyBiZXR3ZWVuIG5vcm1sIGFuZCBmdWxsIHNjcmVlblxuICAgICAqIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxTY3JlZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzRnVsbFNjcmVlbk1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGdWxsU2NyZWVuKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcHVzaCB0aGlzIGNvbXBvbmVudCB0byBmdWxsIHNjcmVlbiBtb2RlIG9yIG1heWJlIGZ1bGwgcGFnZSBtb2RlIHdlIG5lZWQgcnVuIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICAtIEV4ZWN1dGUgZXhwYW5kIHRyYW5zZm9ybWF0aW9uLCB3aGVyZSB3ZSBoYXZlIGFkZGl0aW9uYWwgb3ZlcmxheSBkaXYgdGhhdCB3ZSBzbG93bHkgZXhwYW5kXG4gICAgICogIGFuZCB0aGlzIGNyZWF0ZXMgaW1wcmVzc2lvbiB0aGUgRFQgaXMgZXhwYW5kaW5nXG4gICAgICpcbiAgICAgKiAgLSBhcHBseSBmdWxsLXNjcmVlbiBjbGFzcyBvbiB0b3AgaG9zdCBlbGVtZW50ICAtIGluIHRoaXMgY2FzZSBpdHMgRGF0YVRhYmxlIHRvIHN3aXRjaFxuICAgICAqICB0byBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAqXG4gICAgICogIC0gbWFrZSBzdXJlIHdlIGFyZSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cFxuICAgICAqXG4gICAgICogIC0gaGlkZSBhbGwgdGhlIGVsZW1lbnRzIG9uIHRoZSBwYWdlIHNvIHRoZWlyIGRpbWVuc2lvbiBkb24ndCBpbnRlcmZlcmUgd2l0aCB0aGlzIHRhYmxlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuRnVsbFNjcmVlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxTY3JlZW5Nb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJ1bkV4cGFuZEVmZmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbk9uRFQodHJ1ZSk7XG5cblxuICAgICAgICAvLyBtYXJrIG15IGVsZW1lbnQgaW4gdGhlIHBhdGggdGhhdCBuZWVkcyB0byBzdGF5XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgndS1mdWxsLXNjcmVlbi1lbGVtZW50Jyk7XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgIHRoaXMuZHQuc3RhdGUubGltaXQgPSBNYXRoLnJvdW5kKHRoaXMuY2FsY3VsYXRlTGltaXQoKSk7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LnN0YXRlKTtcblxuICAgICAgICAvLyBvbmNlIGxvYWRlZCBzZXQgYmFjayBjb3JyZWN0IHBhZ2Ugc2l6ZSB3ZSB1c2Ugd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgdGhpcy5kdC5zdGF0ZS5saW1pdCA9IHRoaXMuZHQucGFnZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgc2FtZSBsaWtlIGFib3ZlIG1ldGhvZCAob3BlbkZ1bGxTY3JlZW4pIGJ1dCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGdWxsU2NyZWVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmlzRnVsbFNjcmVlbk1vZGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnNob3dOb25GdWxsU2NyZWVuRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJ1bkNvbGxhcHNlRWZmZWN0KCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbk9uRFQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5saW1pdCA9IHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5kaXNwbGF5TGltaXQ7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmV0Y2godGhpcy5kdC5kYXRhU291cmNlLnN0YXRlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgdGhpcy5vcmlnaW5hbFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHNldCBvZiBzZXQgb2YgY3NzIHByb3BlcnRpZXMgdG8gbWFrZSB0aGUgRFQgbWFpbiBjb21wb25lbnQgb24gdGhlIHBhZ2UgZXhwYW5kIHRvXG4gICAgICogZnVsbCBwYWdlIG1vZGUgYW5kIGJhY2tcbiAgICAgKlxuICAgICAqIFdlIHdhbnQgdG8gbWFrZSBpdCB3aXRoIGxpdHRsZSBkZWxheSB0byBsZXQgb3RoZXIgYW5pbWF0aW9uIGZpbmlzaFxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxTY3JlZW5PbkRUKGZ1bGxTY3JlZW46IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCArPSAnZHQtZnVsbC1zY3JlZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCA9IHRoaXMuZHQuY2xhc3NMaXN0LnJlcGxhY2UoJ2R0LWZ1bGwtc2NyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgaW5maW5pdGUgc2Nyb2xsIGV2ZW50IGFuZCByZXF1ZXN0IG5ldyBkYXRhIGZyb20gZGF0YSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTGF6eUxvYWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChldmVudC5pc0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHQuc3RhdGUub2Zmc2V0ID0gZXZlbnQub2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRhdGFQcm92aWRlciA9IHRoaXMuZHQuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXI7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoZGF0YS5zbGljZSgwLCBldmVudC5vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5pbWF0aW9uIGVmZmVjdCB0byBtYWtlIGl0IGZlZWwgbGlrZSB0aGUgZWxlbWVudCAoaW4gdGhpcyBjYXNlIERUKSBpcyBleHBhbmRpbmdcbiAgICAgKiBmcm9tIHRoZSBtaWRkbGUgdG8gdGhlIGZ1bGwgcGFnZSBtb2RlLlxuICAgICAqXG4gICAgICogV2UgdGFrZSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0YWJsZSB0aGVuIGl0IGlzIHNjYWxlZCBzbG93bHkgdG8gdGhlIGZ1bGwgcGFnZVxuICAgICAqL1xuICAgIHByaXZhdGUgcnVuRXhwYW5kRWZmZWN0KClcbiAgICB7XG4gICAgICAgIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZXhwYW5kQ29sb3JGcm9tO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvclRvO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGFuZCBzY2FsZSB0aGUgaGVscGVyIGRpdiAob3ZlcmxheSkgZG93biB0byBtYWtlIGl0IGxvb2sgbGlrZVxuICAgICAqIGl0IGNvbGxhcHNlc1xuICAgICAqL1xuICAgIHByaXZhdGUgcnVuQ29sbGFwc2VFZmZlY3QoKVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbihmYWxzZSk7XG5cblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCh0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQsIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9LCA0MDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERGUyAgLSB0byBnbyB0aHJ1IGFsbCB0aGUgZWxlbWVudCB1bmRlciBCT0RZIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQocGFyZW50RWxlbWVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlID09PSBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRUcmF2ZXJzZURvd24oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3UtZnMtZWxlbWVudC1vdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1dCBhbGwgdGhlIGVsZW1lbnQgdGhhdCB3ZXJlIHByZXZpb3VzbHkgcmVtb3ZlZCBieSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoKSBiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93Tm9uRnVsbFNjcmVlbkVsZW1lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudS1mcy1lbGVtZW50LW91dCcpKVxuICAgICAgICAgICAgLmZvckVhY2goKGVsZW06IGFueSkgPT4gZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCd1LWZzLWVsZW1lbnQtb3V0JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBJbnRlcm5hbFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBuZWVkVHJhdmVyc2VEb3duKGVsZW1lbnQ6IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoZWxlbWVudCkgJiYgZWxlbWVudC50YWdOYW1lICE9PSAnU0NSSVBUJyAmJlxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3UtZnVsbC1zY3JlZW4tZWxlbWVudCcpICYmXG4gICAgICAgICAgICAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJyk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGVudGVyIGZ1bGwgc2NyZWVuIC9wYWdlIG1vZGUgd2hlbiBuZWVkIHRvIGNhbGN1bGF0ZSBob3cgbWFueSByb3dzIHRvIGxvYWQgaW5pdGlhbGx5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZUxpbWl0KCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGJyb3dzZXJIID0gdGhpcy5kb21VdGlscy5icm93c2VyRGltZW50aW9ucygpLmhlaWdodDtcbiAgICAgICAgbGV0IHJvd0ggPSB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHkgdHI6Zmlyc3QtY2hpbGQnKS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQocm93SCkgJiYgcm93SCA+IDApID8gKGJyb3dzZXJIIC8gcm93SCkgKyAyMCA6IDUwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBJbnRlcm5hbFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVFbGVtZW50KGw6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHc6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGg6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGwgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSB0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGx5VHJhbnNmb3JtYXRpb24oZXhwYW5kOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHgsIHksIHR4LCB0eTtcbiAgICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICAgICAgeCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgICAgICAgICAgIHkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHR4ID0gKHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGggLyAyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQpIC8geDtcbiAgICAgICAgICAgIHR5ID0gKHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAvIDJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wKSAvIHk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSAxO1xuICAgICAgICAgICAgeSA9IDE7XG4gICAgICAgICAgICB0eCA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIHR5ID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgJ3NjYWxlWCgnICsgeCArICcpIHNjYWxlWSgnICsgeSArICcpIHRyYW5zbGF0ZTNkKCcgKyAodHgpICsgJ3B4LCAnICsgKHR5KSArICdweCwgMHB4KSc7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJTkZJTklURSBTQ1JPTExJTkcgTUVUSE9EU1xuICAgICAqL1xuXG4gICAgcHJpdmF0ZSBpbml0RnVsbFNjcmVlbigpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydEZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGxvYWRpbmcgaXMgZmluaXNoZWQgbWFyayBsb2FkaW5nIGljb24gaXMgZG9uZSBzbyB3ZSBjYW4gaGlkZSBpdC4gSSBhbSB1c2luZyBsaXR0bGVcbiAgICAgKiBkZWxheSB0byBtYWtlIHRoZSBhbmltYXRpb24gdmlzaWJsZVxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZGluZ0ZpbmlzaGVkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbmZpbml0ZVNjcm9sbCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5pbmZpbml0ZVNjcm9sbC5jb21wbGV0ZSgpLCAyMDApO1xuXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQge0FmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIHJlc3BvbnNpYmxlIGZvciBjaGVja2luZyBhbmQgc2V0dGluZyB0aGUgd2lkZXN0IGNvbnRlbnQgd2lkdGggb250b1xuICogQ29sdW1uIGNvbXBvbmVudCBhcyB0aGUgd2lkZXN0Q2VsbCBwcm9wZXJ0eS5cbiAqXG4gKiBXZSB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zaWRlIGR0LWNvbHVtbi5jb21wb25lbnQgdG8gc3RvcmUgYSBjdXJyZW50IHdpZHRoIGZvciBlYWNoIHRkLHRoXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZHRNYXhXaWR0aF0nXG59KVxuZXhwb3J0IGNsYXNzIFNldENlbGxNYXhXaWR0aERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdFxue1xuXG4gICAgQElucHV0KClcbiAgICBkdE1heFdpZHRoOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRkOiBEVENvbHVtbjJDb21wb25lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2VsbCBNYXggV2lkdGg6ICcgKyB0aGlzLmR0TWF4V2lkdGgsIHRoaXMuZHRNYXhXaWR0aCA+IDApO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHRNYXhXaWR0aCkgJiYgdGhpcy5kdE1heFdpZHRoID4gMCkge1xuICAgICAgICAgICAgbGV0IGlubGluZURhdGEgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtY29sLWNlbGwtZGF0YScpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpbmxpbmVEYXRhKSkge1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBpbmxpbmVEYXRhLm9mZnNldFdpZHRoOyAvLyB0ZFxuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5UaHJlc0hvbGQoY2VsbFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9IHRoaXMudGRQYWRkaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCA+IHRoaXMudGQud2lkdGhQeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFdpZHRoIDwgdGhpcy5kdE1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRkLndpZGVzdENlbGwgPSBjZWxsV2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGwgPyBjZWxsV2lkdGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbDtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNlbGxXaWR0aCA+PSB0aGlzLmR0TWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9ICh0aGlzLmR0TWF4V2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmR0TWF4V2lkdGggOiB0aGlzLnRkLndpZGVzdENlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIHRoZSBuZXcgd2lkdGggdGhlIHNhbWUgYXMgdGhlIG9uZSBhbHJlYWR5IHNldCBvbiB0aGUgY29sdW1uPyBJZiB5ZXMgdGhlbiBwcm9iYWJseVxuICAgICAqIG5ldyBjb250ZW50IGRvZXMgbm90IGRpZmZlciB0aGF0IG11Y2guIFdlIHN0aWxsIGtlZXAgY2VydGFpbiB0aHJlc2hvbGQgYXMgdGhlIG5ldyBjb250ZW50XG4gICAgICogd2lkdGggbWlnaHQgZGlmZmVyIDEgb3IgMiBwaXhlcyBkZXBlbmRpbmcgaG93IHNldCB0aGUgY3NzLlxuICAgICAqXG4gICAgICogVG8gbWFrZSBzdXJlIHdlIHJlc2l6ZSBjb2x1bW4gb25seSBpZiBuZWNlc3NhcnkgYmVjYXVzZSBpdCBjb3VsZCBiZSBvcmlnaW5hbCBzaXplXG4gICAgICogaXMgNDAwcHggYnV0IHRoZSBuZXcgb25lIGlzIDQwMXB4IHNpbmNlIHNvbWV3aGVyZSBhZGQgc29tZSBleHRyYSBib3JkZXIgd2UgaGF2ZSB0aGlzXG4gICAgICogc2FmZSB0aHJlc2hvbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW5UaHJlc0hvbGQobmV3V2lkdGg6IG51bWJlcik6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnRkLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy50ZC53aWRlc3RDZWxsIC0gbmV3V2lkdGgpID4gMyAmJiBuZXdXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdGRQYWRkaW5nKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgbGV0IGNlbGwgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgfHwgMDtcbiAgICAgICAgY2VsbCArPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcblxuICAgICAgICAvLyBwbHVzIGdpdmUgaXQgc29tZSBsaXR0bGUgc3BhY2UgYXJvdW5kIHRoZSB0ZXh0IHNvIGl0IG5vdHMgcHggdG8gcHggaW5uZXIgd2lkdGggb2YgdGhlIHRkXG4gICAgICAgIC8vIGN1eiBpdCBjb3VsZCB3cmFwXG4gICAgICAgIGNlbGwgKz0gNTtcblxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cblxuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LFxuICAgIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEcmFnRGlyZWN0aW9uLCBEcmFnRXZlbnRzLCBEcm9wUG9zaXRpb259IGZyb20gJy4uL2F3LWRhdGF0YWJsZSc7XG5cblxuLyoqXG4gKiBEaXJlY3RpdmUgdXNlZCBpbnNpZGUgRFQgaW4gb3JkZXIgdG8gc3VwcG9ydCB0YWJsZSByb3dzIHJlLW9yZGVyaW5nLiBUaGlzIG1hbmFnZXMgYWxsIHRoZVxuICogRCZEIG5lY2Vzc2FyeSBsb2dpYyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFtkdERyYWdnYWJsZVJvd10gaXMgdXNlZCBpbnNpZGUgdGhlIGByb3dUZW1wbGF0ZWAgbGlrZSB0aGlzOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogPG5nLXRlbXBsYXRlICNyb3dUZW1wbGF0ZSBsZXQtcm93RGF0YSBsZXQtZXZlbj0nZXZlbnRcIiBsZXQtb2RkPVwib2RkXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIlxuICogICAgICAgICAgICAgIGxldC1uZXN0aW5nTGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIiBsZXQtY29sc1RvUmVuZGVyPVwiY29sc1RvUmVuZGVyXCI+XG4gKlxuICogICAgIDx0ciAjcm93RWxlbWVudCBkdERyYWdnYWJsZVJvdyBbZG5kUm93SW5kZXhdPVwicm93SW5kZXhcIlxuICogICAgICAgICAgY2xhc3M9XCJkdC1ib2R5LXJvd1wiXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiB3aGljaCBlbmFibGVkIG9yIGRpc2FibGVzIGJhc2VkIG9uIHRoZSB1c2VkIERUIGJpbmRpbmcgW2RuZFJvd0VuYWJsZWRdLiBCeSBkZWZhdWx0IGl0cyBkaXNhYmxlZC5cbiAqXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZHREcmFnZ2FibGVSb3ddJ1xufSlcbmV4cG9ydCBjbGFzcyBEVERyYWdnYWJsZVJvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkaXJlY3RpdmUgaWYgd2UgZW5hYmxlIG1pZGRsZSByb3cgem9uZSB0byBjcmVhdGUgYW4gZWZmZWN0IHRoYXQgd2UgYXJlIGRyb3BwaW5nXG4gICAgICogaW50byB0aGUgcm93LiBVc2VkIGZvciBvdXRsaW5lIERUIG1haW5seS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZHJvcEludG9FbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IFRSIGluZGV4IG51bWJlclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dJbmRleDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IG91ciBkcmFnZ2luZyBkaXJlY3Rpb24gVVAgYW5kIERPV04gaW4gb3JkZXIgdG8gYXNzaWduIGNvcnJlY3Qgc3R5bGVcbiAgICAgKiB0aGF0IGhpZ2hsaWdodHMgdGhlIHJvdyBhdCB0aGUgdG9wIG9yIGJvdHRvbVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyOiBEcmFnRGlyZWN0aW9uID0gRHJhZ0RpcmVjdGlvbi5Ob25lO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgd2UgZHJhZ2dlZCBvdXIgcm93IGFuZCBzdG9wcGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIG90aGVyIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbk1pZGRsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDdXJyZW50IGRyYWcgWSBjb29yZGluYXRlcyB3aGljaCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIGRyYWdEaXIgd2hlbiBhc3NpbmdpbmcgZHJhZ2dpbmdcbiAgICAgKiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRyYWdZOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogbGlzdGVuZXJzIGhhbmRsZXJzIGhlcmUgLSB0aGUgcmV0dXJuIGZyb20gLmJpbmQodGhpcykuXG4gICAgICovXG4gICAgcHJpdmF0ZSBldmVudEhhbmRsZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkdDogRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSlcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5kbmRSb3dFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZHQuZG5kUm93RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBsaXN0ZW5lcnMgYW5kIHJldHVybnMgaGFuZGxlIHRvIHRoZW0gc28gd2UgY2FuIGxhdGVyIG9uIHVuc3Vic2NyaWJlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0dXBFdmVudExpc3RlbmVycygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snbW91c2Vkb3duJ10gPSB0aGlzLm9uTW91c2VEb3duRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydtb3VzZWRvd24nXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ3N0YXJ0J10gPSB0aGlzLm9uRHJhZ1N0YXJ0RXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnc3RhcnQnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ292ZXInXSA9IHRoaXMub25EcmFnT3ZlckV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnb3ZlciddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnbGVhdmUnXSA9IHRoaXMub25EcmFnTGVhdmVFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdsZWF2ZSddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcm9wJ10gPSB0aGlzLm9uRHJvcEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2Ryb3AnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2VuZCddID0gdGhpcy5vbkRyYWdFbmRFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnZW5kJ10pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgY3JlYXRlZCBsaXN0ZW5lcnMgaW5zaWRlIGRlc3Ryb3koKSBjYWxsYmFja1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVsZWFzZUV2ZW50TGlzdGVuZXJzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIERyYWdFdmVudHMuZm9yRWFjaCgobmFtZTogc3RyaW5nKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCduYW1lJywgdGhpcy5ldmVudEhhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZmlyc3QgZXZlbnQgd2hlcmUgd2U6XG4gICAgICpcbiAgICAgKiAgLSBNYXJrIGVsZW1lbnQgZHJhZ2dhYmxlIHRvIGVuYWJsZSBEJkRcbiAgICAgKiAgLSBTZXQgY2xpY2sgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgY3VycmVudCByb3dcbiAgICAgKiAgICAgIFRoaXMgaXMgbWFpbmx5IG5lZWRlZCB3aGVuIHdlIGFyZSB0cnlpbmcgdG8gY2FsY3VsYXRlIHNvbWV0aGluZyBmb3JcbiAgICAgKiAgICAgIGRyb3BJbnRvIHJvdyAob3V0bGluZSlcbiAgICAgKlxuICAgICAqIGV2ZW50LnRhcmdldCB1c3VhbGx5IGNvbnRhaW5zIHJlZmVyZW5jZSB0byBURCBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBvbk1vdXNlRG93bkV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIHRoaXMuZG9tVXRpbHMuaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgJy5kdC1yb3ctZHJhZ2dhYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZWxUb0JlRHJhZ2dlZCA9IHRoaXMuZG9tVXRpbHMuZWxlbWVudERpbWVuc2lvbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuZHQuZW52LnNldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnLCAoZWxUb0JlRHJhZ2dlZC5oZWlnaHQgLyAyKSAtIGV2ZW50Lm9mZnNldFkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZWNvbmQgdHJpZ2dlcmVkIGV2ZW50IHdoZW4gdGhlIGFjdHVhbCBkcmFnZ2luZyBzdGFydHMuIEhlcmUgd2UgbmVlZCB0byBkaXNhYmxlXG4gICAgICogZHJhZ2dlZCByb3cgYW5kIHNhdmUgaW5mb3JtYXRpb24gdGhhdCBhcmUgY29tbW9uIHRvIGEgdGFibGUuXG4gICAgICpcbiAgICAgKiBNYXJraW5nIHJvdyBkaXNhYmxlZCB3aXRoIHRoZSBzdHlsZSAuZHQtcm93LWRyYWdnaW5nIHVzaW5nIHNldFRpbWVvdXQgaXMgbmVlZGVkIGFzXG4gICAgICogaWYgd2Ugd291bGQgZ28gd2l0aG91dCBpdCB0aGVuIEQmRCBmcmFtZXdvcmsgd291bGQgY3JlYXRlIGEgY29weSBvZiByb3cgaW4gZGlzYWJsZWQgc3RhdGUuXG4gICAgICogTm93IHdlIGdyYWIgYSByb3cgd2l0aCBhY3RpdmUgc3RhdGUgYW5kIGFmdGVyIGEgMjAwbXMgZGVsYXkgd2UgZGlzYWJsZSB0aGUgb3JpZ2luYWwgcm93LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdTdGFydEV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnZHQtcm93LWRyYWdnaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG5cbiAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2lzRHJhZ2dpbmcnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2RuZElkJywgdGhpcy5kbmRSb3dJbmRleCk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgdGhpcy5kbmRSb3dJbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50cyBoYXBwZW5zIGFueXRpbWUgYXMgd2UgZHJhZyBvdmVyIHJvd3MuIFRoaXMgZXZlbnQgdHJpZ2dlcmVkIGFmdGVyIGNlcnRhaW5cbiAgICAgKiBkZWxheS4gSW4gaGVyZSB3ZSBjYWxjdWxhdGUgdGhlIG1vdXNlIG1vdmVtZW50IHRvIGlkZW50aWZ5IGlmIHdlIGFyZSBnb2luZyBVUCBvciBET1dOLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBtYWlubHkgbmVlZGVkIHRvIG1hcmsgYSByb3cgd2l0aCB0aGUgY29ycmVjdCBsaW5lIG9uIFRPUCBvciBCT1RUT00gdG8gdmlzdWFsbHlcbiAgICAgKiBzaG93IGEgdXNlciB3aGVyZSB3ZSBhcmUuXG4gICAgICpcbiAgICAgKiBPbmNlIHdlIGtub3cgdGhlIGRpcmVjdGlvbiBhbmQgdGhlIGRyb3AgdGFyZ2V0IGlzIHZhbGlkIHdlIG1hcmsgdGhlIHJvdyB3aXRoIGNvcnJlY3QgY2xhc3NcbiAgICAgKiB0aGF0IGRvZXMgdGhlIHRyaWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdPdmVyRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgICBpZiAodGhpcy5kcmFnWSA8IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLkRvd247XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnWSA+IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLlVwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbnQgc2V0IGFnYWluIHVubGVzcyBpdHMgZGlmZmVyZW50XG4gICAgICAgIGlmICh0aGlzLmRyYWdZICE9PSBldmVudC5wYWdlWSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERyb3BUYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0b2RvIHRlc3QgdGhpcyBwcmV2ZW50RGVmYXVsdCgpIHNvIGl0IGRvZXMgbm90IGNyZWF0ZSBzb21lIHNpZGVlZmZlY3RcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQsIHRoaXMuZG9tVXRpbHMuY2xvc2VzdChldmVudC50YXJnZXQsICd0cicpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZmluaXNoaW5nIGV2ZW50IGp1c3QgYmVmb3JlIEQmRCBpcyBkb25lLiBJdCB0YWtlcyBjdXJyZW50IGluZm9ybWF0aW9uIGFuZFxuICAgICAqIGJyb2FkY2FzdCB0aGVtIHRvIHRoZSBEVCBzbyBEVCBjYW4gZG8gbmVjZXNzYXJ5IHJvdyByZW9yZGVyaW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25Ecm9wRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgb3JpZ0luZHggPSB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgbGV0IGRyb3BQb3M6IERyb3BQb3NpdGlvbiA9IHRoaXMuaW5NaWRkbGUgPyBEcm9wUG9zaXRpb24uSW50byA6IChcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCA/IERyb3BQb3NpdGlvbi5CZWZvcmUgOiBEcm9wUG9zaXRpb24uQWZ0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kdC5vbkRuRFJvd0Ryb3Aob3JpZ0luZHgsIHRoaXMuZG5kUm93SW5kZXgsIGRyb3BQb3MpO1xuXG4gICAgICAgIHRoaXMuaW5NaWRkbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnWSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnkgdGltZSB3ZSBkcmFnIG92ZXIgdGhlIGVsZW1lbnQgd2UgYXBwbHkgc29tZSBjbGFzc2VzIHRvIHRoZSBpdC4gdGhpcyBtZXRob2QgZG9lcyB0aGVcbiAgICAgKiBvcHBvc2l0ZSB3aGljaCBpcyB0byByZW1vdmUgZXZlcnl0aGluZyBzbyB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBuZXh0IHJvd1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ0xlYXZlRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB0ciA9IHRoaXMuZG9tVXRpbHMuY2xvc2VzdChldmVudC50YXJnZXQsICd0cicpO1xuICAgICAgICB0aGlzLmNsZWFyQ2xhc3Nlcyh0cik7XG5cbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RuZE9uSG9sZEluZGV4Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGxhc3QgZXZlbnQgd2l0aGluIEQmRCBmbG93LiBNYWlubHkgdXNlZCB0byBjbGVhbiB1cCBhbGwgdGhlIHJlc291cmNlIHRoYXQgaGFzIG5vdFxuICAgICAqIGJlZW4gY2xlYW4gdXAgYWxyZWFkeSBpbnNpZGUgb25Ecm9wRXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ0VuZEV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGV2ZW50LnRhcmdldC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHQtcm93LWRyYWdnaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyQ2xhc3NlcyhldmVudC50YXJnZXQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2lzRHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIHRoaXMuZHQuZW52LmRlbGV0ZVZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBDU1MgY2xhc3NlcyB0byB0aGUgcm93IHRvIGNyZWF0ZSBhbiBoaWdobGlnaHRpbmcgZWZmZWN0IHRvIGNhcHR1cmUgY3VycmVudCBwb3NpdGlvblxuICAgICAqIGZvciB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEJhc2VkIG9uIHRoZSBEcmFnIGRpcmVjdGlvbiB3ZSBlaXRoZXIgYXBwbHlcbiAgICAgKiBjc3MgY2xhc3MgdGhhdCBjcmVhdGVzIGEgbGluZSBvbiB0b3Agb3IgYm90dG9tLiAgT25seSBmb3IgdGhlIGRyb3BJbnRvIGZ1bmN0aW9uYWxpdHkgd2VcbiAgICAgKiBuZWVkIHRvIGNhbGN1bGF0ZSBzb21lIG1vcmUgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIHJlYWxseSBpbiB0aGUgbWlkZGxlIG9mIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiBEcm9wSW50bzpcbiAgICAgKiAtLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEluaXRpYWxseSB3ZSBjYXB0dXJlZCBhIHBvc2l0aW9uIChpbiBtb3VzZWRvd24pIHRoZSBkaXN0YW5jZSB0byB0aGUgbWlkZGxlIG9mIHRoZSByb3cgYW5kXG4gICAgICogdGhpcyB3ZSBhcmUgdXNpbmcgaGVyZSB3aXRoIHNvbWUgdGhyZXNob2xkIG9mIDIgcGl4ZXMgc28gd2UgZG9udCBoYXZlIHRvIGJlIGV4YWN0bHkgb24gcGl4ZWxcbiAgICAgKiBwZXJmZWN0LlxuICAgICAqXG4gICAgICogLSBsZXQgY3VycmVudFRyQ2VudGVyID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhhY3RpdmVSb3cpLmhlaWdodCAvIDI7XG4gICAgICogICAgICBSZWFkIGNlbnRlciBvZiBjdXJyZW50IHJvd1xuICAgICAqXG4gICAgICogLSBsZXQgZHJhZ2dlZFRyQ2VudGVyID0gZXZlbnQub2Zmc2V0WSArIHRoaXMuZHQuZW52LmdldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICAgKiAgICAgIFJlYWQgbW91c2UgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY3VycmVudCByb3cvdGQgYW5kIGFkZCB0byBpdCBvdXIgZGV2aWF0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQ6IGFueSwgYWN0aXZlUm93OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGFjdGl2ZVJvdyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZHJhZyBpdGVtIGlzIGluIHRoZSBtaWRkbGUgb2Ygb3RoZXIgcm93XG4gICAgICAgIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IGRyYWdnZWRUckNlbnRlciA9IGV2ZW50Lm9mZnNldFkgKyB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZGRDbGlja0RldmlhbmNlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcEludG9FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluTWlkZGxlID0gTWF0aC5hYnMoY3VycmVudFRyQ2VudGVyIC0gZHJhZ2dlZFRyQ2VudGVyKSA8IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbk1pZGRsZSkge1xuICAgICAgICAgICAgYWN0aXZlUm93LmNsYXNzTGlzdC5hZGQoRHJhZ0RpcmVjdGlvbi5NaWRkbGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVSb3cuY2xhc3NMaXN0LmFkZCh0aGlzLmRyYWdEaXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEcm9wIHRhcmdldCBtdXN0IGJlIG9ubHkgYW5vdGhlciBUUiBhbmQgaXQgY2Fubm90IGJlIHRoZSBlbGVtZW50IGl0c2VsZiB0aGUgb25lIHdlIGFyZVxuICAgICAqIGRyYWdnaW5nIGFuZCBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGFsbG93IHRvIGRyb3AgdG8gdGhlIHNhbWUgcG9zaXRpb24gd2Ugc3RhcnRlZCBmcm9tXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzVmFsaWREcm9wVGFyZ2V0KGV2ZW50OiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgb3JpZ0lueCA9IHRoaXMuZHQuZW52LmdldFZhbHVlKCdkbmRJZCcpO1xuICAgICAgICBsZXQgc2libGluZ1JvdyA9IHRoaXMuZG5kUm93SW5kZXggLSBvcmlnSW54O1xuXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQucGFyZW50RWxlbWVudC50YWdOYW1lID09PSAnVFInICYmIHRoaXMuZG5kUm93SW5kZXggIT09IG9yaWdJbnggJiZcbiAgICAgICAgICAgICEoc2libGluZ1JvdyA9PT0gMSAmJiB0aGlzLmRyYWdEaXIgPT09IERyYWdEaXJlY3Rpb24uVXApICYmXG4gICAgICAgICAgICAhKHNpYmxpbmdSb3cgPT09IC0xICYmIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5Eb3duKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNsZWFyQ2xhc3Nlcyh0cjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctdG9wJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdHRvbScpO1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy1ib3RoJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ0RpclRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdEaXIpIHtcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VwJztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiAnRG93bic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnTm90IFN1cmUnO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4uL291dGxpbmUvb3V0bGluZS1mb3IubW9kdWxlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUV3JhcHBlcn0gZnJvbSAnLi90YWJsZS13cmFwcGVyL3RhYmxlLXdyYXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdJbnB1dEZpZWxkTW9kdWxlfSBmcm9tICcuLi9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vbXVsdGktc2VsZWN0L2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge1xuICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9kdC1jZWxsLWRpcmVjdGl2ZXMnO1xuaW1wb3J0IHtEVERyYWdnYWJsZVJvd0RpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICBEVFdyYXBwZXIsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgRFRIZWFkZXJDb21wb25lbnQyLFxuICAgICAgICBEVERldGFpbFJvd0NvbXBvbmVudCxcbiAgICAgICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCxcbiAgICAgICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlLFxuICAgICAgICBTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQsXG4gICAgICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBEVEhlYWRlckNvbXBvbmVudDIsXG4gICAgICAgIERURGV0YWlsUm93Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRGF0YXRhYmxlMk1vZHVsZVxue1xufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gY29uZmlybWF0aW9uIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29uZmlybWF0aW9uQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24taGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBjb25maXJtYXRpb24gaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBDb25maXJtYXRpb25Db21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbi1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBDb25maXJtYXRpb24gQ29tcG9uZW50IGlzIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgZGlhbG9nIHdoZXJlIGl0IHN1cHBvcnRzIGNvbmZpcm0gYW5kIGNhbmNlbFxuICogZnVuY3Rpb25hbGl0eS4gSXQgYmVoYXZlcyBsaWtlIGEgZGlhbG9nLCBpcyBtb2RhbCwgYW5kIG5vdCBjbG9zYWJsZSBieSBkZWZhdWx0LlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8Q29uZmlybWF0aW9uQ29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoaXMgdXNhZ2UgaXMgYSBxdWljayB3YXkgdG8gc2hvd1xuICogICAgICAgIGEgY29uZmlybWF0aW9uIHRvIHRoZSB1c2VyLlxuICpcbiAqICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48Q29uZmlybWF0aW9uQ29tcG9uZW50PihDb25maXJtYXRpb25Db21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb25maXJtYXRpb24nLFxuICogICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgIEFyZSB5b3Ugc3VyZSA/IGAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzMDAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29uZmlybTogKCkgPT4ge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6ICgpID0+IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWNvbmZpcm1hdGlvbiBbdGl0bGVdPVwiJ0NvbmZpcm1hdGlvbidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsodmlzaWJsZSldPVwiZGlzcGxheVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25Db25maXJtKT1cImNvbmZpcm1BY3Rpb24oKVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNhbmNlbCk9XCJjYW5jZWxBY3Rpb24oKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIGljb24tYWxlcnRcIj48L2k+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgeW91ciBoYXJkIGRyaXZlP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jb25maXJtYXRpb24+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvcGVuKClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BlbiBDb25maXJtYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW4oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gKiAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb24oKSAge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24gPSBcImNvbmZpcm1lZFwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gZmFsc2U7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbiA9IFwiY2FuY2VsZWRcIjtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnY29uZmlybWF0aW9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnY29uZmlybWF0aW9uLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uQ29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXJcbntcbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIERpYWxvZy4gIGlmIHRpdGxlIGFuZCAnVGl0bGVUZW1wbGF0ZScgYXJlIGJvdGggc2V0LCB0aXRsZVRlbXBsYXRlIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5IHNlY3Rpb24gZm9yIERpYWxvZy4gQ2FsbGVyIHNob3VsZCB1c2UgZWl0aGVyIHRoZSBib2R5IHN0cmluZywgb3IgY29udGVudCBwcm9qZWN0aW9uXG4gICAgICogdG8gYWRkIHZhbHVlcyB0byB0aGUgZGlhbG9nLiBJZiBib3RoIGFyZSB1c2VkLCB0aGV5IHdpbGwgYm90aCBzaG93IHVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gT0sgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb25maXJtQWN0aW9uTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIENhbmNlbCBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNhbmNlbEFjdGlvbkxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHN1cHBvcnQgdHdvIHdheSBkYXRhIGJpbmRpbmcgb24gdmlzaWJsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUncyBhbiB4IGF0IHRoZSB0b3AgcmlnaHQgdGhhdCBtYWtlcyB0aGUgZGlhbG9nIGNsb3NhYmxlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2xvc2FibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZGlhbG9nLiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBkaWFsb2cgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgZGlhbG9nIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGNsaWNrZWQgb24gY29uZmlybSBidXR0b24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Db25maXJtOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdXNlciBjbGlja2VkIG9uIGNhbmNlbCBidXR0b24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWw6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGNvbXBvbmVudC4gVXN1YWxseSBjb250YWlucyB0aGUgdGl0bGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQpIGhlYWRlcjogQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRGlhbG9nIGZvb3Rlci4gVXN1YWxseSBjb250YWlucyBidXR0b25zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnQpIGZvb3RlcjogQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IDQwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIC8vIFRvZG86IGludGVybmF0aW9uYWxpemUuXG4gICAgICAgIHRoaXMuY29uZmlybUFjdGlvbkxhYmVsID0gJ0NvbmZpcm0nO1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbkxhYmVsID0gJ0NhbmNlbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3BlbiBjb25maXJtYXRpb24uXG4gICAgICovXG4gICAgb3BlbigpXG4gICAge1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgY29uZmlybWF0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuXG4gICAgICAgIC8vIEltcG9ydGFudCB0byBtYWtlIHN1cmUgY2hhbmdlIGlzIHNldCBvbiBwYXJlbnQgYmluZGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFyaWFibGUgYW5kIGRpYWxvZyBvcGVuL2Nsb3NlIHN0YXRlIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2Ygc3luYyBhbmQgd2Ugd291bGRuJ3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgY29uZmlybWF0aW9uIGhhdmUgaGVhZGVyIGNvbnRlbnQ/XG4gICAgICovXG4gICAgaGFzSGVhZGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGNvbmZpcm1hdGlvbiBoYXZlIGZvb3RlciBjb250ZW50P1xuICAgICAqL1xuICAgIGhhc0Zvb3RlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZm9vdGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maXJtIGFjdGlvbi5cbiAgICAgKi9cbiAgICBjb25maXJtKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vbkNvbmZpcm0uZW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhY3Rpb24uXG4gICAgICovXG4gICAgY2FuY2VsKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vbkNhbmNlbC5lbWl0KCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtDb25maXJtYXRpb25Db21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7QVdEaWFsb2dNb2R1bGV9IGZyb20gJy4uL2RpYWxvZy9kaWFsb2cubW9kdWxlJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NvbmZpcm1hdGlvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBDb250YWluZXIgcGFuZWwgcHJvdmlkaW5nIHNjcm9sbGluZyBmdW5jdGlvbmFsaXR5IGZvciBpdHMgY2hpbGRyZW4uIFlvdSBjYW4gY29uZmlndXJlIHRoaXNcbiAqIGNvbnRhaW5lciB0byBsZXQgaXQgdG8gc2Nyb2xsIGl0cyBjb250ZW50IGVpdGhlciBob3Jpem9udGFsbHksIHZlcnRpY2FsbHkgb3IgbGV0IHRoZSBjb250ZW50XG4gKiB3cmFwLlxuICpcbiAqXG4gKiBVc2FnZSBpcyBwcmV0dHkgc2ltcGxlOlxuICpcbiAqICAjIyMgRXhhbXBsZSB1c2luZyBob3Jpem9udGFsIHNjcm9sbCAoZGVmYXVsdCBiZWhhdmlvcik6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZT5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKlxuICogIGBgYFxuICpcbiAqICAjIyMgRXhhbXBsZSB1c2luZyB2ZXJ0aWNhbCBzY3JvbGw6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZSBbZGlyZWN0aW9uXT1cIid2ZXJ0aWNhbCdcIiBbaGVpZ2h0XT1cIic0MHZoJ1wiPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIyMjIEV4YW1wbGUgc2Nyb2xsaW5nIGlzIGRpc2FibGVkIGFuZCBjb250ZW50IHdyYXBzIGFuZCBjZW50ZXJzOlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LXNjcm9sbGFibGUgW2RpcmVjdGlvbl09XCInbm9uZSdcIiBbYWxpZ25tZW50XT1cIidjZW50ZXInXCI+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICogIGBgYFxuICpcbiAqICMjIyBIZWlnaHQgcHJvcGVydHk6XG4gKlxuICogV2hlbiB1c2luZyBcImhvcml6b250YWwgc2Nyb2xsaW5nXCIgaXQgc2V0IFwiZmxleGJveC1kaXJlY3Rpb25cIiB0byBcInJvd1wiIHdoZXJlIGhlaWdodFxuICogaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGNvbnRlbnQuIFRoZSBoZWlnaHQgc2hvdWxkIGJlIGFsd2F5cyAxMDAlIHdoZW4gdXNpbmdcbiAqIHRoaXMgaW4gcGFyZW50IGNvbnRhaW5lci5cbiAqXG4gKiBJZiBcInZlcnRpY2FsIHNjcm9sbGluZ1wiIGlzIHVzZWQgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQ6XG4gKiAgIC0geW91ciBwYXJlbnQgY29udGFpbmVyIHNldHMgdGhlIGJvdW5kYXJpZXMgd2l0aCBjb3JyZWN0bHkgc2V0IHdpZHRoIGFuZCBoZWlnaHRcbiAqICAgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIDEwMCUgb2YgdGhlIHZpZXdwb3J0XG4gKiAgIC0gaWYgdXNlZCBhcyBzdGFuZGFsb25lIHlvdSBuZWVkIHRvIGxpbWl0IHRoZSBoZWlnaHQgb3RoZXJ3aXNlIGl0IHdpbGwgZXhwYW5kIHRvIDEwMCUgb2ZcbiAqICAgdGhlIGRvY3VtZW50XG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNjcm9sbGFibGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnc2Nyb2xsYWJsZS1jb250YWluZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydzY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmVyIG1lYW5pbmcgdGVsbHMgd2hpY2ggb3ZlcmZsb3cgYXhpZXMgd2lsbCBiZVxuICAgICAqIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFwiaG9yaXpvbnRhbFwiOiBIZXJlIHdlIGxvY2sgb3ZlcmZsb3cteSBhbmQgb3ZlcmZsb3cteCBzZXQgdG8gYXV0by5cbiAgICAgKlxuICAgICAqIFdoZW4gc2Nyb2xsaW5nIGRpcmVjdGlvbiBpcyBcInZlcnRpY2FsXCIgcGxlYXNlIG1ha2Ugc3VyZSB5b3UgbWFpbnRhaW4gY29ycmVjdCBoZWlnaHQgYW5kXG4gICAgICogd2lkdGguXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpcmVjdGlvbjogU2Nyb2xsaW5nRGlyZWN0aW9uID0gJ2hvcml6b250YWwnO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgZmxleGJveCBjb250YWluZXIgaXRlbXMgc2hvdWxkIGJlIGFsaWduZWQuIERlZmF1bHQgYmVoYXZpb3IgaXMgTEVGVFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbm1lbnQ6IENvbnRhaW5lckl0ZW1zQWxpZ25tZW50ID0gJ2xlZnQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwcm9wZXJ0aWVzIGZvciBjYWxjdWxhdGVkIGNsYXNzIGxpc3RcbiAgICAgKi9cblxuICAgIGxheW91dENsYXNzOiBzdHJpbmc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHdlIHJlLWluaXRpYWxpemUgZGVmYXVsdCB3aGVuIElucHV0IEJpbmRpbmdzIGNoYW5nZXNcbiAgICAgKlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmluaXREZWZhdWx0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGRlZmF1bHQgdmFsdWVzIGFuZCBDYWxjdWxhdGVzIGxheW91dCBhbmQgYWxpZ25tZW50IGNsYXNzLiBUaGUgcmVhc29uIGZvciB1c2luZ1xuICAgICAqIHRoZXNlIHV0aWxpdHkgY2xhc3NlcyBpcyB0aGF0IHdlIGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yIGFueXRpbWUgYXMgY29tcGFyZWQgdG8gdXNpbmdcbiAgICAgKiBkaXJlY3RseSBbc3R5bGUueHh4XSBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqICMjIyBEaXJlY3Rpb24gZmxvdyBjbGFzczpcbiAgICAgKiAgLSB1LXNjcm9sbGFibGUtZjxkaXJlY3Rpb24+XG4gICAgICpcbiAgICAgKiAjIyMgQWxpZ25tZW50IGNsYXNzOlxuICAgICAqICAtIHUtc2Nyb2xsYWJsZS1hPGFsaWdubWVudD5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdERlZmF1bHQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZmgnO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZ2JztcblxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsLXJvdycpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZ2LXJvdyc7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mYic7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mbic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheW91dENsYXNzICs9ICcgdS1zY3JvbGxhYmxlLWEnICsgdGhpcy5hbGlnbm1lbnQuc3Vic3RyaW5nKDAsIDEpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdHlsZUNsYXNzKSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyArPSBgICR7dGhpcy5zdHlsZUNsYXNzfWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHNvbWUgdmFsdWUgaW4gY2FzZSBzb21lYm9keSBwYXNzZXMgbnVsbFxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLndpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNIb3Jpem9udGFsU2Nyb2xsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBzY3JvbGxDb250YWluZXIgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1zY3JvbGxhYmxlJyk7XG4gICAgICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGggPiBzY3JvbGxDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1ZlcnRpY2FsU2Nyb2xsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBzY3JvbGxDb250YWluZXIgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1zY3JvbGxhYmxlJyk7XG4gICAgICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsQ29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB9XG59XG5cbi8qKlxuICogU2Nyb2xsaW5nRGlyZWN0aW9uIGlzIGEgbmV3IHR5cGUgdGhhdCBkcml2ZXMgc2Nyb2xsaW5nIGJlaGF2aW9yOlxuICogIC0gaG9yaXpvbnRhbCA9PiBvdmVyZmxvdy14OiBhdXRvLCBvdmVyZmxvdy15OmhpZGRlblxuICogIC0gdmVydGljYWwgPT4gb3ZlcmZsb3cteDogaGlkZGVuLCBvdmVyZmxvdy15OmF1dG9cbiAqICAtIHZlcnRpY2FsLXJvdyA9PiBvdmVyZmxvdy14OiBoaWRkZW4sIG92ZXJmbG93LXk6YXV0bzsgZmxvdzogcm93IHdyYXBcbiAqICAtIGJvdGggPT4gb3ZlcmZsb3cteDogYXV0bywgb3ZlcmZsb3cteTphdXRvXG4gKiAgLSBub25lID0+IHNldHMgZmxvdy1mbG93IHRvIHJvdyB3cmFwXG4gKi9cbmV4cG9ydCB0eXBlIFNjcm9sbGluZ0RpcmVjdGlvbiA9ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgfCAndmVydGljYWwtcm93JyB8ICdib3RoJyB8ICdub25lJztcblxuXG4vKipcbiAqXG4gKiBDb250cm9scyB0aGUganVzdGlmeS1jb250ZW50IHByb3BlcnR5OlxuICpcbiAqIC0gbGVmdCA9PiBmbGV4LXN0YXJ0XG4gKiAtIHJpZ2h0ID0+IGZsZXgtZW5kXG4gKiAtIGNlbnRlciA9PiBjZW50ZXJcbiAqIC0ganVzdGlmeSA9PiBzcGFjZS1iZXR3ZWVuXG4gKlxuICovXG5leHBvcnQgdHlwZSBDb250YWluZXJJdGVtc0FsaWdubWVudCA9ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50fSBmcm9tICcuL3Njcm9sbGFibGUtY29udGFpbmVyLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtMaXN0Ym94LCBTZWxlY3RJdGVtfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtDaGVja2JveENvbXBvbmVudH0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50JztcblxuXG5leHBvcnQgY29uc3QgTEJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqXG4gKiBUaGUgTGlzdCBjb21wb25lbnQgcmVwcmVzZW50IGEgc3RydWN0dXJlIHdoaWNoIGNvbnRhaW5zIGEgbGlzdCBvZiBzZWxlY3RhYmxlIGl0ZW1zLiBJdGVtc1xuICogc2VsZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIGluIHNpbmdsZS1zZWxlY3Rpb24sIG11bHRpLXNlbGVjdGlvbiBvciBtdWx0aS1zZWxlY3Rpb24gd2l0aCB2aXNpYmxlXG4gKiBjaGVja2JveGVzIG1vZGUuXG4gKiBJbiBhZGRpdGlvbiBpdCBjYW4gZGlzcGxheSBkYXRhIGluc2lkZSAzIHpvbmVzIExFRlQsIE1JRERMRSBhbmQgUklHSFQgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICogZWFzeSB3YXkgZm9yIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBsYXlvdXQgaXRzIG93biBjdXN0b20gY29udGVudCBvciBldmVuIGNoYW5nZSBvdXQgb2YgYm94XG4gKiBiZWhhdmlvci5cbiAqXG4gKlxuICogICMjIyBFeGFtcGxlc1xuICpcbiAqICAxLiBSZW5kZXIgc2ltcGxlIHNpbmdsZSBzZWxlY3Rpb24gbGlzdFxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICAgICA8YXctbGlzdCBbbGlzdF09XCJsaXN0XCI+PC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqICAyLiBSZW5kZXIgbGlzdCAtIG11bHRpIHNlbGVjdGlvbiB3aXRoIGN1c3RvbSBSSUdIVCBjb250ZW50IHRvIHNob3cgYSBDaGVja01hcmsgd2hlbiBpdGVtXG4gKiAgaXMgc2VsZWN0ZWRcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgPGF3LWxpc3QgI2F3bGlzdCBbbGlzdF09XCJsaXN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9XCIxNTBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIyNTBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbk1vZGVdPVwiJ211bHRpJ1wiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNyaWdodCBsZXQtaXRlbT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNhcC1pY29uXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnaWNvbi1hY2NlcHQnOiBhd2xpc3QucExpc3RCb3guaXNTZWxlY3RlZChpdGVtKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnOiAhYXdsaXN0LnBMaXN0Qm94LmlzU2VsZWN0ZWQoaXRlbSl9XCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICA8L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICpcbiAqIDMuIFJlbmRlciBsaXN0IC0gbXVsdGkgc2VsZWN0aW9uIHdpdGggdmlzaWJsZSBjaGVja2JveGVzIGFuZCBjdXN0b20gTUlERExFIGNvbnRlbnQgdG8gY2hhbmdlXG4gKiAgdGhlIHdheSBpdGVtIG5hbWUgaXMgcmVuZGVyZWRcbiAqXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICA8YXctbGlzdCBbbGlzdF09XCJsaXN0XCIgaGVpZ2h0PVwiMTgwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMjAwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0aW9uXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uTW9kZV09XCInbXVsdGlXaXRoQ2hlY2tib3gnXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI21pZGRsZSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgICAgICAgICAgIFhYLXt7aXRlbS52YWx1ZX19XG4gKiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICA8L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9saXN0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIExCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGlzdENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBMaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb3B0aW9uIHRoYXQgd2lsbCBzaG93IGluIHRoZSBsaXN0LiBQbGVhc2Ugbm90IHRoYXQgdGhpcyBsaXN0IGlzIGN1cnJlbnQgdXNlZCB0b1xuICAgICAqIHNob3cgbGltaXRlZCBudW1iZXIgb2YgaXRlbXMuIEl0IGRvZXMgbm90IGhhdmUgYW55IHNjcm9sbGluZyBmZWF0dXJlIGFuZCBsYXp5IGxvYWRpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBJdGVtcyB3aGljaCB3YXMgc2VsZWN0ZWQgYXMgYSBkZWZhdWx0IHZhbHVlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgcmVjb2duaXplcyAzIG1vZGVzOiBzaW5nbGUsIG11bHRpLCBtdWx0aSB3aXRoIHZpc2libGUgY2hlY2tib3hlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZSA9ICdzaW5nbGUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdXNlZCB0byBmb3JtYXQgZWFjaCBzZWxlY3Rpb24gZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlVHJhbnNmb3JtZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHdoZW4gZGVhbGluZyB3aXRoIG9iamVjdCB0byBpZGVudGlmeSBzcGVjaWZpYyBmaWVsZCBvbiB0aGUgb2JqZWN0IGZvcmNvbXBhcmlzb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpZWxkOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIERvbid0IHJlbmRlciBMaXN0Ym94IGJvcmRlci4gVXNlZCBmb3IgZW1iZWRkaW5nIHRoaXMgaW5zaWRlIG90aGVyIGNvbXBvbmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9yZGVybGVzczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gd2UgZG91YmxlIGNsaWNrIG9uIHRoZSBsaXN0IEl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIHdhbnQgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvciBvciBMZWZ0IHpvbmUuIFdlIGV4cG9zZSB0aGlzIGxpc3RCb3ggaW4gb3JkZXIgdG9cbiAgICAgKiBoYXZlIGFjY2VzcyBwcmltZU5nIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbGlzdGJveCcpXG4gICAgcExpc3RCb3g6IExpc3Rib3g7XG5cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB0ZW1wbGF0ZXMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvci4gVGhlIGxpc3QgaXRlbSBpcyBkaXZpZGVkIGludG8gMyB6b25lc1xuICAgICAqXG4gICAgICpcbiAgICAgKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICB8ICAgTCAgIHwgICAgICAgICAgICAgTSAgICAgICAgICAgICAgICAgICAgIHwgICBSICAgIHxcbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbGVmdCcpXG4gICAgbFpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGQoJ21pZGRsZScpXG4gICAgbVpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGQoJ3JpZ2h0JylcbiAgICByWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKi9cbiAgICBpbnRlcm5hbExpc3Q6IFNlbGVjdEl0ZW1bXTtcblxuICAgIGxpc3RTdHlsZToge1tuYW1lOiBzdHJpbmddOiBhbnl9ID0ge307XG5cbiAgICBpc011bHRpcGxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgc2hvd0NoZWNrYm94OiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLmlzTXVsdGlwbGUgPSB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScgfHxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpV2l0aENoZWNrYm94JztcbiAgICAgICAgdGhpcy5zaG93Q2hlY2tib3ggPSB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aVdpdGhDaGVja2JveCc7XG5cbiAgICAgICAgLy8gY2Fubm90IGhhdmUgYm90aCBlaXRoZXIgd2UgdXNlIGZpZWxkIHRvIGdldCBkaXNwbGF5IHZhbHVlIG9yIHZhbHVlVHJhbnNmb3JtZXJcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZpZWxkKSAmJiBpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIGhhdmUgZWl0aGVyIFtmaWVsZF0gb3IgW3ZhbHVlVHJhbnNmb3JtZXJdLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRMaXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgW2xpc3RdIGJpbmRpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHNvIGFkZCBvdmVyZmxvd1kgdG8gbWFrZSBzdXJlIGl0IGNhbiBzY3JvbGwgYW5kIGRvZXMgbm90IGV4cGFuZCBiYXNlZCBvbiBpdHMgY29udGVudFxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ2hlaWdodCddID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnb3ZlcmZsb3cteSddID0gJ2F1dG8nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLndpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ3dpZHRoJ10gPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYm9yZGVybGVzcykge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ2JvcmRlci1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaW5jZSB3ZSBhcmUgdXNpbmcgPGF3LWNoZWNrYm94PiB3ZSBuZWVkIHRvIGhhdmUgY3VzdG9tIGhhbmRsaW5nIGJvdGggd2hlbiBjbGlja2luZyBvbiB0aGVcbiAgICAgKiBjaGVja2JveCBhcyB3ZWxsIGFzIGl0ZW0gdGV4dC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaXRlbUNsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55LCBjaGVja2JveDogQ2hlY2tib3hDb21wb25lbnQpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBMaXN0Qm94Lm9uT3B0aW9uQ2xpY2soZXZlbnQsIGl0ZW0pO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNSaWdodFRlbXBsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5yWm9uZVRlbXBsKTtcbiAgICB9XG5cbiAgICBoYXNMZWZ0VGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmxab25lVGVtcGwpO1xuICAgIH1cblxuXG4gICAgaGFzTWlkZGxlVGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1ab25lVGVtcGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcmVkIGJ5IHAtbGlzdGJveCBjb21wb25lbnQgd2hlbiBpdGVtIGlzIHNlbGVjdGVkLiBXaGVuIHN0YXRlIGlzIG1hbmFnZWQgaW50ZXJuYWxseVxuICAgICAqIHdlIGFsc28gdXBkYXRlIEZvcm1Db250cm9sIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgb25JdGVtU2VsZWN0ZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KGV2ZW50LnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKGV2ZW50LnZhbHVlLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZChldmVudC52YWx1ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCFlcXVhbHModmFsdWUsIHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBleHRlcm5hbCBmb3JtIG9mIHRoZSBsaXN0IGludG8gUHJpbWVORyBleHBlY3RlZCBmb3JtYXQgd2hlcmUgaXQgdXNlc1xuICAgICAqIFNlbGVjdGlvbkl0ZW0gaW50ZXJmYWNlXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0TGlzdCgpXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0Lm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IHRoaXMuZGlzcGxheVZhbHVlKGl0ZW0pLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlcyBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxpc3QgYm94LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkaXNwbGF5VmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbCA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZpZWxkKSkge1xuICAgICAgICAgICAgdmFsID0gaXRlbVt0aGlzLmZpZWxkXTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlVHJhbnNmb3JtZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59XG5cbi8qKlxuICogTGlzdCBzdXBwb3J0IHRoZXNlIHRocmVlIHNlbGVjdGlvbiBtb2Rlc1xuICpcbiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdzaW5nbGUnIHwgJ211bHRpJyB8ICdtdWx0aVdpdGhDaGVja2JveCc7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0xpc3Rib3hNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0xpc3RDb21wb25lbnR9IGZyb20gJy4vbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIExpc3Rib3hNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGVcblxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdMaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQGF1dGhvciBhbWFudWwuY2hvd2RodXJ5XG4gKiBDb3B5cmlnaHQgMjAxOCBTQVAgQXJpYmFcbiAqXG4gKiBXaXphcmRQcm9ncmVzc0NvbXBvbmVudCBjYW4gYmUgdXNlZCBhcyBhIHN0ZXAgcHJvZ3Jlc3NcbiAqIGluIGEgcGFnZSB0aGF0IGhhcyBtdWx0aXBsZSBzdGVwc1xuICogYDxhdy13aXphcmQtcHJvZ3Jlc3NcbiAqICBbc3RlcHNdPVwic3RlcHNcIlxuICogIFtjdXJyZW50U3RlcF09XCJjdXJyZW50U3RlcFwiXG4gKiAgKHN0ZXBDaGFuZ2VkKT1cIm9uU3RlcENoYW5nZWQoJGV2ZW50KVwiPlxuICogPC9hdy13aXphcmQtcHJvZ3Jlc3M+YFxuICovXG5cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZXBcbntcbiAgICBjb21wbGV0ZTogYm9vbGVhbjtcbiAgICBjdXJyZW50OiBib29sZWFuO1xuICAgIHRpdGxlPzogc3RyaW5nO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXdpemFyZC1wcm9ncmVzcycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3dpemFyZC1wcm9ncmVzcy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vd2l6YXJkLXByb2dyZXNzLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbntcbiAgICBASW5wdXQoKVxuICAgIHN0ZXBzOiBBcnJheTxTdGVwPjtcblxuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDA7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzdGVwQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIHRvdGFsU3RlcHM6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXBzKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuc3RlcHMuZmlsdGVyKHN0ZXAgPT4gc3RlcC5jdXJyZW50KVswXSk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsU3RlcHMgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFN0ZXAofmN1cnJlbnRJbmRleCA/IGN1cnJlbnRJbmRleCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudFN0ZXAoaW5kZXg6IG51bWJlciA9IDApXG4gICAge1xuICAgICAgICB0aGlzLnN0ZXBzW2luZGV4XS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2VkLmVtaXQoe2N1cnJlbnQ6IHRoaXMuY3VycmVudFN0ZXB9KTtcbiAgICB9XG5cbiAgICBnb1RvU3RlcChpbmRleDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0ZXBzW2luZGV4XS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLnN0ZXBzLmZpbHRlcihzdGVwID0+IHN0ZXAuY3VycmVudClbMF0pO1xuICAgICAgICB0aGlzLnN0ZXBzW2N1cnJlbnRJbmRleF0uY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0ZXAoaW5kZXgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1dpemFyZFByb2dyZXNzQ29tcG9uZW50fSBmcm9tICcuL3dpemFyZC1wcm9ncmVzcy5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkUHJvZ3Jlc3NNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBSZW5kZXJzIGEgVG9nZ2xlIFN3aXRjaFxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ215VG9nZ2xlU2VjdGlvbicgLFxuICogICAgICAgICAgdGVtcGxhdGU6ICc8YXctdG9nZ2xlIFttb2RlbF09XCJpbnB1dFZhbHVlXCIgW2xhYmVsVGV4dF09XCJsYWJlbFRleHRcIiA+XG4gKiAgICAgICAgICAgICAgPC9hdy10b2dnbGU+J1xuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgTXlOb3RlQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlucHV0VmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAqICAgICAgICAgIGxhYmVsVGV4dDogc3RyaW5nID0gJ215IGxhYmVsJztcbiAqICAgICAgfVxuICpcbiAqIGBgYFxuICovXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctdG9nZ2xlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdG9nZ2xlLXN3aXRjaC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdG9nZ2xlLXN3aXRjaC5jb21wb25lbnQuc2NzcyddXG59KVxuXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSBtb2RlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpIG1vZGVsOiBib29sZWFuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogbGFiZWwgdGV4dFxuICAgICAqL1xuICAgIEBJbnB1dCgpIGxhYmVsVGV4dDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRvZ2dsZVxuICAgICAqL1xuICAgIGNoYW5nZUhhbmRsZXIoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9ICF0aGlzLm1vZGVsO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtUb2dnbGVTd2l0Y2hDb21wb25lbnR9IGZyb20gJy4vdG9nZ2xlLXN3aXRjaC5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVG9nZ2xlU3dpdGNoQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFRvZ2dsZVN3aXRjaENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUb2dnbGVTd2l0Y2hDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtPdmVybGF5UGFuZWx9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBPdmVybGF5IENvbXBvbmVudCBpcyBhIHNpbXBsZSB2ZXJzaW9uIG9mIHRoZSBkaWFsb2cgd2hlcmUgdGhlcmUncyBvbmx5IGNvbnRlbnQuXG4gKiBPdmVybGF5IHdpbGwgYXBwZWFyIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYWN0aW9uIHBlcmZvcm1lZCB0cmlnZ2VyIGFuIG92ZXJsYXkuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxPdmVybGF5Q29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoZSB1c2FnZSBpcyBhIGxpdHRsZSB0cmlja3lcbiAqICAgICAgICBiZWNhdXNlIGFuZ3VsYXIgY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCBkeW5hbWljIGNvbnRlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiAgICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48T3ZlcmxheUNvbXBvbmVudD4oT3ZlcmxheUNvbXBvbmVudCwge30pO1xuICpcbiAqICAgICAgICAgICAgLy8gQWRkIGNvbnRlbnQuIFRoZXJlJ3Mgbm90IHN1cHBvcnQgZm9yIGR5bmFtaWMgY29udGVudCBwcm9qZWN0aW9uIHlldC5cbiAqICAgICAgICAgICAgLy8gU28gaGF2ZSBhZGQgY29udGVudCBkaXJlY3RseS5cbiAqICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3Qgd2F5LlxuICogICAgICAgICAgb3ZlcmxheS5pbnN0YW5jZS5vdmVybGF5LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi51aS1vdmVybGF5cGFuZWwtY29udGVudFwiKVxuICogICAgICAgICAgICAgICAuaW5uZXJIVE1MID0gYDxpbWcgc3R5bGU9J3dpZHRoOjMwMHB4Oycgc3JjPVwic2FsZXMucG5nXCIgYWx0PVwiU2FsZXMgQ2hhcnRcIiAvPmA7XG4gKlxuICogICAgICAgICAgLy8gZGVsYXkgdGhlIG9wZW5pbmcgYWZ0ZXIgbmcgbGlmZWN5Y2xlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IG92ZXJsYXkuaW5zdGFuY2Uub3BlbihldmVudCk7IH0sIDEpO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctb3ZlcmxheSAjb3ZlcmxheSAob25PcGVuKT1cIm92ZXJsYXlBY3Rpb249J29wZW4nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25DbG9zZSk9XCJvdmVybGF5QWN0aW9uPSdjbG9zZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cInNhbGVzLnBuZ1wiIGFsdD1cIkNoYXJ0XCIvPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctb3ZlcmxheT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm92ZXJsYXkub3BlbigkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wZW4gT3ZlcmxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUFjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb3ZlcmxheScsXG4gICAgdGVtcGxhdGVVcmw6ICdvdmVybGF5LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnb3ZlcmxheS5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE92ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lciBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdJbml0XG57XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBoaWRlIG92ZXJsYXkgd2hlbiBvdXRzaWRlIGlzIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNtaXNzYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgY2xvc2UgaWNvbiAneCcgYXQgdG9wIG9mIHJpZ2h0IGNvcm5lci5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dDbG9zZUljb246IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUYXJnZXQgZWxlbWVudCB0byBhdHRhY2ggdGhlIG92ZXJsYXkuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIG92ZXJsYXkgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBqdXN0IGJlZm9yZSBvdmVybGF5IGlzIGNsb3NlZFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGJlZm9yZUNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgb3ZlcmxheSBwYW5lbC5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKE92ZXJsYXlQYW5lbClcbiAgICBvdmVybGF5OiBPdmVybGF5UGFuZWw7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gcGxhY2UgaG9sZGVyIHRvIGJlIG92ZXJyaWRkZW4gYnkgTW9kYWwgU2VydmljZVxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBwbGFjZSBob2xkZXIgdG8gYmUgb3ZlcnJpZGRlbiBieSBNb2RhbCBTZXJ2aWNlXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBPcGVuIE92ZXJsYXlcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvcGVuKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5zaG93KGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMub25PcGVuZWQobnVsbCk7XG4gICAgICAgIH0sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIE92ZXJsYXlcbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICB0aGlzLmJlZm9yZUNsb3NlLmVtaXQobnVsbCk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5oaWRlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgb3BlbiBhbmQgY2xvc2UuXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgdG9nZ2xlKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS50b2dnbGUoZXZlbnQpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cblxuICAgIG9uT3BlbmVkKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBvbkNsb3NlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoZXZlbnQpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QW5pbWF0aW9uRXZlbnR9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7T3ZlcmxheUNvbXBvbmVudH0gZnJvbSAnLi4vb3ZlcmxheS9vdmVybGF5LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBEZWZpbmVzIHdoZXJlIHRoZSBDYXJkIGlzIHBvc2l0aW9uZWQuIEl0IGNhbiBiZSBlaXRoZXI6XG4gKiAgICAtIGFib3ZlIHRoZSB0cmlnZ2VyaW5nIGxpbmtcbiAqICAgIC0gdW5kZXIgdGhlIHRyaWdnZXJpbmcgbGlua1xuICogICAgLSBjb21wbGV0ZWx5IG9uIHRvcCBvZiBpdCAtIGNvdmVyaW5nIGl0LiBGb3IgdGhpcyBjYXNlIHRoZXJlIGlzIG5vbmUgYXMgbm8gc3R5bGUgaXMgYXBwbGllZFxuICovXG5leHBvcnQgZW51bSBIQ0NhcmRQb3NpdGlvblxue1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbm9uZVxufVxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZCBieSBkZWZhdWx0LiBNZWFuaW5nIHdoZXJlIHByaW1lTkcgY29kZSBwdXQgaXQuXG4gKlxuICogV2hlbiB0aGVyZSBpcyBhbGxvdCBvZiBzcGFjZSBvbiB0aGUgc2lkZXMgPj0gIChMZWZ0IG9yIFJpZ2h0KSBpcyB1c2VkXG4gKiAocGFkZGVkTGVmdCwgcGFkZGVkUmlnaHQpIG90aGVyd2lzZS4gV2hlbiB0aGVyZSBpcyBub3QgbXVjaCBzcGFjZSBhbmQgY2FyZCBjb250YWluZXJcbiAqICBpcyBub3QgYWxpZ25lZCAobGVmdCwgcmlnaHQpIHdpdGggdGhlIHRyaWdlcmluZyBpY29uIGJ1dCBpdCBpcyBzaGlmdGVkIHRvIGZpdCBpbnRvIHRoZSBzY3JlZW5cbiAqL1xuZW51bSBIQ0NhcmRBbGlnbm1lbnRcbntcbiAgICBsZWZ0LFxuICAgIHBhZGRlZExlZnQsXG4gICAgcmlnaHQsXG4gICAgcGFkZGVkUmlnaHQsXG4gICAgZGVmYXVsdFxufVxuXG4vKipcbiAqIE1hcHMgcG9zaXRpb24gdG8gc3R5bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIENhcmQgY29udGFpbmVyLiBUaGlzIGlzIGp1c3QgdG8gbWFrZSBpdCBlYXNpZXJcbiAqIGFzIHdlIGFyZSB3b3JraW5nIHdpdGggZW51bWVyYXRpb25zIGFuZCBoYXZlIGFscmVhZHkgZW51bSB0eXBlLlxuICpcbiAqIHUtaGMtYXJyb3ctYjogQXJyb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICogdS1oYy1hcnJvdy10OiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKlxuICogdS1oYy1zaGFkb3ctdDogQm9yZGVyIHNoYWRvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKiB1LWhjLXNoYWRvdy1iOiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSBib3R0b21cbiAqL1xuY29uc3QgUG9zaXRpb25Ub1N0eWxlID0ge1xuICAgIHRvcDogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctYiB1LWhjLXNoYWRvdy10JyxcbiAgICBib3R0b206ICcgdy1oYy1wYW5lbC1hcnJvdyB1LWhjLWFycm93LXQgdS1oYy1zaGFkb3ctYicsXG4gICAgbm9uZTogJydcbn07XG5cblxuLyoqXG4gKlxuICogTWFwcyBhbGlnbmVkIENhcmQgY29udGFpbmVyIHRvIGN1c3RvbSBzdHlsZXMgaW4gb3JkZXIgdG8gYXBwbHkgY29ycmVjdCBhcnJvd1xuICpcbiAqIC1sbDogU3RhbmRzIGZvciBMYXJnZSBMZWZ0IChsYXJnZTogdGhlcmUgaXMgcGxlbnR5IG9mIHNwYWNlIGFyb3VuZCApXG4gKiAtbHI6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqIC1zbDogU3RhbmRzIGZvciBTbWFsbCBsZWZ0IChTbWFsbCBhbmQgcmVzaXplZCBzY3JlZW4gd2hlcmUgd2UgdHJ5IHRvIGZpdCBjYXJkIGNvbnRhaW5lclxuICogc29tZXdoZXJlIGluIGJldHdlZW4pXG4gKiAtc3I6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqXG4gKi9cbmNvbnN0IEFsaWdubWVudFRvU3R5bGUgPSB7XG4gICAgbGVmdDogJyB1LWhjLWFycm93LWxsJyxcbiAgICByaWdodDogJyB1LWhjLWFycm93LWxyJyxcbiAgICBwYWRkZWRMZWZ0OiAnIHUtaGMtYXJyb3ctc2wnLFxuICAgIHBhZGRlZFJpZ2h0OiAnIHUtaGMtYXJyb3ctc3InLFxuICAgIGRlZmF1bHQ6ICcgdS1oYy1hcnJvdy1sbCcsXG59O1xuXG4vKipcbiAqIFRoZSBIb3ZlckNhcmQgY29tcG9uZW50cyBhZGRzIGhvdmVyIGJlaGF2aW9yIHRvIHRleHQsIHRoZSBzcGVjaWZpZWQgY29udGVudCBpcyBsb2FkZWRcbiAqIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG9kbzogZXh0ZW5kcyBzbyB3ZSBjYW4gd3JhcCBhbnkgZWxlbWVudCBhbmQgYW55IGVsZW1lbnQgY2FuIGJlIHRyaWdnZXJpbmcgdGhpcy4gTm90IG9ubHlcbiAqIGxpbmtUaXRsZVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZyYW5rIGtvbGFyJ1wiPlxuICogICAgICAgPGgzPk15IENhcmQgVGl0bGU8L2gzPlxuICogICAgICAgPGRpdj5cbiAqXG4gKiAgICAgICAgICAgVGhpcyBpcyBteSBjb250ZW50c1xuICpcbiAqICAgICAgIDwvZGl2PlxuICpcbiAqXG4gKiAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0IHRoZXJlIGlzIFtmb3JjZUNsb3NlXT10cnVlIHdoaWNoIGZvcmNlcyB0aGUgdXNlciB0byB1c2UgWCBjbG9zZSBpY29uXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaG92ZXItY2FyZCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2hvdmVyLWNhcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2hvdmVyLWNhcmQuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckNhcmRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBhZGRpbmcgcmVwcmVzZW50aW5nIGEgaGVpZ2h0IG9mIHRoZSBBcnJvdyBmb3Igd2hpY2ggd2UgbmVlZCB0byB2ZXJ0aWNhbGx5IGFkanVzdFxuICAgICAqIENhcmQgY29udGFpbmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFycm93UGFkID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHNhZmUgdGhyZXNob2xkIHdoZXJlIHRoZXJlIG1pZ2h0IG5vdCBiZSBlbm91Z2ggc3BhY2UgYXJvdW5kIG9yIENhcmQgaXMgYWxpZ25lZCB3aXRoXG4gICAgICogdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQgZm9yIHdoaWNoIHdlIG5lZWQgdG8gcG9zaXRpb24gdGhlIEFycm93IGNsb3NlciB0byB0aGVcbiAgICAgKiBzaWRlIG9mIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNwYWNpbmdMaW1pdCA9IDUwO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGxpbmtUaXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHdlIGtlZXAgdGhlIGhvdmVyIGNhcmQgb3BlbiBhbmQgZm9yY2UgdXNlciB0byBtYW51YWxseSBjbG9zZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JjZUNsb3NlOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGN1cnJlbnQgd29ya2Fyb3VuZCB1bnRpbCB3ZSBmaW5kIGJldHRlciBzb2x1dGlvbi4gUHJpbWVORyBvdmVybGF5cyBvcGVyYXRlcyB3aXRoaW5cbiAgICAgKiBpdHMgcmVsYXRpdmUgZWxlbWVudCBzbyBpZiB0aGUgb3ZlcmxheSBpcyB3cmFwcGVkIGluc2lkZSBzb21lIG90aGVyIHJlbGF0aXZlIGNvbnRhaW5lclxuICAgICAqIHRoZSBvdmVybGF5IGNvbnRlbnQgaXMgY3JvcGVkIGJ5IGl0cyBwYXJlbnQgYW5kIGNvbnRlbnQgaXMgbm90IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBUaGV5IGhhdmUgW2FwcGVuZFRvXSBiaW5kaW5nIHdoaWNoIHdlIG5lZWQgdG8gdXNlIGZvciB0aGlzIHB1cnBvc2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kQ29udGVudFRvQm9keTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gT3ZlcmxheUNvbXBvbmVudCB0byBjYW4gYWNjZXNzIFByaW1lTkcgY29tcG9uZW50IGFzIHdlbGxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JylcbiAgICBhd092ZXJsYXk6IE92ZXJsYXlDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJuYWwgc3R5bGUgY2xhc3MgdG8gdXNlIHRvIGFwcGx5IGFkZGl0aW9uYWwgc3R5bGVzIHdoZW4gaXQgbmVlZHMgdG8gc2hvdyBhIEFycm93IG9uIHRoZVxuICAgICAqIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIGFycm93Q2xhc3M6IHN0cmluZyA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwcm9wZXJ0aWVzIHRvIHJlZmVyZW5jZXMgdGVtcGxhdGUgZWxlbWVudHMgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHRpdGxlQXJlYVJlY3Q6IGFueTtcbiAgICB0cmlnUmVjdDogYW55O1xuICAgIHRyaWdJY29uTWlkZGxlOiBhbnk7XG5cbiAgICBvcGVuaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBhcHBlbmRUbzogJ2JvZHknO1xuXG4gICAgY3VycnJlbnRQb3NpdGlvbjogSENDYXJkUG9zaXRpb24gPSBIQ0NhcmRQb3NpdGlvbi5ub25lO1xuXG4gICAgb3ZlcmxheU9uQW5pbWF0aW9uU3RhcnQ6IChldmVudDogQW5pbWF0aW9uRXZlbnQpID0+IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG8gaW5qZWN0IGR5bmFtaWMgY29udGVudCB1c2luZyBwcm9ncmFtbWF0aWMgQVBJIHdlIHVzZSB0aGlzIGV4dHJhXG4gICAgICogZWxlbWVudCB3aGljaCBpcyBvdXRzaWRlIG9mIHRoZSA8bmctY29udGVudD4gYW5kIGhpZGRlbiBhbmQgb25jZSB0aGUgPG5nLWNvbnRlbnQ+ICBvZlxuICAgICAqIHRoZSBjb21wb25lbnQgaXMgc2hvd24gd2UgbW92ZSB0aGlzIGR5bmFtaWMgY29udGVudCBpbnRvIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgZHluYW1pY0NvbnRlbnQ6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW06IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5saW5rVGl0bGUpLCAnWW91IG11c3QgcHJvdmlkZSBbbGlua1RpdGxlXSBiaW5kaW5nICEnKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgb3BlbiBIQyB3aGVuIHdlIHN0YXJ0IG5ldyBjb21wb25lbnRcbiAgICAgICAgdGhpcy5lbnYuZGVsZXRlVmFsdWUoJ2hjLW9wZW4nKTtcblxuICAgICAgICBpZiAoIXRoaXMuYXBwZW5kQ29udGVudFRvQm9keSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUbyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm92ZXJsYXlPbkFuaW1hdGlvblN0YXJ0ID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS5vbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLmF3T3ZlcmxheS5vdmVybGF5Lm9uQW5pbWF0aW9uU3RhcnQgPSAoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlPbkFuaW1hdGlvblN0YXJ0LmNhbGwodGhpcy5hd092ZXJsYXkub3ZlcmxheSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmNhcmRPcGVuZWQoKTtcbiAgICAgICAgICAgIHRoaXMub25BbmltYXRpb25TdGFydChldmVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcyBzcGFuIGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5keW5hbWljQ29udGVudCA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy51LW5nY29udGVudCcpO1xuICAgIH1cblxuXG4gICAgb25BbmltYXRpb25TdGFydChldmVudDogQW5pbWF0aW9uRXZlbnQpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5vcGVuaW5nKSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS5jb250YWluZXI7XG4gICAgICAgICAgICBsZXQgY250UmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJyZW50UG9zaXRpb24gIT09IEhDQ2FyZFBvc2l0aW9uLm5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENhcmQoY29udGFpbmVyLCBjbnRSZWN0LCB0aGlzLmF3T3ZlcmxheS5vdmVybGF5KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcGVuaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGluamVjdER5bmFtaWNDb250ZW50KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmF3T3ZlcmxheS5vdmVybGF5LnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5Q250ID0gdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcignLnVpLW92ZXJsYXlwYW5lbC1jb250ZW50IC51LW5nY29udGVudCcpO1xuXG4gICAgICAgICAgICBpZiAoaXNCbGFuayhvdmVybGF5Q250KSAmJiB0aGlzLmR5bmFtaWNDb250ZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5Q250ID0gdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnVpLW92ZXJsYXlwYW5lbC1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheUNudC5wcmVwZW5kKHRoaXMuZHluYW1pY0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY0NvbnRlbnQuc3R5bGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljQ29udGVudC5zdHlsZSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXQgZWxlbWVudHMgQm91bmRpbmdDbGllbnRSZWN0IHRoYXQgd2UgdXNlIGZvciBjYWxjdWxhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgaW5pdEVsZW1lbnRzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB0aXRsZUVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1oYy10aXRsZScpO1xuICAgICAgICBsZXQgdHJpZ2dlckVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc2FwLWljb24nKTtcbiAgICAgICAgdGhpcy50aXRsZUFyZWFSZWN0ID0gdGl0bGVFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnRyaWdSZWN0ID0gdHJpZ2dlckVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ0ljb25NaWRkbGUgPSB0aGlzLnRyaWdSZWN0LndpZHRoIC8gMjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgd2hlbiB1c2VyIG1vdXNlIG92ZXIgdGhlIHRyaWdnZXJpbmcgaWNvbiBhbmQgb3BlbnMgdXAgb3ZlcmxheSBjb21wb25lbnQuIFRvIG1ha2Ugc3VyZVxuICAgICAqIG9ubHkgb25lIENhcmQgaXMgb3BlbmVkIGF0IHRoZSB0aW1lIGl0IHVzZXMgRW52aXJvbm1lbnQgdG8gc2F2ZSBleHRyYSBpbmZvcm1hdGlvbiBmb3IgaXRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbkNhcmQoZXZlbnQ6IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF3T3ZlcmxheSkgJiYgIXRoaXMuZW52Lmhhc1ZhbHVlKCdoYy1vcGVuJykpIHtcbiAgICAgICAgICAgIHRoaXMuYXdPdmVybGF5Lm9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLmVudi5zZXRWYWx1ZSgnaGMtb3BlbicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIG9wZW5pbmcgY3ljbGUgd2hlbiBhbGwgaXMgaW5pdGlhbGl6ZWQgYW5kIHRoZSBjYXJkIGlzIGFib3V0IHRvXG4gICAgICogZmFkZSBpbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGZpcnN0IHNpbXVsYXRlcyBkaXNwbGF5aW5nIGNhcmQgYnkgc2V0dGluZyBkaXNwbGF5OmJsb2NrIGFuZFxuICAgICAqIGRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbiBzbyB3ZSBjYW4gcmVhZCBkaW1lbnNpb25zIGFuZCB0aGVuIGxhdGVyIG9uIHBvc2l0aW9uIHRoZSBjYXJkXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKi9cbiAgICBjYXJkT3BlbmVkKGV2ZW50PzogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkuY29udGFpbmVyO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS50YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5vcGVuRm9yQWRqdXN0bWVudHMoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5pbmplY3REeW5hbWljQ29udGVudCgpO1xuXG4gICAgICAgIC8vIHByZS1ydW4gcG9zaXRpb25pbmcgc28gd2UgY2FuIGNhbGN1bGF0ZSBuZXcgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5hd092ZXJsYXkub3ZlcmxheS5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24oY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICBsZXQgY250UmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5jdXJycmVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkZvckNhcmQoY29udGFpbmVyLCBjbnRSZWN0KTtcblxuICAgICAgICB0aGlzLmFwcGx5U3R5bGVDbGFzcyhjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNhcmQgaXMgY2xvc2VkIHdlIG5lZWQgdG8gcmVsZWFzZSBpdCBhbmQgZGVsZXRlIGFsbCB0aGUgcmVmZXJlbmNlcyBmcm9tIEVudmlyb25tZW50XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGNhcmRDbG9zZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZW52LmRlbGV0ZVZhbHVlKCdoYy1vcGVuJyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAgKiBCZWZvcmUgb3ZlcmxheSBpcyBjbG9zZWQgd2UgaGlkZSBpbnRlcm5hbCBjb250ZW50IG90aGVyIGl0IGRvZXMgbGl0dGxlIHNoYWtlLi5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYmVmb3JlQ2xvc2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHluYW1pY0NvbnRlbnQuc3R5bGUgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIHN0eWxlLlRPUCBhbmQgc3R5bGUuTEVGVCB0byB0aGUgY29udGFpbmVyIGluIG9yZGVyIHRvIHJlcG9zaXRpb24gaXQgYW5kIGFkZFxuICAgICAqIGV4dHJhIGFycm93LlxuICAgICAqXG4gICAgICogRmlyc3QgYmFzZWQgb24gdGhlIGluaXRpYWwgcG9zaXRpb24gd2UgYXBwbHkgc3R5bGUuVE9QIGFuZCBkZXBlbmRpbmcgaWYgaXRzIG9uIHRoZVxuICAgICAqIHRvcCBvciBib3R0b20gd2UgYXBwbHkgZWl0aGVyIC1Ib3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgb3IgK0hvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZC5cbiAgICAgKlxuICAgICAqIFRoZW4gZm9yIHBvc2l0aW9uaW5nIGhvcml6b250YWxseSB3ZSB1c2UgdHdvIHR5cGVzLlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgYWxsb3Qgb2Ygc3BhY2UgdGhlIGFycm93IGlzIDI1JSBmcm9tIHRoZSBlZGdlXG4gICAgICpcbiAgICAgKiAgICAtLS0tLV4tLS0tLS0tLS0tLS0gICBvciAgICAgICAtLS0tLS0tLS0tLV4tLS0tXG4gICAgICpcbiAgICAgKlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgbGVzcyBvciBub25lIHNwYWNlIHdlIGhhdmUgb25seSAxMCUgZmFyIGF3YXkgZm9ybSB0aGUgZWRnZVxuICAgICAqXG4gICAgICogICAgLS1eLS0tLS0tLS0tLS0tICAgb3IgICAgICAgLS0tLS0tLS0tLS1eLS1cbiAgICAgKlxuICAgICAqICBPbmNlIHdlIHBpY2sgdGhlIGNvcnJlY3QgcG9zaXRpb25pbmcgKDI1JSwgMTAlKSB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGFuZCBzaGlmdCB0aGUgY2FyZFxuICAgICAqICBlaXRoZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGp1c3RDYXJkKGNvbnRhaW5lcjogYW55LCBjb250YWluZXJSZWN0OiBhbnksIG1vZGFsQ29udGFpbmVyOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgZGlmZiA9ICh0aGlzLmN1cnJyZW50UG9zaXRpb24gPT09IEhDQ2FyZFBvc2l0aW9uLmJvdHRvbSkgPyAxIDogLTE7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBtb2RhbENvbnRhaW5lci5kb21IYW5kbGVyLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICBsZXQgcG9zV2l0aFNjcm9sbCA9IGNvbnRhaW5lclJlY3QudG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gKHBvc1dpdGhTY3JvbGwgKyAoSG92ZXJDYXJkQ29tcG9uZW50LkFycm93UGFkICogZGlmZikpICsgJ3B4JztcblxuICAgICAgICBsZXQgYWxpZ25tZW50ID0gdGhpcy5hbGlnbm1lbnRGb3JDYXJkKGNvbnRhaW5lclJlY3QsIG1vZGFsQ29udGFpbmVyKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSB0aGlzLmNhbGNMZWZ0Rm9yQWxpZ25tZW50KGNvbnRhaW5lclJlY3QsIGFsaWdubWVudCkgKyAncHgnO1xuICAgIH1cblxuXG4gICAgYXBwbHlTdHlsZUNsYXNzKGNvbnRhaW5lcjogYW55LCBjb250YWluZXJSZWN0OiBhbnksIG1vZGFsQ29udGFpbmVyOiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJyZW50UG9zaXRpb24gIT09IEhDQ2FyZFBvc2l0aW9uLm5vbmUpIHtcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAoPGFueT5Qb3NpdGlvblRvU3R5bGUpWyg8YW55PkhDQ2FyZFBvc2l0aW9uKVt0aGlzLmN1cnJyZW50UG9zaXRpb25dXTtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyArPSAoPGFueT5BbGlnbm1lbnRUb1N0eWxlKVsoPGFueT5IQ0NhcmRBbGlnbm1lbnQpW2FsaWdubWVudF1dO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0cyBpZiB0aGUgY2FyZCBpcyBnb2luZyB0byBiZSBzaG93biBvbiB0aGUgdG9wIG9mIHRoZSBMaW5rIGxhYmVsIG9yIHVuZGVyLiBPciBpZlxuICAgICAqIGl0cyBjb3ZlcmluZyBpdC5cbiAgICAgKlxuICAgICAqL1xuICAgIHBvc2l0aW9uRm9yQ2FyZChjb250YWluZXI6IGFueSwgYm91bmRpbmdSZWN0OiBhbnkpOiBIQ0NhcmRQb3NpdGlvblxuICAgIHtcbiAgICAgICAgLy8gc2VjdXJlIHRoaXMgaW4gY2FzZSBvZiBJRSByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgICAgIGxldCBib3JkZXJXaWR0aCA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5ib3JkZXJXaWR0aDtcbiAgICAgICAgbGV0IGNudFdpZHRoID0gcGFyc2VGbG9hdChib3JkZXJXaWR0aCB8fCAnMCcpO1xuICAgICAgICBsZXQgcG9zID0gSENDYXJkUG9zaXRpb24ubm9uZTtcblxuICAgICAgICBpZiAodGhpcy50cmlnUmVjdC5ib3R0b20gPCBib3VuZGluZ1JlY3QudG9wKSB7XG4gICAgICAgICAgICBwb3MgPSBIQ0NhcmRQb3NpdGlvbi5ib3R0b207XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC50b3AgPiAoYm91bmRpbmdSZWN0LmJvdHRvbSAtIGNudFdpZHRoKSkge1xuICAgICAgICAgICAgcG9zID0gSENDYXJkUG9zaXRpb24udG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0IGhvcml6b250YWwgYWxpZ25tZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBhbGlnbm1lbnRGb3JDYXJkKGJvdW5kaW5nUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogSENDYXJkQWxpZ25tZW50XG4gICAge1xuICAgICAgICBsZXQgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LmxlZnQ7XG4gICAgICAgIGxldCB2aWV3UG9ydCA9IG1vZGFsQ29udGFpbmVyLmRvbUhhbmRsZXIuZ2V0Vmlld3BvcnQoKTtcblxuICAgICAgICBpZiAodGhpcy50cmlnUmVjdC5sZWZ0LnRvRml4ZWQoMCkgPT09IGJvdW5kaW5nUmVjdC5sZWZ0LnRvRml4ZWQoMCkgJiZcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ID4gSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdClcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LmxlZnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChib3VuZGluZ1JlY3QubGVmdCA8IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5wYWRkZWRMZWZ0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoKHZpZXdQb3J0LndpZHRoIC0gYm91bmRpbmdSZWN0LnJpZ2h0KSA8IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5wYWRkZWRSaWdodDtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJpZ1JlY3QucmlnaHQudG9GaXhlZCgwKSA9PT0gYm91bmRpbmdSZWN0LnJpZ2h0LnRvRml4ZWQoMCkgfHxcbiAgICAgICAgICAgICh2aWV3UG9ydC53aWR0aCAtIGJvdW5kaW5nUmVjdC5yaWdodCkgPiBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KVxuICAgICAgICB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQucmlnaHQ7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGlnbm1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUdXJuIG9uIHRlbXBvcmFyeSBkaXNwbGF5IHRvIEJMT0NLIHNvIHdlIGNhbiByZWFkIGRpbWVuc2lvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW5Gb3JBZGp1c3RtZW50cyhjb250YWluZXI6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB0aGlzLmluaXRFbGVtZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUdXJuIG9mZiBkaXNwbGF5IGJhY2sgTk9ORVxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXI6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAvLyBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsY3VsYXRlcyBwb3NpdGlvbmluZyBmb3Igc3R5bGUuTEVGVC4gQXMgYWxyZWFkeSBzYWlkIHRoZXkgYXJlIHR3byB0eXBlcyBvZiB0cmlhbmdsZXMgdGhhdFxuICAgICAqIGFyZSBhcHBsaWVzIGZvciB0aGVzZSBjYXNlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBhKSBMYXJnZSBsZWZ0LCBMYXJnZSByaWdodFxuICAgICAqXG4gICAgICogIFByaW1lTkcgYWxpZ25zIHRoZSBjYXJkIHdpdGggZWl0aGVyIHRoZSByaWdodCBzaWRlIG9yIGxlZnQgc2lkZSBvZiB0aGUgdHJpZ2dlcmluZyBpY29uXG4gICAgICpcbiAgICAgKlxuICAgICAqICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbiAgICAgKiAgLi4uLi4uXi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvciAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5eLi4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgYikgU21hbGwgbGVmdCAsIHNtYWxsIHJpZ2h0XG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhbmQgUHJpbWVORyBwb3NpdGlvbiB0aGUgY2FyZCBvZmYgdG8gdGhlXG4gICAgICogIHRyaWdnZXJpbmcgaWNvbnMsIHNvIGV2ZW4gcHJpbWVOZyBkb2VzIG5vdCBoYXZlIHNwYWNlIHRvIGFsaWduIGl0IHdpdGggdGhlIFZcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogIC4uLi5eLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9yICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLl4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqIGMpQWxpZ25lZCB3aXRoIHRoZSBlZGdlIG9mIGJyb3dzZXJcbiAgICAgKlxuICAgICAqIE9uIHRoZSByaWdodCBzaWRlIHRoaXMgaXMgcHJvYmxlbSBhcyB3ZSBjYW5ub3QgY2FsY3VsYXRlIGZ1bGwgZnV0dXJlIHdpZHRoIG9mIHRoZSBjYXJkLlxuICAgICAqIGJ1dCB3ZSBhcHBsbHkgZm9yIHRoaXMgY2FzZSAjYiAoYXJyb3cgMTAlIClcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGNMZWZ0Rm9yQWxpZ25tZW50KGJvdW5kaW5nUmVjdDogYW55LCBhbGlnbm1lbnQ6IEhDQ2FyZEFsaWdubWVudCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgLy8gd2lkdGggZm9yIHdoaWNoIHdlIG5lZWQgdG8gc2hpZnQgY2FyZC4gMjUlIG9yIDEwJSBvZiB0aGUgY29udGFpbmVyIHdpZHRoXG4gICAgICAgIGxldCB3TGFyZ2VUcmlhbmdsZSA9IGJvdW5kaW5nUmVjdC53aWR0aCAqIDAuMjU7XG4gICAgICAgIGxldCB3U21hbGxUcmlhbmdsZSA9IGJvdW5kaW5nUmVjdC53aWR0aCAqIDAuMTA7XG5cbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnJpZ2h0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdFJpZ2h0ID0gYm91bmRpbmdSZWN0LmxlZnQgKyB3TGFyZ2VUcmlhbmdsZTtcbiAgICAgICAgICAgICAgICBsZXQgdHJpZ1JpZ2h0ID0gdGhpcy50cmlnUmVjdC5yaWdodCAtIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0UmlnaHQgLSAoYm91bmRpbmdSZWN0LnJpZ2h0IC0gdHJpZ1JpZ2h0KTtcblxuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkUmlnaHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0UmlnaHRTID0gYm91bmRpbmdSZWN0LmxlZnQgKyB3U21hbGxUcmlhbmdsZTtcbiAgICAgICAgICAgICAgICBsZXQgdHJpZ1JpZ2h0UyA9IHRoaXMudHJpZ1JlY3QucmlnaHQgLSB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdFJpZ2h0UyAtIChib3VuZGluZ1JlY3QucmlnaHQgLSB0cmlnUmlnaHRTKTtcblxuXG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5wYWRkZWRMZWZ0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdExlZnRQYWQgPSBib3VuZGluZ1JlY3QubGVmdCAtIHdTbWFsbFRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdExlZnRQYWQgKyB0aGlzLnRyaWdJY29uTWlkZGxlO1xuXG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5sZWZ0OlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRMZWZ0ID0gYm91bmRpbmdSZWN0LmxlZnQgLSB3TGFyZ2VUcmlhbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRMZWZ0ICsgdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRDaGVja2VkLFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIERpcmVjdGl2ZSxcbiAgICBEb0NoZWNrLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgU2ltcGxlQ2hhbmdlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnQsIHByaW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNweSBsaWZlY3ljbGUgZGlyZWN0aXZlIGlzIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyB0byB0cmFjayBsaWZlY3ljbGUgY2FsbGJhY2tcbiAqXG4gKiAjIyNVc2FnZVxuICpcbiAqIGBgYFxuICogICA8bXktZGlyZWN0aXZlIHNweWhvb2tzPjxteS1kaXJlY3RpdmU+XG4gKlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW3NweUhvb2tzXSd9KVxuZXhwb3J0IGNsYXNzIFNweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQsIERvQ2hlY2ssIE9uQ2hhbmdlcyxcbiAgICBBZnRlckNvbnRlbnRJbml0LCBBZnRlckNvbnRlbnRDaGVja2VkLCBBZnRlclZpZXdJbml0LCBBZnRlclZpZXdDaGVja2VkXG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnb25Jbml0Jyk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnb25EZXN0cm95Jyk7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7WyBwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlfSlcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nT25DaGFuZ2VzID0gJyArIGNoYW5nZXMpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0RvQ2hlY2snKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlckNvbnRlbnRJbml0Jyk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKClcbiAgICB7XG5cbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlckNvbnRlbnRDaGVja2VkJyk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJWaWV3SW5pdCcpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyVmlld0NoZWNrZWQnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxvZ0l0KG1zZzogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgbGV0IGxldmVsID0gMDtcbiAgICAgICAgbGV0IG1lID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCB0YWdCb2R5ID0gbWU7XG5cbiAgICAgICAgd2hpbGUgKCh0YWdCb2R5ID0gdGFnQm9keS5wYXJlbnROb2RlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgaWYgKHRhZ0JvZHkudGFnTmFtZSA9PT0gJ0FQUC1ST09UJyB8fCBsZXZlbCA9PT0gNikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRlbnQgPSAnJztcbiAgICAgICAgbGV0IGluZGVudE51bWJlciA9IGxldmVsO1xuICAgICAgICB3aGlsZSAobGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJ1xcdCc7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgcGFyYW1zID0gJyc7XG4gICAgICAgIGlmIChpc1ByZXNlbnQobWUuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBhdHRyOiBBdHRyID0gbWUuYXR0cmlidXRlcy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZShhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBwYXJhbXMgKz0gJygnICsgYXR0ci5uYW1lICsgJz0nICsgYXR0ci52YWx1ZSArICcpLCAgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmludChpbmRlbnQgKyBtZS50YWdOYW1lICsgJygnICsgaW5kZW50TnVtYmVyICsgJyk6ICcgKyBtc2cgKyAnID0+ICcgKyBwYXJhbXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaWdub3JlKG5hbWU6IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBuYW1lLmluZGV4T2YoJ19uZycpID4gLTEgfHxcbiAgICAgICAgICAgIG5hbWUuaW5kZXhPZignbmctJykgPiAtMSB8fFxuICAgICAgICAgICAgbmFtZS5pbmRleE9mKCdzcHlob29rcycpID4gLTE7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtPdmVybGF5Q29tcG9uZW50fSBmcm9tICcuL292ZXJsYXkuY29tcG9uZW50JztcbmltcG9ydCB7T3ZlcmxheVBhbmVsTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPdmVybGF5Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBPdmVybGF5UGFuZWxNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBPdmVybGF5Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnQsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV092ZXJsYXlNb2R1bGVcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SG92ZXJDYXJkQ29tcG9uZW50fSBmcm9tICcuL2hvdmVyLWNhcmQuY29tcG9uZW50JztcbmltcG9ydCB7QVdPdmVybGF5TW9kdWxlfSBmcm9tICcuLi9vdmVybGF5L292ZXJsYXkubW9kdWxlJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEhvdmVyQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEhvdmVyQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBIb3ZlckNhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdIb3ZlckNhcmRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QVBQX0lOSVRJQUxJWkVSLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7XG4gICAgQWNjb3JkaW9uTW9kdWxlLFxuICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICBCdXR0b25Nb2R1bGUsXG4gICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgQ2hlY2tib3gsXG4gICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgRGF0YVRhYmxlTW9kdWxlLFxuICAgIERpYWxvZyxcbiAgICBEaWFsb2dNb2R1bGUsXG4gICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgRWRpdG9yTW9kdWxlLFxuICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgIE1lbnVNb2R1bGUsXG4gICAgT3ZlcmxheVBhbmVsTW9kdWxlLFxuICAgIFBhZ2luYXRvck1vZHVsZSxcbiAgICBQYW5lbE1vZHVsZSxcbiAgICBSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICBTaGFyZWRNb2R1bGUsXG4gICAgVGFiTWVudU1vZHVsZSxcbiAgICBUb29sYmFyTW9kdWxlLFxuICAgIFRyZWVNb2R1bGVcbn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QXJpYmFDb3JlTW9kdWxlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7U3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmV9IGZyb20gJy4vc3B5LWxpZmVjeWNsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHtFbWJlZGRlZEl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vY29yZS9lbWJlZGRlZC1pdGVtJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vZW50cnktY29tcG9uZW50cyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7QVdCYXNpY05hdmlnYXRvck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Jhc2ljLW5hdmlnYXRvci9iYXNpYy1uYXZpZ2F0b3IubW9kdWxlJztcbmltcG9ydCB7QVdDaGVja0JveExpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hvb3Nlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvbmZpcm1hdGlvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24ubW9kdWxlJztcbmltcG9ydCB7QVdDdXJyZW5jeU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2N1cnJlbmN5L2N1cnJlbmN5Lm1vZHVsZSc7XG5pbXBvcnQge0FXRGF0ZUFuZFRpbWVNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kYXRlLWFuZC10aW1lL2RhdGEtYW5kLXRpbWUubW9kdWxlJztcbmltcG9ydCB7QVdEaWFsb2dNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLm1vZHVsZSc7XG5pbXBvcnQge0FXRHJvcGRvd25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuaW1wb3J0IHtBV0dlbmVyaWNDaG9vc2VyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlJztcbmltcG9ydCB7QVdJbnB1dEZpZWxkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlJztcbmltcG9ydCB7QVdPdXRsaW5lRm9yTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvb3V0bGluZS9vdXRsaW5lLWZvci5tb2R1bGUnO1xuaW1wb3J0IHtBV092ZXJsYXlNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9vdmVybGF5L292ZXJsYXkubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24ubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlV3JhcHBlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlJztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbkxpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV1JpY2hUZXh0QXJlYU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JpY2gtdGV4dC1hcmVhL3JpY2gtdGV4dC1hcmVhLm1vZHVsZSc7XG5pbXBvcnQge0FXSG92ZXJDYXJkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaG92ZXItY2FyZC9ob3Zlci1jYXJkLm1vZHVsZSc7XG5pbXBvcnQge1xuICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZVxufSBmcm9tICcuL3dpZGdldHMvc2Nyb2xsYWJsZS1jb250YWluZXIvc2Nyb2xsYWJsZS1jb250YWluZXIubW9kdWxlJztcbmltcG9ydCB7QVdTZWN0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLm1vZHVsZSc7XG5pbXBvcnQge0FXU3RlcHBlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtBV1RleHRBcmVhTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdGb3JtVGFibGVNb2R1bGV9IGZyb20gJy4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUubW9kdWxlJztcbmltcG9ydCB7QVdMaXN0TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2FyZE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NhcmQvY2FyZC5tb2R1bGUnO1xuaW1wb3J0IHtBV0RhdGF0YWJsZTJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTIubW9kdWxlJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZXJyb3ItbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7QXdOYW1lU3RvcmV9IGZyb20gJy4vY29yZS9hdy1uYW1lL2F3LW5hbWUuc3RvcmUnO1xuaW1wb3J0IHtEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtXaXphcmRQcm9ncmVzc01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3dpemFyZC1wcm9ncmVzcy93aXphcmQtcHJvZ3Jlc3MubW9kdWxlJztcbmltcG9ydCB7VG9nZ2xlU3dpdGNoTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvdG9nZ2xlLXN3aXRjaC90b2dnbGUtc3dpdGNoLm1vZHVsZSc7XG5cbi8qKlxuICogQ29tcG9uZW50IG1vZHVsZSBpcyBjb3JlIG1vZHVsZSBmb3IgdGhlIGNvbW1vbiBsYXlvdXRzIGFuZCB3aWRnZXRzIGxpYnJhcmllcy5cbiAqXG4gKiB0b2RvOiBUaGVyZSBhcmUgc29tZSB0aGluZ3MgdGhhdCBJIHN0aWxsIG5lZWQgdG8gcmVzb2x2ZSAtIHBsZWFzZSBzZWUgYW5kIG5vdGljZXMgQER1cGxpY2F0ZXNcbiAqIGpzZG9jIEkgd2FudCB0byBrZWVwIHRoaXMgdGhlcmUgdG8gcmVtaW5kIG1lIHRoYXQgSSBuZWVkIHRvIHJlZmFjdG9yIHRoaXMgYXMgb2Ygbm93IHRoZXJlIGFyZVxuICogbm90IG11Y2ggb3B0aW9uIHdpdGggYW5ndWxhci5cbiAqXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBBcmliYUNvcmVNb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG5cbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlLFxuICAgICAgICBBV0NhcmRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXQ29uZmlybWF0aW9uTW9kdWxlLFxuICAgICAgICBBV0N1cnJlbmN5TW9kdWxlLFxuICAgICAgICBBV0RhdGVBbmRUaW1lTW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdHZW5lcmljQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZSxcbiAgICAgICAgQVdQYWdlV3JhcHBlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGUsXG4gICAgICAgIEFXUmljaFRleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGUsXG4gICAgICAgIEFXU2VjdGlvbk1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV1RleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV0Zvcm1UYWJsZU1vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSG92ZXJDYXJkTW9kdWxlLFxuICAgICAgICBBV0xpc3RNb2R1bGUsXG4gICAgICAgIEFXRGF0YXRhYmxlMk1vZHVsZSxcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NNb2R1bGUsXG4gICAgICAgIFRvZ2dsZVN3aXRjaE1vZHVsZSxcblxuICAgICAgICAvLyBQcmltZU5HIHJlbW92ZSB3aGVuIGFsbCBBVyBhcmUgaW1wb3J0ZWRcbiAgICAgICAgUGFuZWxNb2R1bGUsXG4gICAgICAgIEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgVG9vbGJhck1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBTaGFyZWRNb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZSxcbiAgICAgICAgTWVudU1vZHVsZSxcbiAgICAgICAgVGFiTWVudU1vZHVsZSxcbiAgICAgICAgQWNjb3JkaW9uTW9kdWxlLFxuICAgICAgICBFZGl0b3JNb2R1bGUsXG4gICAgICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICAgICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgICAgICBPdmVybGF5UGFuZWxNb2R1bGUsXG4gICAgICAgIFRyZWVNb2R1bGVcblxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlLFxuICAgICAgICAvLyAzdGggcGFydHkgZGVjbGFyYXRpb25cbiAgICBdLFxuICAgIGJvb3RzdHJhcDogW10sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG5cbiAgICAgICAgLy8gUHJpbWVOR1xuICAgICAgICBDaGVja2JveCxcbiAgICAgICAgRGlhbG9nXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlLFxuICAgICAgICBBV0NhcmRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXQ29uZmlybWF0aW9uTW9kdWxlLFxuICAgICAgICBBV0N1cnJlbmN5TW9kdWxlLFxuICAgICAgICBBV0RhdGVBbmRUaW1lTW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdHZW5lcmljQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZSxcbiAgICAgICAgQVdQYWdlV3JhcHBlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGUsXG4gICAgICAgIEFXUmljaFRleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGUsXG4gICAgICAgIEFXU2VjdGlvbk1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV1RleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV0Zvcm1UYWJsZU1vZHVsZSxcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdIb3ZlckNhcmRNb2R1bGUsXG4gICAgICAgIEFXTGlzdE1vZHVsZSxcbiAgICAgICAgQVdEYXRhdGFibGUyTW9kdWxlLFxuICAgICAgICBXaXphcmRQcm9ncmVzc01vZHVsZSxcbiAgICAgICAgVG9nZ2xlU3dpdGNoTW9kdWxlLFxuXG4gICAgICAgIC8vIFByaW1lTkdcbiAgICAgICAgU2hhcmVkTW9kdWxlLFxuICAgICAgICBQYW5lbE1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZSxcbiAgICAgICAgTWVudU1vZHVsZSxcbiAgICAgICAgVGFiTWVudU1vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgICAgIFBhZ2luYXRvck1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBcmliYUNvbXBvbmVudHNNb2R1bGVcbntcblxuXG4gICAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVyc1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBBcmliYUNvbXBvbmVudHNNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBNb2RhbFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRXJyb3JNYW5hZ2VyU2VydmljZSxcbiAgICAgICAgICAgICAgICBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIERhdGFQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgRGF0YUZpbmRlcnMsXG4gICAgICAgICAgICAgICAgQXdOYW1lU3RvcmUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBBUFBfSU5JVElBTElaRVIsXG4gICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHJlZ2lzdGVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZGVwczogW0NvbXBvbmVudFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyhjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KTogRnVuY3Rpb25cbntcbiAgICByZXR1cm4gY29tcFJlZ2lzdHJ5LmluaXRpYWxpemUuYmluZChjb21wUmVnaXN0cnksIGNvbXBvbmVudHMpO1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vZW50cnktY29tcG9uZW50cyc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC5zZXJ2aWNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQge0F3TmFtZVN0b3JlfSBmcm9tICcuL2NvcmUvYXctbmFtZS9hdy1uYW1lLnN0b3JlJztcbmltcG9ydCB7RGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcblxuXG4vKipcbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyB1c2VkIG1haW5seSBmb3IgdGVzdHMgYXMgaW1wb3J0aW5nIGEgbW9kdWxlIHdpdGggYWxsIHRoZSBjb21wb25lbnRzIGFuZCB5b3VcbiAqIHVzZSBvbmx5IDEgb3IgdHdvIGhhcyBhIGJpZyBpbXBhY3Qgb24gdGhlIHBlcmZvcm1hbmNlIGV4ZWN1dGlvbi4gZS5nLiBmcm9tIGV4ZWN1dGluZyBjb3VwbGVcbiAqIHRlc3RzIHVuZGVyIDEgc2VjIGNhbiBnbyB1cCB0byAxMHNlYyBpZiB5b3UgaW1wb3J0IGFsbCB0aGUgdGhpbmdzIHRoYXQgeW91IGFyZSBub3QgdXNpbmcuXG4gKlxuICogSSBoYXZlbnQgbm90aWNlZCBhbnl0aGluZyBzaW1pbGFyIGluIGFwcGxpY2F0aW9uIGl0cyBvbmx5IGphc21pbmUva2FybWEgdGhhdCBuZWVkcyB0byBpbml0XG4gKiBjb21wb25lbnRzIGZvciBldmVyeSB0ZXN0LlxuICpcbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBcmliYUNvbXBvbmVudHNUZXN0UHJvdmlkZXJNb2R1bGUge1xuXG5cbiAgICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBBcmliYUNvbXBvbmVudHNUZXN0UHJvdmlkZXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBNb2RhbFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRXJyb3JNYW5hZ2VyU2VydmljZSxcbiAgICAgICAgICAgICAgICBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIERhdGFQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgRGF0YUZpbmRlcnMsXG4gICAgICAgICAgICAgICAgQXdOYW1lU3RvcmUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBBUFBfSU5JVElBTElaRVIsXG4gICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHJlZ2lzdGVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZGVwczogW0NvbXBvbmVudFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyhjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KTogRnVuY3Rpb24ge1xuICAgIHJldHVybiBjb21wUmVnaXN0cnkuaW5pdGlhbGl6ZS5iaW5kKGNvbXBSZWdpc3RyeSwgY29tcG9uZW50cyk7XG59XG5cblxuIl0sIm5hbWVzIjpbImlzUHJlc2VudCIsIkRpcmVjdGl2ZSIsIlZpZXdDb250YWluZXJSZWYiLCJJbnB1dCIsImlzQmxhbmsiLCJNYXBXcmFwcGVyIiwiQ29tcG9uZW50IiwiUmVuZGVyZXIyIiwiRWxlbWVudFJlZiIsIkFwcENvbmZpZyIsInRzbGliXzEuX19leHRlbmRzIiwibm9vcCIsIkZvcm1Hcm91cCIsInV1aWQiLCJGb3JtQ29udHJvbCIsIkVudmlyb25tZW50IiwiSW5qZWN0IiwiU2tpcFNlbGYiLCJPcHRpb25hbCIsImZvcndhcmRSZWYiLCJEb21TYW5pdGl6ZXIiLCJpc1N0cmluZ01hcCIsIkluamVjdGFibGUiLCJhc3NlcnQiLCJDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIiLCJDaGFuZ2VEZXRlY3RvclJlZiIsIlN0cmluZ1dyYXBwZXIiLCJWaWV3Q2hpbGQiLCJQaXBlIiwiQ3VycmVuY3lQaXBlIiwiRXZlbnRFbWl0dGVyIiwiT3V0cHV0IiwiTmdab25lIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiLCJpc1R5cGUiLCJvYmplY3RUb05hbWUiLCJCZWhhdmlvclN1YmplY3QiLCJvYnNlcnZhYmxlT2YiLCJGaWVsZFBhdGgiLCJpc0FycmF5IiwiaXNTdHJpbmciLCJ1bmltcGxlbWVudGVkIiwiaXNGdW5jdGlvbiIsImlzSnNPYmplY3QiLCJvYmplY3RWYWx1ZXMiLCJJbmplY3Rpb25Ub2tlbiIsIkhvc3RCaW5kaW5nIiwiVmFsaWRhdG9ycyIsIkxpc3RXcmFwcGVyIiwiQ29udGVudENoaWxkIiwiQ29udGVudENoaWxkcmVuIiwiRm9ybXNNb2R1bGUiLCJSZWFjdGl2ZUZvcm1zTW9kdWxlIiwiSW5wdXRUZXh0TW9kdWxlIiwiTkdfVkFMVUVfQUNDRVNTT1IiLCJEZWNpbWFsUGlwZSIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwiQnV0dG9uTW9kdWxlIiwiVG9vbGJhck1vZHVsZSIsImlzQm9vbGVhbiIsIkNoZWNrYm94TW9kdWxlIiwiZXF1YWxzIiwiQXV0b0NvbXBsZXRlTW9kdWxlIiwiRHJvcGRvd25Nb2R1bGUiLCJpc0RhdGUiLCJDYWxlbmRhck1vZHVsZSIsIkRpYWxvZ01vZHVsZSIsIlJhZGlvQnV0dG9uTW9kdWxlIiwiaXNFbnRpdHkiLCJ0cmlnZ2VyIiwic3RhdGUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJhbmltYXRlIiwiQW5pbWF0aW9uQnVpbGRlciIsIklucHV0VGV4dGFyZWFNb2R1bGUiLCJTdWJqZWN0IiwiUm91dGluZ1NlcnZpY2UiLCJSb3V0ZXJNb2R1bGUiLCJFZGl0b3JNb2R1bGUiLCJBY2NvcmRpb25Nb2R1bGUiLCJBcmliYUNvcmVNb2R1bGUiLCJTaGFyZWRNb2R1bGUiLCJCb29sZWFuV3JhcHBlciIsIlZpZXdFbmNhcHN1bGF0aW9uIiwiRG9tSGFuZGxlciIsInRzbGliXzEuX192YWx1ZXMiLCJPYmplY3RVdGlscyIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiSW5qZWN0b3IiLCJkZWJvdW5jZVRpbWUiLCJzd2l0Y2hNYXAiLCJvZiIsImlzUGxhdGZvcm1Ccm93c2VyIiwiUExBVEZPUk1fSUQiLCJMaXN0Ym94TW9kdWxlIiwiT3ZlcmxheVBhbmVsIiwicHJpbnQiLCJPdmVybGF5UGFuZWxNb2R1bGUiLCJBUFBfSU5JVElBTElaRVIiLCJQYW5lbE1vZHVsZSIsIk1lbnVNb2R1bGUiLCJUYWJNZW51TW9kdWxlIiwiRGF0YVRhYmxlTW9kdWxlIiwiUGFnaW5hdG9yTW9kdWxlIiwiVHJlZU1vZHVsZSIsIkNoZWNrYm94IiwiRGlhbG9nIiwicmVnaXN0ZXJDb21wb25lbnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBa0ZJLCtCQUFvQixjQUFnQztZQUFoQyxtQkFBYyxHQUFkLGNBQWMsQ0FBa0I7U0FFbkQ7UUFaRCxzQkFDSSx1Q0FBSTs7OztnQkFEUixVQUNTLElBQVM7Z0JBRWQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7YUFDOUI7OztXQUFBOzs7Ozs7Ozs7UUFhRCwyQ0FBVzs7Ozs7WUFBWCxVQUFZLE9BQXNCO2dCQUU5QixJQUFJQSxnQkFBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFD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
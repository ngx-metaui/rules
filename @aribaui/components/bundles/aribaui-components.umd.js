(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@aribaui/core'), require('@angular/forms'), require('@angular/platform-browser'), require('@angular/common'), require('rxjs'), require('primeng/components/inputtext/inputtext'), require('rxjs/operators'), require('primeng/primeng'), require('@angular/animations'), require('@angular/router'), require('primeng/components/utils/objectutils')) :
    typeof define === 'function' && define.amd ? define('@aribaui/components', ['exports', '@angular/core', '@aribaui/core', '@angular/forms', '@angular/platform-browser', '@angular/common', 'rxjs', 'primeng/components/inputtext/inputtext', 'rxjs/operators', 'primeng/primeng', '@angular/animations', '@angular/router', 'primeng/components/utils/objectutils'], factory) :
    (factory((global.aribaui = global.aribaui || {}, global.aribaui.components = {}),global.ng.core,null,global.ng.forms,global.ng.platformBrowser,global.ng.common,global.rxjs,null,global.rxjs.operators,null,global.ng.animations,global.ng.router,null));
}(this, (function (exports,core,core$1,forms,platformBrowser,common,rxjs,inputtext,operators,primeng,animations,router,objectutils) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * When we have a custom component like dropdown, radiobuttonlist and
     * many more we want to provide a custom content to it like so:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     *
     * ```
     * Who else would know how to render list of objects..
     *
     * But its not possible in current form. if I do not provide Angular some as they call it this
     * syntactic sugar *,
     *
     *
     * ```
     *  <aw-dropdown *mySugerDirective=.....>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     * ```
     *
     *
     * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
     * inside the component
     *
     * So the only way I found (expecting I do not want to change anything in terms of bindings and the
     * signature I use it. I have to use it like this:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      <ng-template let-item> {{item.userName}}</ng-template>
     *
     *   <aw-dropdown
     *
     * ```
     *
     *  This way it could work. Since I am inside ngFor I want to render the item into the correct
     * viewContainer of ngFor's current item.
     *
     *  This way I can also expose item outside using Angular's special local variable called:
     * $implicit.
     *
     * This gets even more complex if we try to pass this template 2 levels down, like in case of
     * RadioButtonList. But later on I might want to refactor this into custom NG FOR
     *
     * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
     *
     */
    var EmbeddedItemDirective = (function () {
        function EmbeddedItemDirective(_viewContainer) {
            this._viewContainer = _viewContainer;
        }
        Object.defineProperty(EmbeddedItemDirective.prototype, "item", {
            set: /**
             * @param {?} item
             * @return {?}
             */ function (item) {
                this._implicitValue = item;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        /**
         *
         * @param {?} changes
         * @return {?}
         */
        EmbeddedItemDirective.prototype.ngOnChanges = /**
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(this._viewRef)) {
                    this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
                }
                if (core$1.isPresent(this.embeddedItem)) {
                    var /** @type {?} */ context = new EmbededItem(this._implicitValue);
                    this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
                }
            };
        EmbeddedItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[embeddedItem]' },] },
        ];
        /** @nocollapse */
        EmbeddedItemDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef }
            ];
        };
        EmbeddedItemDirective.propDecorators = {
            embeddedItem: [{ type: core.Input }],
            item: [{ type: core.Input }]
        };
        return EmbeddedItemDirective;
    }());
    /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */
    var /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */ EmbededItem = (function () {
        function EmbededItem($implicit) {
            this.$implicit = $implicit;
        }
        return EmbededItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * GenericContainerComponent is used by include-component.directive to dynamically create an
     * HTMLElement and use this element to wrap a child component. This is very useful when we want to
     * modify a child by wrapping it with a border, a background, or bold its text.
     *
     * The wrapper element is dynamically created. It's element is specified by the tagName property in
     * the bindings \@Input.
     *
     *  ### Example.  Directly in html
     *
     *   app.html
     *      <aw-generic-container tagName="tagName" bindings="bindings">
     *          <my-component ..bindings..></my-component>
     *      </aw-generic-container>
     *
     *   app.component.ts
     *
     *       tagName = (bBold) ? 'h1' : 'span';
     *       bindings = {  style: 'background-color: red' }
     *
     */
    var GenericContainerComponent = (function () {
        /**
         * param renderer - Renderer is used to create 'tagName' element.
         */
        function GenericContainerComponent(renderer, element) {
            this.renderer = renderer;
            this.element = element;
            this.nativeElement = element.nativeElement;
        }
        /**
         * During the initialization, verify that at least one input has been set.
         */
        /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
        GenericContainerComponent.prototype.ngOnInit = /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
            function () {
                // If there's no input, this component wouldn't know what to do and throw exception.
                if (core$1.isBlank(this.bindings) && core$1.isBlank(this.tagName)) {
                    throw new Error('GenericContainerComponent input bindings or tagName ' +
                        'have not been set.');
                }
                // If the tagName is blank, the get it from bindings.
                if (core$1.isBlank(this.tagName)) {
                    this.tagName = this.bindings.get('tagName');
                    if (core$1.isBlank(this.tagName)) {
                        this.tagName = GenericContainerComponent.DefaultTagName;
                    }
                }
                // Save first added
                this.childElement = this.nativeElement.firstChild;
                this.doRender();
            };
        /**
         * @return {?}
         */
        GenericContainerComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.childElement) &&
                    this.childElement.parentNode !== this.nativeElement.firstChild) {
                    this.nativeElement.firstChild.appendChild(this.childElement);
                }
            };
        /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
        GenericContainerComponent.prototype.doRender = /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ el = this.renderer.createElement(this.tagName);
                if (core$1.isPresent(this.nativeElement)) {
                    this.renderer.appendChild(this.nativeElement, el);
                }
                // Loop through all the bindings and add them to the element.
                core$1.MapWrapper.iterable(this.bindings).forEach(function (v, k) {
                    _this.renderer.setStyle(el, k, v);
                });
                // Attach the component to this divElement.
                el.appendChild(this.childElement);
            };
        /**
         * Default tagName if none is specified inside bindings.
         *
         */
        GenericContainerComponent.DefaultTagName = 'div';
        GenericContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-container',
                        template: '<ng-content></ng-content>',
                        styles: []
                    },] },
        ];
        /** @nocollapse */
        GenericContainerComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.ElementRef }
            ];
        };
        GenericContainerComponent.propDecorators = {
            bindings: [{ type: core.Input }],
            tagName: [{ type: core.Input }]
        };
        return GenericContainerComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  Base component shares common functionality among all the components (layouts, widgets).
     *
     * @abstract
     */
    var BaseComponent = (function () {
        function BaseComponent(env) {
            this.env = env;
            /**
             * Adds disabled flag to the component
             *
             */
            this.disabled = false;
            /**
             * Weather this component is visible
             * Default is false;
             */
            this.visible = false;
            /**
             * Tell  the component if we are in editing mode.
             *
             */
            this.editable = true;
            /**
             * Removes padding from the component. Usually used when we are nesting other component with
             * its own grid.
             */
            this.omitPadding = false;
            /**
             * Prefix for the correct asset path
             */
            this.assetFolder = 'assets';
            this.extBindings = new Map();
            this.omitPadding = false;
        }
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.assetFolder = this.env.getValue(core$1.AppConfig.AssetFolder);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        BaseComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
            };
        BaseComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            visible: [{ type: core.Input }],
            editable: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            styleClass: [{ type: core.Input }],
            omitPadding: [{ type: core.Input }]
        };
        return BaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var WidgetSizeColumns = {
        xsmall: 1,
        small: 3,
        medium: 6,
        large: 9,
        xlarge: 12,
    };
    WidgetSizeColumns[WidgetSizeColumns.xsmall] = "xsmall";
    WidgetSizeColumns[WidgetSizeColumns.small] = "small";
    WidgetSizeColumns[WidgetSizeColumns.medium] = "medium";
    WidgetSizeColumns[WidgetSizeColumns.large] = "large";
    WidgetSizeColumns[WidgetSizeColumns.xlarge] = "xlarge";
    /**
     *  BaseFormComponnet extends BaseComponent for add specific form behavior
     *
     * @abstract
     */
    var BaseFormComponent = (function (_super) {
        __extends(BaseFormComponent, _super);
        /**
         * Some of the BaseFormComponent can wrap other component and in these cases we want to
         * inherit some of the behavior from parent
         *
         * @Inject(Environment) public env: Environment : is tem a workaround as without inject
         * on this specific component it complains that Environment is unresolved symbol
         *
         */
        function BaseFormComponent(env, parentContainer) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Is current element visible
             */
            _this.hidden = false;
            /**
             * Renders required flex around the component
             *
             */
            _this.required = false;
            /**
             *  a text displayed when value is empty or NULL
             */
            _this.placeHolder = '';
            /**
             * Identify if this control is used directly or if its part of some other control
             * e.g. GenericChooser and managed by this control.
             * Meaning State is mananged outside of this component
             *
             */
            _this.isStandalone = true;
            _this.onModelChanged = core$1.noop;
            _this.onModelTouched = core$1.noop;
            return _this;
        }
        /**
         * @return {?}
         */
        BaseFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.parentContainer)) {
                    this.formGroup = this.parentContainer.formGroup;
                    this.editable = this.parentContainer.editable;
                }
                this.checkInitForm();
            };
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         */
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
        BaseFormComponent.prototype.checkInitForm = /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.env.currentForm)) {
                    this.env.currentForm = new forms.FormGroup({});
                }
                /**
                         * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                         * number basedon some semantics app.page.component if there are more component on the page
                         * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                         */
                if (core$1.isBlank(this.name)) {
                    this.name = core$1.uuid();
                }
                if (core$1.isBlank(this.id)) {
                    this.id = core$1.uuid();
                }
            };
        /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.doRegister = /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
            function (name, value) {
                var /** @type {?} */ fControl;
                if (core$1.isBlank(this.formGroup.controls[name])) {
                    this.formGroup.registerControl(name, new forms.FormControl(value));
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                }
                else {
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                    var /** @type {?} */ updatedValue = core$1.isPresent(fControl.value) ? fControl.value : value;
                    fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
                }
                return fControl;
            };
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param value default value to be pre-set
         */
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
        BaseFormComponent.prototype.registerFormControl = /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
            function (value) {
                this.formControl = this.doRegister(this.name, value);
                if (this.disabled) {
                    this.formControl.disable();
                }
            };
        Object.defineProperty(BaseFormComponent.prototype, "formGroup", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._formGroup = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         */
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
        BaseFormComponent.prototype.canSetType = /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelChanged = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelTouched = fn;
            };
        /*
             *  Supported layout constants. It is expected there will be more options as we currently
             *  support only these two there will be other variations of it. e.g. for stacked it will not
             *  be 1 columns like it is now but multiple columns
             *
             */
        BaseFormComponent.LayoutStacked = 'stacked';
        BaseFormComponent.LayoutInline = 'inline';
        /** @nocollapse */
        BaseFormComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment, decorators: [{ type: core.Inject, args: [core$1.Environment,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        BaseFormComponent.propDecorators = {
            name: [{ type: core.Input }],
            id: [{ type: core.Input }],
            hidden: [{ type: core.Input }],
            required: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            isStandalone: [{ type: core.Input }],
            formGroup: [{ type: core.Input }]
        };
        return BaseFormComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple component rendering values in the read only mode. Just needed some component used
     * to render Strings in read only mode
     *
     *
     *  ### Example
     *
     * Using it inside form container along with label
     *
     *
     *  ```
     * \@Component({
     *              selector: 'userInfo' ,
     *              template: `
     *                      <aw-form-table [editable]="false" >
     *                          <aw-form-row [name]="fieldName"  [label]="label">
     *                                 <aw-string [value]="inputValue" ></aw-string>
     *                           </aw-form-row>
     *                      </aw-form-table>
     *
     *                  `
     *          })
     *          export class UserProfileComponent
     *          {
     *              inputValue: string = 'Some text';
     *              inputType: string = 'string';
     *              fieldName: string = 'firstName';
     *              label: string = 'My Name';
     *              required: boolean = true;
     *              editing: boolean = true;
     *              labelsOnTop: boolean = false;
     *
     *          }
     *
     *  ```
     *
     * You can also pass html tags.
     *
     */
    var StringComponent = (function (_super) {
        __extends(StringComponent, _super);
        function StringComponent(env, sanitizer, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.sanitizer = sanitizer;
            _this.parentContainer = parentContainer;
            /**
             *  Value to be interpolated
             *
             */
            _this._value = '';
            return _this;
        }
        Object.defineProperty(StringComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.sanitizer.bypassSecurityTrustHtml(this._value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        StringComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-string',
                        template: "\n        <span class=\"w-string-field\" [innerHTML]=\"value\"></span>\n    ",
                        styles: [".w-string-field{display:inline-block}"]
                    },] },
        ];
        /** @nocollapse */
        StringComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: platformBrowser.DomSanitizer },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        StringComponent.propDecorators = {
            value: [{ type: core.Input }]
        };
        return StringComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A class holding a references to components. The methods are self-explanatory.
     *
     */
    var ComponentRegistry = (function () {
        function ComponentRegistry(env) {
            this.env = env;
            this._nameToType = new Map();
        }
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.initialize = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                this.registerTypes(references);
                var /** @type {?} */ promise = new Promise(function (resolve) {
                    resolve(true);
                });
                return promise;
            };
        /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
        ComponentRegistry.prototype.registerType = /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
            function (name, type) {
                if (!this.nameToType.has(name)) {
                    this._nameToType.set(name, type);
                }
            };
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.registerTypes = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                var _this = this;
                if (!core$1.isStringMap(references)) {
                    return;
                }
                Object.keys(references).forEach(function (name) {
                    _this.registerType(name, references[name]);
                });
            };
        Object.defineProperty(ComponentRegistry.prototype, "nameToType", {
            get: /**
             * @return {?}
             */ function () {
                return this._nameToType;
            },
            enumerable: true,
            configurable: true
        });
        ComponentRegistry.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ComponentRegistry.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        return ComponentRegistry;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
     * based on the name. It can accepts bindings as well which will be automatically bound and applied
     * to the component
     *
     *  ### usage:
     *
     *  Instead of inserting component in the way:
     *
     *  ```
     *    <textfield value="some value">
     *
     *  ```
     *
     *  you can do so dynamically like this:
     *
     * ```
     *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
     * ```
     *
     * This is the main building block to dynamically generated UI.
     *
     *
     * Todo: Currently the way Angular API work and we use it to create programatically components
     * is too complext we need to create everything 3 different calls to place a component to the
     * container. What I want is is to create some kind of representation of ContainerElement and this
     * can be also parent for our BaseComponent with method add and remove content. Then we could have
     * some AWContent.
     *
     * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
     * component to the view.
     *
     * ```ts
     *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
     *  containerElement.add('Clck Me')
     * ```
     *
     * To assemble different components together - not only adding string content
     *
     * ```ts
     *  let content = new AWContent(ButtonComponent, bindingsMap)
     *  content.add('Click Me');
     *  containerElement.add(content)
     *
     * ```
     *
     * add more component hierarchy:
     *
     * ```ts
     *  let content = new AWContent(HoverCardComponnets, bindingsMap)
     *  content.add(createLayout();
     *  containerElement.add(content)
     *
     * ```
     *
     *
     *
     *
     */
    var IncludeComponentDirective = (function () {
        function IncludeComponentDirective(viewContainer, factoryResolver, cd, compRegistry) {
            this.viewContainer = viewContainer;
            this.factoryResolver = factoryResolver;
            this.cd = cd;
            this.compRegistry = compRegistry;
            /**
             * I use this flag to identify that component is rendering for first time or its updated during
             * change detection
             *
             */
            this.initRenderInProgress = false;
            /**
             * Not sure if we need this, but want to keep it here or maybe move it to some service so we
             * can cache created components and maybe reuse them.
             *
             */
            this.componentReferences = new Map();
            this.bindings = new Map();
        }
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = true;
                // todo: check if this the right lifecycle callback, this is called only once and you want
                // to probably listen for changes, and change dection decide there is some change and we
                // need to re-draw the view
                this.viewContainer.clear();
                this.doRenderComponent();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(changes['name']) &&
                    (changes['name'].currentValue !== changes['name'].previousValue)) {
                    this.viewContainer.clear();
                    this.doRenderComponent();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = false;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // check to see if we need to render and reposition DOM element both for wrapper and
                // content
                this.createWrapperElementIfAny();
                this.createContentElementIfAny();
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         */
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.createWrapperElementIfAny = /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
            function () {
            };
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         */
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
        IncludeComponentDirective.prototype.doRenderComponent = /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
            function () {
                var _this = this;
                this.placeTheComponent();
                // this.currentComponent.changeDetectorRef.detach();
                this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
                // this.currentComponent.changeDetectorRef.detectChanges();
                // Still not sure about this what all I should release here.
                this.currentComponent.onDestroy(function () {
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    _this.destroy();
                });
            };
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         */
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.placeTheComponent = /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ reference = this.componentReference();
                this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
            };
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return need to run detect changes ? default is false
         */
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
        IncludeComponentDirective.prototype.createContentElementIfAny = /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
            function () {
                var /** @type {?} */ detectChanges = false;
                var /** @type {?} */ ngContent = this.ngContent();
                var /** @type {?} */ ngContentElement = this.ngContentElement();
                if (core$1.isPresent(ngContent)) {
                    var /** @type {?} */ awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
                    var /** @type {?} */ component = this.viewContainer.createComponent(awContentComponent, 0);
                    ((component.instance)).value = ngContent;
                    var /** @type {?} */ awContentContainer = this.currentComponent.location.nativeElement.firstChild;
                    awContentContainer.appendChild(component.location.nativeElement);
                    detectChanges = true;
                }
                else if (core$1.isPresent(ngContentElement)) ;
                return detectChanges;
            };
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         */
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContent = /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
                    this.bindings.delete(IncludeComponentDirective.NgContent);
                }
                return content;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContentElement = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
                    this.bindings.delete(IncludeComponentDirective.NgContentElement);
                }
                return content;
            };
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         */
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
        IncludeComponentDirective.prototype.componentReference = /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.resolvedComponentRef)) {
                    return this.resolvedComponentRef;
                }
                var /** @type {?} */ currType = this.resolveComponentType();
                var /** @type {?} */ componentFactory = this.factoryResolver
                    .resolveComponentFactory(currType);
                var /** @type {?} */ componentMeta = this.resolveDirective(componentFactory);
                var /** @type {?} */ compReference = {
                    metadata: componentMeta,
                    resolvedCompFactory: componentFactory,
                    componentType: currType,
                    componentName: this.name
                };
                this.resolvedComponentRef = compReference;
                return compReference;
            };
        /**
         * Iterates thru ComponentMetadata @Inputs() and check if we have available binding inside the
         * 'this.bindings'
         */
        /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
        IncludeComponentDirective.prototype.applyBindings = /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
            function (cRef, component, bindings) {
                var /** @type {?} */ inputs = cRef.metadata.inputs;
                if (core$1.isBlank(inputs) || inputs.length === 0) {
                    return;
                }
                // should we do any type conversion?
                core$1.MapWrapper.iterable(bindings).forEach(function (v, k) {
                    if (core$1.isPresent(component.instance[k])) {
                        component.instance[k] = v;
                    }
                });
            };
        /**
         * Resolves a component Type based on the string literal
         *
         * @returns component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        IncludeComponentDirective.prototype.resolveComponentType = /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
            function () {
                var /** @type {?} */ componentType = this.compRegistry.nameToType.get(this.name);
                if (core$1.isBlank(componentType)) {
                    core$1.assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                        ' of throwing this error');
                    return;
                }
                return componentType;
            };
        /**
         * @param {?} compFactory
         * @return {?}
         */
        IncludeComponentDirective.prototype.resolveDirective = /**
         * @param {?} compFactory
         * @return {?}
         */
            function (compFactory) {
                var /** @type {?} */ compMeta = {
                    inputs: [],
                    outputs: []
                };
                if (core$1.isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
                    compFactory.inputs.forEach(function (input) {
                        compMeta.inputs.push(input.propName);
                    });
                }
                if (core$1.isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
                    compFactory.outputs.forEach(function (output) {
                        compMeta.outputs.push(output.propName);
                    });
                }
                return compMeta;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent.destroy();
                    this.currentComponent = undefined;
                }
                if (core$1.isPresent(this.viewContainer)) {
                    this.viewContainer.clear();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent = null;
                    this.resolvedComponentRef = null;
                }
            };
        IncludeComponentDirective.NgContent = 'ngcontent';
        IncludeComponentDirective.NgContentElement = 'ngcontentElement';
        IncludeComponentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'aw-include-component'
                    },] },
        ];
        /** @nocollapse */
        IncludeComponentDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver },
                { type: core.ChangeDetectorRef },
                { type: ComponentRegistry }
            ];
        };
        IncludeComponentDirective.propDecorators = {
            name: [{ type: core.Input }],
            bindings: [{ type: core.Input }]
        };
        return IncludeComponentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Error Manager is a service used by Forms components to map error codes into meaningful messages.
     * Currently it does not have much but once we plug in localization it will make more sense
     *
     *
     * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
     * externalize these messages into locale files.
     *
     */
    var ErrorManagerService = (function () {
        function ErrorManagerService() {
            this.messages = {
                'required': 'Required field',
                'minlength': 'Field does not meet minimum length',
                'maxlength': 'Field does not meet maximum length',
                'customMsg': '%s',
                'metavalid': '%s'
            };
        }
        /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
        ErrorManagerService.prototype.errorMessage = /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
            function (validatorName, validatorValue) {
                var /** @type {?} */ message = this.messages[validatorName];
                if (core$1.StringWrapper.contains(message, '%s')) {
                    // todo: use ng-translate with proper message formatting
                    return core$1.StringWrapper.replace(message, '%s', validatorValue.msg);
                }
                return message;
            };
        ErrorManagerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ErrorManagerService.ctorParameters = function () { return []; };
        return ErrorManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
     * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
     *
     *
     *
     */
    var ErrorMessagesComponent = (function () {
        function ErrorMessagesComponent(errManager) {
            this.errManager = errManager;
        }
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.hasMessage = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ msg = this.errorMsg;
                return core$1.isPresent(msg);
            };
        Object.defineProperty(ErrorMessagesComponent.prototype, "errorMsg", {
            /**
             * Retrieve a messages if any registered by added validators
             *
             */
            get: /**
             * Retrieve a messages if any registered by added validators
             *
             * @return {?}
             */ function () {
                for (var /** @type {?} */ propertyName in this.control.errors) {
                    if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                        return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         */
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
        ErrorMessagesComponent.prototype.showErrors = /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
            function () {
                return !this.control.valid && !this.control.pristine && this.control.touched;
            };
        ErrorMessagesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'a-error-messages',
                        template: "\n            <div class=\"ui-g\">\n                    <small *ngIf=\"hasMessage()\"\n                        class=\"ui-g-12 ui-message ui-messages-error ui-corner-all\">\n                        {{ errorMsg }}\n                    </small>\n            </div>\n    ",
                        styles: [""]
                    },] },
        ];
        /** @nocollapse */
        ErrorMessagesComponent.ctorParameters = function () {
            return [
                { type: ErrorManagerService }
            ];
        };
        ErrorMessagesComponent.propDecorators = {
            control: [{ type: core.Input }]
        };
        return ErrorMessagesComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
     * The service also keeps track of the created modal dialog and can close it by calling the
     * service's close()
     *
     * Modal service requires a ViewContainer to insert newly created modals. This is taken care
     * by the ModalComponent.
     *
     * Usage:
     *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
     *     page where a modal dialog will appear.
     *
     *    1.  Popup a dialog without creating your own component.
     *        Use the existing DialogComponent in widgets.
     *
     *             this.modalService.open<DialogComponent>(DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Creating your own Dialog Component to popup.
     *
     *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
     * {inputs});
     *
     * \@Component({
     *                selector: 'aw-mydialog' ,
     *                           template: `
     *                                         <aw-dialog (onClose)="closePopup()">
     *                                              <ng-template #titleTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Title </span>
     *                                              </ng-template>
     *                                              <ng-template #bodyTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Body </span>
     *                                              </ng-template>
     *                                        </aw-dialog>
     *                                     `
     *         })
     *         export class MyDialogComponent extends DialogComponent implements OnInit {
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     closePopup() {
     *                            this.modalService.close();
     *                      }
     *         }
     */
    var ModalService = (function () {
        /**
         * DI ComponentFactoryResolver to be used to create modal component.
         *
         * @param cfr
         */
        function ModalService(cfr) {
            this.cfr = cfr;
        }
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param vcRef
         */
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
        ModalService.prototype.registerViewContainerRef = /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
            function (vcRef) {
                this.vcRef = vcRef;
            };
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         */
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
        ModalService.prototype.open = /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
            function (component, parameters) {
                var /** @type {?} */ cf = this.cfr.resolveComponentFactory(component);
                var /** @type {?} */ componentRef = this.vcRef.createComponent(cf);
                // Auto set visiblity to true. So that the Dialog will display
                parameters = (parameters) ? parameters : {};
                parameters['visible'] = true;
                // Handle output parameters.
                ModalService.OUTPUT_PARAMETERS.forEach(function (param) {
                    if (parameters[param]) {
                        ((componentRef.instance))[param].subscribe(parameters[param]);
                        delete parameters[param];
                    }
                });
                Object.assign(componentRef.instance, parameters);
                // had to cast it in order to avoid any index Error
                // Attach a destroy method to the newly created component.
                ((componentRef.instance))['destroy'] = function () {
                    componentRef.destroy();
                };
                // Save the instance, so it can be destroyed later.
                this.instance = componentRef;
                return componentRef;
            };
        /**
         * Calling close() will remove the modal from view.
         */
        /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
        ModalService.prototype.close = /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
            function () {
                if (this.instance) {
                    this.instance.destroy();
                    this.instance = null;
                }
            };
        /**
         * This is a static list of output parameter from Dialog, Confirmation components
         * that needs to be handled.
         *
         */
        ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
        ModalService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ModalService.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver }
            ];
        };
        return ModalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Place holder for all modal dialogs. This component works with the modalService by providing
     * a place holder for it to inject Dialog component into.
     */
    var ModalComponent = (function () {
        function ModalComponent(modalService) {
            this.modalService = modalService;
        }
        /**
         * @return {?}
         */
        ModalComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.modalService.registerViewContainerRef(this.viewContainerRef);
            };
        ModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-modal',
                        template: "<div #modal></div>\n",
                        styles: [""]
                    },] },
        ];
        /** @nocollapse */
        ModalComponent.ctorParameters = function () {
            return [
                { type: ModalService }
            ];
        };
        ModalComponent.propDecorators = {
            viewContainerRef: [{ type: core.ViewChild, args: ['modal', { read: core.ViewContainerRef },] }]
        };
        return ModalComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This currency formatter will ignore null and empty string for value.
     * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
     */
    var CurrencyFormatPipe = (function () {
        function CurrencyFormatPipe(currencyPipe) {
            this.currencyPipe = currencyPipe;
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        CurrencyFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                // Default values
                var /** @type {?} */ currencyCode = 'USD', /** @type {?} */ symbolDisplay = true, /** @type {?} */ digits = '1.0-2';
                if (!value || value.length === 0) {
                    return value;
                }
                if (args && args.length > 0) {
                    var /** @type {?} */ code = args[0];
                    if (code && code.length > 0) {
                        currencyCode = code;
                    }
                }
                return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
            };
        CurrencyFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'currencyFormat',
                        pure: false
                    },] },
        ];
        /** @nocollapse */
        CurrencyFormatPipe.ctorParameters = function () {
            return [
                { type: common.CurrencyPipe }
            ];
        };
        return CurrencyFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple utility directive that is used by NG For cycle in situation where we need to call a
     * or execute some logic after each iteration
     */
    var NgForSetDirective = (function () {
        function NgForSetDirective() {
            this.onItem = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        NgForSetDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.onItem.emit('--');
            };
        NgForSetDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngForSet]'
                    },] },
        ];
        /** @nocollapse */
        NgForSetDirective.ctorParameters = function () { return []; };
        NgForSetDirective.propDecorators = {
            onItem: [{ type: core.Output }]
        };
        return NgForSetDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
     * or traversal should be put into this service
     *
     */
    var DomUtilsService = (function () {
        function DomUtilsService() {
        }
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         */
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.hasParent = /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                return core$1.isPresent(this.closest(nativeElement, selector));
            };
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         */
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.closest = /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                var /** @type {?} */ firstChar = selector.charAt(0);
                var /** @type {?} */ parentNode = nativeElement;
                while (core$1.isPresent((parentNode = parentNode.parentNode))) {
                    if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                        return parentNode;
                    }
                    if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                        return parentNode;
                    }
                    // If selector is a tag
                    if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                        return parentNode;
                    }
                    if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                        return null;
                    }
                }
                return null;
            };
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         */
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
        DomUtilsService.prototype.insertIntoParentNgContent = /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
            function (parentNativeEl, childNativeEl) {
                // default behavior is to insert it as child to parentNativeEl
                var /** @type {?} */ ngContentParent = parentNativeEl;
                var /** @type {?} */ foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
                if (core$1.isPresent(foundNgContent)) {
                    // we don't cover a case where there could be multiple ngcontents
                    ngContentParent = foundNgContent;
                }
                ngContentParent.appendChild(childNativeEl);
            };
        /**
         *
         * Retrieves current browser window width and height
         *
         */
        /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
        DomUtilsService.prototype.browserDimentions = /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
            function () {
                return {
                    width: (window.innerWidth || document.documentElement.clientWidth
                        || document.body.clientWidth),
                    height: (window.innerHeight || document.documentElement.clientHeight
                        || document.body.clientHeight)
                };
            };
        /**
         *
         * Retrieves elemements dimensions
         *
         */
        /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
        DomUtilsService.prototype.elementDimensions = /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                if (core$1.isPresent(element.getBoundingClientRect)) {
                    return element.getBoundingClientRect();
                }
                return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
            };
        DomUtilsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DomUtilsService.ctorParameters = function () { return []; };
        return DomUtilsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The Infinite Scroll allows you to perform an action when the user
     * scrolls a specified distance from the bottom or top of the page.
     *
     * The expression assigned to the `infinite` event is called when
     * the user scrolls to the specified distance. When this expression
     * has finished its tasks, it should call the `complete()` method
     * on the infinite scroll instance.
     *
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
     *  </aw-infinite-scroll>
     *
     * ```
     *
     *
     * You can also set a threshold to change the distance when the lazy load kicks
     * in.
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
     *  </aw-infinite-scroll>
     *
     * ```
     */
    var InfiniteScrollComponent = (function () {
        function InfiniteScrollComponent(_render, _zone, domUtils, _cd) {
            this._render = _render;
            this._zone = _zone;
            this.domUtils = domUtils;
            this._cd = _cd;
            this._lastCheck = 0;
            this._lastScrollTop = 0;
            this._thr = '10%';
            this._thrPx = 0;
            this._thrPc = 0.10;
            this._init = false;
            /**
             * \@internal
             */
            this.state = STATE_ENABLED;
            /**
             * \@output {event} Emitted when the scroll reaches
             * the threshold distance. From within your infinite handler,
             * you must call the infinite scroll's `complete()` method when
             * your async operation has completed.
             */
            this.onLoad = new core.EventEmitter();
            /**
             *
             * Lazy load current numbers. tell the app starting point and what is the size of loaded
             * list
             *
             */
            this.fetchSize = 0;
            this.loadOffset = 0;
        }
        Object.defineProperty(InfiniteScrollComponent.prototype, "distance", {
            /**
             * @input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             */
            get: /**
             * \@input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             * @return {?}
             */ function () {
                return this._thr;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._thr = val;
                if (val.indexOf('%') > -1) {
                    this._thrPx = 0;
                    this._thrPc = (parseFloat(val) / 100);
                }
                else {
                    this._thrPx = parseFloat(val);
                    this._thrPc = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollComponent.prototype, "enabled", {
            /**
             * @input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             */
            set: /**
             * \@input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             * @param {?} shouldEnable
             * @return {?}
             */ function (shouldEnable) {
                this.enable(shouldEnable);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._render.addClass(document.body, 'has-infinite-scroll');
            };
        /**
         * @param {?} ev
         * @return {?}
         */
        InfiniteScrollComponent.prototype._onScroll = /**
         * @param {?} ev
         * @return {?}
         */
            function (ev) {
                if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
                    return;
                }
                // must throttle the class by 100ms
                if (this._lastCheck + 100 > ev.timeStamp) {
                    // no need to check less than every XXms
                    return;
                }
                this._lastCheck = ev.timeStamp;
                var /** @type {?} */ scrollTop = this.scrollTop();
                var /** @type {?} */ winHeight = this.domUtils.browserDimentions().height;
                var /** @type {?} */ height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
                if (!height) {
                    // if there is no height of this element then do nothing
                    return;
                }
                var /** @type {?} */ threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
                var /** @type {?} */ distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
                // console.log('Document height (' + height + ') , Distance from bottom '
                // + distanceFromInfinite + ',  => threshold = ' +
                //     this.distance + ' (' + threshold + ')');
                if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
                    this.fireOnLazyLoad();
                }
                else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
                    && this.loadOffset !== this.fetchSize) {
                    this.fireOnLazyUnLoad();
                }
                this._lastScrollTop = scrollTop;
                return;
            };
        /**
         * Todo: refactor to one method
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyLoad = /**
         * Todo: refactor to one method
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        _this.onLoad.emit({
                            isLoad: true,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                        // start on the next record
                        // start on the next record
                        _this.loadOffset += _this.fetchSize;
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyUnLoad = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        // start on the next record
                        // start on the next record
                        _this.loadOffset = _this.fetchSize;
                        _this.onLoad.emit({
                            isLoad: false,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.scrollTop = /**
         * @return {?}
         */
            function () {
                return (window.pageYOffset || this._content.scrollTop);
            };
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         */
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.complete = /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state !== STATE_LOADING) {
                    return;
                }
                setTimeout(function () {
                    _this.state = STATE_ENABLED;
                    // need to trigger extra detect changes to rerender loading icon
                    // need to trigger extra detect changes to rerender loading icon
                    _this._cd.detectChanges();
                }, 100);
            };
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         */
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.enable = /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
            function (shouldEnable) {
                this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
                this._setListeners(shouldEnable);
            };
        /**
         * Subscribes to native windows scroll event
         */
        /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
        InfiniteScrollComponent.prototype._setListeners = /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
            function (shouldListen) {
                var _this = this;
                if (this._init) {
                    if (shouldListen) {
                        if (!this._scLsn) {
                            this._zone.runOutsideAngular(function () {
                                _this._scLsn = _this._onScroll.bind(_this);
                                window.addEventListener('scroll', _this._scLsn);
                            });
                        }
                    }
                    else {
                        if (core$1.isPresent(this._scLsn)) {
                            window.removeEventListener('scroll', this._scLsn);
                            this._scLsn = null;
                        }
                    }
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.isLoading = /**
         * @return {?}
         */
            function () {
                return this.state === STATE_LOADING;
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._init = true;
                this._docBody = document.body;
                this._content = document.documentElement;
                this._setListeners(this.state !== STATE_DISABLED);
                if (this.loadOffset === 0) {
                    this.fireOnLazyLoad();
                }
            };
        /**
         * @hidden
         */
        /**
         * @hidden
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnDestroy = /**
         * @hidden
         * @return {?}
         */
            function () {
                this._setListeners(false);
            };
        InfiniteScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-infinite-scroll',
                        template: "<div class=\"w-infinite-loader-panel\" *ngIf=\"isLoading()\">\n    <span class=\"sap-icon icon-synchronize u-spin-icon\"></span>\n</div>\n",
                        styles: [".w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}"],
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.NgZone },
                { type: DomUtilsService },
                { type: core.ChangeDetectorRef }
            ];
        };
        InfiniteScrollComponent.propDecorators = {
            distance: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            onLoad: [{ type: core.Output }],
            loadPanel: [{ type: core.ViewChild, args: ['loadinPanel',] }],
            fetchSize: [{ type: core.Input }]
        };
        return InfiniteScrollComponent;
    }());
    var /** @type {?} */ STATE_ENABLED = 'enabled';
    var /** @type {?} */ STATE_DISABLED = 'disabled';
    var /** @type {?} */ STATE_LOADING = 'loading';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AwNameStore = (function () {
        function AwNameStore() {
            this.store = new Map();
        }
        /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
        AwNameStore.prototype.add = /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
            function (name, el) {
                if (this.collides(name)) {
                    throw new Error('Name is not unique!');
                }
                return this.store.set(name, el);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.remove = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.delete(name);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.collides = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.has(name);
            };
        /**
         * @return {?}
         */
        AwNameStore.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.store.clear();
            };
        AwNameStore.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AwNameStore.ctorParameters = function () { return []; };
        return AwNameStore;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
     * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
     * and inherant immutable element attributes.
     *
     * **Generating the Base Name**
     *
     * The 'awName' directive generates a base name from element tag name and attributes which are
     * static by nature.
     *
     *     Example:
     *         <button name="order" awName>
     *
     *     Result:
     *         <button name="order" awname="button_order">
     *
     * If the element has an 'id', that value takes precedent and is used instead of a generated
     * name.
     *
     *     Example:
     *         <button name="order" id="myOrderButton" awName>
     *
     *     Result:
     *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
     *
     *
     * **Repeated Elements and the 'ext' Parameter**
     *
     * There are many cases where elements are generated dynamically in the code as lists or tables.
     * In such cases, it may not be easy to distinguish individual elements by standard HTML
     * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
     * using the 'ext' attribute.
     *
     *    Example:
     *        fruits = ['apple', 'banana', 'orange'];
     *
     *        <ul>
     *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
     *        </ul>
     *
     *   Result:
     *       <ul>
     *           <li awname="li_apple">apple</li>
     *           <li awname="li_banana">banana</li>
     *           <li awname="li_orane">orange</li>
     *       </ul>
     *
     * **Adding Context Through Ancestor Inspection**
     *
     * In order to provide context to the element naming, the 'awName' directive loops through the
     * parent ancestry and searches for any unique element 'id' to prepend to the base name.
     *
     *     Example:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *
     *     Result:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awname="applicant_input_firstName">
     *            <input type="text" name="lastName" awname="applicant_input_lastName">
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awname="spouse_input_firstName">
     *            <input type="text" name="lastName" awname="spouse_input_lastname">
     *         </form>
     *
     * **Uniqueness Check**
     *
     * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
     * creates a new name during the `ngOnInit` phase it checks it against the existing map,
     * and will throw an error if it encounters a duplicate. Moreover during the element destruction
     * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
     *
     *
     * **In Production**
     *
     * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
     * a production environment, 'awName' serves no functionality to the end user, but may have
     * a performance impact on the application. As such, 'awName' takes into account the
     * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
     * is `true`.
     *
     * In your application, you can turn on production mode by setting `devmode.enabled` to
     * `false` when configuring `AribaCoreModule`:
     *
     *     AribaCoreModule.forRoot({
     *         'devmode.enabled': false
     *     })
     *
     */
    var AwNameDirective = (function () {
        function AwNameDirective(el, store, config) {
            this.el = el;
            this.store = store;
            this.config = config;
            this.separator = '_';
        }
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.config.isProductionMode()) {
                    this.name = this.createName(this.el);
                    this.addElementToStore(this.name, this.el);
                    this.el.nativeElement.setAttribute('awname', this.name);
                }
            };
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.store.remove(this.name);
            };
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         */
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
        AwNameDirective.prototype.addElementToStore = /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
            function (name, elem) {
                try {
                    this.store.add(name, elem);
                }
                catch (e) {
                    console.error(e.message + (". \"" + name + "\" is already in use."), elem.nativeElement);
                    return;
                }
            };
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @return String Name/ID
         */
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
        AwNameDirective.prototype.createName = /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
            function (elem) {
                var /** @type {?} */ tagName = this.getTagName(elem);
                // Initialize array of string parts
                var /** @type {?} */ parts = [];
                // Find ancestor tag id, if there is one
                var /** @type {?} */ parentID = this.getAncestorId(elem);
                if (parentID) {
                    parts.push(parentID);
                }
                // Check the tag type
                if (tagName === 'option') {
                    var /** @type {?} */ parentName = this.getParentName(elem);
                    if (parentName) {
                        parts.push(parentName);
                    }
                }
                // Get tagname
                parts.push(tagName);
                // Choose id property if it exists
                if (elem.nativeElement.id) {
                    parts.push(elem.nativeElement.id);
                    // Otherwise build extension from tag properties
                }
                else {
                    // check for a name attribute
                    if (elem.nativeElement.hasAttribute('name')) {
                        parts.push(elem.nativeElement.name);
                    }
                    // check for value attribute if 'option' tag
                    if (tagName === 'option') {
                        if (elem.nativeElement.hasAttribute('value')) {
                            parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                        }
                    }
                }
                // Add custom extension if it exists
                if (this.ext) {
                    parts.push(this.spacesToUnderscore(this.ext));
                }
                return parts.join(this.separator);
            };
        /**
         * Get tag name from element reference.
         * @param elem Reference to element
         */
        /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getTagName = /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                return elem.nativeElement.tagName.toLowerCase();
            };
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param elem Reference to element
         */
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getAncestorId = /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                var /** @type {?} */ parent = elem.nativeElement.parentNode;
                var /** @type {?} */ id = '';
                while (parent && !id) {
                    if (parent.id) {
                        id = parent.id;
                    }
                    parent = parent.parentNode;
                }
                return id;
            };
        /**
         * Get name attribute from parent if name attribute exists.
         * @param elem Reference to element
         */
        /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getParentName = /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                var /** @type {?} */ parent = elem.nativeElement.parentNode;
                return (parent.name && !parent.id) ? parent.name : null;
            };
        /**
         * @param {?} str
         * @return {?}
         */
        AwNameDirective.prototype.spacesToUnderscore = /**
         * @param {?} str
         * @return {?}
         */
            function (str) {
                return str.replace(/\s+/g, '_');
            };
        AwNameDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[awName]',
                    },] },
        ];
        /** @nocollapse */
        AwNameDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: AwNameStore },
                { type: core$1.AppConfig }
            ];
        };
        AwNameDirective.propDecorators = {
            ext: [{ type: core.Input }]
        };
        return AwNameDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCoreComponentModule = (function () {
        function AWCoreComponentModule() {
        }
        AWCoreComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            GenericContainerComponent,
                            ModalComponent
                        ],
                        exports: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ]
                    },] },
        ];
        return AWCoreComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */
    var /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */ ModalContainer = (function (_super) {
        __extends(ModalContainer, _super);
        function ModalContainer(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Override function.
             */
            _this.destroy = core$1.noop;
            return _this;
        }
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         */
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
        ModalContainer.prototype.closeModal = /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
            function () {
                this.destroy();
            };
        return ModalContainer;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DataTypeProviderRegistry aggregates different DataProviders per type.
     */
    var DataTypeProviderRegistry = (function () {
        function DataTypeProviderRegistry() {
            this.registryByProvider = new Map();
            this.registryNameToClass = new Map();
        }
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         */
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.registerProvider = /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                if (core$1.isBlank(target) || (!core$1.isStringMap(target) && !core$1.isType(target))) {
                    throw new Error(' Cannot register non-object');
                }
                var /** @type {?} */ name = core$1.isType(target) ? target.prototype.constructor.name : target.constructor.name;
                this.registryByProvider.set(name, provider);
                var /** @type {?} */ prototype = Object.getPrototypeOf(target);
                this.registryNameToClass.set(name, prototype);
            };
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         */
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForClass = /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
            function (className) {
                var /** @type {?} */ registeredClassName = className;
                var /** @type {?} */ classProto = this.registryNameToClass.get(className);
                while (core$1.isPresent(registeredClassName)) {
                    var /** @type {?} */ provider = this.registryByProvider.get(registeredClassName);
                    if (core$1.isPresent(provider)) {
                        provider.type = className;
                        return provider;
                    }
                    // Go up to parent
                    if (core$1.isPresent(classProto)) {
                        classProto = Object.getPrototypeOf(classProto);
                        var /** @type {?} */ parentName = core$1.objectToName(classProto);
                        registeredClassName =
                            (core$1.isPresent(parentName) && parentName !== registeredClassName) ? parentName
                                : null;
                    }
                    else {
                        return null;
                    }
                }
                return null;
            };
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         */
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForType = /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
            function (type) {
                var /** @type {?} */ name = core$1.objectToName(type);
                this.registryNameToClass.set(name, type);
                return this.bestMatchForClass(name);
            };
        DataTypeProviderRegistry.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataTypeProviderRegistry.ctorParameters = function () { return []; };
        return DataTypeProviderRegistry;
    }());
    /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */
    var /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */ DataProvider = (function () {
        function DataProvider() {
            /**
             * Notifies all the listeners in case of data are available or if they changed due to some user
             * interaction  (search, adding or removing).
             *
             */
            this.dataChanges = new rxjs.BehaviorSubject([]);
        }
        /**
         *  Return size of the source
         *
         */
        /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
        DataProvider.prototype.expectedCount = /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return -1;
            };
        /**
         *
         * Returns non-async current state of data
         */
        /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
        DataProvider.prototype.data = /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
            function () {
                return this.dataChanges.getValue();
            };
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         */
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
        DataProvider.prototype.canCRUD = /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Tells if this DataProvider supports query capability
         *
         */
        /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
        DataProvider.prototype.canQuery = /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         */
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.insert = /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         */
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.remove = /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to provide access to low level searcg API.
         *
         */
        /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
        DataProvider.prototype.query = /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
            function (params) {
            };
        return DataProvider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Default implementation for Arrays.
     * @template T
     */
    var /**
     * Default implementation for Arrays.
     * @template T
     */ ArrayDataProvider = (function (_super) {
        __extends(ArrayDataProvider, _super);
        function ArrayDataProvider(values) {
            var _this = _super.call(this) || this;
            _this.values = values;
            _this.type = Array;
            _this.offScreenData = _this.values;
            _this.dataChanges.next(_this.values);
            return _this;
        }
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.expectedCount = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return this.offScreenData.length;
            };
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.dataForParams = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                if (core$1.isBlank(params)) {
                    return this.offScreenData;
                }
                var /** @type {?} */ data = this.offScreenData;
                if (core$1.isPresent(params) && params.has('offset') && params.has('limit')) {
                    var /** @type {?} */ offset = params.get('offset');
                    var /** @type {?} */ limit = params.get('limit');
                    if (data.length > (offset + limit)) {
                        data = data.slice(offset, offset + limit);
                    }
                    else {
                        data = data.slice(offset, data.length);
                    }
                }
                if (params.has('orderby') && params.has('selector')) {
                    this.sort(data, params.get('orderby'), params.get('selector'));
                }
                return data;
            };
        /**
         * @param {?} params
         * @return {?}
         */
        ArrayDataProvider.prototype.fetch = /**
         * @param {?} params
         * @return {?}
         */
            function (params) {
                return rxjs.of(this.dataForParams(params));
            };
        /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        ArrayDataProvider.prototype.sort = /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (arrayToSort, key, sortOrder) {
                arrayToSort.sort(function (data1, data2) {
                    var /** @type {?} */ value1 = core$1.FieldPath.getFieldValue(data1, key);
                    var /** @type {?} */ value2 = core$1.FieldPath.getFieldValue(data2, key);
                    var /** @type {?} */ result = null;
                    if (value1 == null && value2 != null) {
                        result = -1;
                    }
                    else if (value1 != null && value2 == null) {
                        result = 1;
                    }
                    else if (value1 == null && value2 == null) {
                        result = 0;
                    }
                    else if (typeof value1 === 'string' && typeof value2 === 'string') {
                        result = value1.localeCompare(value2);
                    }
                    else {
                        result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                    }
                    return (sortOrder * result);
                });
            };
        return ArrayDataProvider;
    }(DataProvider));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
     * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
     * provider or instantiate our implicit provider for native types such as Array.
     *
     *
     */
    var DataProviders = (function () {
        function DataProviders(registry) {
            this.registry = registry;
        }
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         */
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
        DataProviders.prototype.find = /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (core$1.isArray(target)) {
                    return new ArrayDataProvider(target);
                }
                else if (core$1.isString(target)) {
                    return this.registry.bestMatchForClass(target);
                }
                return this.registry.bestMatchForType(target);
            };
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         */
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataProviders.prototype.register = /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                this.registry.registerProvider(target, provider);
            };
        DataProviders.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataProviders.ctorParameters = function () {
            return [
                { type: DataTypeProviderRegistry }
            ];
        };
        return DataProviders;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Provides a registry of different data Finders used mostly by DataSources. All Finders are
     * registered by this class as we don't have any needs right now to expose this to developer.
     *
     */
    var DataFinders = (function () {
        function DataFinders() {
            this.findersByType = new Map();
            this.initFinders();
        }
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         */
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
        DataFinders.prototype.find = /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
            function (forProvider, forType) {
                var /** @type {?} */ finderMatch;
                this.findersByType.forEach(function (v, k) {
                    if (k.accepts(forProvider, forType)) {
                        finderMatch = v;
                        return true;
                    }
                });
                if (core$1.isPresent(finderMatch)) {
                    var /** @type {?} */ copy = new finderMatch();
                    copy.forData(forProvider);
                    return copy;
                }
                return null;
            };
        /**
         * Registers new finder
         *
         */
        /**
         * Registers new finder
         *
         * @template T
         * @param {?} prototype
         * @param {?} type
         * @return {?}
         */
        DataFinders.prototype.register = /**
         * Registers new finder
         *
         * @template T
         * @param {?} prototype
         * @param {?} type
         * @return {?}
         */
            function (prototype, type) {
                this.findersByType.set(prototype, type);
            };
        /**
         * @return {?}
         */
        DataFinders.prototype.initFinders = /**
         * @return {?}
         */
            function () {
                // create a prototype for each
                this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
                this.findersByType.set(new OutlineFullTextArrayDataFinder(), OutlineFullTextArrayDataFinder);
            };
        DataFinders.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataFinders.ctorParameters = function () { return []; };
        return DataFinders;
    }());
    /** @enum {number} */
    var QueryType = {
        FullText: 0,
        FullTextOutline: 1,
        Predicate: 2,
        FullTextAndPredicate: 3,
    };
    QueryType[QueryType.FullText] = "FullText";
    QueryType[QueryType.FullTextOutline] = "FullTextOutline";
    QueryType[QueryType.Predicate] = "Predicate";
    QueryType[QueryType.FullTextAndPredicate] = "FullTextAndPredicate";
    /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */
    var /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */ DataFinder = (function () {
        function DataFinder() {
        }
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         */
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        DataFinder.prototype.accepts = /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return false;
            };
        /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         */
        /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
        DataFinder.prototype.match = /**
         *
         * Query can be a simple string literal or a map having different key value pair as a
         * filter
         *
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
            function (query, max) {
                if (max === void 0) {
                    max = -1;
                }
                return core$1.unimplemented();
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        DataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return core$1.unimplemented();
            };
        return DataFinder;
    }());
    /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     */
    var /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     */ FullTextArrayDataFinder = (function (_super) {
        __extends(FullTextArrayDataFinder, _super);
        function FullTextArrayDataFinder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(FullTextArrayDataFinder.prototype, "lookupKey", {
            set: /**
             * @param {?} key
             * @return {?}
             */ function (key) {
                this._keyPath = core$1.isPresent(key) ? new core$1.FieldPath(key) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.accepts = /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
            };
        /**
         * @param {?} provider
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.forData = /**
         * @param {?} provider
         * @return {?}
         */
            function (provider) {
                this._provider = provider;
                return this;
            };
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatch = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                var /** @type {?} */ list = this._provider.dataForParams(new Map().set('limit', max));
                return this.instantMatchWithSelections(list, query, max);
            };
        /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selectionsForMatch, query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                if (core$1.isBlank(query)) {
                    return selectionsForMatch;
                }
                var /** @type {?} */ result = [];
                var /** @type {?} */ toLowerPattern = query.toLowerCase();
                for (var /** @type {?} */ i = 0; i < selectionsForMatch.length; i++) {
                    var /** @type {?} */ item = selectionsForMatch[i];
                    if (this.matches(item, toLowerPattern)) {
                        result.push(item);
                        if (result.length >= max) {
                            break;
                        }
                    }
                }
                return result;
            };
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         */
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matches = /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
            function (item, pattern) {
                var /** @type {?} */ val = (core$1.isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
                if (core$1.isFunction(val)) {
                    val = val.call(item);
                }
                else if (core$1.isJsObject(item)) {
                    return this.hasObjectValue(item, pattern);
                }
                else {
                    return core$1.isBlank(pattern) ||
                        core$1.isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
                }
            };
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.match = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                return rxjs.of(this.instantMatch(query, max));
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return rxjs.of(this.instantMatchWithSelections(selections, query, max));
            };
        /**
         * @param {?} obj
         * @param {?} pattern
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.hasObjectValue = /**
         * @param {?} obj
         * @param {?} pattern
         * @return {?}
         */
            function (obj, pattern) {
                var _this = this;
                var /** @type {?} */ values = core$1.objectValues(obj);
                var /** @type {?} */ parentObj = core$1.objectToName(obj);
                var /** @type {?} */ length2 = values.filter(function (value) {
                    if (core$1.isBlank(value) || core$1.isArray(value)) {
                        return false;
                    }
                    else if (!core$1.isJsObject(value) && !core$1.isFunction(value)) {
                        return value.toString().toLowerCase().indexOf(pattern) !== -1;
                    }
                    else if (core$1.isJsObject(value) && core$1.objectToName(value) !== parentObj) {
                        return _this.hasObjectValue(value, pattern);
                    }
                    return false;
                }).length;
                return length2 > 0;
            };
        return FullTextArrayDataFinder;
    }(DataFinder));
    /**
     * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
     * children on lowest level and moving up to the root and marking nodes that can be removed.
     *
     *  For simple data structure which operates on local array this should be good enough we this
     *  can never match with real DB full text search.
     *
     */
    var /**
     * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
     * children on lowest level and moving up to the root and marking nodes that can be removed.
     *
     *  For simple data structure which operates on local array this should be good enough we this
     *  can never match with real DB full text search.
     *
     */ OutlineFullTextArrayDataFinder = (function (_super) {
        __extends(OutlineFullTextArrayDataFinder, _super);
        function OutlineFullTextArrayDataFinder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.accepts = /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return forData instanceof ArrayDataProvider && forType === QueryType.FullTextOutline;
            };
        /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
         * @template T
         * @param {?} selectionsForMatch
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selectionsForMatch, query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                if (core$1.isBlank(query)) {
                    return selectionsForMatch;
                }
                var /** @type {?} */ toLowerPattern = query.toLowerCase();
                var /** @type {?} */ sourceToSearch = selectionsForMatch.slice();
                this.rollup(sourceToSearch, toLowerPattern);
                return this.shake(sourceToSearch);
            };
        /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         */
        /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         * @param {?} nodes
         * @param {?} query
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.rollup = /**
         *
         * Going thru the tree from bottom up and mark all that matches query
         *
         * @param {?} nodes
         * @param {?} query
         * @return {?}
         */
            function (nodes, query) {
                var _this = this;
                nodes.forEach(function (item) {
                    // start from bottom up and capture how many occurrences is found for future use
                    var /** @type {?} */ hasChildrenMatch = false;
                    if (core$1.isPresent(item.children) && item.children.length > 0) {
                        hasChildrenMatch = _this.rollup(item.children, query);
                    }
                    item.visible = hasChildrenMatch || _this.matches(item, query);
                });
                return nodes.some(function (item) { return item.visible; });
            };
        /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         */
        /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         * @param {?} nodes
         * @return {?}
         */
        OutlineFullTextArrayDataFinder.prototype.shake = /**
         * Filter out all the nodes that are marked as visible = false and make sure and
         * don't modify original list
         *
         * @param {?} nodes
         * @return {?}
         */
            function (nodes) {
                var _this = this;
                return nodes
                    .filter(function (node) { return node.visible; })
                    .map(function (node) { return (__assign({}, node, { isExpanded: node.visible, children: node.children && _this.shake(node.children) })); });
            };
        return OutlineFullTextArrayDataFinder;
    }(FullTextArrayDataFinder));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DATA_SOURCE = new core.InjectionToken('DATA_SOURCE');
    /**
     * DataSource describes basic functionality for handling stream of data specific to component
     *
     * It is expected that DataSource will be defined as component provider using
     *
     * \@Components ({
     *      ...
     *      providers:[
     *
     *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
     * deps: [DataProviders, DataFinders]
     *      ]
     *
     * })
     *
     *
     * so all the dependencies (DataProviders, DataFinders) are properly injected.
     *
     * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
     * Or you can use instant() method to retrieve current state of this DataSource (sync)
     *
     * @abstract
     */
    var DataSource = (function () {
        /**
         *
         * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
         * implementation
         *
         */
        function DataSource(dataProviders, finders) {
            this.dataProviders = dataProviders;
            this.finders = finders;
        }
        /**
         * Returns a data instantly from the internal state of DataProvider
         */
        /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
        DataSource.prototype.instant = /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        DataSource.MaxLength = 10;
        DataSource.MaxRecentSelected = 5;
        return DataSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var TopZoneComponent = (function () {
        function TopZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad ';
        }
        TopZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-top',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        TopZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return TopZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var LeftZoneComponent = (function () {
        function LeftZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        LeftZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-left',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        LeftZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return LeftZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var MiddleZoneComponent = (function () {
        function MiddleZoneComponent() {
            this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
        }
        MiddleZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-middle',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        MiddleZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return MiddleZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var RightZoneComponent = (function () {
        function RightZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        RightZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-right',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        RightZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return RightZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var BottomZoneComponent = (function () {
        function BottomZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        BottomZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-bottom',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        BottomZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return BottomZoneComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
     * include actual component such is DropDown or InputField but mainly provides a enough context for
     * the component to specify the size, how it should layout, whether we need to show required flag,
     * to show/hide labels in case if we have no label layout and much more.
     *
     * FormRow component also registers angular validator for the current row/field. As already
     * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
     * information to/from user and let somebody else to figure out where it appear and how.
     *
     * todo: Move under FormTable
     */
    var FormRowComponent = (function (_super) {
        __extends(FormRowComponent, _super);
        function FormRowComponent(env, 
        // Event this creates CI depends. Need to have a reference to parent
        // I need to refactor more parent to not use this child and refactor layouting
        parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Hides the label
             *
             */
            _this.noLabelLayout = false;
            /**
             * Renders row with highlighted background
             *
             */
            _this.highlightRow = false;
            /**
             *
             *  Field label that should appear above or next to the control
             *
             */
            _this.label = '';
            /**
             *
             * For single column layout without zones we need to apply grid directly to the FormRow tag
             * so we don't need to introduce extra div level
             *
             */
            _this.classList = '';
            _this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
            return _this;
        }
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         */
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
        FormRowComponent.prototype.ngOnInit = /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, null);
                this.registerValidators();
                this.omitPadding = this.parentContainer.omitPadding;
                this.classList += core$1.isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
                this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
                this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
            };
        Object.defineProperty(FormRowComponent.prototype, "size", {
            /**
             * Just a size getter
             *
             */
            get: /**
             * Just a size getter
             *
             * @return {?}
             */ function () {
                return this._size;
            },
            /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             */
            set: /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var /** @type {?} */ isDynVal = false;
                if (core$1.StringWrapper.startsWidth(value, 'd-')) {
                    isDynVal = true;
                    value = value.substr(2, value.length - 1);
                }
                if (core$1.isPresent(value)) {
                    this._size = value;
                    var /** @type {?} */ dSize = this.dynSize(value, isDynVal);
                    this._size = 'ui-g-12 ui-md-' + dSize;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FormRowComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
                if (core$1.isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
                    this.editable = this.parentContainer.editable;
                }
            };
        /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
        FormRowComponent.prototype.registerValidators = /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
            function () {
                var /** @type {?} */ validators = [];
                if (core$1.isPresent(this.maxLength)) {
                    validators.push(forms.Validators.maxLength(this.maxLength));
                }
                if (core$1.isPresent(this.minLength)) {
                    validators.push(forms.Validators.minLength(this.minLength));
                }
                if (core$1.isPresent(this.required) && this.required) {
                    validators.push(forms.Validators.required);
                }
                if (core$1.isPresent(this.pattern)) {
                    validators.push(forms.Validators.pattern(this.pattern));
                }
                if (core$1.isPresent(this.customValidators)) {
                    core$1.ListWrapper.addAll(validators, this.customValidators);
                }
                if (validators.length === 1) {
                    this.formControl.setValidators(validators[0]);
                }
                else if (validators.length > 1) {
                    this.formControl.setValidators(forms.Validators.compose(validators));
                }
                if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
                    this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
                }
                else if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
                    this.formControl.setAsyncValidators(forms.Validators.composeAsync(this.customAsyncValidators));
                }
            };
        Object.defineProperty(FormRowComponent.prototype, "labelsOnTop", {
            /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             */
            get: /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._labelsOnTop) && core$1.isPresent(this.parentContainer)) {
                    return ((this.parentContainer)).isLabelsOnTop();
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
        FormRowComponent.prototype.dynSize = /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
            function (value, isDynValue) {
                var /** @type {?} */ normalizeSize = value.toLowerCase().replace('-', '');
                if (core$1.isPresent(this.parentContainer) &&
                    ((this.parentContainer)).hasTwoColumn && isDynValue) {
                    var /** @type {?} */ enumValues = Object.keys(WidgetSizeColumns);
                    normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
                }
                return ((WidgetSizeColumns))[normalizeSize];
            };
        FormRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-row',
                        template: "<div *ngIf=\"!hidden\"\n     class=\"w-form-row ui-g\"\n     [class.highlight-row]=\"highlightRow\"\n     [class.required]=\"required\"\n     [class.label-on-top]=\"labelsOnTop\"\n     [class.label-on-side]=\"!labelsOnTop\"\n     [class.has-danger]=\"!formControl.valid && !formControl.pristine \"\n     [ngClass]=\"styleClass\">\n\n    <div class=\"control-label ui-g-12 ui-g-nopad\"\n         *ngIf=\"!noLabelLayout\"\n         [class.ui-md-3]=\"!labelsOnTop\">\n        <label [class.sr-only]=\"noLabelLayout\">{{label}}</label>\n    </div>\n\n    <div class=\"control-value ui-g-nopad\" [ngClass]=\"size\"\n         [class.read-only]=\"!editable\">\n        <ng-content></ng-content>\n        <a-error-messages [control]=\"formControl\"></a-error-messages>\n    </div>\n</div>\n",
                        styles: [".required label:after{content:\"*\";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.control-label{color:#636363}.u-validation-error{border-color:red}"],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormRowComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        FormRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: FormTableComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormTableComponent; }),] }] }
            ];
        };
        FormRowComponent.propDecorators = {
            noLabelLayout: [{ type: core.Input }],
            highlightRow: [{ type: core.Input }],
            label: [{ type: core.Input }],
            maxLength: [{ type: core.Input }],
            minLength: [{ type: core.Input }],
            pattern: [{ type: core.Input }],
            customAsyncValidators: [{ type: core.Input }],
            customValidators: [{ type: core.Input }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            size: [{ type: core.Input }]
        };
        return FormRowComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * FormTable is a specific layout component for rendering Labels and its controls in two columns
     * and 5 different zones.
     *
     * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
     * This
     * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
     * fields in the form I do not want controls to be aware of error validation, size, labels, and
     * some other things. Control such INPUT is just responsible for retrieve user value but not how it
     * appear on the page.
     *
     * This way we can be flexible how we treat widgets for different kinds of situation depending
     * where they appear
     * FormTable just like the rest of the components are using Model driven approach how to work with
     * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
     * otherwise its automatically created when the FormTable is instantiated.
     *
     * FormGroup is saved insode Environment where we are using this to pass this around the pages and
     * components.
     *
     * ### Example
     *
     * Simple Layout fields and its control
     *
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: `
     *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
     *  				<aw-form-row [label]="'name'" [name]="'name'">
     *  					<aw-input-field [type]="'string'"></aw-input-field>
     *  				</aw-form-row>
     *
     *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *  					<aw-checkbox-list [list]="checkBoxListValues"
     *  					                 [selections]="selectedValues"
     *  					                 [layout]="'inline'"
     *  					                 (onSelection)="onCBClick($event)">
     *  					</aw-checkbox-list>
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
     *
     *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *
     *  					</aw-radiobutton-list>
     *
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
     *
     *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
     *  					</aw-date-time>
     *  				</aw-form-row>
     *  			</aw-form-table>
     *    `
     *  })
     *  export class ShowUserInfoComponent
     *  {
     *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
     *     , 'black' , 'Green'
     *     , 'Gray' , 'Navy' ,
     *          'Olive' , 'Aqua' , 'Purple'];
     *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *      rbValues: string[] = ['male' , 'female' , 'other'];
     *      rbSelection: string = 'male';
     *      editable: boolean = true;
     *      showTime: boolean = true;
     *
     *      formGroup: FormGroup = new FormGroup({});
     *
     *
     *      onCBClick (event): void
     *      {
     *          console.log('onCBClick = ' + event);
     *      }
     *
     *      onSubmit (model: any): void
     *      {
     *         console.log(model)
     *
     *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
     *     male}
     *      }
     *
     *  }
     *
     *  ```
     *
     *  Or you can use zone to layout these fields into two columns:
     *
     *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
     *     specific pattern. In our case instead of creating extra wrapper custom component use simple
     *     CSS class
     *
     *
     *  ```
     *            <aw-form-table #metaFormTable [editable]="editing"
     *                          [useFiveZone]="isFiveZoneLayout"
     *                          (onSubmit)="onSaveAction($event)">
     *
     *                <aw-left  *ngIf="canShowZone('zLeft')">
     *
     *                        <aw-form-row [label]="'name'" [name]="'name'">
     *                            <aw-input-field [type]="'string'"></aw-input-field>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *                            <aw-checkbox-list [list]="checkBoxListValues"
     *                                             [selections]="selectedValues"
     *                                             [layout]="'inline'"
     *                                             (onSelection)="onCBClick($event)">
     *                            </aw-checkbox-list>
     *                        </aw-form-row>
     *                </aw-left>
     *
     *
     *                <aw-right  *ngIf="canShowZone('zRight')">
     *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
     *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *                                </aw-radiobutton-list>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
     *     [size]="'small'">
     *                            <aw-date-time [value]="date" [editable]="editable"
     *     [showTime]="showTime">
     *                            </aw-date-time>
     *                        </aw-form-row>
     *                </<aw-right>
     *            </aw-form-table>
     *
     *  ```
     *
     *  todo: remove my css selectors for zones and replace it with real component even just a tag
     *  todo: would work file
     *
     */
    var FormTableComponent = (function (_super) {
        __extends(FormTableComponent, _super);
        function FormTableComponent(env) {
            var _this = _super.call(this, env, null) || this;
            _this.env = env;
            /**
             * Used for the form layout to see if we need to render labels stacked  or side by side next to
             * the control
             *
             */
            _this.labelsOnTop = false;
            /**
             *
             * Is this a 4 zone layout
             *
             */
            _this.useFiveZone = false;
            /**
             * For certain usecase we dont want to set automatically this to all children
             */
            _this.editabilityCheck = true;
            /**
             *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
             *
             *
             */
            _this.onSubmit = new core.EventEmitter();
            /**
             * Cache calculated properties when init this component
             *
             */
            _this.hasOneColumn = false;
            _this.hasTwoColumn = false;
            _this.hasThreeColumn = false;
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        FormTableComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['editable']) &&
                    changes['editable'].previousValue !== changes['editable'].currentValue) {
                    this.updateFormFields();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FormTableComponent.prototype.onSubmitForm = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onSubmit.emit(event);
            };
        /**
         *
         * Are labels on top
         *
         */
        /**
         *
         * Are labels on top
         *
         * @return {?}
         */
        FormTableComponent.prototype.isLabelsOnTop = /**
         *
         * Are labels on top
         *
         * @return {?}
         */
            function () {
                return this.labelsOnTop;
            };
        /**
         *
         * Used by child component to inherit editability
         *
         */
        /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
        FormTableComponent.prototype.isFormEditable = /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
            function () {
                return this.editable;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.applyColumns = /**
         * @return {?}
         */
            function () {
                if (!this.useFiveZone && this.hasAnyZones()) {
                    throw new Error('Zones detected in the FormTable but useFiveZone option is false');
                }
                this.hasOneColumn = !core$1.isPresent(this.rightZone) && !core$1.isPresent(this.middleZone);
                this.hasTwoColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    !core$1.isPresent(this.middleZone);
                this.hasThreeColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    core$1.isPresent(this.middleZone);
                if (this.hasTwoColumn && !this.isTwoZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-6';
                    this.rightZone.classList += ' ui-md-6 ui-lg-6';
                }
                if (this.hasThreeColumn && !this.isThreeZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-4';
                    this.rightZone.classList += ' ui-md-6 ui-lg-4';
                }
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.hasAnyZones = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.leftZone) || core$1.isPresent(this.rightZone) || core$1.isPresent(this.middleZone)
                    || core$1.isPresent(this.topZone) || core$1.isPresent(this.bottomZone);
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isTwoZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-6') > 0;
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isThreeZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-4') > 0;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // problem since Angular 4.2, ngAfterContentInit
                // without this I get error that value was changed after view was checked
                // todo: refactor  - mainly our zones left, right middle
                setTimeout(function () {
                    _this.applyColumns();
                    _this.updateFormFields();
                    _this.adjustLayout();
                });
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.updateFormFields = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.editabilityCheck && core$1.isPresent(this.formFields) && this.formFields.length > 0) {
                    this.formFields.forEach(function (item) {
                        item.editable = _this.editable;
                        // item.formGroup = this.formGroup;
                    });
                }
            };
        /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
        FormTableComponent.prototype.adjustLayout = /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.rows) && this.rows.length > 0) {
                    if (this.hasThreeColumn) {
                        this.rows.forEach(function (item) { return item.size = 'large'; });
                    }
                }
            };
        FormTableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-table',
                        template: "<form class=\"w-form-table ui-g ui-fluid\" [formGroup]=\"formGroup\"\n      [ngClass]=\"styleClass\"\n      (ngSubmit)=\"onSubmitForm(formGroup.value)\" novalidate>\n\n    <div class=\"ui-g-12 ui-g-nopad\">\n\n        <div class=\"ui-g\">\n            <ng-content></ng-content>\n        </div>\n\n    </div>\n</form>\n\n",
                        styles: [".page-container>form{margin-top:1em}.w-form-table button{float:right}"],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormTableComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        FormTableComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        FormTableComponent.propDecorators = {
            labelsOnTop: [{ type: core.Input }],
            useFiveZone: [{ type: core.Input }],
            editabilityCheck: [{ type: core.Input }],
            onSubmit: [{ type: core.Output }],
            leftZone: [{ type: core.ContentChild, args: [LeftZoneComponent,] }],
            middleZone: [{ type: core.ContentChild, args: [MiddleZoneComponent,] }],
            rightZone: [{ type: core.ContentChild, args: [RightZoneComponent,] }],
            topZone: [{ type: core.ContentChild, args: [TopZoneComponent,] }],
            bottomZone: [{ type: core.ContentChild, args: [BottomZoneComponent,] }],
            formFields: [{ type: core.ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
            rows: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return FormRowComponent; }), { descendants: true },] }]
        };
        return FormTableComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWFormTableModule = (function () {
        function AWFormTableModule() {
        }
        AWFormTableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        exports: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ]
                    },] },
        ];
        return AWFormTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This component represent a Input field and it can  accept different types of values such as
     * text, number.
     *
     *
     *
     * ### Example
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *
     *
     * ### Example wher input field is initialized with ngModel
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
     *
     */
    var /** @type {?} */ INPUT_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return InputFieldComponent; }),
        multi: true
    };
    var InputFieldComponent = (function (_super) {
        __extends(InputFieldComponent, _super);
        function InputFieldComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to save and read  when rendering and updating a component
             *
             */
            _this.value = '';
            /**
             * The formatted decimal value. Uses angular decimalPipe to format based on locale.
             */
            _this.displayValue = '';
            /**
             * Input field type. Currently we support either Number or text
             */
            _this._type = 'string';
            _this.decimalPipe = new common.DecimalPipe(env.locale);
            return _this;
        }
        Object.defineProperty(InputFieldComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this._type;
            },
            /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             */
            set: /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
                    this._type = 'text';
                }
                else if (value.toLowerCase() === 'number') {
                    this._type = 'number';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.bigDecimal);
                this.vchSubscriber = this.formControl.valueChanges
                    .pipe(operators.distinctUntilChanged())
                    .subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
                if (this.bigDecimal) {
                    this.displayValue = this.formatNumber(this.bigDecimal.amount);
                }
                else {
                    this.displayValue = this.value;
                }
            };
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.canSetType = /**
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * @param {?} el
         * @return {?}
         */
        InputFieldComponent.prototype.onKeyDown = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._type === 'number') {
                    this.displayValue = el.value;
                    this.onModelChanged(this.displayValue);
                }
            };
        /**
         * @param {?} el
         * @return {?}
         */
        InputFieldComponent.prototype.onBlur = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._type === 'number') {
                    this.bigDecimal = new BigDecimal(Number(el.value));
                    this.displayValue = this.formatNumber(this.bigDecimal.amount);
                    this.onModelChanged(this.displayValue);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.displayValue) {
                    this.value = value;
                    this.displayValue = '';
                    if (this.value) {
                        this.displayValue = this.value;
                    }
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        /**
         * Format the number object according to its precision.
         *
         */
        /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.formatNumber = /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!value) {
                    return '';
                }
                // If precision is present, use it for format the bigDecimal value for display.
                if (core$1.isPresent(this.precision) &&
                    this._type === 'number') {
                    // The default precision is 2. For example, 10.23.
                    var /** @type {?} */ digits = '1.0-2';
                    digits = '1.0-' + this.precision;
                    return this.decimalPipe.transform(value, digits);
                }
                return value;
            };
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.vchSubscriber)) {
                    this.vchSubscriber.unsubscribe();
                }
            };
        InputFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-input-field',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\" class=\"w-input-wrapper\">\n\n    <input pInputText\n           #inputFieldValue\n           [attr.name]=\"name\"\n           [attr.type]=\"type\"\n           class=\"w-input-field\"\n           [ngClass]=\"styleClass\"\n           [class.has-icon]=\"icon\"\n           placeholder=\"{{placeHolder}}\"\n           [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n           formControlName=\"{{name}}\"\n           (keydown)=\"onKeyDown(inputFieldValue)\"\n           (blur)=\"onBlur(inputFieldValue)\"\n           [value]=\"displayValue\">\n    <span *ngIf=\"icon\" class=\"sap-icon\" [ngClass]=\"icon\"></span>\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"displayValue\"></aw-string>\n</ng-template>\n",
                        styles: [".w-input-wrapper{position:relative}.w-input-field{padding-right:35px}.w-input-field~span{top:13px;position:absolute;right:15px}"],
                        providers: [
                            INPUT_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return InputFieldComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        InputFieldComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        InputFieldComponent.propDecorators = {
            value: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            bigDecimal: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            type: [{ type: core.Input }]
        };
        return InputFieldComponent;
    }(BaseFormComponent));
    /**
     * BigDecimal object is represented as a value, locale, and currencyCode
     */
    var /**
     * BigDecimal object is represented as a value, locale, and currencyCode
     */ BigDecimal = (function () {
        function BigDecimal(amount, locale) {
            if (amount === void 0) {
                amount = 0;
            }
            if (locale === void 0) {
                locale = 'en_US';
            }
            this.amount = amount;
            this.locale = locale;
        }
        /**
         * @return {?}
         */
        BigDecimal.prototype.getTypes = /**
         * @return {?}
         */
            function () {
                return {
                    amount: Number,
                    locale: String
                };
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.className = /**
         * @return {?}
         */
            function () {
                return 'BigDecimal';
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.$proto = /**
         * @return {?}
         */
            function () {
                return new BigDecimal(1, 'en_US');
            };
        /**
         * @return {?}
         */
        BigDecimal.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.amount + ', locale: ' + this.locale;
            };
        /**
         * @param {?=} data
         * @return {?}
         */
        BigDecimal.prototype.clone = /**
         * @param {?=} data
         * @return {?}
         */
            function (data) {
                if (data === void 0) {
                    data = {};
                }
                return new BigDecimal(core$1.isPresent(data.amount) ? data.amount : this.amount, core$1.isPresent(data.locale) ? data.locale : this.locale);
            };
        return BigDecimal;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWStringFieldModule = (function () {
        function AWStringFieldModule() {
        }
        AWStringFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StringComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule
                        ],
                        entryComponents: [
                            StringComponent
                        ],
                        exports: [
                            StringComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWStringFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWInputFieldModule = (function () {
        function AWInputFieldModule() {
        }
        AWInputFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            InputFieldComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            InputFieldComponent
                        ],
                        exports: [
                            InputFieldComponent,
                            AWStringFieldModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWInputFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * basic navigation bar provide a main action buttons for its content (page level buttons).
     * This is not the Top level application navigation. This component provides by default action OK,
     * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
     * event. Or you can provide your own buttons template which will be used instead of this default
     * one.
     *
     *
     *
     *
     *
     * ### Example 1:
     *
     * In order to use navigation bar in its basic usage you can do following:
     * this will render buttons on the top as well as on the bottom around the content.
     *
     *
     *  ```html
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     *  if you do not want button on the top or bottom you can say thi using binding showTop or
     * showBottom.
     *
     *
     * ### Example 2:
     *  In this example we are providing custom buttons as well as brank section
     *
     *
     *  ```html
     *
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *            <ng-template #buttons>
     *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
     *                    <li class="nav-item ">
     *                        <button class="btn btn-secondary" type="button"
     * (click)="onSaveAction($evemt)">Cancel</button>
     *                    </li>
     *                    <li class="nav-item active">
     *                        <button class="btn btn-primary" type="button"
     * (click)="onCancelAction($event)"> Save
     *                        </button>
     *                    </li>
     *                </ul>
     *            </ng-template>
     *
     *            <ng-template #brand>
     *                <span class="brand-title">Ariba</span>
     *            </ng-template>
     *
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     */
    var BasicNavigatorComponent = (function (_super) {
        __extends(BasicNavigatorComponent, _super);
        function BasicNavigatorComponent(env, appConfig) {
            var _this = _super.call(this, env) || this;
            /**
             * Indicates that buttons will be rendered on the top
             *
             * Default value is TRUE
             *
             */
            _this.showTop = true;
            /**
             * Indicates that buttons will be rendered on the bottom
             *
             * Default value is TRUE
             *
             */
            _this.showBottom = true;
            /**
             * Indicates that brand section that is on the left side and only in the top bar is visible
             *
             * Default value is TRUE
             *
             */
            _this.showBrand = true;
            /**
             *
             * EventEmitter that is triggered when you click on default OK Action
             *
             */
            _this.onOKAction = new core.EventEmitter();
            /**
             *
             * EventEmitter that is triggered when you click on default CANCEL Action
             *
             */
            _this.onCancelAction = new core.EventEmitter();
            // todo: load this from resource file using ngTranslate service
            // todo: load this from resource file using ngTranslate service
            _this.okActionLabel = 'OK';
            _this.cancelActionLabel = 'Cancel';
            _this.brandImg = 'images/aribalogobal.png';
            return _this;
        }
        /**
         * @return {?}
         */
        BasicNavigatorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.showCancelButton)) {
                    this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                        && this.onOKAction.observers.length > 0);
                }
            };
        /**
         * Returns if buttonsTemplate is available
         *
         */
        /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasButtonTemplate = /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.buttonsTemplate);
            };
        /**
         * Returns if brandTemplate is available
         *
         */
        /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasBrandTemplate = /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.brandTemplate);
            };
        BasicNavigatorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-basic-navigator',
                        template: "<p-toolbar *ngIf=\"showTop\" [class]=\"'w-basic-navigator'\">\n    <div class=\"ui-toolbar-group-left\">\n\n        <a class=\"nav-brand\" href=\"#\" *ngIf=\"showBrand\">\n            <ng-template [ngIf]=\"!hasBrandTemplate()\">\n                <img src=\"{{assetFolder}}/{{brandImg}}\" height=\"30\" alt=\"\">\n                <span class=\"nav-brand-title\">Ariba</span>\n            </ng-template>\n\n            <ng-template [embeddedItem]=\"brandTemplate\" [item]=\"context\"\n                         *ngIf=\"hasBrandTemplate()\"></ng-template>\n        </a>\n\n    </div>\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n\n\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n<ng-content></ng-content>\n\n<p-toolbar *ngIf=\"showBottom\">\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n\n\n",
                        styles: ["a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}"]
                    },] },
        ];
        /** @nocollapse */
        BasicNavigatorComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core$1.AppConfig }
            ];
        };
        BasicNavigatorComponent.propDecorators = {
            showTop: [{ type: core.Input }],
            showBottom: [{ type: core.Input }],
            showBrand: [{ type: core.Input }],
            brandImg: [{ type: core.Input }],
            okActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            context: [{ type: core.Input }],
            showCancelButton: [{ type: core.Input }],
            onOKAction: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            buttonsTemplate: [{ type: core.ContentChild, args: ['buttons',] }],
            brandTemplate: [{ type: core.ContentChild, args: ['brand',] }]
        };
        return BasicNavigatorComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Button component that implements consistent styling, behavior. Button can be rendered either as
     * a button or as a link. It could be standalone or be part of a form.
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *   <aw-form-table >
     *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
     *
     *           <aw-button [type]="'submit'" [name]="'button'"
     *                     (action)="onClicked($event)" [value]="command"
     *                     [style]="'warning'" >Button</aw-button>
     *       </aw-form-row>
     *   </aw-form-table>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(value:string) {
     *           if (value) {
     *              // submit form.
     *           }
     *        }
     *    }
     */
    var ButtonComponent = (function (_super) {
        __extends(ButtonComponent, _super);
        function ButtonComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Button types  [ button | submit | reset ]
             *
             */
            _this.type = 'button';
            /**
             * styling for this button. See ButtonStyle for all supported styles.
             */
            _this.style = 'primary';
            /**
             * sizing for this button. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            // Default button class is secondary.
            // Default button class is secondary.
            _this.buttonClass = 'ui-button-secondary';
            // Default disabled
            // Default disabled
            _this.disabled = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // How to style this button.
                if (core$1.isPresent(this.style)) {
                    if (this.style === 'primary') {
                        // Default .ui-button and .ui-button-primary get the same style.
                        // .ui-button-primary is necessary because button style can be overridden
                        // when included inside other widgets. So specify primary
                        this.buttonClass = 'ui-button-primary';
                    }
                    else {
                        this.buttonClass = 'ui-button-' + this.style;
                    }
                }
                // Determine the button class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.buttonClass += ' btn-lg';
                            break;
                        case 'normal':
                            this.buttonClass += ' btn-mid';
                            break;
                        case 'small':
                            this.buttonClass += ' btn-sm';
                            break;
                    }
                }
            };
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * @Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         */
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
        ButtonComponent.prototype.ngAfterViewInit = /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.element)) {
                    var /** @type {?} */ button = this.element.nativeElement.querySelector('button');
                    var /** @type {?} */ buttonTitle = button.children[0];
                    button.children[0].textContent = this.element.nativeElement.textContent.trim()
                        .replace('ui-button', '').replace('ui-btn', '');
                    button.classList.remove('ui-button-text-empty');
                    button.textContent = '';
                    button.appendChild(buttonTitle);
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
        ButtonComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                this.action.emit(core$1.isBlank(this.value) ? $event : this.value);
            };
        ButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-button',
                        template: "<button\n    pButton\n    [attr.type]=\"type\"\n    [attr.name]=\"name\"\n    [ngClass]=\"buttonClass\"\n    [disabled]=\"disabled\"\n    [attr.value]=\"value\"\n    (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</button>\n",
                        styles: [".ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}"]
                    },] },
        ];
        /** @nocollapse */
        ButtonComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        ButtonComponent.propDecorators = {
            type: [{ type: core.Input }],
            name: [{ type: core.Input }],
            style: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return ButtonComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWButtonModule = (function () {
        function AWButtonModule() {
        }
        AWButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ButtonModule,
                        ],
                        entryComponents: [
                            ButtonComponent
                        ],
                        exports: [
                            ButtonComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWBasicNavigatorModule = (function () {
        function AWBasicNavigatorModule() {
        }
        AWBasicNavigatorModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BasicNavigatorComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ToolbarModule,
                            AWButtonModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            BasicNavigatorComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWBasicNavigatorModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardZoneTopComponent = (function () {
        function CardZoneTopComponent() {
        }
        CardZoneTopComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-top",
                        host: {
                            'class': 'w-card-ztop'
                        }
                    },] },
        ];
        return CardZoneTopComponent;
    }());
    var CardZoneBottomComponent = (function () {
        function CardZoneBottomComponent() {
        }
        CardZoneBottomComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-bottom",
                        host: {
                            'class': 'w-card-zbottom'
                        }
                    },] },
        ];
        return CardZoneBottomComponent;
    }());
    /**
     *
     * Card component is a container rendering its content inside 3 different zones.
     *
     *  ------------------------------------------
     *  |   TITLE                       | ACTION |
     *  |-----------------------------------------
     *  |                                        |
     *  |   TOP                                  |
     *  |                                        |
     *  ------------------------------------------
     *  |                                        |
     *  |   BOTTOM                               |
     *  |                                        |
     *  |                                        |
     *  ------------------------------------------
     *
     *
     *  There are 3 zones  + 1 placeholder for the actionIcon
     *
     *  Cards can be selectable which means when you click on it there will be rendered a border with
     *  a check mark inside Action zone (this is default behavior).
     *  You can use [selectable] binding to disable this, in such case card will have just a border
     *  without any check mark.
     *
     *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
     *  application level you can listen for (click) events as well as you can provide your own action
     *  icon
     *
     *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
     *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
     *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
     *  only one action which click on the hover overlay.
     *
     *
     * ###example 1:
     *  Basic hover card which by default support selectable mode
     *
     * ```
     *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *  ###example 2:
     *   Hover card with custom action. when unselected action will appear and user can click on it.
     *
     * ```
     *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
     *                     (onAction)="onAction(3, $event)">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *
     *
     */
    var CardComponent = (function (_super) {
        __extends(CardComponent, _super);
        function CardComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Tells if we should explicitly hide the action
             *
             */
            _this.hasAction = false;
            /**
             *
             * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
             * ACTION zone when selected
             *
             */
            _this.selectable = true;
            /**
             * Option to pass custom "Card Selected" Icon
             *
             */
            _this.selectedIcon = 'icon-accept';
            /*
                 * Enable and disables hover effect on top of the card
                 */
            _this.hasHover = false;
            /**
             *
             * Default icon name for the hover overlay. This icons shows up in the middle over the card
             * vertically and horizontally centered
             *
             */
            _this.hoverIcon = 'icon-add';
            /**
             *  Selection state
             *
             */
            _this.selected = true;
            /**
             * Fired when the card is selected.
             *
             */
            _this.onSelect = new core.EventEmitter();
            /**
             * Fired when action icon is clicked.
             *
             */
            _this.onAction = new core.EventEmitter();
            /**
             * Fired when the user clicks on the hover overlay.
             *
             */
            _this.onHoverAction = new core.EventEmitter();
            /**
             * Usually when template is provided we want to use it and replace internal one but in this
             * case it will be always conditional and application developer can switch between default
             * template with zones and custom one provided by developer.
             *
             */
            _this.useBodyTemplate = false;
            // sets default value
            // sets default value
            _this.width = '202px';
            _this.height = '154px';
            return _this;
        }
        /**
         * @return {?}
         */
        CardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If application wants to use action it must provide actionIcon
                if (core$1.isBlank(this.actionIcon) && this.hasAction) {
                    throw new Error('You need to provide action icon');
                }
            };
        /**
         * @return {?}
         */
        CardComponent.prototype.showBottomSection = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bottom);
            };
        /**
         * fires select and unselect event.
         */
        /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.toggleSelect = /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.selectable) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    this.selected = !this.selected;
                    this.onSelect.emit(this.selected);
                }
            };
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         */
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.onActionClick = /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.hasAction && (!this.selected || !this.selectable)) {
                    this.onAction.emit(this.selected);
                }
            };
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         */
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
        CardComponent.prototype.onHover = /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
            function (isEnter) {
                if (core$1.isPresent(this.hoverDiv)) {
                    this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
                }
            };
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         */
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
        CardComponent.prototype.showBodyTemplate = /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bodyTemplate) && this.useBodyTemplate;
            };
        CardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-card',
                        template: "<div class=\"w-card\" [style.width]=\"width\" [style.height]=\"height\"\n     [class.u-is-hover]=\"hasHover\"\n     (mouseenter)=\"onHover(true)\"\n     (mouseleave)=\"onHover(false)\"\n     [class.u-card-selected]=\"selected\"\n     [class.u-card-unselected]=\"!selected\"\n     [ngClass]=\"styleClass\"\n>\n\n    <div class=\"card-body ui-g\"  *ngIf=\"!showBodyTemplate()\">\n        <!-- Hover element that is triggered by mouseenter, mouseleave events-->\n        <div #hoverDiv *ngIf=\"hasHover\" class=\"u-card-hover\" (click)=\"onHoverAction.emit($event)\">\n            <span [style.width]=\"'100%'\" class=\"sap-icon\" [ngClass]=\"hoverIcon\"></span>\n        </div>\n        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->\n        <div class=\"ui-g-12 ui-g-nopad w-card-header\">\n            <div class=\"w-card-ztitle ui-g-nopad\" (click)=\"toggleSelect($event)\"\n                 [class.u-card-pointer]=\"selectable\"\n                 [ngClass]=\"{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}\">\n                <ng-content select=\"aw-card-title\"></ng-content>\n            </div>\n\n            <div *ngIf=\"hasAction || selectable\" class=\"w-card-zaction ui-g-nopad ui-g-3\">\n\n                <span *ngIf=\"selected && selectable\" class=\"sap-icon selection\"\n                      [class.u-card-pointer]=\"selectable\"\n                      [class.u-card-action-bg]=\"selected\"\n                      (click)=\"toggleSelect($event)\"\n                      [ngClass]=\"selectedIcon\"></span>\n\n\n                <span *ngIf=\"hasAction && (!selected || !selectable) \"\n                      class=\"sap-icon action\"\n                      [class.u-card-pointer]=\"true\"\n                      (click)=\"onActionClick($event)\"\n                      [ngClass]=\"actionIcon\"\n                ></span>\n            </div>\n        </div>\n\n        <!--TOP CARD SECTION-->\n        <div class=\"w-card-ztop ui-g-nopad ui-g-12 \"\n             (click)=\"toggleSelect($event)\"\n             [class.u-card-pointer]=\"selectable\">\n            <ng-content select=\"aw-card-top\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-g-nopad w-card-line-divider  \" *ngIf=\"showBottomSection()\"></div>\n        <!--BOTTOM CARD SECTION-->\n        <div *ngIf=\"showBottomSection()\" class=\"ui-g-12 ui-g-nopad w-card-zbottom\"\n             [class.u-card-pointer]=\"selectable\"\n             (click)=\"toggleSelect($event)\">\n            <ng-content select=\"aw-card-bottom\"></ng-content>\n        </div>\n    </div>\n\n    <div *ngIf=\"showBodyTemplate()\" class=\"w-card-user-cnt\" >\n        <ng-container *ngTemplateOutlet=\"bodyTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n",
                        styles: [".w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s ease;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}"]
                    },] },
        ];
        /** @nocollapse */
        CardComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        CardComponent.propDecorators = {
            hasAction: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            selectedIcon: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            hasHover: [{ type: core.Input }],
            hoverIcon: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            onSelect: [{ type: core.Output }],
            onAction: [{ type: core.Output }],
            onHoverAction: [{ type: core.Output }],
            bottom: [{ type: core.ContentChild, args: [CardZoneBottomComponent,] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }],
            hoverDiv: [{ type: core.ViewChild, args: ['hoverDiv',] }]
        };
        return CardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Maps our internal alignment value to real css values
     *
     */
    var /** @type {?} */ VAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'flex-start',
        'top-right': 'flex-start',
        'center-left': 'center',
        'center-center': 'center',
        'center-right': 'center',
        'bottom-left': 'flex-end',
        'bottom-center': 'flex-end',
        'bottom-right': 'flex-end'
    };
    var /** @type {?} */ HAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'center',
        'top-right': 'flex-end',
        'center-left': 'flex-start',
        'center-center': 'center',
        'center-right': 'flex-end',
        'bottom-left': 'flex-start',
        'bottom-center': 'center',
        'bottom-right': 'flex-end'
    };
    /**
     * Title zone provides a content placeholder for the Title Area. This zone is adding ability
     * to align its content into 9 different position.
     *
     * You can use this Title zone within <aw-card> as:
     *
     *
     * ```html
     *
     *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
     *                       [selectable]="false" [hasAction]="false"
     *                  (onHoverAction)="onAction(7, $event)" >
     *
     *                  <aw-card-title [align]="'bottom-left'">
     *                      <span class="a-supplier-tag">
     *                          Preferred
     *                      </span>
     *                  </aw-card-title>
     *
     *   </aw-card>
     *
     * ```
     * Default alignment is top-left
     *
     *
     *
     *
     */
    var CardZoneTitleComponent = (function (_super) {
        __extends(CardZoneTitleComponent, _super);
        function CardZoneTitleComponent(env, elem) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elem = elem;
            /**
             * Special property which is used to apply flex properties for aligning content vertically
             * as well as horizontally
             *
             */
            _this.align = 'top-left';
            return _this;
        }
        /**
         * @return {?}
         */
        CardZoneTitleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
                this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
            };
        CardZoneTitleComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-title",
                        host: {
                            'class': 'w-card-title'
                        }
                    },] },
        ];
        /** @nocollapse */
        CardZoneTitleComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        CardZoneTitleComponent.propDecorators = {
            align: [{ type: core.Input }]
        };
        return CardZoneTitleComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCardModule = (function () {
        function AWCardModule() {
        }
        AWCardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        entryComponents: [
                            CardComponent
                        ],
                        exports: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
     * {\@link CheckboxComponent}: form and action checkbox as described above.
     *
     *
     * Usage: Basic example having red checkbox checked
     *
     * ```HTML
     *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
     *                                        [(ngModel)]="model">
     *        </aw-checkbox>
     *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                                        [(ngModel)]="model">
     *       </aw-checkbox>
     *
     * ```
     *
     * ```ts
     *
     *
     *   class CBBasicWithNgModelComponent
     *   {
     *
     *       model: string[] = ['red'];
     *
     *       constructor()
     *       {
     *       }
     *   }
     *
     * ```
     *
     * For more examples please see a playground or unit test.
     *
     */
    var /** @type {?} */ CB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var CheckboxComponent = (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this checkbox
             *
             */
            _this.value = '';
            /**
             * Type of checkbox. Form based updates model and Action based only fires click events
             *
             */
            _this.type = 'form';
            /**
             * Trigger click event.
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
             * remove values.
             *
             * In our case Checktype = Action is always binary or when this.value is boolean
             *
             */
            _this.isBinary = false;
            return _this;
        }
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.model = this.value;
                this.type = this.action.observers.length > 0 ? 'action' : this.type;
                if (this.isFormType()) {
                    _super.prototype.ngOnInit.call(this);
                    if (this.isStandalone) {
                        _super.prototype.registerFormControl.call(this, this.value);
                        this.model = this.formControl.value;
                        this.onModelChanged(this.model);
                    }
                    else {
                        // get control from parent
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // When value is boolean we are dealing with PrimeNg Binary checkbox
                // which only sets TRUE/FALSE and does not add or remove values
                this.isBinary = core$1.isBoolean(this.value);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['value']) &&
                    (changes['value'].currentValue !== changes['value'].previousValue)) {
                    this.model = changes['value'].currentValue;
                }
            };
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         */
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
        CheckboxComponent.prototype.onChange = /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFormType()) {
                    this.onModelChanged(this.model);
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model);
                    }
                }
                else {
                    this.action.emit(event);
                }
            };
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         */
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
        CheckboxComponent.prototype.isFormType = /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
            function () {
                return this.type === 'form';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model && this.isFormType()) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.onModelChanged(this.model);
                        this.formControl.setValue(this.model);
                    }
                }
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox',
                        template: "<span class=\"w-checkbox\">\n\n    <ng-template [ngIf]=\"editable && isFormType()\">\n        <p-checkbox [name]=\"name\" [value]=\"value\" [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    [binary]=\"isBinary\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\"\n                    [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        >\n        </p-checkbox>\n    </ng-template>\n\n\n    <ng-template [ngIf]=\"!isFormType()\">\n        <p-checkbox [binary]=\"isBinary\"\n                    [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\">\n        </p-checkbox>\n\n    </ng-template>\n</span>\n",
                        styles: ["/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}"],
                        providers: [
                            CB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckboxComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        CheckboxComponent.propDecorators = {
            value: [{ type: core.Input }],
            type: [{ type: core.Input }],
            label: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return CheckboxComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCheckBoxModule = (function () {
        function AWCheckBoxModule() {
        }
        AWCheckBoxModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckboxComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CheckboxModule
                        ],
                        entryComponents: [
                            CheckboxComponent
                        ],
                        exports: [
                            CheckboxComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWCheckBoxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
     * component
     *
     * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
     * primitive values.
     *
     * @see {\@link check-box/check-box.component.ts}
     *
     *
     * ### Example
     *
     *
     * \@Component({
     *       selector: 'showCheckBoxList' ,
     *       template: `
     *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
     *
     *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
     *           </aw-checkbox-list>
     *       `
     *
     *       })
     *        class MyShowCLComponent
     *        {
     *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
     *     'silver' , 'black' ,
     *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *
     *            formGroup: FormGroup = new FormGroup({});
     *
     *
     *            onCBClick (event): void
     *            {
     *                console.log('onCBClick = ' + event);
     *            }
     *
     *        }
     * *
     */
    var /** @type {?} */ CB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckBoxListComponent; }),
        multi: true
    };
    var CheckBoxListComponent = (function (_super) {
        __extends(CheckBoxListComponent, _super);
        function CheckBoxListComponent(env, cd, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.cd = cd;
            _this.parentContainer = parentContainer;
            /**
             * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
             * actuall internal model value in this case array of choices
             *
             */
            _this.onSelection = new core.EventEmitter();
            /**
             * Internal model
             */
            _this.model = [];
            return _this;
        }
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.selections)) {
                    this.selections = [];
                }
                this.registerFormControl(this.selections);
                this.updateModel(this.selections);
                this.onModelChanged(this.selections);
            };
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ updatedModel = [];
                this.model.forEach(function (index) { return updatedModel.push(_this.list[index]); });
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                this.cd.detectChanges();
            };
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         */
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.labelValue = /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         */
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
        CheckBoxListComponent.prototype.onChange = /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                var /** @type {?} */ updatedModel = [];
                this.model.forEach(function (index) {
                    updatedModel.push(_this.list[index]);
                });
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
        CheckBoxListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
            function (sourceList) {
                var _this = this;
                sourceList.forEach(function (item) {
                    var /** @type {?} */ index = _this.list.findIndex(function (elem) {
                        return core$1.equals(item, elem);
                    });
                    _this.model.push(index);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckBoxListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isPresent(this.model) && core$1.isPresent(value)) {
                    var /** @type {?} */ newModel = value;
                    this.updateModel(newModel);
                    // this.cd.markForCheck();
                }
            };
        CheckBoxListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox-list',
                        template: "<div *ngFor=\"let item of list; let i = index\" class=\"ui-g\">\n\n    <!-- in the future we should be able to to support inline and stack-->\n    <div class=\"ui-g-12\">\n        <aw-checkbox [(ngModel)]=\"model\"\n                     (ngModelChange)=\"onChange($event)\"\n                     [editable]=\"editable\"\n                     [isStandalone]=\"false\"\n                     [name]=\"name\"\n                     [value]=\"i\"\n                     [label]=\"labelValue(item)\">\n\n        </aw-checkbox>\n    </div>\n\n</div>\n\n",
                        styles: [""],
                        providers: [
                            CB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckBoxListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CheckBoxListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CheckBoxListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selections: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            labelFormatter: [{ type: core.Input }]
        };
        return CheckBoxListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCheckBoxListModule = (function () {
        function AWCheckBoxListModule() {
        }
        AWCheckBoxListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckBoxListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCheckBoxModule
                        ],
                        exports: [
                            CheckBoxListComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWCheckBoxListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
     * native link functionality. In addition, it supports navigation to components through the action
     * binding.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link button/button.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
     *                        (action)="onClicked($event)" [value]="customerId"
     *                        [size]="'large'" >my link</aw-hyperlink>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(customerId:string) {
     *           if (customerId) {
     *              // display customer details component.
     *           }
     *        }
     *    }
     */
    var HyperlinkComponent = (function (_super) {
        __extends(HyperlinkComponent, _super);
        function HyperlinkComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * sizing for this link. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            /**
             * Internal CSS class that styles this hyperlink based on input 'size'
             */
            _this.linkClass = 'link';
            return _this;
        }
        /**
         * @return {?}
         */
        HyperlinkComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // Determine the link class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.linkClass += ' link-lg';
                            break;
                        case 'normal':
                            this.linkClass += ' link-mid';
                            break;
                        case 'small':
                            this.linkClass += ' link-sm';
                            break;
                    }
                }
                // If I have an action tag, and no href. We add default styling and behavior.
                if (this.action.observers.length > 0) {
                    this.linkClass += ' link-bh';
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
        HyperlinkComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.action.emit({
                    event: event,
                    value: this.value
                });
            };
        HyperlinkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hyperlink',
                        template: "<a [attr.type]=\"type\"\n   [attr.href]=\"href\"\n   [attr.rel]=\"rel\"\n   [attr.target]=\"target\"\n   [ngClass]=\"linkClass\"\n   [class.disabled]=\"disabled\"\n   (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</a>\n",
                        styles: [".link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}"]
                    },] },
        ];
        /** @nocollapse */
        HyperlinkComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        HyperlinkComponent.propDecorators = {
            type: [{ type: core.Input }],
            href: [{ type: core.Input }],
            rel: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return HyperlinkComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWHyperlinkModule = (function () {
        function AWHyperlinkModule() {
        }
        AWHyperlinkModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HyperlinkComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            HyperlinkComponent
                        ],
                        exports: [
                            HyperlinkComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWHyperlinkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */
    var /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */ ChooserSelectionState = (function () {
        function ChooserSelectionState() {
        }
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         */
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserSelectionState.prototype.setSelectionState = /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
            };
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         */
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObject = /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         * The most recent selections.
         *
         */
        /**
         * The most recent selections.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObjects = /**
         * The most recent selections.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         *
         * Check if the item selection items is in the selectedObjects
         */
        /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
        ChooserSelectionState.prototype.isSelected = /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return core$1.unimplemented();
            };
        return ChooserSelectionState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */
    var /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */ ChooserState = (function () {
        function ChooserState(chooserSelectionState, isMulti) {
            if (isMulti === void 0) {
                isMulti = true;
            }
            /**
             * Indicates if there are any validation like entered value does not much with the source list.
             *
             */
            this.isInvalid = false;
            /**
             *
             * indicates that we started to some editing e.g. starting to type in something into the
             * filter, or removing already selected items
             */
            this.addMode = false;
            this.recentSelectedDisplayed = 0;
            /**
             * When this option is active we do not show all selected items, but max number that is
             * defined. User is able to toggle to expand the view to see all selections and hide them as
             * well
             */
            this.showAllRecentlySelected = false;
            this.selectionState = chooserSelectionState;
            this.multiselect = isMulti;
            if (core$1.isBlank(this.selectionState)) {
                this.selectionState = new DefaultSelectionState(this.multiselect);
            }
        }
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         */
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
        ChooserState.prototype.updatedSelectedObjects = /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    item = this.currentItem;
                }
                if (!this.multiselect) {
                    this.setSelectionState(item, true);
                }
                else {
                    var /** @type {?} */ selectedObject = this.selectedObject();
                    var /** @type {?} */ selectedObjects = this.selectedObjects();
                    if (this.addMode) {
                        if (this.isInvalid) {
                            if (core$1.isPresent(selectedObject)) {
                                this.setSelectionState(selectedObject, false);
                            }
                        }
                        this.setSelectionState(item, !core$1.ListWrapper.containsComplex(selectedObjects, item));
                    }
                    else {
                        if (core$1.isPresent(selectedObject)) {
                            this.setSelectionState(selectedObject, false);
                        }
                        this.setSelectionState(item, true);
                    }
                }
            };
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         */
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
        ChooserState.prototype.toggleAllSelected = /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
            function () {
                this.showAllRecentlySelected = !this.showAllRecentlySelected;
            };
        Object.defineProperty(ChooserState.prototype, "recentSelectedObjects", {
            /**
             *
             * Renders user's selection under the input field
             *
             */
            get: /**
             *
             * Renders user's selection under the input field
             *
             * @return {?}
             */ function () {
                if (!this.multiselect) {
                    return [];
                }
                var /** @type {?} */ recentSelectedObjects = [];
                this.recentSelectedDisplayed = 0;
                var /** @type {?} */ selectedObjects = this.selectedObjects();
                var /** @type {?} */ size = selectedObjects.length;
                var /** @type {?} */ maxCount = DataSource.MaxRecentSelected;
                if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
                    maxCount -= 1;
                }
                if (this.showAllRecentlySelected) {
                    maxCount = size;
                }
                for (var /** @type {?} */ i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
                    var /** @type {?} */ selection = selectedObjects[i];
                    recentSelectedObjects.push(selection);
                    this.recentSelectedDisplayed++;
                }
                return recentSelectedObjects;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObject();
            };
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObjects();
            };
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (core$1.isPresent(selection)) {
                    this.selectionState.setSelectionState(selection, selected);
                }
            };
        return ChooserState;
    }());
    /**
     * Dummy implementation ChooserSelectionState
     */
    var /**
     * Dummy implementation ChooserSelectionState
     */ DefaultSelectionState = (function (_super) {
        __extends(DefaultSelectionState, _super);
        function DefaultSelectionState(multiSelect) {
            var _this = _super.call(this) || this;
            _this.multiSelect = multiSelect;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        DefaultSelectionState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected) {
                    this._selectedObject = selection;
                    if (this.multiSelect && !core$1.ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                        this.selectedObjects().push(selection);
                    }
                }
                else {
                    if (this.multiSelect) {
                        core$1.ListWrapper.removeIfExist(this.selectedObjects(), selection);
                    }
                }
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this._selectedObject;
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this._selectedObjects)) {
                    this._selectedObjects = [];
                }
                return this._selectedObjects;
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        DefaultSelectionState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return _super.prototype.isSelected.call(this, selection);
            };
        return DefaultSelectionState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */
    var /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */ ChooserDataSource = (function (_super) {
        __extends(ChooserDataSource, _super);
        function ChooserDataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            return _this;
        }
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         */
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
        ChooserDataSource.prototype.init = /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                var /** @type {?} */ init = args[0];
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                if (core$1.isPresent(init.state)) {
                    this.state = init.state;
                }
                else {
                    this.state = new ChooserState(null, init.multiselect);
                }
                this.dataFinder.lookupKey = init.lookupKey;
                this.state.lookupKey = init.lookupKey;
            };
        /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
        ChooserDataSource.prototype.find = /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
            function (pattern, max) {
                var _this = this;
                this.state.pattern = pattern;
                this.state.lastFullMatchPattern = pattern;
                if (pattern.length === 0) {
                    return;
                }
                if (pattern === '*') {
                    // query everything
                    pattern = '';
                }
                // make sure we dataFinder has expected lookup key
                var /** @type {?} */ origKey = this.dataFinder.lookupKey;
                this.dataFinder.lookupKey = this.state.lookupKey;
                this.dataFinder.forData(this.dataProvider).match(pattern, max)
                    .subscribe(function (result) {
                    _this.state.matches = result;
                    if (_this.state.multiselect) {
                        for (var /** @type {?} */ i = 0; i < _this.state.selectedObjects().length; i++) {
                            var /** @type {?} */ item = _this.state.selectedObjects()[i];
                            core$1.ListWrapper.removeIfExist(_this.state.matches, item);
                        }
                    }
                    _this.dataFinder.lookupKey = origKey;
                });
            };
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         */
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
        ChooserDataSource.prototype.showMoreSelected = /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
            function () {
                return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.open = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        ChooserDataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
                this.state = null;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.instant = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.data();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ChooserDataSource.prototype.updateValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                this.state.addMode = true;
                if (core$1.isArray(value)) {
                    var /** @type {?} */ items = value;
                    items.forEach(function (item) { return _this.state.updatedSelectedObjects(item); });
                }
                else {
                    this.state.updatedSelectedObjects(value);
                }
                this.state.addMode = false;
            };
        Object.defineProperty(ChooserDataSource.prototype, "lookupKey", {
            get: /**
             * @return {?}
             */ function () {
                return this.dataFinder.lookupKey;
            },
            enumerable: true,
            configurable: true
        });
        return ChooserDataSource;
    }(DataSource));
    /**
     * @param {?} init
     * @return {?}
     */
    function isDSChooserInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
     * requires little bit different setup. It requires at minimum \@Input dataSource or
     * destinationClass
     *
     *
     * By default chooser is multi-select. If you want single select then you must provide multi-select
     * with \@Input.
     *
     * ### Example
     *
     * In simple scenario you can use Chooser like so:
     *
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
     *                      [dataSource]="ds"></aw-chooser>`
     *  })
     *  export class MyChooserApp
     *  {
     *
     *      ds: ChooserDataSource;
     *
     *     constructor(private data: DataProviders, private finders: DataFinders){
     *          this.ds = new ChooserDataSource(this.data, this.finders);
     *
     *       this.ds.init({
     *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
     *            multiselect: true
     *       });
     *
     *     }
     *  }
     *
     * ````
     *  Above example will use provided dataSource and render multi-select chooser. With default
     *  implementation  selected values will appear as a tags under the input box
     *
     *
     *
     * * ### Example
     *
     *  In this example we provide custom template to change the way how chooser's MenuItem are
     *     rendered as well as template for the selection item looks like
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
     *
     *          <ng-template #menuItem let-item>
     *             	<span>
     *             		<i class="fa fa-envira " ></i>
     *             		{{item}}
     *             	</span>
     *
     *          </ng-template>
     *
     *          <ng-template #selectionItem let-item>
     *             	<span class="tag tag-circle">
     *             		item: {{item }}
     *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
     *             	</span>
     *
     *
     *          </ng-template>
     *
     *
     *          </aw-chooser>
     *      `
     *      style: [`
     *              .tag-circle {
     *              	border-radius: 6rem;
     *              	height: 7rem;
     *              	color: #e8eef1;
     *              	background-color: rgba(53, 56, 58, 0.67);
     *              	line-height: 6rem;
     *              }
     *      `]
     *  })
     *
     * ````
     *
     *  In above example we change how the chooser's menu item look like as well as we define custom
     *     template for selection item to turn all selection to circles with text in the middle.
     *
     *
     *
     */
    var /** @type {?} */ CHOOSER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ChooserComponent; }),
        multi: true
    };
    var ChooserComponent = (function (_super) {
        __extends(ChooserComponent, _super);
        function ChooserComponent(env, elemementRef, _defaultDS, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.elemementRef = elemementRef;
            _this._defaultDS = _defaultDS;
            _this.parentContainer = parentContainer;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.maxLength = 10;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.minLenForSearch = 1;
            /**
             * Is this multiselect
             *
             */
            _this.multiselect = true;
            _this.delay = 300;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            if (core$1.isBlank(_this.placeHolder)) {
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                _this.placeHolder = 'Search';
            }
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            _this.hideLink = 'Hide';
            return _this;
        }
        /**
         * @return {?}
         */
        ChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.dataSource)) {
                    this.dataSource = this._defaultDS;
                    this.initDatasource();
                }
                if (core$1.isPresent(this.formControl) && core$1.isPresent(this.formControl.value)) {
                    this.dataSource.updateValue(this.formControl.value);
                }
                this.initInternalModel();
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.internalChooserModel);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
            };
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         */
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewInit = /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                var /** @type {?} */ searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
                if (core$1.isPresent(searchInput)) {
                    var /** @type {?} */ iconElement = document.createElement('span');
                    iconElement.className = 'search-icon-right fa fa-fw fa-search';
                    searchInput.appendChild(iconElement);
                }
                if (core$1.isPresent(this.selectionAppendTo) && core$1.isPresent(this.selectionViewElem)) {
                    var /** @type {?} */ parentElem = this.selectionAppendTo instanceof core.ElementRef ?
                        this.selectionAppendTo.nativeElement : this.selectionAppendTo;
                    parentElem.appendChild(this.selectionViewElem.nativeElement);
                }
            };
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         */
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewChecked = /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                var /** @type {?} */ tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
                if (core$1.isPresent(tokens) && tokens.length > 0) {
                    tokens.forEach(function (item) {
                        item.remove();
                    });
                }
            };
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         */
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
        ChooserComponent.prototype.match = /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
            function (pattern) {
                var /** @type {?} */ maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
                this.dataSource.find(pattern, maxLen);
                // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
                // doesn't give us any popup panel
                if (this.env.inTest && core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         */
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
        ChooserComponent.prototype.onDropdownClick = /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.match('*');
                setTimeout(function () {
                    _this.match('*');
                }, 100);
            };
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         */
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.selectItem = /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.dataSource.state.addMode = true;
                this.onModelChanged(this.internalChooserModel);
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = true;
                if (!this.dataSource.state.multiselect) {
                    this.autoCompleteComponent.inputEL.nativeElement.value =
                        this.displayItem(this.internalChooserModel);
                }
            };
        /**
         *
         * Unselect item
         *
         */
        /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.removeValue = /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.dataSource.state.addMode = true;
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = false;
                this.internalChooserModel = this.dataSource.state.selectedObjects();
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.onModelChanged(this.internalChooserModel);
                if (core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         */
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.displayItem = /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return null;
                }
                this.dataSource.state.currentItem = item;
                if (core$1.isPresent(this.valueTransformer)) {
                    return this.valueTransformer(item);
                }
                else if (core$1.isPresent(this.dataSource.lookupKey)) {
                    return item[this.dataSource.lookupKey];
                }
                else {
                    return item.toString();
                }
            };
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         */
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
        ChooserComponent.prototype.moreSelectString = /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ moreSelected = this.dataSource.state.selectedObjects().length -
                    this.dataSource.state.recentSelectedDisplayed;
                if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
                    return '';
                }
                if (this.dataSource.state.showAllRecentlySelected) {
                    return this.hideLink;
                }
                return moreSelected + " more selected...";
            };
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         */
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
        ChooserComponent.prototype.singleValueSelected = /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
            function () {
                return !this.dataSource.state && core$1.isPresent(this.dataSource.state.currentItem)
                    && !this.dataSource.state.addMode;
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasMenuTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.menuTemplate);
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasSelectionTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.selectionTemplate);
            };
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         */
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
        ChooserComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isBlank(value)) {
                    return;
                }
                if (core$1.isPresent(this.dataSource)) {
                    this.dataSource.updateValue(value);
                }
                else {
                    var /** @type {?} */ selState = new DefaultSelectionState(this.multiselect);
                    var /** @type {?} */ chState = new ChooserState(selState, this.multiselect);
                    this.initDatasource(chState);
                    this.dataSource.updateValue(value);
                }
                this.initInternalModel();
            };
        /**
         * @param {?=} chooserState
         * @return {?}
         */
        ChooserComponent.prototype.initDatasource = /**
         * @param {?=} chooserState
         * @return {?}
         */
            function (chooserState) {
                core$1.assert(core$1.isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
                this.dataSource.init({
                    obj: this.destinationClass,
                    queryType: QueryType.FullText,
                    lookupKey: this.field,
                    state: chooserState,
                    multiselect: this.multiselect
                });
            };
        /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
        ChooserComponent.prototype.initInternalModel = /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
            function () {
                if (this.dataSource.state.multiselect) {
                    this.internalChooserModel = this.dataSource.state.selectedObjects();
                }
                else {
                    this.internalChooserModel = this.dataSource.state.selectedObject();
                }
                if (core$1.isPresent(this.formControl)) {
                    this.formControl.setValue(this.internalChooserModel);
                }
            };
        ChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-chooser',
                        template: "<div class=\"w-chooser \">\n\n    <p-autoComplete #autoCompplete [(ngModel)]=\"internalChooserModel\"\n                    [suggestions]=\"dataSource.state.matches\"\n                    [multiple]=\"dataSource.state.multiselect\"\n                    [dropdown]=\"!dataSource.state.multiselect\"\n                    [minLength]=\"minLenForSearch\"\n                    [placeholder]=\"placeHolder\"\n                    [delay]=\"delay\"\n                    [disabled]=\"disabled\"\n                    (onDropdownClick)=\"onDropdownClick($event)\"\n                    (completeMethod)=\"match($event.query)\"\n                    (onSelect)=\"selectItem($event)\"\n                    (onUnselect)=\"removeValue($event)\">\n\n\n        <ng-template let-internalChooserModel pTemplate=\"item\">\n            <ng-template [ngIf]=\"!hasMenuTemplate()\">\n                {{ displayItem(internalChooserModel) }}\n            </ng-template>\n            <ng-template [embeddedItem]=\"menuTemplate\" [item]=\"internalChooserModel\"\n                         *ngIf=\"hasMenuTemplate()\"></ng-template>\n        </ng-template>\n    </p-autoComplete>\n\n    <!--\n        Wrap whole selection with one extra element so we can move it around\n\n         see: selectionAppendTo\n    -->\n    <span #selectionView>\n        <div class=\"w-chooser-selections\"\n             *ngIf=\"multiselect && dataSource.state.recentSelectedObjects.length > 0\">\n\n        <ng-template [ngIf]=\"!hasSelectionTemplate()\">\n\n            <!-- no selection template render it as it is from CORE-->\n            <ul class=\"ui-autocomplete-multiple-container ui-widget ui-state-default \"\n                [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}\">\n\n                <li #token *ngFor=\"let item of dataSource.state.recentSelectedObjects\"\n                    class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\" tabindex=\"0\"\n                    (keyup.delete)=\"removeValue(item)\"\n                    (keyup.backspace)=\"removeValue(item)\">\n\t\t\t\t\t<span class=\"ui-autocomplete-token-icon sap-icon icon-decline\"\n                          (click)=\"removeValue(item)\"></span>\n                    <span class=\"ui-autocomplete-token-label\">{{ displayItem(item) }}</span>\n                </li>\n            </ul>\n        </ng-template>\n\n            <!--Yes there is selection template let's iterate and push each item to be rendered-->\n        <ng-template ngFor [ngForOf]=\"dataSource.state.recentSelectedObjects\" let-item>\n            <ng-template [embeddedItem]=\"selectionTemplate\" [item]=\"item\"\n                         *ngIf=\"hasSelectionTemplate()\"></ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"dataSource.showMoreSelected()\">\n\t\t\t<span class=\"more-selected\">\n\t\t\t\t<aw-hyperlink [size]=\"'small'\" (action)=\"dataSource.state.toggleAllSelected()\">\n\t\t\t\t\t{{moreSelectString()}}\n\t\t\t\t</aw-hyperlink>\n\t\t\t</span>\n        </ng-template>\n    </div>\n    </span>\n\n\n</div>\n\n",
                        styles: ["/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}"],
                        providers: [
                            CHOOSER_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ]
                    },] },
        ];
        /** @nocollapse */
        ChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ChooserComponent.propDecorators = {
            maxLength: [{ type: core.Input }],
            minLenForSearch: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            selectionAppendTo: [{ type: core.Input }],
            delay: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            field: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            menuTemplate: [{ type: core.ContentChild, args: ['menuItem',] }],
            selectionTemplate: [{ type: core.ContentChild, args: ['selectionItem',] }],
            autoCompleteComponent: [{ type: core.ViewChild, args: ['autoCompplete',] }],
            selectionViewElem: [{ type: core.ViewChild, args: ['selectionView',] }]
        };
        return ChooserComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWChooserModule = (function () {
        function AWChooserModule() {
        }
        AWChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.AutoCompleteModule,
                            AWHyperlinkModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            ChooserComponent
                        ],
                        exports: [
                            ChooserComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A popup like component rendering list of values as. Based on PrimeNG component and one of the
     * main reason why we need to wrap this is to extend its capabilities to accept almost any
     * data type without using Primens's specific SelectItem type.
     *
     *
     * ### Example
     *
     * ```
     * \@Component({
     *      selector: 'showDropDown' ,
     *      template: '<aw-dropdown [list]="testItemSmall"
     *     (onSelection)="onSelection($event)"></aw-dropdown>'
     *  })
     *  export class MyDropComponent
     *  {
     *      testItemSmall: string[] = ['view' , 'edit'];
     *
     *      // when you switch list binding to refert to large item fiilter automatically is shown and
     *     max 10 items are
     *      // visible
     *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
     *     'Computer' , 'A Desk' ,
     *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
     *     'Czech Republic' ,
     *      'Last Item'];
     *
     *
     *      itemSelected: string = 'view';
     *      itemSelectedLg: string = 'Monday';
     *
     *      noselString: string = '(no selection)';
     *
     *
     *      onSelection (event): void
     *      {
     *          this.itemSelected = event;
     *
     *      }
     *  }
     *
     *  ```
     *
     */
    var /** @type {?} */ DD_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DropdownComponent; }),
        multi: true
    };
    var DropdownComponent = (function (_super) {
        __extends(DropdownComponent, _super);
        function DropdownComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         */
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
        DropdownComponent.prototype.ngOnInit = /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
            function () {
                if (this.isStandalone) {
                    _super.prototype.ngOnInit.call(this);
                    _super.prototype.registerFormControl.call(this, this.selection);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // transform a value to PrimeNg Format, we are not really be using a label field only a
                // value.
                this.internalList = [];
                // if (isPresent(this.noSelectionString)) {
                //     this.internalList.push({
                //         label: this.noSelectionString,
                //         value: null
                //     });
                //
                //     if (isBlank(this.selection)) {
                //         this.selection = this.noSelectionString;
                //     }
                // }
                if (core$1.isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
                    this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
                else if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.slice(0).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
            };
        /**
         * @return {?}
         */
        DropdownComponent.prototype.hasEmbeddedTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.itemTemplate);
            };
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         */
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.itemExist = /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item);
            };
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         */
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
        DropdownComponent.prototype.showFilter = /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
            function () {
                return false;
                // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
            };
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         */
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.onItemSelection = /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value.value;
                this.onSelection.emit(value.value);
                if (this.isStandalone) {
                    this.formControl.setValue(this.selection);
                    this.formControl.markAsDirty({ onlySelf: true });
                }
                this.onModelChanged(value.value);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.displayItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item) ? item.label : 'No Selection';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    this.formControl.setValue(value);
                }
            };
        DropdownComponent.MaxNumShown = 10;
        DropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dropdown',
                        template: "<div class=\"w-dropdown\" [formGroup]=\"formGroup\">\n\n    <ng-template [ngIf]=\"isStandalone\">\n        <p-dropdown [options]=\"internalList\"\n                    [formControlName]=\"name\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n\n                </ng-template>\n            </ng-template>\n\n\n        </p-dropdown>\n    </ng-template>\n</div>\n\n\n<!-- no formControl Name here. ngModel cannot have formGroup around -->\n<ng-template [ngIf]=\"!isStandalone\">\n    <div class=\"w-dropdown\">\n        <p-dropdown [options]=\"internalList\"\n                    [(ngModel)]=\"selection\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n                </ng-template>\n            </ng-template>\n        </p-dropdown>\n    </div>\n</ng-template>\n",
                        styles: ["/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}"],
                        providers: [
                            DD_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DropdownComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        DropdownComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        DropdownComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            itemTemplate: [{ type: core.ContentChild, args: ['itemTemplate',] }]
        };
        return DropdownComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDropdownModule = (function () {
        function AWDropdownModule() {
        }
        AWDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DropdownComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.DropdownModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            DropdownComponent
                        ],
                        exports: [
                            DropdownComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Lightweight and configurable Currency component based on the ng bootstrap directive. This
     * component combines an input and currency code dropdown.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link currency/currency.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'amount' ,
     *    template: `
     *
     *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
     *      </aw-currency>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        amount: number = 1000;
     *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
     *        currencyCode: string = this.currencies[0];
     *
     *        constructor ()
     *        {
     *        }
     *    }
     */
    var /** @type {?} */ CURRENCY_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CurrencyComponent; }),
        multi: true
    };
    var CurrencyComponent = (function (_super) {
        __extends(CurrencyComponent, _super);
        function CurrencyComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Disable user to change Money's currency code and still
             * allow user to edit Money's amount.
             */
            _this.readonlyCurrencyCode = false;
            // Initialize currencies.
            // Initialize currencies.
            _this.initCurrencies();
            _this.currencyPipe = new common.CurrencyPipe(env.locale);
            env.onLocaleChange.subscribe(function (locale) {
                _this.currencyPipe = new common.CurrencyPipe(locale);
                if (core$1.isPresent(_this.money)) {
                    _this.displayValue = _this.formatCurrency(_this.money.amount);
                }
            });
            return _this;
        }
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.money);
                this.initCurrencies();
                if (core$1.isBlank(this.currencySelection)) {
                    this.currencySelection = this._currencies[0];
                }
                // ready the money field if it exists. and override the existing values.
                if (this.money) {
                    this.currencySelection = this.money.currency;
                }
                else {
                    this.money = new Money(null, this.currencySelection);
                }
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.initCurrencies = /**
         * @return {?}
         */
            function () {
                if (!this._currencies || this._currencies.length === 0) {
                    this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
                }
            };
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param el
         */
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onFocus = /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (core$1.isPresent(this.money) && core$1.isPresent(this.money.amount)) {
                    this.displayValue = this.money.amount.toString();
                }
            };
        /**
         * display the formatted currency value when the user navigates away.
         * @param el
         */
        /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onBlur = /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
            function (el) {
                this.money = this.money.clone({ amount: Number(el.value) });
                this.displayValue = this.formatCurrency(this.money.amount);
                this.onModelChanged(this.money);
            };
        /**
         * @param {?} currency
         * @return {?}
         */
        CurrencyComponent.prototype.onSelection = /**
         * @param {?} currency
         * @return {?}
         */
            function (currency) {
                this.currencySelection = currency;
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
        CurrencyComponent.prototype.formatCurrency = /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
            function (val) {
                if (!val || val.length === 0) {
                    return val;
                }
                if (isNaN(val)) {
                    return val;
                }
                var /** @type {?} */ code = 'USD';
                if (this.currencySelection) {
                    code = this.currencySelection;
                }
                this.money = this.money.clone({ currency: this.currencySelection });
                // By default, the precision is 2. For example, 10.23 USD.
                var /** @type {?} */ digits = '1.0-2';
                // If precision is present, use it for format the money value for display.
                if (core$1.isPresent(this.precision)) {
                    digits = '1.0-' + this.precision;
                }
                return this.currencyPipe.transform(val, code, 'symbol', digits);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.getMoneyCurrency = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.displayValue) && this.displayValue.length > 0) {
                    return this.currencySelection;
                }
                return '';
            };
        Object.defineProperty(CurrencyComponent.prototype, "currencies", {
            get: /**
             * @return {?}
             */ function () {
                return this._currencies;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (core$1.isPresent(value)) {
                    this._currencies = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CurrencyComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if ((value instanceof Money) && !core$1.equals(value, this.money)) {
                    this.money = value;
                    if (core$1.isPresent(this.money.currency)) {
                        this.currencySelection = this.money.currency;
                    }
                    this.displayValue = this.formatCurrency(this.money.amount);
                    this.formControl.setValue(this.money);
                }
            };
        CurrencyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-currency',
                        template: "<ng-template [ngIf]=\"editable\">\n    <div class=\"w-currency-field ui-fluid\" [formGroup]=\"formGroup\">\n        <div class=\"ui-g \">\n            <div class=\"ui-g-8 ui-g-nopad \">\n                <input #currencyInput\n                       pInputText\n                       type=\"text\" class=\"w-text-field currency-format\"\n                       [attr.name]=\"name\"\n                       [attr.placeholder]=\"placeHolder\"\n                       [value]=\"displayValue\"\n                       (focus)=\"onFocus(currencyInput)\"\n                       (blur)=\"onBlur(currencyInput)\"\n                       [disabled]=\"disabled\">\n            </div>\n            <div class=\"ui-g-4 ui-g-nopad w-cc-field\">\n                <aw-dropdown *ngIf=\"!readonlyCurrencyCode\"\n                             [isStandalone]=\"false\" [list]=\"currencies\"\n                             [selection]=\"money.currency\"\n                             (onSelection)=\"onSelection($event)\"\n                             [disabled]=\"disabled\">\n\n                </aw-dropdown>\n                <div *ngIf=\"readonlyCurrencyCode\" class=\"w-cc-readonly-field\">{{money.currency}}</div>\n            </div>\n        </div>\n    </div>\n</ng-template>\n\n<!-- currency:'USD':true -->\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{displayValue}} {{ getMoneyCurrency() }}\"></aw-string>\n</ng-template>\n",
                        styles: [".w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}"],
                        providers: [
                            CURRENCY_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CurrencyComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CurrencyComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CurrencyComponent.propDecorators = {
            money: [{ type: core.Input }],
            readonlyCurrencyCode: [{ type: core.Input }],
            currencySelection: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            currencies: [{ type: core.Input }]
        };
        return CurrencyComponent;
    }(BaseFormComponent));
    /**
     * Money object is represented as a value, locale, and currencyCode
     */
    var /**
     * Money object is represented as a value, locale, and currencyCode
     */ Money = (function () {
        function Money(amount, currency, locale) {
            if (amount === void 0) {
                amount = 0;
            }
            if (currency === void 0) {
                currency = 'USD';
            }
            if (locale === void 0) {
                locale = 'en_US';
            }
            this.amount = amount;
            this.currency = currency;
            this.locale = locale;
        }
        /**
         * @return {?}
         */
        Money.prototype.getTypes = /**
         * @return {?}
         */
            function () {
                return {
                    amount: Number,
                    currency: String,
                    locale: String
                };
            };
        /**
         * @return {?}
         */
        Money.prototype.className = /**
         * @return {?}
         */
            function () {
                return 'Money';
            };
        /**
         * @return {?}
         */
        Money.prototype.$proto = /**
         * @return {?}
         */
            function () {
                return new Money(1, '23', '33');
            };
        /**
         * @return {?}
         */
        Money.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
            };
        /**
         * @param {?=} data
         * @return {?}
         */
        Money.prototype.clone = /**
         * @param {?=} data
         * @return {?}
         */
            function (data) {
                if (data === void 0) {
                    data = {};
                }
                return new Money(core$1.isPresent(data.amount) ? data.amount : this.amount, core$1.isPresent(data.currency) ? data.currency : this.currency, core$1.isPresent(data.locale) ? data.locale : this.locale);
            };
        return Money;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCurrencyModule = (function () {
        function AWCurrencyModule() {
        }
        AWCurrencyModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CurrencyComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextModule,
                            primeng.DropdownModule,
                            AWDropdownModule,
                            AWStringFieldModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            CurrencyComponent
                        ],
                        exports: [
                            CurrencyComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: [common.CurrencyPipe]
                    },] },
        ];
        return AWCurrencyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Lightweight and configurable Date and Time component based on the primeng. This
     * component combines both date picker as well as time picker
     *
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *
     *        date: Date = new Date();
     *
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     * By default you will see date field and time field is hidden to show both you just do following:
     *
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *
     *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *        date: Date = new Date();
     *        showTime = true;
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     *
     *
     */
    var /** @type {?} */ DATETIME_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DateAndTimeComponent; }),
        multi: true
    };
    var DateAndTimeComponent = (function (_super) {
        __extends(DateAndTimeComponent, _super);
        function DateAndTimeComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Default date format pattern used if none is passed
             *
             */
            _this.formatPattern = 'mm/dd/yy';
            /**
             * Special workaround as formatters in the primeNG and angular are different so until its
             * fixed we need to keep this extra pattern.
             */
            _this.formatPatternNG = 'MM/dd/yy';
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showNavigation = false;
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showIcon = true;
            /**
             * Whether to show timepicker
             */
            _this.showTime = false;
            /**
             * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
             * true
             */
            _this.showDate = true;
            /**
             *
             * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
             * it shows the AM, PM
             *
             */
            _this.hourFormat = '24';
            /**
             * Triggers event when specific date is clicked inside DatePicker
             *
             */
            _this.onChange = new core.EventEmitter();
            /**
             * Set the date to highlight on first opening if the field is blank.
             *
             */
            _this.defaultDate = new Date();
            _this.timePlaceHolder = 'hh:ss';
            return _this;
        }
        /**
         * @return {?}
         */
        DateAndTimeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                // default to dateTime pattern which is defined in resource files
                if (this.hourFormat !== '12' && this.hourFormat !== '24') {
                    this.hourFormat = '24';
                }
                this.timePlaceHolder = (this.hourFormat === '12') ?
                    " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
                this.initTranslations();
                this.env.onLocaleChange.subscribe(function (locale) {
                    _this.initTranslations();
                });
            };
        /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
        DateAndTimeComponent.prototype.initTranslations = /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
            function () {
                this.formatNameWithTime = this.formatPattern;
                if (!this.showDate) {
                    this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                if (this.showTime) {
                    var /** @type {?} */ timeStarts = this.formatPattern.indexOf('h');
                    if (timeStarts !== -1) {
                        this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
                    }
                    this.formatPatternNG += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                this.i18n = {
                    firstDayOfWeek: 0,
                    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                        'Saturday'],
                    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                        'September', 'October', 'November', 'December'],
                    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                        'Nov', 'Dec']
                };
            };
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         */
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
        DateAndTimeComponent.prototype.onDateChange = /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event)) {
                    // throw some error ?
                    return;
                }
                this.value = core$1.isDate(event) ? event : new Date(event);
                this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
                this.onModelChanged(this.value);
                this.onChange.emit(this.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DateAndTimeComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        DateAndTimeComponent.NgTime12 = 'hh:mm a';
        DateAndTimeComponent.NgTime24 = 'HH.mm a';
        DateAndTimeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-date-time',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <div class=\"w-datetime \" [class.has-time]=\"showTime\" [formGroup]=\"formGroup\">\n\n        <p-calendar formControlName=\"{{name}}\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    dateFormat=\"{{showTime ? formatNameWithTime : formatPattern}}\"\n                    [yearNavigator]=\"showNavigation\"\n                    [monthNavigator]=\"showNavigation\"\n                    [yearRange]=\"yearRange\"\n                    placeholder=\"{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [timeOnly]=\"!showDate\"\n                    [readonlyInput]=\"true\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n        <p-calendar *ngIf=\"showTime\"\n                    icon=\"icon-history\"\n                    formControlName=\"{{name}}\"\n                    [hourFormat]=\"hourFormat\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    [timeOnly]=\"showTime\"\n                    [showTime]=\"showTime\"\n                    [placeholder]=\"timePlaceHolder\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n    </div>\n</ng-template>\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{value | date: formatPatternNG}}\"></aw-string>\n</ng-template>\n",
                        styles: ["/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}"],
                        providers: [
                            DATETIME_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DateAndTimeComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        DateAndTimeComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        DateAndTimeComponent.propDecorators = {
            value: [{ type: core.Input }],
            formatPattern: [{ type: core.Input }],
            formatPatternNG: [{ type: core.Input }],
            showNavigation: [{ type: core.Input }],
            yearRange: [{ type: core.Input }],
            showIcon: [{ type: core.Input }],
            showTime: [{ type: core.Input }],
            showDate: [{ type: core.Input }],
            hourFormat: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return DateAndTimeComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDateAndTimeModule = (function () {
        function AWDateAndTimeModule() {
        }
        AWDateAndTimeModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DateAndTimeComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CalendarModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            DateAndTimeComponent
                        ],
                        exports: [
                            DateAndTimeComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ]
                    },] },
        ];
        return AWDateAndTimeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogHeaderComponent = (function () {
        function DialogHeaderComponent() {
        }
        DialogHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-header',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DialogHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogFooterComponent = (function () {
        function DialogFooterComponent() {
        }
        DialogFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-footer',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DialogFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Dialog Component that provides the look and feel for a modal dialog. This component has three
     * sections: header, body, and footer. It can be used by itself or extended.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
     *
     * Usage:
     *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
     * message to the user.
     *
     *             this.modalService.open<DialogComponent>( DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-dialog [(visible)]="display" [modal]="true"
     *                                        (onOpen)="openAction()" (onClose)="closeAction()">
     *
     *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
     *
     *                                     Dialog Body: Creating a dialog using the dialog component
     *
     *                                    <aw-dialog-footer>
     *                                      <aw-button [size]="'small'" [style]="'primary'"
     *                                                 (click)="close()">OK</aw-button>
     *                                    </aw-dialog-footer>
     *                              </aw-dialog>
     *
     *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     dialogAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     openAction()  {
     *                        this.dialogAction = "open";
     *                      }
     *       }
     *
     *
     */
    var DialogComponent = (function (_super) {
        __extends(DialogComponent, _super);
        function DialogComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * whether this dialog blocks the rest of the page or not when displayed.
             */
            _this.modal = true;
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = true;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            _this.width = 300;
            _this.height = 'auto';
            return _this;
        }
        /**
         * Open this dialog.
         */
        /**
         * Open this dialog.
         * @return {?}
         */
        DialogComponent.prototype.open = /**
         * Open this dialog.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                // visible is a 2-way binding variable.
                this.visibleChange.emit(true);
            };
        /**
         * close the dialog
         */
        /**
         * close the dialog
         * @return {?}
         */
        DialogComponent.prototype.close = /**
         * close the dialog
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does this dialog have header.
         *
         */
        /**
         * Does this dialog have header.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasHeader = /**
         * Does this dialog have header.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does this dialog have footer.
         *
         */
        /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasFooter = /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        DialogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog',
                        template: "<p-dialog [header]=\"title\" [(visible)]=\"visible\"\n          [modal]=\"modal\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n          [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onShow)=\"open()\" (onHide)=\"close()\">\n\n    <p-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-dialog-header\"></ng-content>\n    </p-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n    <p-footer *ngIf=\"hasFooter()\">\n        <div class=\"dialog-footer-separator\"></div>\n        <ng-content select=\"aw-dialog-footer\"></ng-content>\n    </p-footer>\n</p-dialog>\n",
                        styles: ["::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}"]
                    },] },
        ];
        /** @nocollapse */
        DialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        DialogComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            modal: [{ type: core.Input }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DialogHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [DialogFooterComponent,] }]
        };
        return DialogComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDialogModule = (function () {
        function AWDialogModule() {
        }
        AWDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            primeng.DialogModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        exports: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] },
        ];
        return AWDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
     * Chooser. The type of the chooser may be determined dynamically based on the number of items in
     * the data source list, or can be specified explicitly via the "type" binding.
     *
     *
     *
     */
    var GenericChooserComponent = (function (_super) {
        __extends(GenericChooserComponent, _super);
        function GenericChooserComponent(env, _viewContainer, dataSource, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.dataSource = dataSource;
            _this.parentContainer = parentContainer;
            /**
             *  Is this a List property, or a to-one.
             */
            _this.multiselect = false;
            return _this;
        }
        /**
         * @return {?}
         */
        GenericChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.object)) {
                    this.object = ((this._viewContainer.injector)).view.context;
                }
                this.keyPath = new core$1.FieldPath(this.key);
                var /** @type {?} */ defaultDataProvider = null;
                if (core$1.isPresent(this.list)) {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.list);
                }
                else {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
                }
                var /** @type {?} */ projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
                this.initType(projectedSize);
                if (this.type === 'Chooser') {
                    this.dataSource.init({
                        dataProvider: defaultDataProvider,
                        queryType: QueryType.FullText,
                        lookupKey: this.displayKey,
                        state: new ChooserState(new GCChooserState(this), this.multiselect),
                        multiselect: this.multiselect
                    });
                }
                else {
                    // do we need to read this value in async?
                    this.list = defaultDataProvider.data();
                }
                _super.prototype.registerFormControl.call(this, this.selection);
                this.validateRequired();
                if (core$1.isBlank(this.selection)) {
                    // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
                    this.noSelectionString = 'Select a Item';
                }
            };
        /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
        GenericChooserComponent.prototype.initType = /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
            function (projectedSize) {
                if (core$1.isBlank(this.type)) {
                    if (this.multiselect) {
                        this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
                    }
                    else {
                        this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                            : (projectedSize < 6) ? 'Radio' :
                                'Dropdown';
                    }
                }
            };
        /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
        GenericChooserComponent.prototype.validateRequired = /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.object)) {
                    throw Error('Cannot continue without a object');
                }
                if (core$1.isBlank(this.key)) {
                    throw Error('Cannot continue without a key binding');
                }
                if (core$1.isBlank(this.list) && core$1.isBlank(this.destinationClass)) {
                    throw Error('Cannot continue without having either list of values or destinationClass');
                }
                if (core$1.isPresent(this.type) &&
                    (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                        this.type !== 'Chooser')) {
                    throw Error('Cannot instantiate GenericChooser  - invalid type');
                }
                if (core$1.isBlank(this.displayKey)) {
                    this.displayKey = 'toString';
                }
            };
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         */
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
        GenericChooserComponent.prototype.displayValue = /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.displayKey)) {
                    return item;
                }
                var /** @type {?} */ fieldValue = core$1.FieldPath.getFieldValue(item, this.displayKey);
                if (core$1.isFunction(fieldValue)) {
                    return fieldValue.call(item);
                }
                return fieldValue;
            };
        Object.defineProperty(GenericChooserComponent.prototype, "selection", {
            /**
             *  Retrieve a current value from the parent/target object
             *
             */
            get: /**
             *  Retrieve a current value from the parent/target object
             *
             * @return {?}
             */ function () {
                return this.keyPath.getFieldValue(this.object);
            },
            /**
             *  set value back to the object
             *
             */
            set: /**
             *  set value back to the object
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.keyPath.setFieldValue(this.object, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        GenericChooserComponent.prototype.onSelection = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value;
                this.formControl.setValue(this.selection);
                this.formControl.markAsDirty();
            };
        GenericChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-chooser',
                        template: "<ng-container [ngSwitch]=\"type\">\n\n    <ng-template [ngSwitchCase]=\"'Checkbox'\">\n        <aw-checkbox-list [list]=\"list\"\n                          [editable]=\"editable\"\n                          [selections]=\"selection\"\n                          [name]=\"name\"\n                          [disabled]=\"disabled\"\n                          [labelFormatter]=\"displayValue\"\n                          (onSelection)=\"onSelection($event)\">\n        </aw-checkbox-list>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Radio'\">\n        <aw-radiobutton-list [list]=\"list\"\n                             [selection]=\"selection\"\n                             [editable]=\"editable\"\n                             [name]=\"name\"\n                             [disabled]=\"disabled\"\n                             [labelFormatter]=\"displayValue\"\n                             (onSelection)=\"onSelection($event)\">\n        </aw-radiobutton-list>\n    </ng-template>\n\n    <ng-template [ngSwitchCase]=\"'Dropdown'\">\n        <aw-dropdown [list]=\"list\"\n                     [isStandalone]=\"false\"\n                     [editable]=\"editable\"\n                     [noSelectionString]=\"noSelectionString\"\n                     [selection]=\"selection\"\n                     [disabled]=\"disabled\"\n                     [name]=\"name\"\n                     (onSelection)=\"onSelection($event)\">\n            <ng-template #itemTemplate let-item>\n\n                <!-- todo: allow to pass a PIPE to do some additional formatting -->\n                {{ displayValue(item.value) }}\n            </ng-template>\n        </aw-dropdown>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Chooser'\">\n        <aw-chooser #chooser\n                    [editable]=\"editable\"\n                    [isStandalone]=\"false\"\n                    [name]=\"name\"\n                    [multiselect]=\"multiselect\"\n                    [dataSource]=\"dataSource\"\n                    [valueTransformer]=\"displayValue\"\n                    [disabled]=\"disabled\">\n\n        </aw-chooser>\n\n    </ng-template>\n\n</ng-container>\n",
                        styles: [""],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return GenericChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ]
                    },] },
        ];
        /** @nocollapse */
        GenericChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        GenericChooserComponent.propDecorators = {
            list: [{ type: core.Input }],
            object: [{ type: core.Input }],
            key: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            choiceProviderParams: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            type: [{ type: core.Input }],
            displayKey: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }]
        };
        return GenericChooserComponent;
    }(BaseFormComponent));
    /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */
    var /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */ GCChooserState = (function (_super) {
        __extends(GCChooserState, _super);
        function GCChooserState(gChooser) {
            var _this = _super.call(this) || this;
            _this.gChooser = gChooser;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        GCChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected === this.isSelected(selection)) {
                    return;
                }
                if (this.gChooser.multiselect) {
                    // Check if we can implement smarter and more generic way how we use it in java
                    // RelationshipField.addTo(_object, _keyPath, selection);
                    var /** @type {?} */ multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
                    if (core$1.isBlank(multiRel)) {
                        multiRel = [];
                    }
                    else if (core$1.isPresent(multiRel) && !core$1.isArray(multiRel)) {
                        throw new Error('I can not store multiselect value into non-array object');
                    }
                    if (selected) {
                        multiRel.push(selection);
                        this.gChooser.selection = multiRel;
                    }
                    else {
                        core$1.ListWrapper.removeIfExist(multiRel, selection);
                    }
                }
                else {
                    if (!selection) {
                        selection = null;
                    }
                    this.gChooser.selection = selection;
                }
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                if (this.gChooser.multiselect) {
                    var /** @type {?} */ objects = this.selectedObjects();
                    return (core$1.isBlank(objects) || core$1.ListWrapper.isEmpty(objects)) ? null : core$1.ListWrapper.last(objects);
                }
                return this.gChooser.selection;
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ selection = this.gChooser.selection;
                if (this.gChooser.multiselect && core$1.isBlank(selection)) {
                    selection = [];
                }
                return (this.gChooser.multiselect && core$1.isArray(selection)) ? selection : [selection];
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        GCChooserState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                if (this.gChooser.multiselect) {
                    return core$1.ListWrapper.containsComplex(this.selectedObjects(), selection);
                }
                var /** @type {?} */ curValue = this.selectedObject();
                return core$1.equals(curValue, selection);
            };
        return GCChooserState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
     *
     *
     * ### Example
     *
     *
     * ```
     * \@Component({
     *          selector: 'gender-selector' ,
     *          template: `
     *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
     *     [selection]="selectedValue" [name]="'name'">
     *               </aw-radiobutton-list>
     *      `
     *      })
     *      export class GenderSelectorComponent
     *      {
     *          rbListValues: string[] = ['male' , 'female' , 'other'];
     *          selectedValue: string = 'other';
     *          layout: string = 'stacked';
     *
     *
     *          formGroup: FormGroup = new FormGroup({});
     *
     *
     *          onCBClick (event): void
     *          {
     *              console.log('onCBClick = ' + event);
     *          }
     *
     *      }
     *
     * ```
     */
    var /** @type {?} */ RB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonListComponent; }),
        multi: true
    };
    var RadioButtonListComponent = (function (_super) {
        __extends(RadioButtonListComponent, _super);
        function RadioButtonListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Fires an event when radio button is selected
             *
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.selection)) {
                    this.model = 0;
                }
                this.updateModel(this.selection);
                this.onModelChanged(this.selection);
                this.registerFormControl(this.selection);
            };
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         */
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.labelValue = /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         */
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
        RadioButtonListComponent.prototype.onChange = /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ updatedModel = this.list[this.model];
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
        RadioButtonListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
            function (souceItem) {
                var /** @type {?} */ index = this.list.findIndex(function (elem) {
                    return souceItem === elem;
                });
                this.model = index === -1 ? 0 : index;
            };
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ updatedModel = this.list[this.model];
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                // this.cd.detectChanges();
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    var /** @type {?} */ newModel = value;
                    this.updateModel(newModel);
                }
            };
        RadioButtonListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton-list',
                        template: "<div *ngFor=\"let item of list;  let i = index\" class=\"ui-g\">\n\n    <div class=\"ui-g-12\">\n        <aw-radiobutton\n            [(ngModel)]=\"model\"\n            (ngModelChange)=\"onChange($event)\"\n            [isStandalone]=\"false\"\n            [name]=\"name\"\n            [value]=\"i\"\n            [label]=\"labelValue(item)\">\n        </aw-radiobutton>\n    </div>\n\n</div>\n",
                        styles: [""],
                        providers: [
                            RB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            labelFormatter: [{ type: core.Input }],
            onSelection: [{ type: core.Output }]
        };
        return RadioButtonListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Implements standard HTML radio button on top of PrimeNG with ariba styling
     *
     * ### Example
     *
     * 1. Basic usage using ngModel pre-selected first radio
     *
     *  ```ts
     *
     * \@Component({
     *          selector: 'demo-comp',
     *          template: `
     *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
     *                             [(ngModel)]="model">
     *             </aw-radiobutton>
     *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                      [(ngModel)]="model">
     *              </aw-radiobutton>
     *      `
     *      })*
     *      class BasicWithNgModelComponent
     *      {
     *          model: string[] = ['red'];
     *
     *          constructor()
     *          {
     *          }
     *      }
     *
     *  ```
     *
     *
     * 2. Basic usage with formGroup
     *
     *
     * ```ts
     * \@Component({
     *           selector: 'demo-comp',
     *           template: `
     *          <div [formGroup]="env.currentForm">
     *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *
     *       </div>
     *       `
     *       })
     *       class BasicWithFormGroupComponent implements OnInit
     *       {
     *           model: string = 'blue';
     *
     *           constructor(public env: Environment)
     *           {
     *           }
     *
     *           ngOnInit(): void
     *           {
     *               this.env.currentForm = new FormGroup({});
     *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
     *           }
     *
     *
     *           onChange(event: any): void
     *           {
     *               this.modelSet = event;
     *           }
     *
     *       }
     *  ````
     *
     *
     *
     *
     */
    var /** @type {?} */ RAB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var RadioButtonComponent = (function (_super) {
        __extends(RadioButtonComponent, _super);
        function RadioButtonComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this radio
             *
             */
            _this.value = '';
            /**
             * Trigger click event with currrent selected value
             *
             */
            _this.onChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.value);
                    this.model = this.formControl.value;
                    this.onModelChanged(this.model);
                }
                else {
                    this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                }
            };
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         */
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
        RadioButtonComponent.prototype.onModelChange = /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
            function (newVal) {
                this.onModelChanged(this.model);
                if (this.isStandalone) {
                    this.formControl.setValue(this.model, { emitEvent: true });
                }
                this.onChange.emit(this.model);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model, { emitEvent: true });
                    }
                    this.onModelChanged(this.model);
                }
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton',
                        template: "<span class=\"w-radiobutton\">\n\n    <ng-template [ngIf]=\"editable \">\n        <p-radioButton [name]=\"name\"\n                       [value]=\"value\"\n                       [label]=\"label\"\n                       [(ngModel)]=\"model\"\n                       [disabled]=\"disabled\"\n                       (ngModelChange)=\"onModelChange($event)\"\n                       [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\">\n        </p-radioButton>\n    </ng-template>\n</span>\n",
                        styles: ["/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}"],
                        providers: [
                            RAB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonComponent.propDecorators = {
            value: [{ type: core.Input }],
            label: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return RadioButtonComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRadioButtonModule = (function () {
        function AWRadioButtonModule() {
        }
        AWRadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.RadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonComponent
                        ],
                        exports: [
                            RadioButtonComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRadioButtonListModule = (function () {
        function AWRadioButtonListModule() {
        }
        AWRadioButtonListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWRadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonListComponent
                        ],
                        exports: [
                            RadioButtonListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRadioButtonListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWGenericChooserModule = (function () {
        function AWGenericChooserModule() {
        }
        AWGenericChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            GenericChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWDropdownModule,
                            AWCheckBoxListModule,
                            AWChooserModule,
                            AWRadioButtonListModule
                        ],
                        entryComponents: [
                            GenericChooserComponent
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            GenericChooserComponent
                        ]
                    },] },
        ];
        return AWGenericChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
     * holds all important information for the current outline tree and manages expansion states in form
     * of so called expansionPath and expansionStates
     *
     * We need to have a way how to work with generic data structure in order not to hold UI specific
     * information on the domain object model just like we had it before, where we had an interface
     * called OutlineNode, with fields (expanded, selected, etc.. )
     *
     *
     * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
     * OutlineController.
     *
     *
     * If we are dealing with Entity or anything that has identity then we have easier situation as we
     * can ask for ID and it is more efficient for serialization
     */
    var OutlineState = (function () {
        function OutlineState() {
            /**
             *
             * When outline is rendered for first time or re-rendered and we set default value for the
             * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
             *
             */
            this.isExpandedAll = false;
            /**
             *
             * Holds current level during tree node rendering so we can apply correct indentation
             *
             */
            this.currentLevel = -1;
            this.expansionStates = new Map();
        }
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         */
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
        OutlineState.prototype.collapseAll = /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    // for this case we collapse all but root nodes
                    if (this.outlineFor.pushRootSectionOnNewLine) {
                        this.outlineFor.list.forEach(function (item) {
                            _this.updateNodes(item.children || [], false);
                        });
                    }
                    else {
                        this.updateNodes(this.outlineFor.list || [], false);
                    }
                }
                else {
                    this.expansionStates.clear();
                }
                this.isExpandedAll = false;
            };
        /**
         * @return {?}
         */
        OutlineState.prototype.expandAll = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    this.updateNodes(this.outlineFor.list, true);
                }
                else {
                    this.expansionStates.clear();
                }
                this.isExpandedAll = true;
            };
        Object.defineProperty(OutlineState.prototype, "expansionPath", {
            get: /**
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._expansionPath)) {
                    this._expansionPath = [];
                }
                return this._expansionPath;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                this._expansionPath = value;
                if (core$1.isBlank(this._expansionPath)) {
                    return;
                }
                this._expansionPath.forEach(function (item) {
                    _this.setExpansionState(item, true);
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} currentPath
         * @param {?=} children
         * @return {?}
         */
        OutlineState.prototype.toggleExpansion = /**
         * @param {?} currentPath
         * @param {?=} children
         * @return {?}
         */
            function (currentPath, children) {
                if (core$1.isBlank(currentPath)) {
                    return;
                }
                var /** @type {?} */ item = core$1.ListWrapper.last(currentPath);
                var /** @type {?} */ itemChildren = children || [];
                var /** @type {?} */ newState = !this.isExpanded(item);
                this.setExpansionState(item, newState);
                if (!newState) {
                    core$1.ListWrapper.removeLast(currentPath);
                    this.updateNodes(itemChildren, newState);
                }
                this.setExpansionPath(currentPath);
            };
        /**
         * @param {?} nodes
         * @param {?} newState
         * @return {?}
         */
        OutlineState.prototype.updateNodes = /**
         * @param {?} nodes
         * @param {?} newState
         * @return {?}
         */
            function (nodes, newState) {
                var _this = this;
                nodes.forEach(function (child) {
                    var /** @type {?} */ items = _this.outlineFor.childrenForItem(child);
                    if (core$1.isPresent(items) && items.length > 0) {
                        _this.updateNodes(items, newState);
                    }
                    _this.setExpansionState(child, newState);
                });
            };
        /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
        OutlineState.prototype.setExpansionState = /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
            function (item, isExpanded) {
                // Even for tree mode format save the state so we can use it later on in case object
                // references gets meesed up
                if (this.outlineFor &&
                    this.outlineFor.isTreeModelFormat()) {
                    ((item)).isExpanded = isExpanded;
                }
                else {
                    var /** @type {?} */ key = this.itemToKey(item);
                    if (isExpanded === this.isExpandedAll) {
                        this.expansionStates.delete(key);
                    }
                    else {
                        this.expansionStates.set(key, (isExpanded) ? true : false);
                    }
                }
            };
        /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.itemToKey = /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        /**
         * @param {?} items
         * @return {?}
         */
        OutlineState.prototype.setExpansionPath = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                this.expansionPath = items;
                items.forEach(function (node) {
                    _this.setExpansionState(node, true);
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.outlineFor) &&
                    this.outlineFor.isTreeModelFormat()) {
                    return ((item)).isExpanded;
                }
                else {
                    var /** @type {?} */ key = this.itemToKey(item);
                    if (!this.expansionStates.has(key)) {
                        return this.isExpandedAll;
                    }
                    return this.expansionStates.get(key);
                }
            };
        OutlineState.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        OutlineState.ctorParameters = function () { return []; };
        return OutlineState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Checks type for OutlineNode
     *
     * @param {?} node
     * @return {?}
     */
    function isOutlineNode(node) {
        return core$1.isPresent(node) && core$1.isPresent(((node)))
            && core$1.isPresent(((node)).parent)
            && core$1.isPresent(((node)).children);
    }
    /**
     *
     * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
     * those cases where an item may have children.
     *
     *
     * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
     * and other things.
     *
     *
     * This component has minimal styling to make sure it can be changed easily.
     *
     * ### Example rendering tree section, where based on the type we format the out plus
     * for the main root section we always render little popup menu.
     *
     * ```
     *
     *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
     *
     *       <ng-template #outline let-item>
     *
     *           <div class="my-section">
     *               <div class="outline">
     *                   <aw-outline-control>
     *                       <ng-container [ngSwitch]="item.type">
     *                           <ng-template [ngSwitchCase]="'text'">
     *                               <div class="as-paragraf">
     *                                   {{item?.content}}
     *                               </div>
     *                           </ng-template>
     *
     *
     *                           <ng-template ngSwitchDefault>
     *                               {{item?.content}}
     *                           </ng-template>
     *
     *
     *                       </ng-container>
     *
     *
     *                   </aw-outline-control>
     *               </div>
     *
     *               <div class="filters" *ngIf="item.type === 'section'" >
     *
     *                   <aw-hover-card [linkTitle]="'Filter Items'">
     *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
     *                   </aw-hover-card>
     *
     *               </div>
     *           </div>
     *     </ng-template>`
     *   </aw-outline-for>
     *
     * ```
     *
     *
     * We can use it also in embedded mode where we use the `awOutlineFor` directive
     *
     * ## Example
     *
     *
     * ````
     *  <table  class="tree-table" >
     *      <thead>
     *          <tr>
     *              <th>Name</th>
     *              <th>Type</th>
     *          </tr>
     *      </thead>
     *      <tbody #ooo2 awOutlineFor [list]="list"
     *             [hasChildren]="hasChildren"
     *             class="outline-table"
     *      >
     *          <ng-template #outline let-item>
     *              <tr>
     *                  <td class="item-name outline-animation">
     *                      <div><aw-outline-control>
     *                          {{item?.content}}
     *                      </aw-outline-control></div>
     *                  </td>
     *                  <td class="item-type outline-animation">
     *                      <div>{{item.type}}</div>
     *                  </td>
     *              </tr>
     *          </ng-template>
     *      </tbody>
     *  </table>
     *
     * ```
     *
     * I was thinking maybe for first time we don't need the same animation like expanding and
     * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
     * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
     * execute the same rendering just without [\@section]
     *
     *
     * Todo: Think about how to do animation for the table case. Must also write unitest - due to
     * AribaLive aggressive schedule we are skipping them for now
     *
     */
    var OutlineForComponent = (function (_super) {
        __extends(OutlineForComponent, _super);
        function OutlineForComponent(env, _viewContainer, builder, element) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.builder = builder;
            _this.element = element;
            /**
             * Tells the component not to render expansion control, in such case we expandAll as a
             * default behavior
             *
             */
            _this.showExpansionControl = true;
            /**
             * Opens all tree nodes.
             *
             */
            _this.expandAll = false;
            /**
             *
             * Set indentation size to be used for each level
             *
             */
            _this.indentationPerLevel = 25;
            _this.pushRootSectionOnNewLine = false;
            /**
             *
             * Identifies current model mode.
             *
             * We recognize two modes:
             *
             * Free - Application needs to implement a children method to retrieve a list of children for
             * each node and format is pretty much upt to the application
             *
             * Tree - this is more restrictive where we have concrete data structure
             * interface that needs to be folled
             *
             * todo: instead of passing format binding try to look into the list to see what type so
             * we dont make it mandatory
             *
             */
            _this.format = 'free';
            /**
             *
             * Used when in selection mode to push current selected Item to the application
             *
             */
            _this.onItemSelected = new core.EventEmitter();
            /**
             *
             * This event is triggered by OutlineControl when node is expanded or collapsed
             *
             */
            _this.onExpandChange = new core.EventEmitter();
            _this.embedded = false;
            /**
             * Flag that tells us that component is fully rendered
             *
             */
            _this.viewInitialized = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.state)) {
                    this.state = new OutlineState();
                }
                if (core$1.isBlank(this.state.outlineFor)) {
                    this.state.outlineFor = this;
                }
                if (this.expandAll) {
                    this.showExpansionControl = false;
                }
                this.state.isExpandedAll = this.expandAll;
                // in case we want to render content of tree outside of outlineFor
                if (core$1.isPresent(this.externalTemplate)) {
                    this.controlTemplate = this.externalTemplate;
                }
                this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
                if (core$1.isBlank(this.context)) {
                    this.context = this;
                }
            };
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
            };
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.isTreeModelFormat = /**
         * @return {?}
         */
            function () {
                return this.format === 'tree';
            };
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         */
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.isExpanded = /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
            function (item, currentLevel) {
                if (currentLevel === void 0) {
                    currentLevel = -1;
                }
                if (currentLevel === 0 && this.pushRootSectionOnNewLine) {
                    // always override/reset for root nodes
                    if (this.isTreeModelFormat()) {
                        ((item)).isExpanded = true;
                    }
                    return true;
                }
                return this.state.isExpanded(item);
            };
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         */
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.childrenForItem = /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.isTreeModelFormat()) {
                    return ((item)).children || [];
                }
                else {
                    return this.hasChildren(item) ? this.doGetChildren(item) : [];
                }
            };
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         */
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.hasChildren = /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.isTreeModelFormat()) {
                    var /** @type {?} */ children = ((item)).children;
                    return core$1.isPresent(children) && children.length > 0;
                }
                else if (core$1.isBlank(this.children) && core$1.isBlank(item.children)) {
                    core$1.assert(false, 'Missing [children] method binding');
                }
                return this.doGetChildren(item).length > 0;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.doGetChildren = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.children.apply(this.context, [item]);
            };
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         */
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
        OutlineForComponent.prototype.toggleExpansion = /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.animationInProgress) {
                    // backup procedure in case onAnimationDone fails
                    setTimeout(function () {
                        if (_this.animationInProgress) {
                            // change only if its fails
                            _this.animationInProgress = false;
                        }
                    }, 200);
                    return;
                }
                if (!this.embedded) {
                    this.animationInProgress = true;
                }
                var /** @type {?} */ currentItem = core$1.ListWrapper.last(this.state.currentPath);
                this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
                if (this.embedded) ;
            };
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         */
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
        OutlineForComponent.prototype.onAnimationDone = /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.animationInProgress = false;
            };
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         */
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.indentation = /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
            function (currentLevel) {
                if (this.pushRootSectionOnNewLine && currentLevel > 0) {
                    currentLevel -= 1;
                }
                return (currentLevel === 0 && this.pushRootSectionOnNewLine)
                    ? 0 : (this.indentationPerLevel * currentLevel);
            };
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         */
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.isVisible = /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.filterOut)) {
                    return !this.filterOut(item);
                }
                return true;
            };
        OutlineForComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-for, [awOutlineFor]',
                        template: "<!--\n    Starts with the list, where nestingLevel is -1.\n    call template outlineItems to iterate and render each item\n-->\n<ng-container [ngIf]=\"list\" *ngTemplateOutlet=\"outlineItems;\n            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}\">\n</ng-container>\n\n<!--\n    Main Entry point for the recursion. this is called by the block above as well as byt the inner\n    piece that calls this template recursively again when an item has children\n-->\n<ng-template #outlineItems let-children let-nestingLevel=\"nestingLevel\"\n             let-parent=\"parentItem\" let-expanded=\"expanded\">\n\n    <ng-template ngFor let-item [ngForOf]=\"children\" let-rowIndex=\"index\">\n\n        <ng-container *ngTemplateOutlet=\"outlineItem;\n            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,\n            expanded: expanded, rowIndex:rowIndex}\">\n        </ng-container>\n\n        <!--\n\n            Recursion piece:\n\n            For non embedded case when even if its not expanded we need to iterate children\n            as we want to apply animation that should go with ngIf which inside the outineItem\n            template\n\n            Dont recurse/ render items that are not visible.\n        -->\n\n        <ng-template [ngIf]=\"hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)\">\n            <ng-container *ngTemplateOutlet=\"outlineItems;\n                        context:{ $implicit: childrenForItem(item),\n                                nestingLevel: nestingLevel+1,\n                                expanded: isExpanded(item, nestingLevel),\n                                parentItem:item }\">\n            </ng-container>\n        </ng-template>\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Renders actual outline node and applies animation while expanding and collapsing\n\n    [@section]=\"expanded || isExpanded(item) ? 'visible' : 'hidden'\"\n-->\n<ng-template #outlineItem let-item let-nestingLevel=\"nestingLevel\" let-parent=\"parentItem\"\n             let-rowIndex=\"rowIndex\"\n             let-expanded=\"expanded\">\n\n    <div class=\"w-outline-item\"\n         *ngIf=\"!embedded && expanded\"\n         [style.padding-left.px]=\"indentation(nestingLevel)\"\n         initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n         [setCurrrentItem]=\"item\"\n         [@section]\n         (@section.done)=\"onAnimationDone($event)\">\n\n        <ng-container *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }\">\n        </ng-container>\n    </div>\n\n    <!--\n        When outline control is used as embedded meaning its inside e..g datatable we\n        cannot have any tags around it.\n\n        Todo: Refactor this in the way so we can do animation when table lines are\n        expanded. Since its embedded we can not have any wrapping element around, the template\n        is fully responsible\n    -->\n    <ng-template [ngIf]=\"embedded && expanded\"\n                 initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n                 [setCurrrentItem]=\"item\"\n    >\n        <ng-container #renderedItem *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }\">\n        </ng-container>\n    </ng-template>\n\n</ng-template>\n\n\n",
                        styles: [".is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}"],
                        animations: [
                            animations.trigger('section', [
                                animations.state('*', animations.style({
                                    'overflow-y': 'hidden',
                                    'height': '*',
                                    'opacity': '1'
                                })),
                                animations.state('void', animations.style({
                                    'height': '0',
                                    'opacity': '0',
                                    'overflow-y': 'hidden'
                                })),
                                animations.transition('* => void', animations.animate('200ms ease-out')),
                                animations.transition('void => *', animations.animate('200ms ease-in'))
                            ]),
                        ]
                    },] },
        ];
        /** @nocollapse */
        OutlineForComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: animations.AnimationBuilder },
                { type: core.ElementRef }
            ];
        };
        OutlineForComponent.propDecorators = {
            list: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            children: [{ type: core.Input }],
            filterOut: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            state: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            externalTemplate: [{ type: core.Input }],
            context: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            format: [{ type: core.Input }],
            onItemSelected: [{ type: core.Output }],
            onExpandChange: [{ type: core.Output }],
            controlTemplate: [{ type: core.ContentChild, args: ['outline',] }],
            outlineItem: [{ type: core.ViewChild, args: ['renderedItem',] }]
        };
        return OutlineForComponent;
    }(BaseComponent));
    /**
     *
     * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
     * use this directive to do the Job
     *
     */
    var InitNestingDirective = (function () {
        function InitNestingDirective(outline) {
            this.outline = outline;
        }
        /**
         * @return {?}
         */
        InitNestingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.setLevel)) {
                    this.outline.state.currentLevel = this.setLevel;
                }
                if (core$1.isPresent(this.setCurrrentItem)) {
                    this.outline.currentItem = this.setCurrrentItem;
                    if (this.outline.isTreeModelFormat()) {
                        this.outline.currentItem['$$parentItem']
                            = ((this.setCurrrentItem)).parent;
                    }
                }
                if (!this.outline.isTreeModelFormat() && core$1.isPresent(this.setParentItem)) {
                    this.outline.currentItem['$$parentItem'] = this.setParentItem;
                }
            };
        InitNestingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[initNesting]'
                    },] },
        ];
        /** @nocollapse */
        InitNestingDirective.ctorParameters = function () {
            return [
                { type: OutlineForComponent }
            ];
        };
        InitNestingDirective.propDecorators = {
            setLevel: [{ type: core.Input }],
            setCurrrentItem: [{ type: core.Input }],
            setParentItem: [{ type: core.Input }]
        };
        return InitNestingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
     * It should be used either in the body of an OutlineFor component, or inside datatable
     *
     *
     * ##Usage inside body:
     *
     *  Here you can see that we need to wrap out content inside ng-template which will push us
     *  give us current item item and then we can place OutlineControlComponent to control
     *  the tree.
     *
     * ```
     *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
     *
     *      <ng-template #outline let-item>
     *          <div class="my-section">
     *              <div class="outline">
     *                  <aw-outline-control>
     *                      {{item?.content}}
     *                  </aw-outline-control>
     *              </div>*
     *          </div>
     *      </ng-template>
     *  </aw-outline-for2>
     *
     *
     * ```
     *
     * We can
     *
     *
     */
    var OutlineControlComponent = (function (_super) {
        __extends(OutlineControlComponent, _super);
        function OutlineControlComponent(env, outlineState, parentControl, outlineFor) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.outlineState = outlineState;
            _this.parentControl = parentControl;
            _this.outlineFor = outlineFor;
            /**
             *
             *  If TRUE it changes the behavior of the outline node text which click is triggered
             *  it selects the item and broadcast the `onItemSelected` event
             *
             */
            _this.allowSelection = false;
            _this.allowEdit = false;
            /**
             *
             * Triggers action when outline item is expanded
             *
             */
            _this.action = new core.EventEmitter();
            _this.isRootItem = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.prepareControl();
            };
        /**
         *
         * We dont show expansion icons when there no children
         *
         */
        /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
        OutlineControlComponent.prototype.hasExpansionControl = /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
            function () {
                return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.isSelected = /**
         * @return {?}
         */
            function () {
                return this.outlineFor.state.selectedItem === this.item;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.calculateStyleClass = /**
         * @return {?}
         */
            function () {
                if (!this.hasExpansionControl() ||
                    (this.outlineFor.pushRootSectionOnNewLine && core$1.isBlank(this.item.$$parentItem))) {
                    return '';
                }
                if (this.outlineFor.embedded) {
                    return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                        : 'icon-slim-arrow-right';
                }
                else {
                    return this.outlineFor.isExpanded(this.item)
                        ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
                }
            };
        /**
         * Collapses and expands current node
         *
         */
        /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
        OutlineControlComponent.prototype.toggleExpansion = /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.outlineFor.state.currentPath = [];
                var /** @type {?} */ currentPath = this.item;
                while (core$1.isPresent(currentPath)) {
                    this.outlineFor.state.currentPath.unshift(currentPath);
                    currentPath = currentPath.$$parentItem;
                }
                this.outlineFor.toggleExpansion();
                var /** @type {?} */ payload = {
                    item: this.item,
                    expanded: this.outlineFor.state.isExpanded(this.item)
                };
                this.action.emit(payload);
                this.outlineFor.onExpandChange.emit(payload);
                event.stopPropagation();
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                this.outlineFor.state.selectedItem = this.item;
                this.outlineFor.onItemSelected.emit(this.item);
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.prepareControl = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.outlineFor) && core$1.isPresent(this.outlineState)) {
                    this.outlineFor = this.outlineState.outlineFor;
                }
                core$1.assert(core$1.isPresent(this.outlineFor), 'Missing outlineFor component');
                if (this.outlineFor.embedded) {
                    var /** @type {?} */ level = this.outlineFor.state.currentLevel;
                    if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                        level -= 1;
                    }
                    this.indentation = (this.outlineFor.indentationPerLevel * level);
                }
                this.item = this.outlineFor.currentItem;
                this.isRootItem = core$1.isBlank(this.item.$$parentItem);
            };
        OutlineControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-control',
                        template: "<!--\n    Control is just the two flex box items for displaying expand/collapse icon and content\n\n    Since we animate only standalone/non-embedded case now then we need to also animate the icon\n    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.\n\n    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down\n-->\n<div class=\"w-outline-control\"\n     [ngClass]=\"{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}\">\n    <div class=\"outline-icon sap-icon\"\n         *ngIf=\"!outlineFor.pushRootSectionOnNewLine || !isRootItem\"\n         (click)=\"toggleExpansion($event)\"\n         [style.margin-left.px]=\"indentation\"\n         [ngClass]=\"calculateStyleClass()\">\n    </div>\n\n    <ng-container *ngIf=\"allowSelection; then withSelection else withoutSelection\">\n    </ng-container>\n</div>\n\n<!--\n We support two case for the content\n\n Selection: When you click on the content it will add extra class so you can style currently\n selected item as well as broadcast event outside so developer can hook in some custom logic\n\n If we dont support selection: Then clicking on the content is just like clicking on expandable\n icon, it toggles the state\n-->\n\n<ng-template #withSelection>\n     <span class=\"outline-content outline-content-selected\" *ngIf=\"!allowEdit && isSelected()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span class=\"outline-content\" *ngIf=\"!allowEdit && !isSelected()\" (click)=\"select()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n\n</ng-template>\n\n\n<ng-template #withoutSelection>\n    <span *ngIf=\"!allowEdit\" class=\"outline-content\" (click)=\"toggleExpansion($event)\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span *ngIf=\"allowEdit\" class=\"outline-content\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n</ng-template>\n\n\n<ng-template #ngContent>\n    <ng-content></ng-content>\n</ng-template>\n\n",
                        styles: [".w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;align-self:center;transition:-webkit-transform 50ms ease-in;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}"],
                    },] },
        ];
        /** @nocollapse */
        OutlineControlComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: OutlineState, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineState; }),] }] },
                { type: OutlineControlComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineControlComponent; }),] }] },
                { type: OutlineForComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineForComponent; }),] }] }
            ];
        };
        OutlineControlComponent.propDecorators = {
            title: [{ type: core.Input }],
            allowSelection: [{ type: core.Input }],
            allowEdit: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return OutlineControlComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWOutlineForModule = (function () {
        function AWOutlineForModule() {
        }
        AWOutlineForModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            InitNestingDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWOutlineForModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders html text area component
     *
     * ### Example
     *
     * ```typescript
     *
     * \@Component({
     *          selector: 'myNote' ,
     *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
     *              </aw-text-area>'
     *      })
     *      export class MyNoteComponent
     *      {
     *          inputValue: string = 'Some really long text';
     *          autoResize: false;
     *      }
     *
     * ```
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
     */
    var /** @type {?} */ TEXTAREA_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TextAreaComponent; }),
        multi: true
    };
    var TextAreaComponent = (function (_super) {
        __extends(TextAreaComponent, _super);
        function TextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to store and read user input
             *
             */
            _this.value = '';
            /**
             * Spefifies visible number of lines
             */
            _this.rows = 2;
            /**
             * Specifies visible width
             */
            _this.columns = 20;
            /**
             * when this option is TRUE and user starts typing it will maximize textarea's width and height
             */
            _this.autoResize = true;
            return _this;
        }
        /**
         * @return {?}
         */
        TextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        TextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        TextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-text-area',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\">\n\n\t<textarea\n        pInputTextarea\n        [attr.name]=\"name\"\n        class=\"w-text-area\"\n        [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        [class.disabled]=\"disabled\"\n        formControlName=\"{{name}}\"\n        [rows]=\"rows\"\n        [cols]=\"columns\"\n        [autoResize]=\"autoResize\"\n        [attr.placeholder]=\"placeHolder\"\n\n    ></textarea>\n\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        styles: [""],
                        providers: [
                            TEXTAREA_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return TextAreaComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        TextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        TextAreaComponent.propDecorators = {
            value: [{ type: core.Input }],
            rows: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            autoResize: [{ type: core.Input }]
        };
        return TextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWTextAreaModule = (function () {
        function AWTextAreaModule() {
        }
        AWTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextareaModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            TextAreaComponent
                        ],
                        exports: [
                            TextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Page-Notification component that implements a notification system for the user regarding
     * the current object he's working on. Typical notification are:
     *      Success - saved.
     *      Warning - Sourcing request requires 3 suppliers.
     *      Error   - cannot connect to server, check internet connection.
     *
     *
     *
     * Usage 1:  As part of page wrapper.
     *
     * \@Component({
     *    selector: 'MyPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="MyPage"
     *                        [objectType]="MyType"
     *                        [notification]="pageNotification">
     *             page content
     *          `
     *       </aw-object-pager-wrapper>
     *    })
     *    export class MyPage
     *    {
     *
     *        pageNotification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     * Usage 2: directly into the page.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *      <aw-header></aw-header>
     *        Page Header
     *
     *        <ng-template [ngIf]="hasNotifications()">
     *          <div class="ui-g-12 u-nopadding">
     *            <aw-page-notification [notification]="notification"></aw-page-notification>
     *          </div>
     *        </ng-template>
     *
     *      <aw-footer></aw-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        notification: PageNotification = new PageNotification("warning",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     */
    var PageNotificationComponent = (function (_super) {
        __extends(PageNotificationComponent, _super);
        function PageNotificationComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationClass = /**
         * @return {?}
         */
            function () {
                return "notification-" + this.notification.type;
            };
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationIcon = /**
         * @return {?}
         */
            function () {
                return "ariba-icon icon-" + this.notification.type;
            };
        PageNotificationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-notification',
                        template: "<div class=\"page-notification\">\n    <div [class]=\"notificationClass()\">\n        <i [class]=\"notificationIcon()\"></i>\n        <span class=\"content\">\n              <span class=\"title\">{{notification.title}}</span>\n              <span class=\"description\">\n                    <ng-template *ngIf=\"notification.hasTemplate(); else description\"\n                                 [ngTemplateOutlet]=\"notification.contentTmpl\">\n                    </ng-template>\n                    <ng-template #description>{{notification.description}}</ng-template>\n              </span>\n      </span>\n    </div>\n</div>\n",
                        styles: [".page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:\"\\EA9D\"}.icon-warning:before{content:\"\\EA9C\"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}"]
                    },] },
        ];
        /** @nocollapse */
        PageNotificationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageNotificationComponent.propDecorators = {
            notification: [{ type: core.Input }]
        };
        return PageNotificationComponent;
    }(BaseComponent));
    /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */
    var /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */ PageNotification = (function () {
        function PageNotification(type, title, description, contentTmpl) {
            this.type = type;
            this.title = title;
            this.description = description;
            this.contentTmpl = contentTmpl;
        }
        /**
         * @return {?}
         */
        PageNotification.prototype.hasTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.contentTmpl);
            };
        /**
         * @return {?}
         */
        PageNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.type + ', title: ' + this.title + ', description:  ' + this.description;
            };
        return PageNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWPageNotificationModule = (function () {
        function AWPageNotificationModule() {
        }
        AWPageNotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            PageNotificationComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            PageNotificationComponent
                        ],
                        exports: [
                            PageNotificationComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWPageNotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Represents an event triggered when a page has been initialized.
     *
     */
    var /**
     * Represents an event triggered when a page has been initialized.
     *
     */ PageInitialized = (function () {
        function PageInitialized(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageInitialized.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageInitializied(title: " + this.title + ")";
            };
        return PageInitialized;
    }());
    /**
     * Represents an event triggered when a page has been destroyed.
     *
     */
    var /**
     * Represents an event triggered when a page has been destroyed.
     *
     */ PageDestroyed = (function () {
        function PageDestroyed(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageDestroyed.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageDestroyed(title: " + this.title + ")";
            };
        return PageDestroyed;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page LifeCycle Service monitors all page initialization and destructions.
     * The purpose of this service is to help the application monitor page lifecycle, subscribe
     * to lifecycle events and execute actions such as user analytics.
     *
     * Usage:
     *
     *    1.  Inject PageLifeCycleService into your constructor
     *
     *    constructor(pageLifecycle:PageLifeCycleService) {
     *        pageLifecycle.pageEvents.subscribe(event:Event => {
     *            if(event instanceof PageInitialized) {
     *            }
     *            // PageDestroyed
     *
     *        });
     *     }
     */
    var PageLifeCycleService = (function () {
        /**
         *
         */
        function PageLifeCycleService() {
            /**
             * Page event queue when all page lifecycle events: init, destroy are emitted.
             * Listeners can subscribe to these events.
             */
            this.pageEvents = new rxjs.Subject();
        }
        /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageInit = /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageInitialized(pageTitle));
            };
        /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageDestroy = /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageDestroyed(pageTitle));
            };
        PageLifeCycleService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PageLifeCycleService.ctorParameters = function () { return []; };
        return PageLifeCycleService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var PageType = {
        Init: 0,
        // Init Page type
        Login: 1,
        // Login Page
        Object: 2,
        // Object detail page
        List: 3,
        // List Page
        MasterDetail: 4,
        // MasterDetail
        Dashboard: 5,
        // Dashboard page
        Modal: 6,
    };
    PageType[PageType.Init] = "Init";
    PageType[PageType.Login] = "Login";
    PageType[PageType.Object] = "Object";
    PageType[PageType.List] = "List";
    PageType[PageType.MasterDetail] = "MasterDetail";
    PageType[PageType.Dashboard] = "Dashboard";
    PageType[PageType.Modal] = "Modal";
    /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */
    var /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */ PageWrapper = (function (_super) {
        __extends(PageWrapper, _super);
        function PageWrapper(env, pageType, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.componentRegistry = componentRegistry;
            _this.pageLifecycleService = pageLifecycleService;
            /**
             * What type of page this is.
             *
             */
            _this.pageType = PageType.Init;
            _this.pageType = pageType;
            return _this;
        }
        /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
        PageWrapper.prototype.getId = /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
            function () {
                if (this.id) {
                    return this.id;
                }
                this.id = this.generatePageId();
            };
        return PageWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Header component that implements consistent styling, behavior for an Ariba page.
     * Header includes a menu, user profile, and alerts.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
     *                                 [menuItems]="menuItems" [notifications]="userNotifications">
     *                     <div class="page-header-center">
     *                           <a class="navbar-brand" tabindex="0" href="/">
     *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
     *                                   alt="Go to homepage" data-pin-nopin="true">
     *                          </a>
     *                     </div>
     *                </aw-page-header>
     *
     *    `
     *    })
     *    export class MyPage
     *    {
     *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
     *                                  new PageMenuItem('icon-expense-report', 'Reports',
     *                                                     '/play/pageheader'),
     *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
     *                                                       '/play/pageheader'),
     *                                  new PageMenuItem('icon-account', 'Accounts',
     *                                                     '/play/pageheader')];
     *
     *     userNotifications: UserNotification[] = [
     *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
     *                             '/play/'),
     *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
     *                             '/play/'),
     *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
     *                               '/play/')
     *        ];
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageHeaderComponent = (function (_super) {
        __extends(PageHeaderComponent, _super);
        function PageHeaderComponent(element, env, routing) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            _this.routing = routing;
            /**
             * Should the user notification icon be hidden. Default it to show the icon even
             * if there's no notifications.
             *
             */
            _this.hideNotification = false;
            /**
             * displays the back link that navigates user to the previous page when clicked.
             */
            _this.showBackAction = false;
            _this.showNotificationPanel = false;
            return _this;
        }
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.backAction = /**
         * @return {?}
         */
            function () {
                this.routing.goBack();
            };
        /**
         * Do i have any menu items.
         *
         */
        /**
         * Do i have any menu items.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasMenuItems = /**
         * Do i have any menu items.
         *
         * @return {?}
         */
            function () {
                return (this.menuItems && this.menuItems.length > 0);
            };
        /**
         * Toggle the side navigation menu.
         */
        /**
         * Toggle the side navigation menu.
         * @return {?}
         */
        PageHeaderComponent.prototype.showHideMenu = /**
         * Toggle the side navigation menu.
         * @return {?}
         */
            function () {
                this.sidenav.toggle();
            };
        /**
         * Do I have any notifications.
         *
         */
        /**
         * Do I have any notifications.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasNotifications = /**
         * Do I have any notifications.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.notifications) && this.notifications.length > 0;
            };
        /**
         * toggling wheather notification panel is displayed or not.
         */
        /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
        PageHeaderComponent.prototype.toggleNotificationPanel = /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
            function () {
                this.showNotificationPanel = !this.showNotificationPanel;
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-header',
                        template: "<nav class=\"navbar page-header\" role=\"navigation\">\n\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-4 navbar-left\">\n\n        <span *ngIf=\"hasMenuItems()\">\n            <a (click)=\"showHideMenu()\">\n                <i class=\"sap-icon icon-paging\"></i>\n            </a>\n\n            <!-- Side menu -->\n            <aw-sidenav #sidemenu [items]=\"menuItems\"></aw-sidenav>\n        </span>\n            <!-- End Hamburger menu. -->\n\n            <!--  back action -->\n            <span class=\"back-action\">\n            <a (click)=\"backAction()\">\n                <i *ngIf=\"showBackAction\" class=\"sap-icon icon-arrow-left\" role=\"button\"></i>\n            </a>\n        </span>\n\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-center\">\n\n            <!-- central section.  Application can add Ariba-logo, search box, etc -->\n            <ng-content select=\".page-header-center\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-right\">\n        <span *ngIf=\"userName\">\n            <img id=\"userProfilePicture\" class=\"profile-logo\" aria-hidden=\"true\"\n                 [title]=\"userName\" src=\"{{assetFolder}}/images/default_image_small.png\">\n            <span class=\"profile-user\" title=\"{{userName}}\">{{userName}}</span>\n        </span>\n\n            <span *ngIf=\"!hideNotification\" class=\"notification-container\">\n\n            <i #notificationIcon class=\"ariba-icon icon-notification\"\n               (click)=\"toggleNotificationPanel()\"></i>\n            <span *ngIf=\"hasNotifications()\" class=\"notification-badge\" aria-hidden=\"true\">{{notifications.length}}</span>\n\n                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.\n                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->\n            <div *ngIf=\"showNotificationPanel\" class=\"notification-panel\">\n\n                <div class=\"notification-header\">\n                     Notifications\n                </div>\n\n                <ul class=\"notification-content\">\n                    <li *ngFor=\"let noti of notifications\" class=\"notification-item\">\n                        <a [routerLink]=\"noti.link\">\n                            <span class=\"notification-item-icon\"><i\n                                [ngClass]=\"'sap-icon ' + noti.icon\"></i></span>\n                            {{noti.label}}\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </span>\n        </div>\n\n\n    </div>\n</nav>\n",
                        styles: [".page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:\"\\eA14\"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:all .3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}"]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core$1.RoutingService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            menuItems: [{ type: core.Input }],
            notifications: [{ type: core.Input }],
            hideNotification: [{ type: core.Input }],
            showBackAction: [{ type: core.Input }],
            userName: [{ type: core.Input }],
            sidenav: [{ type: core.ViewChild, args: ['sidemenu',] }]
        };
        return PageHeaderComponent;
    }(BaseComponent));
    /**
     * PageMenuItem represents an item in the page menu structure.
     */
    var /**
     * PageMenuItem represents an item in the page menu structure.
     */ PageMenuItem = (function () {
        /**
         * @param icon    - Icon of this menu item.
         * @param label   - label of this item.
         * @param link    - link to the destination when user clicks on it.
         */
        function PageMenuItem(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        PageMenuItem.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageMenuItem: (label, " + this.label + ")";
            };
        return PageMenuItem;
    }());
    /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */
    var /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */ UserNotification = (function () {
        /**
         * @param icon   - alert notification icon
         * @param label  - alert notification label
         * @param link   - link
         */
        function UserNotification(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        UserNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageUserNotification: (label, " + this.label + ")";
            };
        return UserNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Footer component that implements consistent styling, behavior.
     * This footer component self contained.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *          <aw-page-footer>
     *               <div class="page-footer-logo">
     *                   <img src="images/ariba_logo_white_bkgd.png">
     *               </div>
     *               <div class="page-footer-user-info">
     *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
     *                   | Buyer Organization
     *               </div>
     *               <span class="page-footer-copyright" #copyright>
     *                   <p> 20202028 The Future, Inc. All rights reserved</p>
     *               </span>
     *           </aw-page-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageFooterComponent = (function (_super) {
        __extends(PageFooterComponent, _super);
        function PageFooterComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * show default copyright. If copyright is passed in, then show the passed in one.
             */
            _this.showDefaultCopyright = true;
            return _this;
        }
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.showDefaultCopyright = !core$1.isPresent(this.copyright);
            };
        PageFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-footer',
                        template: "<div class=\"page-footer\">\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-8\">\n\n            <ng-content select=\".page-footer-logo\"></ng-content>\n\n            <div class=\"user-info\">\n                <ng-content select=\".page-footer-user-info\"></ng-content>\n            </div>\n\n            <ul class=\"footer-links\">\n                <li role=\"presentation\"><a href=\"http://www.ariba.com/legal/ariba_tou.cfm\">Terms of\n                    Use</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_security_policy.cfm\">Security\n                    Disclosure</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_privacy_statement.cfm\">Privacy\n                    Statement</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Cookie Statement</a>\n                </li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Participant\n                    Statement</a></li>\n            </ul>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4\">\n            <div class=\"u-bottom-align\"></div>\n            <div class=\"u-hright copyright\">\n                <ng-content select=\".page-footer-copyright\"></ng-content>\n            </div>\n\n            <!-- Default Copyright -->\n            <div *ngIf=\"showDefaultCopyright\" class=\"u-hright copyright\">\n                <p>\u00A9 1996\u20132017 Ariba, Inc. All rights reserved</p>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                        styles: [".page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:\" \";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}"]
                    },] },
        ];
        /** @nocollapse */
        PageFooterComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageFooterComponent.propDecorators = {
            copyright: [{ type: core.ContentChild, args: ['copyright',] }]
        };
        return PageFooterComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
     * Header, Page title, Page notification, actions, content, and Footer.
     *
     *
     *  Usage:
     *
     * \@Component({
     *    selector: 'RFXPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="rfxEntity.headerInfo.title"
     *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
     *                        [notification]="pageNotification">
     *
     *
     *           <aw-page-actions>
     *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
     *                   Edit
     *                </aw-button>
     *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
     *                                                         [style]="'secondary'">
     *                  Cancel
     *               </aw-button>
     *           </aw-page-actions>
     *
     *           <aw-page-content>
     *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
     *
     *                   <m-context [object]="rfxEntity.headerInfo"
     *                              [operation]="this.editabilityState.headerInfoOp"
     *                              layout="Inspect"
     *                              uiGroup="HeaderGeneral"
     *                   >
     *                       <m-include-component></m-include-component>
     *                   </m-context>
     *
     *             </aw-section>
     *           </aw-page-content>
     *       </aw-object-page-wrapper>
     *    `
     *    })
     *    export class RFXPage
     *    {
     *       // To keep track what section is editable and which read only
     *       editabilityState: EditabilityState;
     *
     *       // Current RFX event
     *       rfxEntity: RfxEventEntity;
     *
     *       // Notifications
     *       notification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var ObjectPageWrapperComponent = (function (_super) {
        __extends(ObjectPageWrapperComponent, _super);
        function ObjectPageWrapperComponent(element, env, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env, PageType.Object, componentRegistry, pageLifecycleService) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Set true if page should not include any header. Need to set to true even no header
             * object is passed in. Otherwise, a default Header component will be added.
             */
            _this.hideHeader = false;
            /**
             * Set true if page should not include any footer. Need to set to true even no footer
             * object is passed in. Otherwise, a default Footer component will be added.
             */
            _this.hideFooter = false;
            /**
             * The positioning of the page actions (page buttons)
             *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
             *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
             *   'both'   : page buttons are placed at both top and bottom.
             *
             */
            _this.pageActionPosition = 'top';
            /**
             * This flag is driven by pageActionPosition. The default position is top.
             * Value is true for both 'top' and 'both' of pageActionPosition.
             */
            _this.hasTopPageActions = true;
            _this.objectStateIndex = 0;
            // Setting Default header component
            // Setting Default header component
            _this.header = PageHeaderComponent;
            _this.footer = PageFooterComponent;
            return _this;
        }
        /**
         * Generate a unique Id for this object.
         *
         */
        /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.generatePageId = /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
            function () {
                return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
            };
        /**
         * Does my page have page notification?
         *
         */
        /**
         * Does my page have page notification?
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasNotifications = /**
         * Does my page have page notification?
         *
         * @return {?}
         */
            function () {
                return (this.notifications && this.notifications.length > 0);
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasObjectStates = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.objectStates);
            };
        /**
         * Initialize my local components
         */
        /**
         * Initialize my local components
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnInit = /**
         * Initialize my local components
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // New Component types that are used in c-include-component
                if (this.header) {
                    this.componentRegistry.registerType(this.header.name, this.header);
                }
                // New Component types that are used in c-include-component
                if (this.footer) {
                    this.componentRegistry.registerType(this.footer.name, this.footer);
                }
                /** notify subscribers of the page lifecycle service  */
                this.pageLifecycleService.onPageInit(this.title);
                // Setting the page action position.
                if (this.pageActionPosition === 'bottom') {
                    this.hasTopPageActions = false;
                    this.hasBottomPageActions = true;
                }
                else if (this.pageActionPosition === 'both') {
                    this.hasTopPageActions = true;
                    this.hasBottomPageActions = true;
                }
                if (core$1.isPresent(this.objectStates) && this.objectStates.length > 1
                    && core$1.isPresent(this.currentState)) {
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['currentState']) &&
                    changes['currentState'].currentValue !== changes['currentState'].previousValue) {
                    // we dont need to check if objectStates exists
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.pageLifecycleService.onPageDestroy(this.title);
            };
        ObjectPageWrapperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-object-page-wrapper',
                        template: "<div class=\"page-wrapper\">\n    <ng-template [ngIf]=\"!hideHeader\">\n        <aw-include-component [name]='header.name'></aw-include-component>\n    </ng-template>\n\n    <div class=\"arc-object-detail\">\n\n        <div class=\"ui-g\">\n\n            <!-- page header -->\n            <div class=\"ui-g-12 page-title\">\n\n                <!-- page title -->\n                <div class=\"ui-g-8 ui-md-8 page-title-text\">{{title}}</div>\n\n                <div class=\"ui-g-4 ui-md-4 page-status\">\n                    <span class=\"object-status-label\">{{objectStatusLabel}} &nbsp;</span>\n                    <span class=\"object-status\">{{objectStatus}}</span>\n                </div>\n            </div>\n\n            <!-- page actions -->\n            <div class=\"ui-g-12 page-actions\" *ngIf=\"hasTopPageActions\">\n                <ng-template [embeddedItem]=\"actionsTemplate\"\n                             *ngIf=\"hasTopPageActions\"></ng-template>\n            </div>\n\n            <!-- object states  displays only if state exists. -->\n            <div class=\"ui-g-12 page-state\">\n                <div class=\"ui-g-3 page-state-left\" [class.content]=\"hasObjectStates()\">\n                    <ng-content select=\".page-state-left\"></ng-content>\n                </div>\n                <div class=\"ui-g-6 page-state-center\">\n                    <ng-container *ngIf=\"hasObjectStates()\">\n                        <aw-stepper [steps]=\"objectStates\"\n                                    [currentStep]=\"objectStateIndex\"></aw-stepper>\n                    </ng-container>\n                </div>\n                <div class=\"ui-g-3 page-state-right\">\n                    <ng-content select=\".page-state-right\"></ng-content>\n                </div>\n            </div>\n\n\n            <!-- Page Notification -->\n            <ng-template [ngIf]=\"hasNotifications()\">\n                <div class=\"ui-g-12 u-nopadding\">\n\n                    <aw-page-notification *ngFor=\"let notification of notifications\"\n                                          [notification]=\"notification\"></aw-page-notification>\n                </div>\n            </ng-template>\n\n            <!-- additional content -->\n            <ng-content select=\"aw-page-content\"></ng-content>\n\n        </div>\n\n    </div>\n\n    <!-- page actions -->\n    <div class=\"ui-g-12 page-actions-bottom\" *ngIf=\"hasBottomPageActions\">\n        <ng-template [embeddedItem]=\"actionsTemplate\"\n                     *ngIf=\"hasBottomPageActions\"></ng-template>\n\n    </div>\n\n    <div class=\"page-push\"></div>\n</div>\n\n<ng-template [ngIf]=\"!hideFooter\">\n    <aw-include-component [name]='footer.name'></aw-include-component>\n</ng-template>\n",
                        styles: [".page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\x000a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}"]
                    },] },
        ];
        /** @nocollapse */
        ObjectPageWrapperComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: ComponentRegistry },
                { type: PageLifeCycleService }
            ];
        };
        ObjectPageWrapperComponent.propDecorators = {
            title: [{ type: core.Input }],
            objectType: [{ type: core.Input }],
            objectStatusLabel: [{ type: core.Input }],
            objectStatus: [{ type: core.Input }],
            objectStates: [{ type: core.Input }],
            currentState: [{ type: core.Input }],
            header: [{ type: core.Input }],
            hideHeader: [{ type: core.Input }],
            footer: [{ type: core.Input }],
            hideFooter: [{ type: core.Input }],
            pageActionPosition: [{ type: core.Input }],
            actionsTemplate: [{ type: core.ContentChild, args: ['pageActions',] }],
            notifications: [{ type: core.Input }]
        };
        return ObjectPageWrapperComponent;
    }(PageWrapper));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
     * page. The wrapper use the ability to position it as needed.
     */
    var PageActionsComponent = (function (_super) {
        __extends(PageActionsComponent, _super);
        function PageActionsComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-actions',
                        template: "<div class=\"page-actions\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".page-actions{text-align:right;padding-top:0;padding-right:0}"]
                    },] },
        ];
        /** @nocollapse */
        PageActionsComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageActionsComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page content is a wrapper for page content.
     * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
     * the page content area will likely get affected.
     */
    var PageContentComponent = (function (_super) {
        __extends(PageContentComponent, _super);
        function PageContentComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-content',
                        template: '<ng-content></ng-content>',
                        styles: [':host {width: 100%; padding: 0 .5em;}']
                    },] },
        ];
        /** @nocollapse */
        PageContentComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageContentComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ STEPPER_COMPLETED_STEP_COLOR = '#58b957';
    var /** @type {?} */ STEPPER_CURRENT_STEP_COLOR = '#0076CB';
    var /** @type {?} */ STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
    /**
     * Stepper component displays a list of steps for user to follow. It can be used as a checklist
     * to indicate completed, current and remaining items. It could be also be used to indicate
     * the state of an document, created, submitted, approved, etc...
     *
     *
     * Usage:
     *   1.   Use the component inside your template. provide a list of steps and the current step.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
     *
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
     *                     currentStep: number = 1;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *   2.  Override the default colors.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
     *                                        [stepColorRemaining]="'#CC0000'"
     *                                        [stepColorCompleted]="'#97a822'"
     *                                        [currentStep]="currentStep">
     *                            </aw-stepper>
     *                  `
     */
    var StepperComponent = (function (_super) {
        __extends(StepperComponent, _super);
        function StepperComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Local variable to indicate whether to use the colors array or not.
             */
            _this.bUseColorArray = false;
            /**
             * The current step that's on. If not provided default to the first step.
             */
            _this.currentStep = 0;
            // Initial color for the different stages of steps.
            // Initial color for the different stages of steps.
            _this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
            _this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
            _this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
            return _this;
        }
        /**
         * @return {?}
         */
        StepperComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // Calculate the connector width based on how many steps
                if (core$1.isPresent(this.steps) && this.steps.length > 1) {
                    // (100% - 20% (side margins)) / (NumOfSteps -1)
                    this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
                }
                /**
                         * Use the color array if it's defined.
                         */
                if (core$1.isPresent(this.colors)) {
                    this.bUseColorArray = true;
                    if (this.colors.length !== this.steps.length) {
                        throw new Error("The size of the steps and colors don't match:\n                  (steps.length = " + this.steps.length + "), (colors.length = " + this.colors.length);
                    }
                }
            };
        /**
         * Getting the color of the step for the current index
         *
         * @param index
         */
        /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getStepColor = /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else if (index === this.currentStep) {
                    return this.stepColorCurrent;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * The connector colors are driven by the step colors.
         *
         */
        /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getConnectorColor = /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * Next step.
         */
        /**
         * Next step.
         * @return {?}
         */
        StepperComponent.prototype.nextStep = /**
         * Next step.
         * @return {?}
         */
            function () {
                this.currentStep++;
            };
        /**
         * previous step.
         */
        /**
         * previous step.
         * @return {?}
         */
        StepperComponent.prototype.prevStep = /**
         * previous step.
         * @return {?}
         */
            function () {
                this.currentStep--;
            };
        StepperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-stepper',
                        template: "<div class=\"stepper-container\">\n    <div class=\"steps\">\n        <div class=\"step-spacing\"></div>\n\n        <ng-container *ngFor=\"let step of steps; let i=index; let last=last;\">\n            <div class=\"step\">\n                <aw-step [title]=\"step\" [color]=\"getStepColor(i)\"></aw-step>\n            </div>\n            <div *ngIf=\"!last\" class=\"step-connector\" [style.width]=\"connectorWidth\">\n                <div class=\"connector\" [style.borderBottomColor]=\"getConnectorColor(i)\"></div>\n            </div>\n        </ng-container>\n\n        <div class=\"step-spacing\"></div>\n    </div>\n\n    <div class=\"step-labels\"></div>\n</div>\n\n\n",
                        styles: [".stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}"]
                    },] },
        ];
        /** @nocollapse */
        StepperComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepperComponent.propDecorators = {
            steps: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            stepColorCompleted: [{ type: core.Input }],
            stepColorCurrent: [{ type: core.Input }],
            stepColorRemaining: [{ type: core.Input }],
            currentStep: [{ type: core.Input }]
        };
        return StepperComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders html step component
     *
     *  * Usage:
     *       Straight forward to use. But mostly it would be used as part of the stepper component.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                           <aw-step [title]="step" [color]="color"></aw-step>
     *                           `
     */
    var /** @type {?} */ DEFAULT_COLOR = '#58b957';
    var StepComponent = (function () {
        function StepComponent(env) {
            this.env = env;
        }
        /**
         * @return {?}
         */
        StepComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.color)) {
                    this.color = DEFAULT_COLOR;
                }
            };
        StepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-step',
                        template: "<div class=\"step-container\">\n    <div class=\"outer-circle\" [style.borderColor]=\"color\">\n        <div class=\"inner-circle\" [style.borderColor]=\"color\" [style.backgroundColor]=\"color\"></div>\n    </div>\n\n    <div class=\"step-title\">{{title}}</div>\n</div>\n\n",
                        styles: [".step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}"]
                    },] },
        ];
        /** @nocollapse */
        StepComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepComponent.propDecorators = {
            color: [{ type: core.Input }],
            title: [{ type: core.Input }]
        };
        return StepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWStepperModule = (function () {
        function AWStepperModule() {
        }
        AWStepperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StepComponent,
                            StepperComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                        ],
                        entryComponents: [
                            StepComponent,
                            StepperComponent
                        ],
                        exports: [
                            StepComponent,
                            StepperComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWStepperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  This is a temporary implementation for the page header component.
     *  When the real implementation of side menu is done, PageHeaderComponent will
     *  be swaped to use it.
     *
     */
    var SidenavComponent = (function (_super) {
        __extends(SidenavComponent, _super);
        function SidenavComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        SidenavComponent.prototype.getSidenavClass = /**
         * @return {?}
         */
            function () {
                // Only show if I have items
                return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.open = /**
         * @return {?}
         */
            function () {
                this.show = true;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.show = false;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.show = !this.show;
            };
        SidenavComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-sidenav',
                        template: "<div [ngClass]=\"getSidenavClass()\">\n    <div class=\"sidenav-content\">\n        <a *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n            <span class=\"sidenav-icon\"><i [ngClass]=\"'sap-icon ' + item.icon\"></i></span>\n            {{item.label}}\n        </a>\n    </div>\n</div>\n",
                        styles: [".sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}"]
                    },] },
        ];
        /** @nocollapse */
        SidenavComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SidenavComponent.propDecorators = {
            items: [{ type: core.Input }],
            show: [{ type: core.Input }]
        };
        return SidenavComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWPageWrapperModule = (function () {
        function AWPageWrapperModule() {
        }
        AWPageWrapperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            AWCoreComponentModule,
                            AWStepperModule,
                            AWPageNotificationModule
                        ],
                        entryComponents: [
                            PageFooterComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageHeaderComponent
                        ],
                        exports: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        providers: [PageLifeCycleService]
                    },] },
        ];
        return AWPageWrapperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var EditorType = {
        Default: 0,
        // Default Editor supports Minimal set of functionality
        // [ bold | italic | underline | ordered | bullet | alignment]
        Full: 1,
        // The full list of functionality,
        TextFormat: 2,
        // Functionalities that affects text formatting.
        Custom: 3,
    };
    EditorType[EditorType.Default] = "Default";
    EditorType[EditorType.Full] = "Full";
    EditorType[EditorType.TextFormat] = "TextFormat";
    EditorType[EditorType.Custom] = "Custom";
    var /** @type {?} */ EDITOR_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RichTextAreaComponent; }),
        multi: true
    };
    var RichTextAreaComponent = (function (_super) {
        __extends(RichTextAreaComponent, _super);
        function RichTextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * A value used to save and read when rendering and updating this component
             */
            _this.value = '';
            /**
             * Expose editorType so that it can be used in this components template.
             */
            _this.EditorType = EditorType;
            _this.type = EditorType.Default;
            _this.styleClass = 'default-editor';
            return _this;
        }
        /**
         * @return {?}
         */
        RichTextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         */
        /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
        RichTextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        RichTextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-richtextarea',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <!-- Basic editor, also the default, which the most used features enabled. -->\n    <div *ngIf=\"type === EditorType.Default\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                    <span class=\"ql-formats\">\n                        <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                        <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                        <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                        <button class=\"ql-list\" value=\"ordered\"></button>\n                        <button class=\"ql-list\" value=\"bullet\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                            <button value=\"left\" selected></button>\n                            <button value=\"center\"></button>\n                            <button value=\"right\"></button>\n                            <button value=\"justify\"></button>\n                    </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Editor with all the features enabled -->\n    <div *ngIf=\"type === EditorType.Full\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\"></p-editor>\n    </div>\n\n    <!-- Editor with all Text formatting  -->\n    <div *ngIf=\"type === EditorType.TextFormat\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n            <span class=\"ql-format-group\">\n              <select title=\"Font\" class=\"ql-font\">\n                <option value=\"sans-serif\" selected=\"\">Sans Serif</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"monospace\">Monospace</option>\n              </select>\n              <select title=\"Size\" class=\"ql-size\">\n                <option value=\"10px\">Small</option>\n                <option value=\"13px\" selected=\"\">Normal</option>\n                <option value=\"18px\">Large</option>\n                <option value=\"32px\">Huge</option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-format-group\">\n              <select title=\"Text Color\" class=\"ql-color\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\" selected=\"\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n              <span class=\"ql-format-separator\"></span>\n              <select title=\"Background Color\" class=\"ql-background\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\" selected=\"\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                <button class=\"ql-list\" value=\"ordered\"></button>\n                <button class=\"ql-list\" value=\"bullet\"></button>\n            </span>\n                <span class=\"ql-formats\">\n                    <button value=\"left\" selected></button>\n                    <button value=\"center\"></button>\n                    <button value=\"right\"></button>\n                    <button value=\"justify\"></button>\n            </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Custom header Text Editor -->\n    <div *ngIf=\"type === EditorType.Custom\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                <ng-content select=\"custom-header\"></ng-content>\n            </p-header>\n        </p-editor>\n    </div>\n\n</ng-template>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        styles: ["/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}"],
                        providers: [
                            EDITOR_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RichTextAreaComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RichTextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RichTextAreaComponent.propDecorators = {
            type: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return RichTextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRichTextAreaModule = (function () {
        function AWRichTextAreaModule() {
        }
        AWRichTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RichTextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.EditorModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            RichTextAreaComponent
                        ],
                        exports: [
                            RichTextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRichTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Allow developer to override default actions. Must have this declared before class when we
     * want to have this declaration inside the same file.
     */
    var SectionActionsComponent = (function () {
        function SectionActionsComponent() {
        }
        SectionActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section-actions',
                        template: "<ng-content></ng-content> ",
                    },] },
        ];
        return SectionActionsComponent;
    }());
    /**
     *
     * Section component that implements a section of the page. It's an outline box that
     * has the ability to expand and hide its content.
     *
     * ```ts
     * \@Component({
     *    selector: 'rfx-details' ,
     *    template: `
     *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
     *                          [editable]="true">
     *
     *                <m-context [object]="rfxEntity.headerInfo"
     *                          [operation]="this.editabilityState.headerInfoOp"
     *                          layout="Inspect"
     *                          uiGroup="HeaderGeneral">
     *                   <m-include-component></m-include-component>
     *               </m-context>
     *           </aw-section>
     *
     *
     *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
     *                [opened]="false">
     *               <supplier-profile-card></supplier-profile-card>
     *           </aw-section>
     *
     *           <aw-section title="RFQ Details"
     *                       description="Review and update information for suppliers to respond."
     *                       [disableClose]="true">
     *
     *               <aw-subsection title="Event timeline">
     *                   <aw-form-table [useFiveZone]="false" [editable]="true">
     *
     *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
     *                                   [highlightRow]="true">
     *                           <aw-date-time
     *                               formatName="dateTime"
     *                               name="startDate" [value]="rfxEntity.created"
     *                               [showTime]="true"></aw-date-time>
     *                       </aw-form-row>
     *                   </aw-form-table>
     *               </aw-subsection>
     *          </aw-section>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     *
     * ```
     *
     * Section component also supports editability modes and if enabled it will render action buttons
     * in the footer. Developer can also override default behavior and provide custom actions.
     *
     *
     * e.g:
     *
     * ```
     *      <aw-section [title]="title" [editable]="true"
     *                          (onCancelAction)="someHandler1($event)"
     *                          (onSaveAction)="someHandler2($event)" >
     *              section content
     *
     *
     *   </aw-section>
     *
     * ```
     *
     * or custom action buttons:
     *
     *
     * ```html
     *
     *       <aw-section-actions>
     *                      <aw-button >
     *                            ButtonTest1
     *                      </aw-button>
     *                      <aw-button>
     *                            ButtonTest2
     *                      </aw-button>
     *     </aw-section-actions>
     *
     * ```
     *
     *
     * There are two edit modes
     *  # Default
     *      Renders action buttons in the footers and emit actions to the application
     *
     *  # External
     *     No action buttons are shown in the footer and behavior is handled by application. Only event
     *     is emited.
     *
     *
     *  e.g:
     *
     *  ```ts
     *
     *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
     *                  [editable]="true" [editMode]="'external'" >
     *                  <div>
     *                      Content
     *                  </div>
     *      </aw-section>
     *
     *  ```
     *
     * Note: When using editing mode you have to call at the end of the editing cycle method
     * `completeEditing()` to commit editing which changes internal state of the Section.
     *
     *
     *
     */
    var SectionComponent = (function (_super) {
        __extends(SectionComponent, _super);
        function SectionComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Should this section be opened at the start. Default is opened.
             */
            _this.opened = true;
            /**
             * Whether this section can be closed or not.
             *
             */
            _this.disableClose = false;
            /**
             * Whether this section is in EditState or not.
             *
             * When in editing state and we show "Cancel / Save" button developer needs use this binding
             * to control the state.
             */
            _this.editState = false;
            /**
             * Current Editing mode. Tells the components if its its default behavior or driven by
             * application using this component.
             *
             * {\@see EditMode}
             *
             */
            _this.editMode = 'default';
            /**
             * Developer can provide custom Edit action icon that will appear in the right top corner
             */
            _this.actionIcon = 'icon-edit';
            /**
             * Event emitted when the section is fully opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Event emitted when the section is fully closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Edit state to broadcast state of current section
             */
            _this.onEdit = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Cancel action
             */
            _this.onCancelAction = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Save action
             */
            _this.onSaveAction = new core.EventEmitter();
            _this.onEditingComplete = new core.EventEmitter();
            _this.editable = false;
            return _this;
        }
        /**
         * @return {?}
         */
        SectionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If I have not header, then I can't close the section.
                if (!this.isHeaderDisplayed()) {
                    this.disableClose = true;
                }
                // If I can't close the section, then it should default open.
                if (this.disableClose) {
                    this.opened = true;
                }
                // initialize the expanded state.
                this.expanded = this.opened;
            };
        /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
        SectionComponent.prototype.isHeaderDisplayed = /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.title) || core$1.isPresent(this.description));
            };
        /**
         * Css Class that control the look and feel for section component.
         */
        /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
        SectionComponent.prototype.aClass = /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
            function () {
                if (!this.isHeaderDisplayed()) {
                    return 'section-no-header';
                }
                return '';
            };
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         */
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
        SectionComponent.prototype.onEditAction = /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                // when in editing make sure we dont switch state as there can be some Form errors
                // which needs to be handled by developer and only then change the editState
                if (!this.editState) {
                    this.editState = !this.editState;
                    var /** @type {?} */ state = (this.editState) ? 'inEdit' : 'notInEdit';
                    this.onEdit.emit(state);
                    this.open();
                }
                // prevent the original event from bubbling up. Because the edit icon is inside
                // the header. If the click even is bubbled up, this event will cause the section to
                // expand or collapse.
                if (core$1.isPresent($event.event)) {
                    $event.event.stopPropagation();
                    $event.event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        SectionComponent.prototype.hasDescription = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.description);
            };
        /**
         * Open this section, if it's already open, will do nothing.
         */
        /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
        SectionComponent.prototype.open = /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                if (!this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Close this section, if it's already close, will do nothing.
         */
        /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.close = /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Callback to be invoked when accordion is opened
         *
         */
        /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionOpen = /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = true;
                this.onOpen.emit('open');
            };
        /**
         * Callback to be invoked when accordion is closed
         *
         */
        /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionClose = /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                this.onClose.emit('close');
            };
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         */
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
        SectionComponent.prototype.hasCustomActions = /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.customActions);
            };
        /**
         * Emit the editing state back to non-editable
         */
        /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
        SectionComponent.prototype.completeEditing = /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
            function () {
                this.editState = false;
                this.onEditingComplete.emit(this.editState);
            };
        SectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section',
                        template: "<div class=\"ui-g-12 section-container\"\n     [class.editing]=\"editable && editState && editMode === 'default'\">\n\n    <p-accordion (onOpen)=\"onSectionOpen($event)\" (onClose)=\"onSectionClose($event)\"\n                 [styleClass]=\"aClass()\">\n        <p-accordionTab #accordionTab [selected]=\"opened\" [disabled]=\"disableClose\">\n            <p-header>\n                <!-- title and description -->\n                <div class=\"section-header-container\">\n                    <div class=\"section-title\">{{title}}</div>\n                    <div *ngIf=\"hasDescription()\" class=\"section-description\">{{description}}</div>\n\n                    <!-- actions: Hide when in editing and editMode is default -->\n                    <div *ngIf=\"(editable && !editState && editMode === 'default') ||\n                        (editable && editMode === 'external')\"\n                         class=\"section-actions\">\n                        <aw-hyperlink (action)=\"onEditAction($event)\">\n                            <i class=\"sap-icon section-edit-action\" [ngClass]=\"actionIcon\"></i>\n                        </aw-hyperlink>\n                    </div>\n                </div>\n            </p-header>\n\n            <ng-content></ng-content>\n        </p-accordionTab>\n    </p-accordion>\n    <!--\n        need to put it outside of p-accordion otherwise button will inherit different\n        color scheme\n    -->\n    <div class=\"section-footer-container\" *ngIf=\"editable && editState &&\n            editMode === 'default'\">\n        <div class=\"footer-actions\">\n\n            <ng-template [ngIf]=\"!hasCustomActions()\">\n                <aw-button [style]=\"'secondary'\" size=\"small\"\n                           (action)=\"onCancelAction.emit($event)\">\n                    Cancel\n                </aw-button>\n                <aw-button size=\"small\" (action)=\"onSaveAction.emit($event)\">\n                    Save\n                </aw-button>\n            </ng-template>\n\n            <ng-content select=\"aw-section-actions\"></ng-content>\n        </div>\n    </div>\n</div>\n",
                        styles: [".section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:\"SAP icon fonts\";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:\"\\e1ed\"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:\"\\e1ef\"}"]
                    },] },
        ];
        /** @nocollapse */
        SectionComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SectionComponent.propDecorators = {
            title: [{ type: core.Input }],
            description: [{ type: core.Input }],
            opened: [{ type: core.Input }],
            disableClose: [{ type: core.Input }],
            editState: [{ type: core.Input }],
            editMode: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            onOpen: [{ type: core.Output }],
            onClose: [{ type: core.Output }],
            onEdit: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            onSaveAction: [{ type: core.Output }],
            onEditingComplete: [{ type: core.Output }],
            accordionTab: [{ type: core.ViewChild, args: ['accordionTab',] }],
            customActions: [{ type: core.ContentChild, args: [SectionActionsComponent,] }]
        };
        return SectionComponent;
    }(BaseComponent));
    var SubSectionComponent = (function () {
        function SubSectionComponent() {
        }
        SubSectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-subsection',
                        template: "\n                    <h4 class=\"subsection-title\">{{title}}</h4>\n                    <ng-content></ng-content>\n                 ",
                        styles: ['.subsection-title {color: #363636; }']
                    },] },
        ];
        SubSectionComponent.propDecorators = {
            title: [{ type: core.Input }]
        };
        return SubSectionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWSectionModule = (function () {
        function AWSectionModule() {
        }
        AWSectionModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.AccordionModule,
                            core$1.AribaCoreModule,
                            AWStringFieldModule,
                            AWHyperlinkModule,
                            AWButtonModule,
                            primeng.SharedModule
                        ],
                        entryComponents: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        exports: [
                            SectionComponent,
                            SectionActionsComponent,
                            SubSectionComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWSectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DTColumn represent single column including header and its body. Each column has its own
     * rendererTemplate which a entry to this component.
     *
     * Keeping this separate from the datatable where DT is not really aware what it is rendering,
     * it allows us more flexibility in terms of different type of column inheriting from this
     * one.. Such as:
     *  DTRowDetail  column
     *  DTSingleSelection column
     *  DTMultiSelection column
     *
     * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
     *
     *  Then later on this will let us create additional logic for the pivotal layout. Because DT
     *  does know anything about the type of the column so whatever is added to the DT.columns it
     *  will be rendered.
     *
     *
     *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
     *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
     *  binding to be set (in px).
     *  We need this to be able to properly position the second table which is changed to absolute
     *  positioning.
     *
     *
     *
     */
    var DTColumn2Component = (function (_super) {
        __extends(DTColumn2Component, _super);
        function DTColumn2Component(env, domHandler) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * Cell alignment. It inserts regular align attribute to the table cell
             *
             */
            _this.align = 'left';
            /**
             *
             * If false applies dt-is-hidden style that hides the column
             *
             */
            _this.isVisible = true;
            /**
             * Sorting direction
             *
             */
            _this.sortOrdering = 'descending';
            /**
             * Tells the template if whether to render a label
             *
             */
            _this.showColumnLabel = true;
            /**
             *
             * See AWDataTable
             *
             */
            _this.showSubHeader = false;
            /**
             *
             * Used together with cell selectionMode to tell which column is selectable
             *
             */
            _this.selectable = false;
            /**
             * Use globally defined HEADER template for current column
             *
             */
            _this.useGlobalHeader = true;
            /**
             * Use globally defined SubHeader template for current column
             *
             */
            _this.useGlobalSubHeader = true;
            /**
             * Use globally defined body template
             *
             */
            _this.useGlobalBody = true;
            /**
             * Tells if the column is data column  - if it is rendering data or just a label or some
             * control
             *
             * This is important when calculating a column span and we need to know which columns are or
             * will be just for selection controls and which holds data
             */
            _this.isDataColumn = true;
            /**
             * Identifies column that will not scroll horizontally with other columns. Column is
             * frozen.
             *
             * For such columns that are marked as frozen binding [width] is required.
             *
             */
            _this.frozen = false;
            _this.maxWidthPx = 0;
            _this.minWidthPx = 0;
            _this.widthPx = 0;
            _this.widestCell = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.key) && core$1.isBlank(this.label)) {
                    throw new Error('Missing required binding: ' +
                        '[key] or [label] bindings must be used at minimum');
                }
                // To be able to position second DT we require [width] to be set as well
                if (this.frozen && core$1.isBlank(this.width)) {
                    throw new Error('Missing required binding [width]: ' +
                        'when [frozen]=true then [width] binding needs to be specified.');
                }
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // need to deffer this and trigger change detection otherwise I get
                // value was changed after it was checked error
                // setTimeout(() =>
                // {
                // });
            };
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         */
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
        DTColumn2Component.prototype.handleHeaderClick = /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
            function (event, element) {
                if (this.isHeaderSelectable()) {
                    this.dt.onHeaderSelectionChange(element, this);
                }
                else if (this.sortable) {
                    this.sort(event);
                }
                event.preventDefault();
            };
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         */
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
        DTColumn2Component.prototype.sort = /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.sortable) {
                    return;
                }
                var /** @type {?} */ targetNode = event.target;
                if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-title') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
                    if (core$1.isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                        this.sortOrder = this.sortOrder * -1;
                        this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
                    }
                    else {
                        this.dt.sortColumn = this;
                    }
                    this.dt.dataSource.state.sortKey = this.key;
                    this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
                    this.dt.sortSingle();
                }
                this.dt.updateDataToRender();
            };
        /**
         * Calculated style class based on data
         *
         *
         */
        /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.dynamicBodyClass = /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ dynClass = core$1.isPresent(this.bodyClassFn)
                    ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
                if (core$1.isPresent(this.bodyStyleClass)) {
                    dynClass += ' ' + this.bodyStyleClass;
                }
                else if (core$1.isPresent(this.styleClass)) {
                    dynClass += ' ' + this.styleClass;
                }
                return dynClass;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isRowSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.dt.isRowSelectable)) {
                    return this.dt.isRowSelectable(item);
                }
                return false;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isCellSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isHeaderSelectable = /**
         * @return {?}
         */
            function () {
                return this.dt.selectionMode === 'cell' && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.getSortOrder = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ order = 0;
                if (core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
                    order = this.dt.sortColumn.sortOrder;
                }
                return order;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isSorted = /**
         * @return {?}
         */
            function () {
                if (!this.sortable) {
                    return false;
                }
                return core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
            };
        /**
         * @param {?} table
         * @return {?}
         */
        DTColumn2Component.prototype.initialize = /**
         * @param {?} table
         * @return {?}
         */
            function (table) {
                this.dt = table;
                if (core$1.isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
                    this.sortable = true;
                    this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
                    this.dt.sortColumn = this;
                }
                if (core$1.isBlank(this.bodyTemplate) && this.useGlobalBody) {
                    this.bodyTemplate = this.dt.bodyTemplate;
                }
                if (core$1.isBlank(this.headerTemplate) && this.useGlobalHeader) {
                    this.headerTemplate = this.dt.headerTemplate;
                }
                if (core$1.isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
                    this.subHeaderTemplate = this.dt.subHeaderTemplate;
                }
                if (core$1.isBlank(this.bodyClassFn)) {
                    this.bodyClassFn = this.dt.bodyClassFn;
                }
                this.maxWidthPx = this.widthToPx(this.maxWidth);
                this.minWidthPx = this.widthToPx(this.minWidth);
                this.widthPx = this.widthToPx(this.width);
            };
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         */
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
        DTColumn2Component.prototype.postInitialize = /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
            function (myIndex) {
                var _this = this;
                var /** @type {?} */ colIndex = myIndex + 1;
                var /** @type {?} */ table;
                if (this.dt.hasFrozenColumns()) {
                    table = ((this.dt)).el
                        .nativeElement.querySelector('.dt-body-frozen table');
                }
                else {
                    table = ((this.dt)).el.nativeElement.querySelector('table');
                }
                if (this.widestCell > 0) {
                    var /** @type {?} */ all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                        'tr td:nth-child(' + colIndex + ')').forEach(function (node) {
                        node.style.width = _this.widestCell + 'px';
                    });
                }
            };
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         */
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
        DTColumn2Component.prototype.isValueColumn = /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.isDataColumn) && core$1.BooleanWrapper.isTrue(this.isDataColumn)) ||
                    core$1.isPresent(this.key);
            };
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         */
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
        DTColumn2Component.prototype.indentForControl = /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
            function (cell, level) {
                if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
                    && core$1.isPresent(cell.nextElementSibling)) {
                    var /** @type {?} */ outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
                    // 1st level is pushed as root
                    if (this.dt.pushRootSectionOnNewLine) {
                        return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                            - outlineNodePadding;
                    }
                    else {
                        return (this.dt.indentationPerLevel * level) + outlineNodePadding;
                    }
                }
                return null;
            };
        /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
        DTColumn2Component.prototype.widthToPx = /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
            function (width) {
                var /** @type {?} */ px;
                if (core$1.isPresent(width)) {
                    if (width.indexOf('%') > 0) {
                        var /** @type {?} */ nonPc = parseFloat(width) / 100;
                        px = nonPc * ((this.dt)).el.nativeElement.offsetWidth;
                    }
                    else {
                        px = parseFloat(width);
                    }
                }
                return px;
            };
        DTColumn2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-column2',
                        template: "<!--\n    To make it more readable Each Column type has its own rendering template instead of putting\n    all this into datatable as this is more responsibility of the column. And the main goal\n    was try to be modular as possible. When There will be different types of columns\n\n    - Regular DTColumn (current implementation),\n    - SelectionColumn (Single/Multi select) - todo,\n    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.\n\n    When implementing new column type you just inherit this DTColumnComponent and provide your\n    own rendering template and DT take care of the rest.\n\n    todo: We have SingleSelect, Multiselect rendering template that is Added programatically\n    todo: We have pivotal rendering template\n\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,\n                 rowIndex:rowIndex}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Templates for header columns. Here we are rendering two types. Header and Subheader that we\n    usually use here as some kind of summary columns. Not really having summary at the bottom like other\n    DT.\n\n    TH column and their text are usually unselectable and most of these were inherited from\n    original PrimeNg DT even not many things got left after we refactor this but the idea is the\n    same.\n\n    Each cell has its dt-cell-def class that sets default styling like font, background, alignment\n    padding, etcs..\n\n\n-->\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\" let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <th #headerCell1 [class]=\"headerStyleClass||styleClass\" *ngIf=\"!isSubHeader\"\n        (click)=\"handleHeaderClick($event, headerCell1)\"\n        [ngClass]=\"{'dt-is-default dt-u-unselectable-text' :true,\n                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),\n                    'dt-u-sortable': sortable,\n                    'dt-is-active': isSorted(),\n                    'dt-is-hidden': !isVisible}\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [attr.tabindex]=\"sortable ? 1 : null\"\n        [dtMaxWidth]=\"maxWidthPx\"\n    >\n\n        <ng-template [ngIf]=\"dt.headerFilterTemplate && columnIndex === 0 \">\n            <ng-container *ngTemplateOutlet=\"dt.headerFilterTemplate\">\n            </ng-container>\n        </ng-template>\n        <!--\n            when cell are selectable we need two version where one wrap the cell content in div\n        -->\n        <ng-template [ngIf]=\"isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"selectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n    </th>\n\n    <th #headerCell2 [class]=\"headerStyleClass||styleClass\" *ngIf=\"isSubHeader\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}\"\n        [dtMaxWidth]=\"maxWidthPx\">\n\n        <span class=\"dt-col-title\" *ngIf=\"dt.showSubHeader && subHeaderTemplate\">\n            <ng-container *ngTemplateOutlet=\"subHeaderTemplate;\n                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </span>\n    </th>\n</ng-template>\n\n\n<!--\n    Template for the body = the TD. For the body and we might want to do the same for header we\n    allow to have calculated body class that comes from the application. So based on the data types\n    you might want to apply different class in order to apply custom styling.\n-->\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        (click)=\"dt.onCellSelectionChange(cell, this, data)\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{ 'dt-is-default': true,\n        'dt-cell-def': !isCellSelectable(data),\n        'dt-is-hidden': !isVisible}\"\n        [dtMaxWidth]=\"maxWidthPx\"\n        >\n\n        <!--\n            Since we need to support cell selection when we need to draw border around it\n            We are wrapping such sells with div which gives us better flexibility\n        -->\n        <ng-template [ngIf]=\"isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"selectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex }\">\n            </ng-container>\n\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </ng-template>\n\n    </td>\n</ng-template>\n\n<!--\n    Todo: create better solution instead of using different template create directive that wraps\n    it with the div conditionally\n-->\n<ng-template #selectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isHeaderSelected(this)}\">\n        <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #headerCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && !headerTemplate\">\n                {{label}}\n    </span>\n\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && headerTemplate\">\n                    <ng-container *ngTemplateOutlet=\"headerTemplate;\n                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }\">\n                    </ng-container>\n    </span>\n\n    <span class=\"dt-col-sortable-icon sap-icon icon-sort\" *ngIf=\"sortable\"\n          [ngClass]=\"{'icon-sort-descending': (getSortOrder() == -1),\n                           'icon-sort-ascending': (getSortOrder() == 1)}\">\n    </span>\n</ng-template>\n\n\n<ng-template #selectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isBodyCellSelected(this, data)}\">\n        <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #bodyCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <!--\n           when no template is used use our FieldPath to access the object value based on the\n           key binding\n        -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"!bodyTemplate\">\n            {{dt.getValue(data, key)}}\n        </span>\n\n\n    <!--\n        In case application wants to provide their own cell component they use\n        #body ng-template to do so.\n    -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"bodyTemplate\">\n            <ng-container *ngTemplateOutlet=\"bodyTemplate;\n            context: {$implicit: this, rowData: data, rowIndex: rowIndex}\"></ng-container>\n        </span>\n</ng-template>\n",
                        styles: [".dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}"],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTColumn2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTColumn2Component.propDecorators = {
            label: [{ type: core.Input }],
            key: [{ type: core.Input }],
            align: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isVisible: [{ type: core.Input }],
            sortable: [{ type: core.Input }],
            sortOrdering: [{ type: core.Input }],
            showColumnLabel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            headerStyleClass: [{ type: core.Input }],
            bodyStyleClass: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            useGlobalHeader: [{ type: core.Input }],
            useGlobalSubHeader: [{ type: core.Input }],
            useGlobalBody: [{ type: core.Input }],
            isDataColumn: [{ type: core.Input }],
            frozen: [{ type: core.Input }],
            maxWidth: [{ type: core.Input }],
            minWidth: [{ type: core.Input }],
            rendererTemplate: [{ type: core.ViewChild, args: ['renderingTemplate',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['header',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['subHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }]
        };
        return DTColumn2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An datatable header area.
     *
     * See {\@link DataTableComponent} for more explanation.
     */
    var DTHeaderComponent2 = (function () {
        function DTHeaderComponent2() {
        }
        DTHeaderComponent2.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-header2',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DTHeaderComponent2;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Custom column implementation to render detail row spaning its column across whole table width.
     *
     *
     */
    var DTDetailRowComponent = (function (_super) {
        __extends(DTDetailRowComponent, _super);
        function DTDetailRowComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * tells if we need to render a line between item row and its detail
             *
             */
            _this.showRowLine = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * Check if we need to keep some leading TDs
         *
         */
        /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
        DTDetailRowComponent.prototype.visibleLeadingCols = /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
            function () {
                return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
            };
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         */
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
        DTDetailRowComponent.prototype.showDetailRow = /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ isVisible = this.isVisible;
                if (core$1.isPresent(this.isVisibleFn)) {
                    isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
                }
                return isVisible;
            };
        /**
         * @param {?} table
         * @return {?}
         */
        DTDetailRowComponent.prototype.initialize = /**
         * @param {?} table
         * @return {?}
         */
            function (table) {
                _super.prototype.initialize.call(this, table);
                this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
            };
        DTDetailRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column',
                        template: "<!--\n    Renders application defined detail column. This template just renders a detail row and\n    not expansion control. This is implemented by different DtColumn implementation and its added\n    (will be) added programmatically during column initialization\n-->\n<ng-template #renderingTemplate let-column=\"column\" let-rowData=\"data\">\n\n    <tr #detailRowElement class=\"dt-body-row dt-detail-row\">\n\n        <td *ngIf=\"dt.hasInvisibleSelectionColumn()\" width=\"1px\"></td>\n        <td *ngIf=\"visibleLeadingCols() > 0\" colspan=\"visibleLeadingCols()\" width=\"1px\">\n            &nbsp;&nbsp;\n        </td>\n        <td [attr.colspan]=\"dt.startOfFirstDataColumn\" [class]=\"dynamicBodyClass(rowData)\"\n            [ngClass]=\"{ 'dt-is-default dt-cell-def': true}\">\n\n            <ng-container\n                *ngTemplateOutlet=\"bodyTemplate; context:{$implicit: this, rowData:rowData}\">\n            </ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTDetailRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTDetailRowComponent.propDecorators = {
            isVisibleFn: [{ type: core.Input }],
            showRowLine: [{ type: core.Input }]
        };
        return DTDetailRowComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     *
     *
     *
     */
    var DTDetailRowExpanderComponent = (function (_super) {
        __extends(DTDetailRowExpanderComponent, _super);
        function DTDetailRowExpanderComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // we dont want to show the row/column unless application says so
            // we dont want to show the row/column unless application says so
            _this.isVisible = false;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.toggleExpansion = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.dt.detailRowExpansionState.toggle(item);
                event.stopPropagation();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.calculateStyleClass = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.detailRowExpansionState.isExpanded(item) ?
                    'icon-slim-arrow-down' : 'icon-slim-arrow-right';
            };
        DTDetailRowExpanderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column-expand',
                        template: "<!--\n   Special column that renders expand/collapse control for detail row when detail row is enabled.\n\n   Just like for the other column it renders header section as well as body section with\n   expand control to toggle the expansion\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\" let-columnIndex=\"columnIndex\" let-rowIndex=\"rowIndex\">\n\n\n    <ng-template [ngIf]=\"isHeader && !isSubHeader\">\n        <th #headerCell1 [class]=\"headerStyleClass||styleClass\"\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,\n                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}\">\n        </th>\n\n    </ng-template>\n\n    <ng-template [ngIf]=\"!isHeader && !isSubHeader\">\n        <td #cell\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{ 'dt-is-default': true,\n                    'dt-cell-def': !isCellSelectable(dataToRender),\n                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),\n                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}\">\n\n            <span (click)=\"toggleExpansion($event, dataToRender)\"\n                  class=\"dt-det-row-expand sap-icon\"\n                  [ngClass]=\"calculateStyleClass(dataToRender)\">\n\n            </span>\n\n        </td>\n\n    </ng-template>\n\n\n</ng-template>\n\n",
                        styles: [".dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}"],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTDetailRowExpanderComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTDetailRowExpanderComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * @license
     * Copyright 2017 SAP Ariba
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     *
     *
     */
    var /** @type {?} */ DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
        'drop', 'dragend'];
    /** @enum {string} */
    var DragDirection = {
        None: 'none',
        Up: 'dt-drag-row-top',
        Down: 'dt-drag-row-bottom',
        Middle: 'dt-drag-row-both',
    };
    /** @enum {string} */
    var DropPosition = {
        Before: 'before',
        After: 'after',
        Into: 'into',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete DataSource implementation for Datatable which defines state and column definition that
     * can programmatically modify rendered columns (if provided) and method for inserting and
     * and deleting records;
     *
     * All operations dealing with data use Observable<T> and instant() method to retrieve current
     * state is not implemented.
     *
     *
     */
    var DT2DataSource = (function (_super) {
        __extends(DT2DataSource, _super);
        function DT2DataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            _this.initialized = false;
            _this.state = Datatable2State.create();
            _this.debugTime = new Date().getTime();
            return _this;
        }
        /**
         * @param {...?} args
         * @return {?}
         */
        DT2DataSource.prototype.init = /**
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                var /** @type {?} */ init = args[0];
                // use existing or find best match for dataProvider
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                // use existing or find best match for dataFinder
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                this.dataFinder.lookupKey = init.lookupKey;
                if (core$1.isBlank(init.state)) {
                    this.state = new Datatable2State();
                }
                else {
                    this.state = init.state;
                }
                this.initialized = true;
            };
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         */
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
        DT2DataSource.prototype.fetch = /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
            function (withParams) {
                var _this = this;
                var /** @type {?} */ params = null;
                if (core$1.isPresent(withParams)) {
                    params = new Map().set('offset', withParams.offset)
                        .set('limit', withParams.limit)
                        .set('orderby', withParams.sortKey)
                        .set('selector', withParams.sortOrder);
                }
                this.dataProvider.fetch(params).subscribe(function (result) {
                    if (withParams.offset > 0) {
                        var /** @type {?} */ incrData = __spread(_this.dataProvider.dataChanges.getValue(), result);
                        _this.dataProvider.dataChanges.next(incrData);
                    }
                    else {
                        _this.dataProvider.dataChanges.next(result);
                    }
                });
            };
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         */
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
        DT2DataSource.prototype.open = /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        DT2DataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
            };
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         */
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.insert = /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.insert(object);
                }
                else {
                    this.dataProvider.offScreenData.push(object);
                    this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
                }
            };
        /**
         * Please see {@link insert} method
         *
         */
        /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.remove = /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.remove(object);
                }
                else {
                    core$1.ListWrapper.removeIfExist(this.dataProvider.offScreenData, object);
                    this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
                }
            };
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         */
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
        DT2DataSource.prototype.find = /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
            function (pattern) {
                var _this = this;
                if (core$1.isBlank(pattern) || pattern.length === 0) {
                    // if we received empty string return orginal list
                    this.fetch(this.state);
                    return;
                }
                var /** @type {?} */ searchParam = pattern;
                if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
                    searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('orderby', this.state.sortKey);
                    }
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('selector', this.state.sortOrder);
                    }
                }
                else {
                    core$1.assert(core$1.isString(pattern), 'Cannot pass non-string value to FullText Finder');
                }
                this.dataFinder.match(searchParam).subscribe(function (result) {
                    _this.dataProvider.dataChanges.next(result);
                });
            };
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         */
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        DT2DataSource.prototype.sort = /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (key, sortOrder) {
                if (core$1.isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
                    return;
                }
                this.state.sortKey = key;
                this.state.sortOrder = sortOrder;
                this.fetch(this.state);
            };
        /**
         *
         * Persist db state
         *
         */
        /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
        DT2DataSource.prototype.updateState = /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
            function (offset, sortField, sOrder) {
                this.state.offset = offset;
                this.state.sortKey = sortField;
                this.state.sortOrder = sOrder;
            };
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         */
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        DT2DataSource.prototype.reorderRows = /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                var /** @type {?} */ array = this.dataProvider.data().slice();
                // take something from top and drag&drop under
                if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
                    newPos -= 1;
                    // take something from bottom and drag&drop above
                }
                else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
                    newPos += 1;
                }
                array.splice.apply(array, __spread([newPos, 0], array.splice(origPos, 1)[0]));
                this.dataProvider.dataChanges.next(array);
            };
        DT2DataSource.MaxLimit = 100;
        return DT2DataSource;
    }(DataSource));
    /**
     * Keeps current datatable state the state which drivers the way while fetching the data as well
     * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
     * browser refresh
     *
     *
     * todo: Create methods to convert this state from and to JSON for easier serialization
     */
    var Datatable2State = (function () {
        function Datatable2State() {
            /**
             * Properties for paging and fetching
             */
            this.offset = 0;
            this.limit = 0;
            /**
             * Identifies default value that is used to render N number of rows in non-fullscreen
             * mode
             *
             */
            this.displayLimit = 0;
            /**
             * Sorting order of the sort field. DataTable support sorting for multiple column but we
             * dont persist it now. Maybe in the future
             */
            this.sortOrder = Datatable2State.Ascending;
            /**
             * If we are using global filter for current datatable then save it here
             */
            this.currentSearchQuery = '';
            this.outlineState = new Map();
            this.detailRowExpandState = new Map();
        }
        /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
        Datatable2State.create = /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
            function (offset, limit, displayLimit, sortField, sOrder, searchQuery, filter, outlineState, detailRowState) {
                if (offset === void 0) {
                    offset = 0;
                }
                if (limit === void 0) {
                    limit = 15;
                }
                if (displayLimit === void 0) {
                    displayLimit = 5;
                }
                if (sortField === void 0) {
                    sortField = '';
                }
                if (sOrder === void 0) {
                    sOrder = 0;
                }
                if (outlineState === void 0) {
                    outlineState = new Map();
                }
                if (detailRowState === void 0) {
                    detailRowState = new Map();
                }
                var /** @type {?} */ s = new Datatable2State();
                s.offset = offset;
                s.limit = limit;
                s.displayLimit = displayLimit;
                s.sortKey = sortField;
                s.sortOrder = sOrder;
                s.currentSearchQuery = searchQuery;
                s.currentFilter = filter;
                s.outlineState = outlineState;
                s.detailRowExpandState = detailRowState;
                return s;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.fromJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var /** @type {?} */ state = JSON.parse(data);
                var /** @type {?} */ ds = new Datatable2State();
                ds.offset = state.offset;
                ds.limit = state.limit;
                ds.displayLimit = state.displayLimit;
                ds.sortKey = state.sortKey;
                ds.sortOrder = state.sortOrder;
                ds.currentSearchQuery = state.currentSearchQuery;
                ds.outlineState = core$1.MapWrapper.createFromAnyMap(state.outlineState);
                ds.detailRowExpandState = core$1.MapWrapper.createFromAnyMap(state.detailRowExpandState);
                return ds;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.toJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var /** @type {?} */ toConvert = {
                    offset: data.offset,
                    limit: data.limit,
                    displayLimit: data.displayLimit,
                    sortKey: data.sortKey,
                    sortOrder: data.sortOrder,
                    currentSearchQuery: data.currentSearchQuery,
                    outlineState: core$1.MapWrapper.toAnyMap(data.outlineState),
                    detailRowExpandState: core$1.MapWrapper.toAnyMap(data.detailRowExpandState)
                };
                return JSON.stringify(toConvert);
            };
        Datatable2State.Ascending = 1;
        Datatable2State.Descending = -1;
        return Datatable2State;
    }());
    /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */
    var /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */ DetailRowExpansionState = (function () {
        function DetailRowExpansionState(dt) {
            this.dt = dt;
        }
        Object.defineProperty(DetailRowExpansionState.prototype, "detailExpansionEnabled", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this.expansionStates);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.expansionStates = new Map();
                }
                else {
                    this.expansionStates = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.toggle = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ key = this.itemToKey(item);
                if (!this.isExpanded(item)) {
                    this.expansionStates.set(key, true);
                }
                else {
                    this.expansionStates.delete(key);
                }
                this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ key = this.itemToKey(item);
                // handle special case where we collapse parent of parent while detail row is expanded
                if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
                    this.expansionStates.delete(key);
                    return false;
                }
                var /** @type {?} */ isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
                return core$1.isPresent(key) && this.expansionStates.has(key);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.itemToKey = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        return DetailRowExpansionState;
    }());
    /**
     * @param {?} init
     * @return {?}
     */
    function isDTInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType) || core$1.isPresent(init.entity);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Column implementation for the Multiselection where we show checkbox control
     *
     *
     */
    var DTMultiSelectColumnComponent = (function (_super) {
        __extends(DTMultiSelectColumnComponent, _super);
        function DTMultiSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTMultiSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-multi-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n\n        <ng-template [ngIf]=\"dt.showSelectAll\">\n            <aw-checkbox [type]=\"'action'\" (action)=\"dt.toggleAllColumns($event)\"\n                         [value]=\"dt.isToggleAllColumnSelected()\"\n                         [disabled]=\"dt.isToggleAllColumnDisabled()\">\n            </aw-checkbox>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!dt.showSelectAll\">&nbsp;\n        </ng-template>\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-checkbox [type]=\"'action'\" [value]=\"dt.isRowSelected(data)\">\n        </aw-checkbox>\n\n    </td>\n</ng-template>\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTMultiSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTMultiSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Column implementation for the SingleSelect where we show checkbox control
     *
     *
     */
    var DTSingleSelectColumnComponent = (function (_super) {
        __extends(DTSingleSelectColumnComponent, _super);
        function DTSingleSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTSingleSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-single-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n        &nbsp;\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-radiobutton [name]=\"'DTRadio'\" [value]=\"data\" [(ngModel)]=\"dt.dataSource.state.selection\">\n        </aw-radiobutton>\n    </td>\n</ng-template>\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTSingleSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTSingleSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DT component that implements the data grid that shows tabular data. Even the basic
     * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
     * allows more extensibility and trying to stay as close as possible to existing AWL implementation
     *
     * There are 3 main pieces:
     *
     *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
     *  contains any additional panels that datatable needs such as our new concept how editing will
     *  work - sliding panel from the bottom
     *
     *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
     *  column into separate component. This way component column has its own renderer template which
     *  can render both header and data cells.
     *  Later on DTColumn is then extended to support other additional column types
     *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
     *
     * To support pivotal layout this can be extended for other additional columns that implements their
     * own rendering templates
     *
     * Datatable - The main component that is only focus on header and body rendering and basaed on the
     * column type it will render the correct template
     * column type it will render the correct template
     *
     *
     *
     *
     *
     */
    var Datatable2Component = (function (_super) {
        __extends(Datatable2Component, _super);
        /**
         *
         * In case of outline table we are inject OutlineState which is provided in the DT component
         * definition. This is used by nested outlineFor component it set itself as reference and
         * initialize the state so it can be used later on inside OutlineControl
         *
         *
         * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
         * inside are unique for this component
         *
         */
        function Datatable2Component(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.el = el;
            _this._defaultDS = _defaultDS;
            _this.changeDetector = changeDetector;
            _this.factoryResolver = factoryResolver;
            _this.outlineState = outlineState;
            _this.zone = zone;
            _this.injector = injector;
            /**
             *  Hides or shows table heading where we have filters and tools menus
             */
            _this.showTableHeader = true;
            /**
             * See AWDataTable
             *
             */
            _this.pivotalLayout = false;
            /**
             * See AWDataTable
             */
            _this.initialSortOrder = 'descending';
            /**
             * When DT is loaded in the page and we are not in the full screen (full page mode), this
             * is hte number of lines that DT will show
             *
             * todo: come up with better name
             */
            _this.displayRowSize = 10;
            /**
             * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
             *
             * todo: come up with better name !!!
             *
             */
            _this.pageSize = 15;
            /**
             * Default message when there are no data .
             *
             * todo: Use i18n value and create resource file
             */
            _this.emptyMessage = 'No records found';
            /**
             *
             * See AWDataTable
             *
             */
            _this.selectionMode = 'none';
            /**
             *
             * Can provide custom icon. These icons are not animated divs, we used css
             * transformation to rotate them.
             *
             */
            _this.loadingIcon = 'icon-synchronize';
            /**
             * Additional indent can be added when rendering detail row
             */
            _this.indentDetailRow = false;
            /**
             * See AWDataTable
             *
             */
            _this.indentationPerLevel = 25;
            /**
             *
             *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
             *  the regular table header
             *
             */
            _this.showSubHeader = false;
            /**
             * See OutlineFor - only used in the tree mode
             */
            _this.expandAll = false;
            /**
             *
             * See OutlineFor  - format - only used in the tree mode
             */
            _this.outlineFormat = 'free';
            /**
             * See AWDataTable
             */
            _this.pushRootSectionOnNewLine = true;
            /**
             * Render or hide expansion control for row detail columns. Expansion control makes sense for
             * simple table, when using this inside outline (tree table), its driven by outline control
             */
            _this.showRowDetailExpansionControl = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectionColumn = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectAll = true;
            /**
             * Show or hide global search term input field in the header
             */
            _this.showGlobalSearch = true;
            /**
             * Enables or disables row reordering
             *
             */
            _this.dndRowEnabled = false;
            /**
             *
             * Fires event that sorting is enabled for column and we trigger sorting
             *
             */
            _this.onSort = new core.EventEmitter();
            /**
             * Based on selection mode it triggers even
             *
             */
            _this.onRowClick = new core.EventEmitter();
            /**
             *
             * When multi or single selection mode is enabled it will trigger event when checkbox or
             * radio buttons is selected
             *
             * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
             */
            _this.onRowSelectionChange = new core.EventEmitter();
            /**
             * When cell body selection changes we fire event
             *
             */
            _this.onCellChange = new core.EventEmitter();
            /**
             * When cell header selection changes we fire event
             *
             */
            _this.onHeaderSelection = new core.EventEmitter();
            /**
             *
             * Triggers when items in the list are updated
             *
             */
            _this.valueChange = new core.EventEmitter();
            _this.classList = 'w-datatable ';
            /**
             *  Indicates that columns were initialed Also used when we hide and show column to trigger
             *  change.
             *
             */
            _this.columnsChanged = false;
            /**
             * See AWDataTable
             */
            _this.numberOfColsBeforeData = 0;
            /**
             * See AWDataTable
             */
            _this.startOfFirstDataColumn = 0;
            _this.dataSource = _this._defaultDS;
            return _this;
        }
        Object.defineProperty(Datatable2Component.prototype, "state", {
            /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             */
            get: /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             * @return {?}
             */ function () {
                return this.dataSource.state;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this.dataSource.state = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.list) && core$1.isPresent(this.destinationClass)) {
                    throw new Error('You cannot use both bindings [list] and [destinationClass]!');
                }
                this.detailRowExpansionState = new DetailRowExpansionState(this);
                // init default columns
                this.rowDetailExpandColumn = this.factoryResolver
                    .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
                this.multiSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
                this.singleSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
                /**
                         * If the data are not deferred and we get list directly then it creates DS. If
                         * ngOnChanges is called first we properly init DS and clean this.list
                         *
                         */
                if (core$1.isPresent(this.destinationClass) || core$1.isPresent(this.list)) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.initDatasource(false);
                }
                // since we work with references let's pass created map inside our state
                this.outlineState.expansionStates = this.state.outlineState;
            };
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         */
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
        Datatable2Component.prototype.ngOnChanges = /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (changes['list'] && core$1.isPresent(changes['list'].currentValue)
                    && !this.dataSource.initialized) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.dataSource.dataProvider.dataChanges.next(this.list);
                }
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // make sure we init a state when detail column is present
                // todo: move this initialization to datasource
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn);
                this.initColumns();
                this.columnsSubscription = this.colsQuery.changes.subscribe(function (_) {
                    _this.initColumns();
                    _this.changeDetector.markForCheck();
                });
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // assign it programatically as we want to have a context for the filter
                if (core$1.isPresent(this.rowDetailColumn) && core$1.isPresent(this.outlineState.outlineFor)) {
                    this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
                }
                if (core$1.isPresent(this.outlineState.outlineFor)) ;
                this.initialized = true;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.columnsChanged && this.el.nativeElement.offsetParent) {
                    this.columnsChanged = false;
                }
                if (this.hasFrozenColumns()) {
                    this.frozenColumns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
                else {
                    this.columns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
            };
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         */
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumns = /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.columns = [];
                this.frozenColumns = [];
                if (this.detailRowExpansionState.detailExpansionEnabled) {
                    this.initDetailColumnExpansion();
                }
                if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
                    this.multiSelectColumn.initialize(this);
                    this.columns.push(this.multiSelectColumn);
                }
                else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
                    this.singleSelectColumn.initialize(this);
                    this.columns.push(this.singleSelectColumn);
                }
                /**
                         * Add expansion column when detail row is enabled
                         */
                if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
                    this.rowDetailExpandColumn.initialize(this);
                    this.columns.push(this.rowDetailExpandColumn);
                }
                this.colsQuery
                    .filter(function (col1) { return !col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.columns.push(col);
                });
                this.initFrozenColumns();
                this.initColumnInfo();
                this.columnsChanged = true;
            };
        /**
         * Check if current column is programmatically created
         *
         */
        /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
        Datatable2Component.prototype.isInternalColumn = /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
            function (col) {
                return col instanceof DTSingleSelectColumnComponent ||
                    col instanceof DTMultiSelectColumnComponent ||
                    col instanceof DTDetailRowExpanderComponent;
            };
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         */
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
        Datatable2Component.prototype.initDatasource = /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
            function (initialize) {
                var _this = this;
                if (initialize === void 0) {
                    initialize = true;
                }
                if (core$1.isBlank(this.state)) {
                    this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
                }
                else {
                    this.state.limit = this.state.displayLimit = this.displayRowSize;
                    if (core$1.isPresent(this.initialSortKey)) {
                        this.state.sortKey = this.initialSortKey;
                        this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
                    }
                }
                if (initialize) {
                    var /** @type {?} */ qType = (this.isOutline() && this.outlineFormat === 'tree') ?
                        QueryType.FullTextOutline : QueryType.FullText;
                    this.dataSource.init({
                        obj: core$1.isPresent(this.destinationClass) ? this.destinationClass : this.list,
                        queryType: qType,
                        state: this.state,
                        multiselect: false
                    });
                }
                this.dataSource.fetch(this.state);
                // reset list to make sure it comes from DataProvider, we use list  to initialize
                this.list = null;
                // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
                // here. We dont work directly with LIST. Any change is reactive and here is listener
                this.dataSource.open().subscribe(function (data) {
                    _this.updateList(data);
                });
            };
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         */
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
        Datatable2Component.prototype.initDetailColumnExpansion = /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.rowDetailColumn)) {
                    this.rowDetailColumn.initialize(this);
                }
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn) &&
                    core$1.BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
            };
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         */
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumnInfo = /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.numberOfColsBeforeData = 0;
                this.columns.forEach(function (col) {
                    if (!col.isValueColumn()) {
                        _this.numberOfColsBeforeData++;
                    }
                });
                if (this.indentDetailRow) {
                    this.numberOfColsBeforeData++;
                }
                this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onCellSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (cell, column, item) {
                if (this.selectionMode !== 'cell') {
                    return;
                }
                var /** @type {?} */ lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    var /** @type {?} */ foundIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey);
                    var /** @type {?} */ isSelected = foundIndex_1 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_1; });
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [lookupKey]);
                    }
                }
                else {
                    this.state.selection = [lookupKey];
                }
                this.onCellChange.emit(this.state.selection);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
        Datatable2Component.prototype.onHeaderSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
            function (cell, column) {
                if (core$1.isPresent(this.state.headerSelection)) {
                    if (this.isHeaderSelected(column)) {
                        this.state.headerSelection = null;
                    }
                    else {
                        this.state.headerSelection = column;
                    }
                }
                else {
                    this.state.headerSelection = column;
                }
                this.onHeaderSelection.emit(this.state.headerSelection);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onHandleRowClicked = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                // special alt key modifier. When used with rows it indicates there is a D&D enabled
                if (event.altKey) {
                    return;
                }
                if (this.selectionMode === 'multi') {
                    this.onRowToggle(event, item);
                }
                else if (this.selectionMode === 'single') {
                    this.onRowSelect(event, item);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowToggle = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                var /** @type {?} */ rowSelected = true;
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    var /** @type {?} */ foundIndex_2 = core$1.ListWrapper.findIndexComplex(this.state.selection, item);
                    var /** @type {?} */ isSelected = foundIndex_2 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_2; });
                        rowSelected = false;
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [item]);
                    }
                    // for the outline go up and down the sync with treeitems
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, isSelected);
                        this.oHandleOutlineRowToggleToParent(item, isSelected);
                    }
                }
                else {
                    this.state.selection = [item];
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, false);
                        this.oHandleOutlineRowToggleToParent(item, false);
                    }
                }
                this.onRowSelectionChange.emit({
                    isSelected: rowSelected,
                    item: this.state.selection
                });
                event.stopPropagation();
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowSelect = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.state.selection = item;
                event.stopPropagation();
                this.onRowSelectionChange.emit(item);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.onHandleOutlineRowToggleToChildren = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                var /** @type {?} */ childrenForNode = this.children.apply(this.context, [currentItem]) || [];
                if (childrenForNode.length > 0) {
                    // If is selected currently then toggle to other state
                    if (!isSelected) {
                        // when checking all from root, deselect children and add all
                        this.onHandleOutlineRowToggleToChildren(currentItem, true);
                        this.state.selection = __spread(this.state.selection, childrenForNode);
                    }
                    else {
                        var _loop_1 = function (child) {
                            var /** @type {?} */ foundIndex = core$1.ListWrapper.findIndexComplex(this_1.state.selection, child);
                            this_1.state.selection = this_1.state.selection
                                .filter(function (val, index) { return index !== foundIndex; });
                        };
                        var this_1 = this;
                        try {
                            // remove each child
                            for (var childrenForNode_1 = __values(childrenForNode), childrenForNode_1_1 = childrenForNode_1.next(); !childrenForNode_1_1.done; childrenForNode_1_1 = childrenForNode_1.next()) {
                                var child = childrenForNode_1_1.value;
                                _loop_1(child);
                            }
                        }
                        catch (e_1_1) {
                            e_1 = { error: e_1_1 };
                        }
                        finally {
                            try {
                                if (childrenForNode_1_1 && !childrenForNode_1_1.done && (_a = childrenForNode_1.return))
                                    _a.call(childrenForNode_1);
                            }
                            finally {
                                if (e_1)
                                    throw e_1.error;
                            }
                        }
                    }
                    try {
                        // apply the same for children of children
                        for (var childrenForNode_2 = __values(childrenForNode), childrenForNode_2_1 = childrenForNode_2.next(); !childrenForNode_2_1.done; childrenForNode_2_1 = childrenForNode_2.next()) {
                            var child = childrenForNode_2_1.value;
                            this.onHandleOutlineRowToggleToChildren(child, isSelected);
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_2_1 && !childrenForNode_2_1.done && (_b = childrenForNode_2.return))
                                _b.call(childrenForNode_2);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                var e_1, _a, e_2, _b;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.oHandleOutlineRowToggleToParent = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                var /** @type {?} */ parent = currentItem.$$parentItem;
                if (core$1.isPresent(parent)) {
                    var /** @type {?} */ childrenForNode = this.children.apply(this.context, [parent]) || [];
                    var /** @type {?} */ allSelected = true;
                    try {
                        for (var childrenForNode_3 = __values(childrenForNode), childrenForNode_3_1 = childrenForNode_3.next(); !childrenForNode_3_1.done; childrenForNode_3_1 = childrenForNode_3.next()) {
                            var child = childrenForNode_3_1.value;
                            allSelected = core$1.ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                                && allSelected;
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_3_1 && !childrenForNode_3_1.done && (_a = childrenForNode_3.return))
                                _a.call(childrenForNode_3);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                    if (!isSelected) {
                        if (allSelected) {
                            this.state.selection.push(parent);
                        }
                    }
                    else {
                        if (!allSelected) {
                            var /** @type {?} */ parentIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, parent);
                            this.state.selection = this.state.selection
                                .filter(function (val, index) { return index !== parentIndex_1; });
                        }
                    }
                    this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
                }
                var e_3, _a;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        Datatable2Component.prototype.onDnDRowDrop = /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                if (core$1.isPresent(this.dataSource)) {
                    // console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
                    this.dataSource.reorderRows(origPos, newPos, dropPos);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.onOutlineExpandChange = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ item = event.item;
                // We dont really need to store a state form outline locally as we are using the same object
                // reference
                // this.state.outlineState = this.outlineState.expansionStates;
                if (this.canUseForDetailRow(item)) {
                    this.detailRowExpansionState.toggle(item);
                }
            };
        /**
         * See AWDataTable
         *
         *
         */
        /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
        Datatable2Component.prototype.sortSingle = /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.list) && core$1.isPresent(this.sortColumn)) {
                    core$1.assert(core$1.isPresent(this.sortColumn.key), 'Invalid column to sort');
                    this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
                    this.onSort.emit({
                        field: this.sortColumn.key,
                        order: this.sortColumn.sortOrder
                    });
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.handleDataChange = /**
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state.sortKey || this.sortColumn) {
                    if (!this.sortColumn && this.columns) {
                        this.sortColumn = this.columns.find(function (col) { return col.key === _this.state.sortKey; });
                    }
                }
                this.updateDataToRender();
                this.valueChange.emit(this.list);
            };
        /**
         * @param {?=} datasource
         * @return {?}
         */
        Datatable2Component.prototype.updateDataToRender = /**
         * @param {?=} datasource
         * @return {?}
         */
            function (datasource) {
                this.dataToRender = datasource || this.list;
                if (core$1.isBlank(this.children) && core$1.isPresent(this.dataToRender)
                    && this.dataToRender.length > 0 && isOutlineNode(this.dataToRender[0])) {
                    this.outlineFormat = 'tree';
                }
                // this.changeDetector.markForCheck();
                this.changeDetector.detectChanges();
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.reset = /**
         * @return {?}
         */
            function () {
                this.sortColumn = null;
                this.updateDataToRender();
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isHeaderSelected = /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.state.headerSelection)) {
                    return false;
                }
                var /** @type {?} */ colMatched = item.key || item.label;
                var /** @type {?} */ currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
                return colMatched === currentCol;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isBodyCellSelected = /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (column, item) {
                var /** @type {?} */ lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                return core$1.isPresent(this.state.selection) &&
                    core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
            };
        /**
         *  See AWDataTable
         *
         */
        /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isRowSelected = /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.hasLeadingSelectColumn() && core$1.isPresent(this.state.selection)) {
                    if (this.selectionMode === 'multi') {
                        return core$1.ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
                    }
                    else if (this.selectionMode === 'single') {
                        return core$1.equals(this.state.selection, item);
                    }
                }
                return false;
            };
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         */
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
        Datatable2Component.prototype.isEmpty = /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
            function () {
                return core$1.isBlank(this.dataToRender) || (this.dataToRender.length === 0);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.hasFrozenColumns = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @return {?}
         */
        Datatable2Component.prototype.hasInvisibleSelectionColumn = /**
         * See AWDataTable
         * @return {?}
         */
            function () {
                return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.hasLeadingSelectColumn = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.visibleColumns = /**
         * @return {?}
         */
            function () {
                return this.columns ? this.columns.filter(function (c) { return c.isVisible; }) : [];
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForString = /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 'ascending') {
                    return 1;
                }
                if (core$1.isBlank(direction) || direction === 'descending') {
                    return -1;
                }
                // todo: log bad key
                return 1;
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForNumber = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 1) {
                    return 'ascending';
                }
                if (core$1.isBlank(direction) || direction === -1) {
                    return 'descending';
                }
                // todo: log bad key
                return 'ascending';
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.toggleAllColumns = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                var /** @type {?} */ selectedObject = this.state.selection || [];
                if (selectedObject.length >= currentItems.length) {
                    this.state.selection = [];
                }
                else {
                    this.state.selection = [];
                    this.state.selection = __spread(currentItems);
                }
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnSelected = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                var /** @type {?} */ selectedObject = this.state.selection || [];
                return currentItems.length > 0 && selectedObject.length >= currentItems.length;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnDisabled = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                return currentItems.length === 0;
            };
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         */
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.showDetailColumn = /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
                    return true;
                }
                return false;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isOutline = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.children) || this.outlineFormat === 'tree';
            };
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         */
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.skipOutlineItem = /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.canUseForDetailRow(item);
            };
        /**
         *
         * See AWDaTable
         *
         */
        /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
        Datatable2Component.prototype.getValue = /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
            function (data, field) {
                return core$1.FieldPath.getFieldValue(data, field);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (this.columnsSubscription) {
                    this.columnsSubscription.unsubscribe();
                }
            };
        /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
        Datatable2Component.prototype.initFrozenColumns = /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.colsQuery
                    .filter(function (col1) { return col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.frozenColumns.push(col);
                });
                if (this.frozenColumns.length > 0) {
                    // find last index of column that is internal / programmatic
                    var /** @type {?} */ lastInx = this.columns.slice()
                        .reverse()
                        .findIndex(function (col) { return _this.isInternalColumn(col); });
                    if (lastInx !== -1) {
                        var /** @type {?} */ idx = this.columns.length - 1 - lastInx;
                        var /** @type {?} */ internalCols = this.columns.splice(0, idx + 1);
                        this.frozenColumns = __spread(internalCols, this.frozenColumns);
                    }
                    var /** @type {?} */ hasValidCols = this.columns
                        .findIndex(function (col) { return core$1.isBlank(col.width); }) === -1;
                    core$1.assert(hasValidCols || core$1.isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                        'column or [scrollWidth] on datatable!');
                    core$1.assert(core$1.isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
                }
            };
        /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
        Datatable2Component.prototype.updateList = /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
            function (newList) {
                var _this = this;
                setTimeout(function () {
                    _this.list = newList;
                    _this.handleDataChange();
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.canUseForDetailRow = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(this.rowDetailColumn) &&
                    ((this.rowDetailColumn)).showDetailRow(item);
            };
        Datatable2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-datatable2',
                        template: "<!--\n    This template focus only on header and body rendering.\n\n    This datatable also supports frozen column and for this rendering it is pretty much transparent\n    as it received sets of column that it needs to render from the TableWrapper.\n\n    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to\n    render to separate tables where one has frozen columns and another one has the rest and its\n    scrollable\n-->\n\n<aw-dt-wrapper #dtWrapper>\n    <ng-template #headingArea>\n        <ng-content select=\"aw-dt-header2\"></ng-content>\n    </ng-template>\n\n    <ng-template #headerRows let-colsToRender let-frozenView=\"frozenColumns\">\n        <ng-container\n            *ngTemplateOutlet=\"header; context:{$implicit: colsToRender, frozen:frozenView }\">\n        </ng-container>\n    </ng-template>\n\n    <ng-template #bodyRows let-colsToRender>\n        <ng-template [ngIf]=\"isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyOutline; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n        <ng-template [ngIf]=\"!isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyPlain; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n    </ng-template>\n</aw-dt-wrapper>\n\n\n<!--\n    Each rendering column has its own renderTemplate which define how things should be render.\n    Based on different column types this code should be transparent as we dont care on this\n    level what kind of column we are rendering.\n\n    Later on when we will support single/multi selection, this will be just another column extending\n    DTColumn and providing its own template\n\n    We pass into this template if we are rendering header, subHeader, or data\n-->\n<ng-template #header let-colsToRender let-frozen=\"frozen\">\n    <tr>\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\"\n                     let-columnIndex=\"index\">\n\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:false,\n                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n\n    <tr *ngIf=\"showSubHeader\">\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:true}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n<ng-template #bodyPlain let-colsToRender>\n\n    <tbody [ngClass]=\"{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}\">\n\n    <ng-template ngFor let-rowData [ngForOf]=\"dataToRender\" let-even=\"even\" let-odd=\"odd\"\n                 let-rowIndex=\"index\" [ngForTrackBy]=\"rowTrackBy\">\n\n        <ng-container *ngTemplateOutlet=\"rowTemplate; context:{$implicit: rowData, even:even,\n                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n\n<ng-template #bodyOutline let-colsToRender>\n    <tbody #outlineFor awOutlineFor [list]=\"dataToRender\"\n           [format]=\"outlineFormat\"\n           [context]=\"context\"\n           [indentationPerLevel]=\"indentationPerLevel\"\n           [pushRootSectionOnNewLine]=\"pushRootSectionOnNewLine\"\n           [children]=\"children\" [expandAll]=\"expandAll\"\n           [state]=\"outlineState\"\n           [ngClass]=\"{'dt-content dt-data-cells ': true,\n                           'dt-is-hoverable-row': rowHover}\"\n           (onExpandChange)=\"onOutlineExpandChange($event)\">\n\n    <ng-template #outline let-rowData let-nestingLevel=\"nestingLevel\" let-rowIndex=\"rowIndex\">\n        <ng-container *ngTemplateOutlet=\"rowTemplate;\n                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n<!--\n    Default template that is display when there are no data\n-->\n<ng-template #noData>\n    <tr *ngIf=\"isEmpty()\" class=\" dt-emptymessage-row\"\n        [style.visibility]=\"loading ? 'hidden' : 'visible'\">\n\n        <td [attr.colspan]=\"visibleColumns().length\" class=\"dt-emptymessage\">\n            <span *ngIf=\"!emptyMessageTemplate\">{{emptyMessage}}</span>\n            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n<!--\n    Template that renders actual row. Renders both header and body column. Each rendered\n    column has its own template called rendererTemplate that has all things that needs to be\n    rendered and we just tell the template if we are rendering header, subheader or body\n-->\n<ng-template #rowTemplate let-rowData let-even=\"event\" let-odd=\"odd\" let-rowIndex=\"rowIndex\"\n             let-nestingLevel=\"nestingLevel\" let-colsToRender=\"colsToRender\">\n\n\n    <tr #rowElement dtDraggableRow [dndRowIndex]=\"rowIndex\"\n        class=\"dt-body-row\"\n        (click)=\"onHandleRowClicked($event, rowData)\"\n        [attr.nestingLevel]=\"nestingLevel\"\n        [ngClass]=\"{'dt-even-row': even, 'dt-odd-row': odd,\n            'dt-row-selected': isRowSelected(rowData),\n            'dt-row-draggable': dndRowEnabled,\n            'dt-root-section': nestingLevel === 0 }\">\n\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-colIndex=\"index\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,\n                    nestingLevel:nestingLevel}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n",
                        styles: [".w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}"],
                        providers: [
                            objectutils.ObjectUtils,
                            OutlineState,
                            { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        Datatable2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: DT2DataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: core.ChangeDetectorRef },
                { type: core.ComponentFactoryResolver },
                { type: OutlineState },
                { type: core.NgZone },
                { type: core.Injector }
            ];
        };
        Datatable2Component.propDecorators = {
            list: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            tableStyleClass: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isRowSelectable: [{ type: core.Input }],
            showTableHeader: [{ type: core.Input }],
            pivotalLayout: [{ type: core.Input }],
            context: [{ type: core.Input }],
            initialSortOrder: [{ type: core.Input }],
            initialSortKey: [{ type: core.Input }],
            displayRowSize: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            emptyMessage: [{ type: core.Input }],
            rowTrackBy: [{ type: core.Input }],
            rowHover: [{ type: core.Input }],
            loading: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            loadingIcon: [{ type: core.Input }],
            indentDetailRow: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            children: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            outlineFormat: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            showRowDetailExpansionControl: [{ type: core.Input }],
            showSelectionColumn: [{ type: core.Input }],
            showSelectAll: [{ type: core.Input }],
            showGlobalSearch: [{ type: core.Input }],
            scrollWidth: [{ type: core.Input }],
            dndRowEnabled: [{ type: core.Input }],
            onSort: [{ type: core.Output }],
            onRowClick: [{ type: core.Output }],
            onRowSelectionChange: [{ type: core.Output }],
            onCellChange: [{ type: core.Output }],
            onHeaderSelection: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DTHeaderComponent2,] }],
            emptyMessageTemplate: [{ type: core.ContentChild, args: ['noDataTempl',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['dtHeader',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['dtSubHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['dtBody',] }],
            headerFilterTemplate: [{ type: core.ContentChild, args: ['headerFilter',] }],
            colsQuery: [{ type: core.ContentChildren, args: [DTColumn2Component,] }],
            rowDetailColumn: [{ type: core.ContentChild, args: [DTDetailRowComponent,] }],
            valueChange: [{ type: core.Output }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            state: [{ type: core.Input }]
        };
        return Datatable2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Please see datatable for more detail description. But the main goal of this wrapper to remove
     * all the common surrounding parts around the datatable and make sure DT can focus only actual
     * header and body structure
     *
     * It is expected that wrapper also provides some code for the sliding up panel containing
     * buttons and other actions that will be used during editing
     *
     *
     * Todo: Extract the expand logic out into some directive or component or just a class
     *
     */
    var DTWrapper = (function (_super) {
        __extends(DTWrapper, _super);
        function DTWrapper(env, render, thisElement, domUtils, platformId, dt) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.render = render;
            _this.thisElement = thisElement;
            _this.domUtils = domUtils;
            _this.platformId = platformId;
            _this.dt = dt;
            /**
             * Color that is used by full screen div overlay to create expanding effect which needs to have
             * little tent;
             *
             */
            _this.expandColorFrom = '#f3f3f3';
            /**
             * Color that is used to set after we are in the full screen so our overlay div hide everything
             * on the page
             *
             */
            _this.expandColorTo = '#FFFFFF';
            /**
             * In order to debounce the typing we need to use subject
             *
             */
            _this.searchTerms = new rxjs.Subject();
            /**
             *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
             *
             */
            _this.isFullScreenMode = false;
            /**
             * Tells if we can support full screen mode - only available for the browser
             *
             */
            _this.supportFullScreen = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                this.querySubscription = this.searchTerms.pipe(
                // wait 300ms after each keystroke before considering the term
                operators.debounceTime(300), 
                // ignore new term if same as previous term
                operators.distinctUntilChanged(), operators.switchMap(function (term) { return rxjs.of(term); })).subscribe(function (term) {
                    if (core$1.isPresent(term)) {
                        _this.dt.dataSource.find(term);
                    }
                });
                this.loadingSub = this.dt.valueChange
                    .subscribe(function (data) { return _this.loadingFinished(); });
            };
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         */
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateFrozenWidth = /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
            function () {
                if (!this.dt.hasFrozenColumns()) {
                    return null;
                }
                var /** @type {?} */ fWidth = 0;
                this.dt.frozenColumns.forEach(function (col) {
                    if (col.maxWidthPx > 0) {
                        fWidth += col.widestCell;
                    }
                    else {
                        fWidth += parseInt(col.width);
                    }
                });
                return fWidth;
            };
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         */
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
        DTWrapper.prototype.alignTablesHeights = /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
            function (frozenView, unFrozenView) {
                core$1.assert(core$1.isPresent(frozenView) && core$1.isPresent(frozenView), 'Cant align table views as one of the view is undefined');
                var /** @type {?} */ frozenRows = frozenView.querySelectorAll('table tr');
                var /** @type {?} */ unFrozenRows = unFrozenView.querySelectorAll('table tr');
                core$1.assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
                Array.from(frozenRows).forEach(function (frozen, index) {
                    var /** @type {?} */ h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
                    frozen.style.height = h + 'px';
                    unFrozenRows[index].style.height = h + 'px';
                });
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.initFullScreen();
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.dt.hasFrozenColumns()) {
                    var /** @type {?} */ frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
                    var /** @type {?} */ unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
                    var /** @type {?} */ frozenWidth = this.calculateFrozenWidth();
                    frozenView.style.width = frozenWidth + 'px';
                    if (core$1.isPresent(unFrozenView)) {
                        // include border and create indent effect by having 1px white space
                        unFrozenView.style.left = (frozenWidth + 2) + 'px';
                        unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                            - frozenView.offsetWidth + 'px';
                        this.alignTablesHeights(frozenView, unFrozenView);
                    }
                }
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.querySubscription)) {
                    this.querySubscription.unsubscribe();
                }
                if (core$1.isPresent(this.loadingSub)) {
                    this.loadingSub.unsubscribe();
                }
            };
        /**
         * FULL SCREEN MODE methods
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreen = /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFullScreenMode) {
                    this.closeFullScreen(event);
                }
                else {
                    this.openFullScreen(event);
                }
            };
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         */
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.openFullScreen = /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.isFullScreenMode = true;
                this.runExpandEffect();
                this.originalScrollPosition = window.pageYOffset;
                window.scroll(0, 0);
                this.toggleFullScreenOnDT(true);
                // mark my element in the path that needs to stay
                var /** @type {?} */ parentNode = this.thisElement.nativeElement.parentNode;
                while (core$1.isPresent(parentNode) && parentNode.tagName !== 'BODY') {
                    parentNode.classList.add('u-full-screen-element');
                    parentNode = parentNode.parentNode;
                }
                this.hideNonFullScreenElement(document.body);
                this.dt.state.limit = Math.round(this.calculateLimit());
                this.dt.dataSource.fetch(this.dt.state);
                // once loaded set back correct page size we use when loading data
                this.dt.state.limit = this.dt.pageSize;
            };
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         */
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.closeFullScreen = /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.isFullScreenMode = false;
                this.showNonFullScreenElement();
                this.runCollapseEffect();
                this.toggleFullScreenOnDT(false);
                this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
                this.dt.dataSource.state.offset = 0;
                this.dt.dataSource.fetch(this.dt.dataSource.state);
                setTimeout(function () {
                    window.scroll(0, _this.originalScrollPosition);
                }, 300);
            };
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         */
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreenOnDT = /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
            function (fullScreen) {
                var _this = this;
                this.dt.el.nativeElement.style.opacity = 0;
                setTimeout(function () {
                    if (fullScreen) {
                        _this.dt.classList += 'dt-full-screen';
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                    else {
                        _this.dt.classList = _this.dt.classList.replace('dt-full-screen', '');
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                }, 200);
            };
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         */
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.onLazyLoad = /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.isLoad) {
                    this.dt.state.offset = event.offset;
                    this.dt.dataSource.fetch(this.dt.state);
                }
                else {
                    var /** @type {?} */ dataProvider = this.dt.dataSource.dataProvider;
                    var /** @type {?} */ data = dataProvider.dataChanges.getValue();
                    dataProvider.dataChanges.next(data.slice(0, event.offset));
                }
            };
        /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
        DTWrapper.prototype.runExpandEffect = /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
            function () {
                var _this = this;
                this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
                this.updateElement();
                this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
                this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
                this.applyTransformation(true);
                setTimeout(function () {
                    _this.dtFullScreenOverlay.nativeElement.style.backgroundColor = _this.expandColorTo;
                }, 300);
            };
        /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
        DTWrapper.prototype.runCollapseEffect = /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
            function () {
                var _this = this;
                this.updateElement();
                this.applyTransformation(false);
                setTimeout(function () {
                    _this.updateElement();
                    _this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
                }, 200);
                setTimeout(function () {
                    _this.updateElement(_this.dtBoundingClientRect.left, _this.dtBoundingClientRect.top, 0, 0);
                }, 400);
            };
        /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
        DTWrapper.prototype.hideNonFullScreenElement = /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
            function (parentElement) {
                if (this.thisElement.nativeElement.parentNode === parentElement) {
                    return;
                }
                for (var /** @type {?} */ i = 0; i < parentElement.children.length; i++) {
                    var /** @type {?} */ element = parentElement.children[i];
                    if (this.needTraverseDown(element)) {
                        this.hideNonFullScreenElement(element);
                    }
                    else if (!element.classList.contains('dt-full-screen')) {
                        element.classList.add('u-fs-element-out');
                    }
                }
            };
        /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
        DTWrapper.prototype.showNonFullScreenElement = /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
            function () {
                Array.from(document.querySelectorAll('.u-fs-element-out'))
                    .forEach(function (elem) { return elem.classList.remove('u-fs-element-out'); });
            };
        /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
        DTWrapper.prototype.needTraverseDown = /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return core$1.isPresent(element) && element.tagName !== 'SCRIPT' &&
                    element.classList.contains('u-full-screen-element') &&
                    !element.classList.contains('dt-full-screen');
            };
        /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateLimit = /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ browserH = this.domUtils.browserDimentions().height;
                var /** @type {?} */ rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
                return (core$1.isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
            };
        /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
        DTWrapper.prototype.updateElement = /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
            function (l, t, w, h) {
                if (l === void 0) {
                    l = this.dtBoundingClientRect.left;
                }
                if (t === void 0) {
                    t = this.dtBoundingClientRect.top;
                }
                if (w === void 0) {
                    w = this.dtBoundingClientRect.width;
                }
                if (h === void 0) {
                    h = this.dtBoundingClientRect.height;
                }
                this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
                this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
                this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
                this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
            };
        /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
        DTWrapper.prototype.applyTransformation = /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
            function (expand) {
                var /** @type {?} */ x, /** @type {?} */ y, /** @type {?} */ tx, /** @type {?} */ ty;
                if (expand) {
                    x = window.innerWidth / this.dtBoundingClientRect.width;
                    y = window.innerHeight / this.dtBoundingClientRect.height;
                    tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                        - this.dtBoundingClientRect.left) / x;
                    ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                        - this.dtBoundingClientRect.top) / y;
                }
                else {
                    x = 1;
                    y = 1;
                    tx = this.dtBoundingClientRect.left;
                    ty = this.dtBoundingClientRect.top;
                }
                this.dtFullScreenOverlay.nativeElement.style.transform =
                    'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
            };
        /**
         * INFINITE SCROLLING METHODS
         * @return {?}
         */
        DTWrapper.prototype.initFullScreen = /**
         * INFINITE SCROLLING METHODS
         * @return {?}
         */
            function () {
                if (!common.isPlatformBrowser(this.platformId)) {
                    this.supportFullScreen = false;
                    return;
                }
                this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
            };
        /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
        DTWrapper.prototype.loadingFinished = /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.infiniteScroll)) {
                    setTimeout(function () { return _this.infiniteScroll.complete(); }, 200);
                }
            };
        DTWrapper.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-wrapper',
                        template: "<div [ngClass]=\"dt.styleClass\" [class.dt-full-screen-mode]=\"isFullScreenMode\"\n     [style.width]=\"dt.width\"\n>\n    <div class=\"dt-loading-overlay\" *ngIf=\"dt.loading\"></div>\n    <div class=\"dt-loading-content\" *ngIf=\"dt.loading\">\n        <i [class]=\"'sap-icon u-dt-spin-icon ' + dt.loadingIcon\"></i>\n    </div>\n\n    <div class=\"dt-header\" *ngIf=\"dt.showTableHeader\">\n        <ng-template *ngIf=\"dt.header; then appDefinedHeader else defaultHeader\"></ng-template>\n    </div>\n\n    <!-- DT BODY with table headers and values -->\n    <div class=\"dt-body-wrapper-view\">\n        <ng-template\n            *ngIf=\"dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns\">\n        </ng-template>\n    </div>\n\n    <!--<div class=\"dt-footer\" *ngIf=\"footer\">-->\n    <!--&lt;!&ndash; footerArea&ndash;&gt;-->\n    <!--<ng-content select=\"aw-dt-footer\"></ng-content>-->\n    <!--</div>-->\n</div>\n\n<!-- todo: dont activate this if we reached the end of list - -->\n<aw-infinite-scroll #infiniteScroll *ngIf=\"isFullScreenMode\"\n                    [distance]=\"'10%'\"\n                    [fetchSize]=\"dt.state.limit\"\n                    (onLoad)=\"onLazyLoad($event)\">\n</aw-infinite-scroll>\n\n\n<ng-template #appDefinedHeader>\n    <ng-container *ngTemplateOutlet=\"heading;\"></ng-container>\n</ng-template>\n\n<ng-template #defaultHeader>\n    <div class=\"dt-global-filter\">\n        <span class=\"sap-icon icon-filter\"></span>\n    </div>\n\n    <div class=\"dt-global-actions\">\n        <div class=\"dt-action-combo\">\n            <span *ngIf=\"supportFullScreen\" class=\"sap-icon icon-resize\"\n                  (click)=\"toggleFullScreen($event)\"></span>\n\n            <aw-input-field *ngIf=\"dt.showGlobalSearch\" styleClass=\"dt-table-search\"\n                            [(ngModel)]=\"dt.state.currentSearchQuery\"\n                            placeHolder=\"search\"\n                            icon=\"icon-search\"\n                            (ngModelChange)=\"searchTerms.next($event)\">\n            </aw-input-field>\n            <span class=\"ariba-icon icon-more\"></span>\n        </div>\n    </div>\n</ng-template>\n\n<!--\n    Each section frozen/non-frozen is calculated inside table-wrapper in the ngAfterViewChecked, where we set\n    proper width for each frame as well as left coordinates for the right one\n-->\n<ng-template #dtBodyNoFrozenColumns>\n    <!--\n        For non-frozen case we also need to set TRUE as the view is actually frozen and does not\n        scroll.\n        We use this frozenColumns flag inside DT to properly set column index on the header level\n        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))\n\n        therefore we need to set true even in this case to return real columnIndex since we dont\n        have the second table.\n    -->\n    <ng-container *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: true }\">\n    </ng-container>\n</ng-template>\n\n<ng-template #dtBodyWithFrozenColumns>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }\">\n    </ng-container>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: false }\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #dtBody let-columns let-frozenColumns=\"frozenColumns\">\n\n    <div #dtContainer class=\"dt-body-wrapper\"\n         [style.width.px]=\"this.calculateFrozenWidth()\"\n         [class.dt-body-unfrozen]=\"dt.hasFrozenColumns() && !frozenColumns\"\n         [class.dt-body-frozen]=\"dt.hasFrozenColumns() && frozenColumns\"\n    >\n\n        <table [ngClass]=\"dt.tableStyleClass\"\n               [style.width]=\"frozenColumns ? null : dt.scrollWidth\"\n               [class.dt-pivot-layout]=\"dt.pivotalLayout\"\n               [class.dt-plain-layout]=\"!dt.pivotalLayout && !dt.isOutline()\">\n\n            <!-- Render TH header rows-->\n            <thead class=\"dt-thead\">\n            <ng-container *ngTemplateOutlet=\"headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }\">\n            </ng-container>\n            </thead>\n\n            <!--\n                Render data rows. For data rows we need to keep tbody tag inside DT table\n                due to Outline\n             -->\n            <ng-container *ngTemplateOutlet=\"bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }\">\n            </ng-container>\n        </table>\n    </div>\n</ng-template>\n\n\n<div #dtFullScreenOverlay class=\"dt-full-screen-overlay u-full-screen-element\"></div>\n",
                        styles: [".dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:all .4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}"],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        DTWrapper.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.Renderer2 },
                { type: core.ElementRef },
                { type: DomUtilsService },
                { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] }
            ];
        };
        DTWrapper.propDecorators = {
            expandColorFrom: [{ type: core.Input }],
            expandColorTo: [{ type: core.Input }],
            heading: [{ type: core.ContentChild, args: ['headingArea',] }],
            headerRows: [{ type: core.ContentChild, args: ['headerRows',] }],
            bodyRows: [{ type: core.ContentChild, args: ['bodyRows',] }],
            footer: [{ type: core.ContentChild, args: ['footerArea',] }],
            dtFullScreenOverlay: [{ type: core.ViewChild, args: ['dtFullScreenOverlay',] }],
            infiniteScroll: [{ type: core.ViewChild, args: ['infiniteScroll',] }]
        };
        return DTWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * This directive is responsible for checking and setting the widest content width onto
     * Column component as the widestCell property.
     *
     * We use this directive inside dt-column.component to store a current width for each td,th
     *
     *
     */
    var SetCellMaxWidthDirective = (function () {
        function SetCellMaxWidthDirective(element, render, td) {
            this.element = element;
            this.render = render;
            this.td = td;
        }
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // console.log('Cell Max Width: ' + this.dtMaxWidth, this.dtMaxWidth > 0);
                if (core$1.isPresent(this.dtMaxWidth) && this.dtMaxWidth > 0) {
                    var /** @type {?} */ inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
                    if (core$1.isPresent(inlineData)) {
                        inlineData.style.whiteSpace = 'nowrap';
                        inlineData.style.display = 'inline-block';
                        var /** @type {?} */ cellWidth = inlineData.offsetWidth; // td
                        inlineData.style.whiteSpace = 'normal';
                        inlineData.style.display = 'inline';
                        if (!this.isInThresHold(cellWidth)) {
                            return;
                        }
                        cellWidth += this.tdPadding();
                        if (cellWidth > this.td.widthPx) {
                            if (cellWidth < this.dtMaxWidth) {
                                this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                                    this.td.widestCell;
                            }
                            else if (cellWidth >= this.dtMaxWidth) {
                                this.td.widestCell = (this.dtMaxWidth > this.td.widestCell)
                                    ? this.dtMaxWidth : this.td.widestCell;
                            }
                        }
                    }
                }
            };
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         */
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.isInThresHold = /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
            function (newWidth) {
                if (this.td.widestCell > 0) {
                    return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
                }
                return true;
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.tdPadding = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ computedStyle = getComputedStyle(this.element.nativeElement);
                var /** @type {?} */ cell = parseInt(computedStyle.paddingLeft) || 0;
                cell += parseInt(computedStyle.paddingRight) || 0;
                cell += parseInt(computedStyle.borderRightWidth) || 0;
                cell += parseInt(computedStyle.borderLeftWidth) || 0;
                // plus give it some little space around the text so it nots px to px inner width of the td
                // cuz it could wrap
                cell += 5;
                return cell;
            };
        SetCellMaxWidthDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dtMaxWidth]'
                    },] },
        ];
        /** @nocollapse */
        SetCellMaxWidthDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: DTColumn2Component }
            ];
        };
        SetCellMaxWidthDirective.propDecorators = {
            dtMaxWidth: [{ type: core.Input }]
        };
        return SetCellMaxWidthDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Directive used inside DT in order to support table rows re-ordering. This manages all the
     * D&D necessary logic for this functionality.
     *
     * [dtDraggableRow] is used inside the `rowTemplate` like this:
     *
     *
     * ```html
     *
     * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
     *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
     *
     *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
     *          class="dt-body-row"
     *
     *
     *
     * ```
     *
     * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
     *
     *
     *
     */
    var DTDraggableRowDirective = (function () {
        function DTDraggableRowDirective(element, dt, domUtils, ngZone) {
            this.element = element;
            this.dt = dt;
            this.domUtils = domUtils;
            this.ngZone = ngZone;
            /**
             *
             * Tells the directive if we enable middle row zone to create an effect that we are dropping
             * into the row. Used for outline DT mainly.
             *
             */
            this.dropIntoEnabled = false;
            /**
             * Current TR index number
             *
             */
            this.dndRowIndex = 0;
            /**
             * Holds information about our dragging direction UP and DOWN in order to assign correct style
             * that highlights the row at the top or bottom
             *
             */
            this.dragDir = DragDirection.None;
            /**
             * Indicates that we dragged our row and stopped in the middle of the other row
             *
             */
            this.inMiddle = false;
            /**
             *
             * Current drag Y coordinates which is used together with the dragDir when assinging dragging
             * direction.
             *
             */
            this.dragY = 0;
        }
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.setupEventListeners();
                }
            };
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.releaseEventListeners();
                }
            };
        /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
        DTDraggableRowDirective.prototype.setupEventListeners = /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
            function () {
                var _this = this;
                this.ngZone.runOutsideAngular(function () {
                    _this.eventHandlers = {};
                    _this.eventHandlers['mousedown'] = _this.onMouseDownEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('mousedown', _this.eventHandlers['mousedown']);
                    _this.eventHandlers['dragstart'] = _this.onDragStartEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragstart', _this.eventHandlers['dragstart']);
                    _this.eventHandlers['dragover'] = _this.onDragOverEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragover', _this.eventHandlers['dragover']);
                    _this.eventHandlers['dragleave'] = _this.onDragLeaveEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragleave', _this.eventHandlers['dragleave']);
                    _this.eventHandlers['drop'] = _this.onDropEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('drop', _this.eventHandlers['drop']);
                    _this.eventHandlers['dragend'] = _this.onDragEndEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragend', _this.eventHandlers['dragend']);
                });
            };
        /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
        DTDraggableRowDirective.prototype.releaseEventListeners = /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
            function () {
                var _this = this;
                DragEvents.forEach(function (name) {
                    document.removeEventListener('name', _this.eventHandlers[name]);
                });
            };
        /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onMouseDownEvent = /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
                    this.element.nativeElement.draggable = true;
                    var /** @type {?} */ elToBeDragged = this.domUtils.elementDimensions(event.target);
                    this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
                }
                else {
                    this.element.nativeElement.draggable = false;
                }
            };
        /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragStartEvent = /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                setTimeout(function () {
                    if (core$1.isPresent(event.target.classList)) {
                        event.target.classList.add('dt-row-dragging');
                    }
                }, 200);
                this.dt.env.setValue('isDragging', true);
                this.dt.env.setValue('dndId', this.dndRowIndex);
                event.dataTransfer.setData('text', this.dndRowIndex);
            };
        /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragOverEvent = /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.dataTransfer.dropEffect = 'move';
                if (this.dragY < event.pageY) {
                    this.dragDir = DragDirection.Down;
                }
                else if (this.dragY > event.pageY) {
                    this.dragDir = DragDirection.Up;
                }
                // dont set again unless its different
                if (this.dragY !== event.pageY) {
                    this.dragY = event.pageY;
                }
                if (this.isValidDropTarget(event)) {
                    // todo test this preventDefault() so it does not create some sideeffect
                    event.preventDefault();
                    this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
                }
            };
        /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDropEvent = /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.clearClasses(event.target.parentElement);
                // event.preventDefault();
                var /** @type {?} */ origIndx = this.dt.env.getValue('dndId');
                var /** @type {?} */ dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
                this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
                this.inMiddle = false;
                this.dragY = 0;
            };
        /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragLeaveEvent = /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ tr = this.domUtils.closest(event.target, 'tr');
                this.clearClasses(tr);
                this.dt.env.deleteValue('dndOnHoldIndex');
            };
        /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragEndEvent = /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(event.target.classList)) {
                    event.target.classList.remove('dt-row-dragging');
                }
                this.clearClasses(event.target);
                this.element.nativeElement.draggable = false;
                this.dt.env.deleteValue('isDragging');
                this.dt.env.deleteValue('dndId');
                this.dt.env.deleteValue('ddClickDeviance');
            };
        /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
        DTDraggableRowDirective.prototype.markRowWithClass = /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
            function (event, activeRow) {
                this.clearClasses(activeRow);
                // Check if drag item is in the middle of other row
                var /** @type {?} */ currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
                var /** @type {?} */ draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
                if (this.dropIntoEnabled) {
                    this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
                }
                if (this.inMiddle) {
                    activeRow.classList.add(DragDirection.Middle);
                }
                else {
                    activeRow.classList.add(this.dragDir);
                }
            };
        /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.isValidDropTarget = /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ origInx = this.dt.env.getValue('dndId');
                var /** @type {?} */ siblingRow = this.dndRowIndex - origInx;
                return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
                    !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
                    !(siblingRow === -1 && this.dragDir === DragDirection.Down);
            };
        /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
        DTDraggableRowDirective.prototype.clearClasses = /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
            function (tr) {
                tr.classList.remove('dt-drag-row-top');
                tr.classList.remove('dt-drag-row-bottom');
                tr.classList.remove('dt-drag-row-both');
            };
        /**
         *  private
         *
         * @return {?}
         */
        DTDraggableRowDirective.prototype.dragDirToString = /**
         *  private
         *
         * @return {?}
         */
            function () {
                switch (this.dragDir) {
                    case DragDirection.Up:
                        return 'Up';
                    case DragDirection.Down:
                        return 'Down';
                    default:
                        return 'Not Sure';
                }
            };
        DTDraggableRowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dtDraggableRow]'
                    },] },
        ];
        /** @nocollapse */
        DTDraggableRowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] },
                { type: DomUtilsService },
                { type: core.NgZone }
            ];
        };
        DTDraggableRowDirective.propDecorators = {
            dropIntoEnabled: [{ type: core.Input }],
            dndRowIndex: [{ type: core.Input }]
        };
        return DTDraggableRowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDatatable2Module = (function () {
        function AWDatatable2Module() {
        }
        AWDatatable2Module.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Datatable2Component,
                            DTWrapper,
                            DTColumn2Component,
                            DTHeaderComponent2,
                            DTDetailRowComponent,
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent,
                            DTDraggableRowDirective,
                            SetCellMaxWidthDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            AWCoreComponentModule,
                            AWCheckBoxModule,
                            AWOutlineForModule,
                            AWRadioButtonModule,
                            AWInputFieldModule
                        ],
                        entryComponents: [
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent
                        ],
                        exports: [
                            Datatable2Component,
                            DTColumn2Component,
                            AWOutlineForModule,
                            DTHeaderComponent2,
                            DTDetailRowComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWDatatable2Module;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationHeaderComponent = (function () {
        function ConfirmationHeaderComponent() {
        }
        ConfirmationHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-header',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return ConfirmationHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationFooterComponent = (function () {
        function ConfirmationFooterComponent() {
        }
        ConfirmationFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-footer',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return ConfirmationFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
     * functionality. It behaves like a dialog, is modal, and not closable by default.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
     *        a confirmation to the user.
     *
     *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
     *                        title: 'Confirmation',
     *                        body: ` Are you sure ? `,
     *                        width: 300,
     *                        onConfirm: () => {
     *                              this.confirmAction();
     *                        },
     *                        onCancel: () => {
     *                              this.cancelAction();
     *                        }
     *           });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-confirmation [title]="'Confirmation'"
     *                                      [(visible)]="display"
     *                                     (onConfirm)="confirmAction()"
     *                                    (onCancel)="cancelAction()">
     *                                       <i class="sap-icon icon-alert"></i>
     *                                       Are you sure you want to delete your hard drive?
     *                            </aw-confirmation>
     *
     *                                   <aw-button [size]="'small'" (click)="open()">
     *                                       Open Confirmation
     *                                   </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     confirmAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     confirmAction()  {
     *                        this.confirmAction = "confirmed";
     *                      }
     *
     *                      close() {
     *                         this.display = false;
     *                      }
     *
     *                      cancelAction() {
     *                          this.confirmAction = "canceled";
     *                      }
     *
     *       }
     *
     *
     */
    var ConfirmationComponent = (function (_super) {
        __extends(ConfirmationComponent, _super);
        function ConfirmationComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = false;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Fired when user clicked on confirm button.
             */
            _this.onConfirm = new core.EventEmitter();
            /**
             * Fired when user clicked on cancel button.
             */
            _this.onCancel = new core.EventEmitter();
            _this.width = 400;
            _this.height = 'auto';
            // Todo: internationalize.
            // Todo: internationalize.
            _this.confirmActionLabel = 'Confirm';
            _this.cancelActionLabel = 'Cancel';
            return _this;
        }
        /**
         * open confirmation.
         */
        /**
         * open confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.open = /**
         * open confirmation.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                this.visibleChange.emit(true);
            };
        /**
         * close confirmation.
         */
        /**
         * close confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.close = /**
         * close confirmation.
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does the confirmation have header content?
         */
        /**
         * Does the confirmation have header content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasHeader = /**
         * Does the confirmation have header content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does the confirmation have footer content?
         */
        /**
         * Does the confirmation have footer content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasFooter = /**
         * Does the confirmation have footer content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        /**
         * Confirm action.
         */
        /**
         * Confirm action.
         * @return {?}
         */
        ConfirmationComponent.prototype.confirm = /**
         * Confirm action.
         * @return {?}
         */
            function () {
                this.close();
                this.onConfirm.emit();
            };
        /**
         * Cancel action.
         */
        /**
         * Cancel action.
         * @return {?}
         */
        ConfirmationComponent.prototype.cancel = /**
         * Cancel action.
         * @return {?}
         */
            function () {
                this.close();
                this.onCancel.emit();
            };
        ConfirmationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation',
                        template: "<aw-dialog [title]=\"title\" [(visible)]=\"visible\"\n           [modal]=\"true\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n           [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onOpen)=\"open()\" (onClose)=\"close()\">\n\n    <aw-dialog-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-confirmation-header\"></ng-content>\n    </aw-dialog-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n\n    <aw-dialog-footer *ngIf=\"hasFooter(); else defaultFooter\">\n        <ng-content select=\"aw-confirmation-footer\"></ng-content>\n    </aw-dialog-footer>\n\n    <ng-template #defaultFooter>\n        <aw-dialog-footer>\n            <aw-button name=\"confirm\" [style]=\"'primary'\" (action)=\"confirm()\">\n                {{confirmActionLabel}}\n            </aw-button>\n\n            <aw-button name=\"cancel\" [style]=\"'secondary'\" (action)=\"cancel()\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n        </aw-dialog-footer>\n    </ng-template>\n\n</aw-dialog>\n",
                        styles: [".confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}"]
                    },] },
        ];
        /** @nocollapse */
        ConfirmationComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        ConfirmationComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            confirmActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            onConfirm: [{ type: core.Output }],
            onCancel: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [ConfirmationHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [ConfirmationFooterComponent,] }]
        };
        return ConfirmationComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWConfirmationModule = (function () {
        function AWConfirmationModule() {
        }
        AWConfirmationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            AWDialogModule,
                            AWButtonModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        exports: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWConfirmationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Container panel providing scrolling functionality for its children. You can configure this
     * container to let it to scroll its content either horizontally, vertically or let the content
     * wrap.
     *
     *
     * Usage is pretty simple:
     *
     *  ### Example using horizontal scroll (default behavior):
     *
     *  ```
     *            <aw-scrollable>
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     *  ```
     *
     *  ### Example using vertical scroll:
     *
     *  ```
     *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     * ```
     *
     *  ### Example scrolling is disabled and content wraps and centers:
     *
     *  ```
     *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *  ```
     *
     * ### Height property:
     *
     * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
     * is set automatically based on its content. The height should be always 100% when using
     * this in parent container.
     *
     * If "vertical scrolling" is used you need to make sure that:
     *   - your parent container sets the boundaries with correctly set width and height
     *   otherwise it will use 100% of the viewport
     *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
     *   the document
     *
     *
     *
     *
     */
    var ScrollableContainerComponent = (function (_super) {
        __extends(ScrollableContainerComponent, _super);
        function ScrollableContainerComponent(env, elementRef) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elementRef = elementRef;
            /**
             * Defines scrolling direction of the container meaning tells which overflow axies will be
             * disabled or enabled.
             *
             * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
             *
             * When scrolling direction is "vertical" please make sure you maintain correct height and
             * width.
             *
             */
            _this.direction = 'horizontal';
            /**
             * Defines how flexbox container items should be aligned. Default behavior is LEFT
             *
             */
            _this.alignment = 'left';
            _this.height = '100%';
            _this.width = '100%';
            return _this;
        }
        /**
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initDefault();
            };
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         */
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnChanges = /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.initDefault();
            };
        /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.initDefault = /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
            function () {
                this.layoutClass = 'u-scrollable-fh';
                if (this.direction === 'vertical') {
                    this.layoutClass = 'u-scrollable-fv';
                }
                if (this.direction === 'vertical-row') {
                    this.layoutClass = 'u-scrollable-fv-row';
                }
                else if (this.direction === 'both') {
                    this.layoutClass = 'u-scrollable-fb';
                }
                else if (this.direction === 'none') {
                    this.layoutClass = 'u-scrollable-fn';
                }
                this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
                if (core$1.isPresent(this.styleClass)) {
                    this.layoutClass += " " + this.styleClass;
                }
                // make sure we default width and height to some value in case somebody passes null
                if (core$1.isBlank(this.width)) {
                    this.width = '100%';
                }
                if (core$1.isBlank(this.height)) {
                    this.height = '100%';
                }
            };
        /**
         * Tells if the horizontal scrollbar is visible
         *
         */
        /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasHorizontalScroll = /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollWidth > scrollContainer.clientWidth;
            };
        /**
         * Tells if the vertical scrollbar is visible
         *
         */
        /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasVerticalScroll = /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollHeight > scrollContainer.clientHeight;
            };
        ScrollableContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-scrollable',
                        template: "<div class=\"w-scrollable\" [ngClass]=\"layoutClass\" [style.width]=\"width\"\n     [style.height]=\"height\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}"]
                    },] },
        ];
        /** @nocollapse */
        ScrollableContainerComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        ScrollableContainerComponent.propDecorators = {
            direction: [{ type: core.Input }],
            alignment: [{ type: core.Input }]
        };
        return ScrollableContainerComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWScrollableContainerModule = (function () {
        function AWScrollableContainerModule() {
        }
        AWScrollableContainerModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ScrollableContainerComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            ScrollableContainerComponent
                        ],
                        exports: [
                            ScrollableContainerComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWScrollableContainerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ LB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ListComponent; }),
        multi: true
    };
    /**
     *
     * The List component represent a structure which contains a list of selectable items. Items
     * selection can be configured in single-selection, multi-selection or multi-selection with visible
     * checkboxes mode.
     * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
     * easy way for application developer to layout its own custom content or even change out of box
     * behavior.
     *
     *
     *  ### Examples
     *
     *  1. Render simple single selection list
     *
     *  ```html
     *
     *      <aw-list [list]="list"></aw-list>
     *
     *  ```
     *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
     *  is selected
     *
     *  ```html
     *
     *   <aw-list #awlist [list]="list"
     *                       height="150px"
     *                       width="250px"
     *                       [selectionMode]="'multi'">
     *
     *                  <ng-template #right let-item>
     *
     *                      <span class="sap-icon"
     *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
     *                            '': !awlist.pListBox.isSelected(item)}">
     *
     *                      </span>
     *                  </ng-template>
     *   </aw-list>
     *
     *  ```
     *
     * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
     *  the way item name is rendered
     *
     *
     *
     *  ```html
     *
     *   <aw-list [list]="list" height="180px"
     *                       width="200px"
     *                       [selection]="selection"
     *                       [selectionMode]="'multiWithCheckbox'">
     *
     *                  <ng-template #middle let-item>
     *                      XX-{{item.value}}
     *                  </ng-template>
     *    </aw-list>
     *
     *  ```
     *
     *
     *
     */
    var ListComponent = (function (_super) {
        __extends(ListComponent, _super);
        function ListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Component recognizes 3 modes: single, multi, multi with visible checkboxes
             */
            _this.selectionMode = 'single';
            /**
             * Don't render Listbox border. Used for embedding this inside other components
             *
             */
            _this.borderless = false;
            /**
             * Triggered when we double click on the list Item
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * Event fired when user select a item
             *
             */
            _this.onSelection = new core.EventEmitter();
            _this.listStyle = {};
            _this.isMultiple = false;
            _this.showCheckbox = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.isMultiple = this.selectionMode === 'multi' ||
                    this.selectionMode === 'multiWithCheckbox';
                this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
                // cannot have both either we use field to get display value or valueTransformer
                if (core$1.isPresent(this.field) && core$1.isPresent(this.valueTransformer)) {
                    throw new Error('You can have either [field] or [valueTransformer].');
                }
                if (core$1.isPresent(this.list)) {
                    this.initList();
                }
                else {
                    throw new Error('Missing [list] binding.');
                }
                // Also add overflowY to make sure it can scroll and does not expand based on its content
                if (core$1.isPresent(this.height)) {
                    this.listStyle['height'] = this.height;
                    this.listStyle['overflow-y'] = 'auto';
                }
                if (core$1.isPresent(this.width)) {
                    this.listStyle['width'] = this.width;
                }
                if (this.borderless) {
                    this.listStyle['border-color'] = 'transparent';
                }
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.selection);
                    if (core$1.isBlank(this.selection)) {
                        this.selection = this.formControl.value;
                    }
                }
            };
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         */
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
        ListComponent.prototype.itemClicked = /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
            function (event, item, checkbox) {
                if (core$1.isPresent(checkbox)) {
                    this.pListBox.onCheckboxClick(event, item);
                }
                else if (core$1.isPresent(this.pListBox)) {
                    this.pListBox.onOptionClick(event, item);
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * Internal
         *
         */
        /**
         * Internal
         *
         * @return {?}
         */
        ListComponent.prototype.hasRightTempl = /**
         * Internal
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.rZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasLeftTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.lZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasMiddleTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.mZoneTempl);
            };
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         */
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
        ListComponent.prototype.onItemSelected = /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event.value)) {
                    return;
                }
                this.onSelection.emit(event.value);
                if (this.isStandalone) {
                    this.formControl.setValue(event.value, { emitEvent: true });
                }
                this.onModelChanged(event.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        ListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(value);
                    }
                }
            };
        /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
        ListComponent.prototype.initList = /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.map(function (item) {
                        return { label: _this.displayValue(item), value: item };
                    });
                }
            };
        /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
        ListComponent.prototype.displayValue = /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return '';
                }
                var /** @type {?} */ val = item.toString();
                if (core$1.isPresent(this.field)) {
                    val = item[this.field];
                }
                else if (core$1.isPresent(this.valueTransformer)) {
                    val = this.valueTransformer(item);
                }
                return val;
            };
        ListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-list',
                        template: "<p-listbox #listbox [options]=\"internalList\" [multiple]=\"isMultiple\" [checkbox]=\"showCheckbox\"\n           [(ngModel)]=\"selection\" [disabled]=\"disabled\" [style]=\"listStyle\" [showToggleAll]=\"false\"\n           (onChange)=\"onItemSelected($event)\" (onDblClick)=\"action.emit($event.value)\"\n           [styleClass]=\"styleClass\">\n\n\n    <ng-template let-item pTemplate=\"item\">\n        <div class=\"w-li-wrapper\">\n            <div class=\"w-li-left\">\n                <ng-template *ngIf=\"hasLeftTempl(); else defaultLeft\"\n                             [ngTemplateOutlet]=\"lZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n\n                <ng-template #defaultLeft>\n                    <aw-checkbox #check *ngIf=\"isMultiple && showCheckbox\"\n                                 [isStandalone]=\"false\"\n                                 [value]=\"listbox.isSelected(item)\"\n                                 type=\"action\"\n                                 (action)=\"itemClicked($event, item, check)\">\n                    </aw-checkbox>\n                </ng-template>\n            </div>\n\n            <div class=\"w-li-middle\" (click)=\"itemClicked($event, item, null)\">\n\n                <ng-template *ngIf=\"hasMiddleTempl(); else defaultMiddle\"\n                             [ngTemplateOutlet]=\"mZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n                <ng-template #defaultMiddle>\n                    {{item.label}}\n                </ng-template>\n\n            </div>\n\n            <div class=\"w-li-right\" *ngIf=\"hasRightTempl()\">\n                <ng-template [ngTemplateOutlet]=\"rZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\">\n                </ng-template>\n\n            </div>\n        </div>\n    </ng-template>\n</p-listbox>\n",
                        styles: ["::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}"],
                        providers: [
                            LB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        ListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            field: [{ type: core.Input }],
            borderless: [{ type: core.Input }],
            action: [{ type: core.Output }],
            onSelection: [{ type: core.Output }],
            pListBox: [{ type: core.ViewChild, args: ['listbox',] }],
            lZoneTempl: [{ type: core.ContentChild, args: ['left',] }],
            mZoneTempl: [{ type: core.ContentChild, args: ['middle',] }],
            rZoneTempl: [{ type: core.ContentChild, args: ['right',] }]
        };
        return ListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWListModule = (function () {
        function AWListModule() {
        }
        AWListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            primeng.ListboxModule,
                            AWCheckBoxModule
                        ],
                        entryComponents: [
                            ListComponent
                        ],
                        exports: [
                            ListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardProgressComponent = (function () {
        function WizardProgressComponent() {
            this.currentStep = 0;
            this.stepChanged = new core.EventEmitter();
            this.totalSteps = 0;
        }
        /**
         * @return {?}
         */
        WizardProgressComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.steps) {
                    var /** @type {?} */ currentIndex = this.steps.indexOf(this.steps.filter(function (step) { return step.current; })[0]);
                    this.totalSteps = this.steps.length;
                    this.setCurrentStep(~currentIndex ? currentIndex : 0);
                }
            };
        /**
         * @param {?=} index
         * @return {?}
         */
        WizardProgressComponent.prototype.setCurrentStep = /**
         * @param {?=} index
         * @return {?}
         */
            function (index) {
                if (index === void 0) {
                    index = 0;
                }
                this.steps[index].current = true;
                this.currentStep = index;
                this.stepChanged.emit({ current: this.currentStep });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        WizardProgressComponent.prototype.goToStep = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (!this.steps[index].complete) {
                    return;
                }
                var /** @type {?} */ currentIndex = this.steps.indexOf(this.steps.filter(function (step) { return step.current; })[0]);
                this.steps[currentIndex].current = false;
                this.setCurrentStep(index);
            };
        WizardProgressComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-wizard-progress',
                        template: "<div class=\"step-indicator\">{{currentStep + 1}}/{{totalSteps}}</div>\n<div class=\"aw-step-progress\">\n    <div class=\"aw-step-progress__item\" *ngFor=\"let step of steps; let i = index;\"\n         [ngClass]=\"{ 'aw-step-progress__item--is-active': step.current === true }\"\n         (click)=\"goToStep(i);\">\n    </div>\n</div>\n",
                        styles: [":host{display:block}.step-indicator{width:100%;text-align:center;font-size:14px;font-weight:600;padding-bottom:.3rem}.aw-step-progress{display:flex;flex-direction:row;padding:.2rem;justify-content:center}.aw-step-progress__item{cursor:pointer;list-style:none;width:1.2rem;margin:0 .2rem;border-radius:.3rem;height:.4rem;background-color:#eaeaea}.aw-step-progress__item:last-child{margin-right:0}.aw-step-progress__item:first-child{margin-left:0}.aw-step-progress__item--is-active{background-color:#09a7af}"]
                    },] },
        ];
        /** @nocollapse */
        WizardProgressComponent.ctorParameters = function () { return []; };
        WizardProgressComponent.propDecorators = {
            steps: [{ type: core.Input }],
            currentStep: [{ type: core.Input }],
            stepChanged: [{ type: core.Output }]
        };
        return WizardProgressComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardProgressModule = (function () {
        function WizardProgressModule() {
        }
        WizardProgressModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            WizardProgressComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            WizardProgressComponent
                        ],
                        exports: [
                            WizardProgressComponent
                        ],
                        providers: []
                    },] },
        ];
        return WizardProgressModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders a Toggle Switch
     *
     * ### Example
     *
     * ```typescript
     *
     * \@Component({
     *          selector: 'myToggleSection' ,
     *          template: '<aw-toggle [model]="inputValue" [labelText]="labelText" >
     *              </aw-toggle>'
     *      })
     *      export class MyNoteComponent
     *      {
     *          inputValue: boolean = false;
     *          labelText: string = 'my label';
     *      }
     *
     * ```
     */
    var ToggleSwitchComponent = (function (_super) {
        __extends(ToggleSwitchComponent, _super);
        function ToggleSwitchComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * toggle model
             */
            _this.model = false;
            return _this;
        }
        /**
         * click handler for toggle
         */
        /**
         * click handler for toggle
         * @return {?}
         */
        ToggleSwitchComponent.prototype.changeHandler = /**
         * click handler for toggle
         * @return {?}
         */
            function () {
                this.model = !this.model;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-toggle',
                        template: "<div class=\"w-toggle\">\n    <label class=\"w-toggle__label\" *ngIf=\"labelText\">\n        {{ labelText }}\n    </label>\n    <div class=\"slider\" (click)=\"changeHandler()\">\n        <div class=\"slider__button\" [ngClass]=\"{ 'slider__button--is-active': model === true }\"></div>\n    </div>\n</div>\n",
                        styles: [":host{display:block}.w-toggle input{display:none}.w-toggle__label{color:#999;margin-right:.2rem}.w-toggle .slider{position:relative;height:.6rem;width:1.5rem;background-color:#d8d8d8;border-radius:.9rem;display:inline-block;border-top:1px solid #7e7e7e;border-left:1px solid #b5b5b5;border-right:1px solid #b5b5b5}.w-toggle .slider__button{left:-.1rem;transition:left .1s ease-out;cursor:pointer;position:absolute;height:1rem;width:1rem;border-radius:50%;background-color:#eaeaea;top:-.2rem}.w-toggle .slider__button--is-active{left:calc(100% - .8rem);background-color:#09a7af}"]
                    },] },
        ];
        /** @nocollapse */
        ToggleSwitchComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        ToggleSwitchComponent.propDecorators = {
            model: [{ type: core.Input }],
            labelText: [{ type: core.Input }]
        };
        return ToggleSwitchComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ToggleSwitchComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            ToggleSwitchComponent
                        ],
                        exports: [
                            ToggleSwitchComponent
                        ],
                        providers: []
                    },] },
        ];
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Overlay Component is a simple version of the dialog where there's only content.
     * Overlay will appear at the position where the action performed trigger an overlay.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
     *        because angular currently doesn't support dynamic content projection.
     *
     *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
     *
     *            // Add content. There's not support for dynamic content projection yet.
     *            // So have add content directly.
     *            // This is probably not the best way.
     *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
     *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
     *
     *          // delay the opening after ng lifecycle has been initialized.
     *          setTimeout(() => { overlay.instance.open(event); }, 1);
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
     *                                                     (onClose)="overlayAction='close'">
     *                                      <img src="sales.png" alt="Chart"/>
     *                                </aw-overlay>
     *
     *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
     *                                    Open Overlay
     *                                </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     overlayAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *
     */
    var OverlayComponent = (function (_super) {
        __extends(OverlayComponent, _super);
        function OverlayComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Enables hide overlay when outside is clicked.
             */
            _this.dismissable = true;
            /**
             * displays the close icon 'x' at top of right corner.
             */
            _this.showCloseIcon = false;
            /**
             * Event fired when overlay is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the overlay is opened.
             */
            _this.onOpen = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        OverlayComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * Open Overlay
         * @param event
         */
        /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.open = /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.overlay.show(event);
                this.onOpened(null);
            };
        /**
         * Close Overlay
         */
        /**
         * Close Overlay
         * @return {?}
         */
        OverlayComponent.prototype.close = /**
         * Close Overlay
         * @return {?}
         */
            function () {
                this.overlay.hide();
            };
        /**
         * toggle open and close.
         * @param event
         */
        /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.toggle = /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.overlay.toggle(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onOpened = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onOpen.emit(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onClosed = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onClose.emit(event);
            };
        OverlayComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-overlay',
                        template: "<p-overlayPanel [dismissable]=\"dismissable\" [showCloseIcon]=\"showCloseIcon\"\n                [styleClass]=\"styleClass\" [appendTo]=\"appendTo\"\n                (onAfterHide)=\"onClosed($event)\">\n    <ng-content></ng-content>\n</p-overlayPanel>\n",
                        styles: ["::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}"]
                    },] },
        ];
        /** @nocollapse */
        OverlayComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        OverlayComponent.propDecorators = {
            dismissable: [{ type: core.Input }],
            showCloseIcon: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            overlay: [{ type: core.ViewChild, args: [primeng.OverlayPanel,] }]
        };
        return OverlayComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var HCCardPosition = {
        top: 0,
        bottom: 1,
        none: 2,
    };
    HCCardPosition[HCCardPosition.top] = "top";
    HCCardPosition[HCCardPosition.bottom] = "bottom";
    HCCardPosition[HCCardPosition.none] = "none";
    /** @enum {number} */
    var HCCardAlignment = {
        left: 0,
        paddedLeft: 1,
        right: 2,
        paddedRight: 3,
        default: 4,
    };
    HCCardAlignment[HCCardAlignment.left] = "left";
    HCCardAlignment[HCCardAlignment.paddedLeft] = "paddedLeft";
    HCCardAlignment[HCCardAlignment.right] = "right";
    HCCardAlignment[HCCardAlignment.paddedRight] = "paddedRight";
    HCCardAlignment[HCCardAlignment.default] = "default";
    /**
     * Maps position to styles that are applied to the Card container. This is just to make it easier
     * as we are working with enumerations and have already enum type.
     *
     * u-hc-arrow-b: Arrow will appear at the bottom
     * u-hc-arrow-t: Arrow will appear at the top
     *
     * u-hc-shadow-t: Border shadow will appear at the top
     * u-hc-shadow-b: Border shadow will appear at the bottom
     */
    var /** @type {?} */ PositionToStyle = {
        top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
        bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
        none: ''
    };
    /**
     *
     * Maps aligned Card container to custom styles in order to apply correct arrow
     *
     * -ll: Stands for Large Left (large: there is plenty of space around )
     * -lr: Stands for Large right
     * -sl: Stands for Small left (Small and resized screen where we try to fit card container
     * somewhere in between)
     * -sr: Stands for Large right
     *
     */
    var /** @type {?} */ AlignmentToStyle = {
        left: ' u-hc-arrow-ll',
        right: ' u-hc-arrow-lr',
        paddedLeft: ' u-hc-arrow-sl',
        paddedRight: ' u-hc-arrow-sr',
        default: ' u-hc-arrow-ll',
    };
    /**
     * The HoverCard components adds hover behavior to text, the specified content is loaded
     * on the left or right side of the element.
     *
     * Todo: extends so we can wrap any element and any element can be triggering this. Not only
     * linkTitle
     *
     *
     * ### Example:
     *
     * ```
     *
     *   <aw-hover-card [linkTitle]="'Frank kolar'">
     *       <h3>My Card Title</h3>
     *       <div>
     *
     *           This is my contents
     *
     *       </div>
     *
     *
     *    </aw-hover-card>
     * ```
     *
     * By default there is [forceClose]=true which forces the user to use X close icon
     *
     *
     *
     */
    var HoverCardComponent = (function (_super) {
        __extends(HoverCardComponent, _super);
        function HoverCardComponent(elem, env, cd) {
            var _this = _super.call(this, env) || this;
            _this.elem = elem;
            _this.env = env;
            _this.cd = cd;
            /**
             * Should we keep the hover card open and force user to manually close
             *
             */
            _this.forceClose = true;
            /**
             *
             * This current workaround until we find better solution. PrimeNG overlays operates within
             * its relative element so if the overlay is wrapped inside some other relative container
             * the overlay content is croped by its parent and content is not visible.
             *
             * They have [appendTo] binding which we need to use for this purpose
             *
             */
            _this.appendContentToBody = true;
            /**
             *
             * Internal style class to use to apply additional styles when it needs to show a Arrow on the
             * card
             *
             */
            _this.arrowClass = '';
            _this.opening = false;
            _this.currrentPosition = HCCardPosition.none;
            return _this;
        }
        /**
         * @return {?}
         */
        HoverCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                core$1.assert(core$1.isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
                // make sure there is open HC when we start new component
                this.env.deleteValue('hc-open');
                if (!this.appendContentToBody) {
                    this.appendTo = null;
                }
            };
        /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         */
        /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         * @return {?}
         */
        HoverCardComponent.prototype.ngAfterViewChecked = /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         * @return {?}
         */
            function () {
                if (this.opening) {
                    var /** @type {?} */ container = this.awOverlay.overlay.container;
                    var /** @type {?} */ cntRect = container.getBoundingClientRect();
                    if (this.currrentPosition !== HCCardPosition.none) {
                        this.adjustCard(container, cntRect, this.awOverlay.overlay);
                    }
                    else {
                        this.arrowClass = '';
                    }
                    this.opening = false;
                }
            };
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         */
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
        HoverCardComponent.prototype.initElements = /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
                var /** @type {?} */ triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
                this.titleAreaRect = titleElem.getBoundingClientRect();
                this.trigRect = triggerElem.getBoundingClientRect();
                this.trigIconMiddle = this.trigRect.width / 2;
            };
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         */
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.openCard = /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
                    this.awOverlay.open(event);
                    this.env.setValue('hc-open', true);
                }
            };
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         */
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardOpened = /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ container = this.awOverlay.overlay.container;
                var /** @type {?} */ target = this.awOverlay.overlay.target;
                this.openForAdjustments(container);
                // pre-run positioning so we can calculate new coordinates
                this.awOverlay.overlay.domHandler.absolutePosition(container, target);
                var /** @type {?} */ cntRect = container.getBoundingClientRect();
                this.currrentPosition = this.positionForCard(container, cntRect);
                this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
                this.closeForAdjustments(container);
                this.opening = true;
            };
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         */
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardClosed = /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.env.deleteValue('hc-open');
            };
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         */
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.adjustCard = /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                var /** @type {?} */ diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
                var /** @type {?} */ scrollTop = modalContainer.domHandler.getWindowScrollTop();
                var /** @type {?} */ posWithScroll = containerRect.top + scrollTop;
                container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
                var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
                container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
            };
        /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.applyStyleClass = /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                if (this.currrentPosition !== HCCardPosition.none) {
                    var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
                    this.arrowClass = ((PositionToStyle))[((HCCardPosition))[this.currrentPosition]];
                    this.arrowClass += ((AlignmentToStyle))[((HCCardAlignment))[alignment]];
                }
                else {
                    this.arrowClass = '';
                }
            };
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         */
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
        HoverCardComponent.prototype.positionForCard = /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
            function (container, boundingRect) {
                // secure this in case of IE returning undefined
                var /** @type {?} */ borderWidth = getComputedStyle(container).borderWidth;
                var /** @type {?} */ cntWidth = parseFloat(borderWidth || '0');
                var /** @type {?} */ pos = HCCardPosition.none;
                if (this.trigRect.bottom < boundingRect.top) {
                    pos = HCCardPosition.bottom;
                }
                else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
                    pos = HCCardPosition.top;
                }
                return pos;
            };
        /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.alignmentForCard = /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (boundingRect, modalContainer) {
                var /** @type {?} */ alignment = HCCardAlignment.left;
                var /** @type {?} */ viewPort = modalContainer.domHandler.getViewport();
                if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
                    boundingRect.left > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.left;
                }
                else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedLeft;
                }
                else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedRight;
                }
                else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
                    (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.right;
                }
                else {
                    alignment = HCCardAlignment.default;
                }
                return alignment;
            };
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         */
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.openForAdjustments = /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'hidden';
                container.style.display = 'block';
                this.initElements();
            };
        /**
         *
         * Turn off display back NONE
         *
         */
        /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.closeForAdjustments = /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'visible';
                // container.style.display = 'none';
            };
        /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
        HoverCardComponent.prototype.calcLeftForAlignment = /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
            function (boundingRect, alignment) {
                // width for which we need to shift card. 25% or 10% of the container width
                var /** @type {?} */ wLargeTriangle = boundingRect.width * 0.25;
                var /** @type {?} */ wSmallTriangle = boundingRect.width * 0.10;
                switch (alignment) {
                    case HCCardAlignment.right:
                        var /** @type {?} */ shiftRight = boundingRect.left + wLargeTriangle;
                        var /** @type {?} */ trigRight = this.trigRect.right - this.trigIconMiddle;
                        return shiftRight - (boundingRect.right - trigRight);
                    case HCCardAlignment.paddedRight:
                        var /** @type {?} */ shiftRightS = boundingRect.left + wSmallTriangle;
                        var /** @type {?} */ trigRightS = this.trigRect.right - this.trigIconMiddle;
                        return shiftRightS - (boundingRect.right - trigRightS);
                    case HCCardAlignment.paddedLeft:
                        var /** @type {?} */ shiftLeftPad = boundingRect.left - wSmallTriangle;
                        return shiftLeftPad + this.trigIconMiddle;
                    case HCCardAlignment.left:
                    default:
                        var /** @type {?} */ shiftLeft = boundingRect.left - wLargeTriangle;
                        return shiftLeft + this.trigIconMiddle;
                }
            };
        /**
         * Default padding representing a height of the Arrow for which we need to vertically adjust
         * Card container
         *
         */
        HoverCardComponent.ArrowPad = 10;
        /**
         * Defines safe threshold where there might not be enough space around or Card is aligned with
         * the left or right edge of the viewport for which we need to position the Arrow closer to the
         * side of the card
         *
         */
        HoverCardComponent.SpacingLimit = 50;
        HoverCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hover-card',
                        template: "<span class=\"w-hc\">\n    <span class=\"w-hc-title\">\n        <aw-string [value]=\"linkTitle\"></aw-string>\n        <span class=\"sap-icon icon-slim-arrow-down\" (mouseover)=\"openCard($event)\"></span>\n    </span>\n\n    <div class=\"w-hc-body\">\n\n         <aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"\n                     [styleClass]=\"arrowClass\"\n                     [appendTo]=\"appendTo\"\n                     (onOpen)=\"cardOpened($event)\"\n                     (onClose)=\"cardClosed($event)\">\n\n        <!-- this is workaround to create a _ngcontent-INDEX reference so we can\n        refer to this ng-content. Angular does not have any way right now to track this\n        -->\n        <span class=\"u-ngcontent\">\n                <ng-content></ng-content>\n            </span>\n\n    </aw-overlay>\n\n    </div>\n</span>\n\n\n<!--<ng-template #contentToBody>-->\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--[appendTo]=\"appendTo\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n\n<!--</ng-template>-->\n\n\n<!--<ng-template #contentToOverlay>-->\n\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n<!--</ng-template>-->\n\n\n",
                        styles: [".w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}"]
                    },] },
        ];
        /** @nocollapse */
        HoverCardComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef }
            ];
        };
        HoverCardComponent.propDecorators = {
            linkTitle: [{ type: core.Input }],
            forceClose: [{ type: core.Input }],
            appendContentToBody: [{ type: core.Input }],
            awOverlay: [{ type: core.ViewChild, args: ['overlay',] }]
        };
        return HoverCardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
     *
     * ###Usage
     *
     * ```
     *   <my-directive spyhooks><my-directive>
     *
     * ```
     */
    var SpyLifeCycleHooksDirective = (function () {
        function SpyLifeCycleHooksDirective(elementRef) {
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.logIt('onInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.logIt('onDestroy');
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.logIt('ngOnChanges = ' + changes);
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                this.logIt('ngDoCheck');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentChecked');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewChecked');
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.logIt = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                var /** @type {?} */ level = 0;
                var /** @type {?} */ me = this.elementRef.nativeElement;
                var /** @type {?} */ tagBody = me;
                while ((tagBody = tagBody.parentNode) != null) {
                    level++;
                    if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                        break;
                    }
                }
                var /** @type {?} */ indent = '';
                var /** @type {?} */ indentNumber = level;
                while (level > 0) {
                    indent += '\t';
                    level--;
                }
                var /** @type {?} */ params = '';
                if (core$1.isPresent(me.attributes)) {
                    for (var /** @type {?} */ i = 0; i < me.attributes.length; i++) {
                        var /** @type {?} */ attr = me.attributes.item(i);
                        if (this.ignore(attr.name.toLowerCase())) {
                            continue;
                        }
                        params += '(' + attr.name + '=' + attr.value + '),  ';
                    }
                }
                core$1.print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ignore = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return name.indexOf('_ng') > -1 ||
                    name.indexOf('ng-') > -1 ||
                    name.indexOf('spyhooks') > -1;
            };
        SpyLifeCycleHooksDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[spyHooks]' },] },
        ];
        /** @nocollapse */
        SpyLifeCycleHooksDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        return SpyLifeCycleHooksDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    var components = /*#__PURE__*/Object.freeze({
        AWCoreComponentModule: AWCoreComponentModule,
        ErrorMessagesComponent: ErrorMessagesComponent,
        ModalContainer: ModalContainer,
        ModalService: ModalService,
        ModalComponent: ModalComponent,
        CurrencyFormatPipe: CurrencyFormatPipe,
        BaseComponent: BaseComponent,
        BaseFormComponent: BaseFormComponent,
        WidgetSizeColumns: WidgetSizeColumns,
        DomUtilsService: DomUtilsService,
        EmbeddedItemDirective: EmbeddedItemDirective,
        EmbededItem: EmbededItem,
        ErrorManagerService: ErrorManagerService,
        GenericContainerComponent: GenericContainerComponent,
        IncludeComponentDirective: IncludeComponentDirective,
        ComponentRegistry: ComponentRegistry,
        DataTypeProviderRegistry: DataTypeProviderRegistry,
        DataProviders: DataProviders,
        DataFinders: DataFinders,
        DataFinder: DataFinder,
        FullTextArrayDataFinder: FullTextArrayDataFinder,
        QueryType: QueryType,
        DATA_SOURCE: DATA_SOURCE,
        DataProvider: DataProvider,
        ArrayDataProvider: ArrayDataProvider,
        NgForSetDirective: NgForSetDirective,
        AwNameDirective: AwNameDirective,
        AwNameStore: AwNameStore,
        FormTableComponent: FormTableComponent,
        AWFormTableModule: AWFormTableModule,
        FormRowComponent: FormRowComponent,
        TopZoneComponent: TopZoneComponent,
        LeftZoneComponent: LeftZoneComponent,
        MiddleZoneComponent: MiddleZoneComponent,
        RightZoneComponent: RightZoneComponent,
        BottomZoneComponent: BottomZoneComponent,
        AWInputFieldModule: AWInputFieldModule,
        AWStringFieldModule: AWStringFieldModule,
        AWBasicNavigatorModule: AWBasicNavigatorModule,
        AWButtonModule: AWButtonModule,
        AWCardModule: AWCardModule,
        AWCheckBoxModule: AWCheckBoxModule,
        AWCheckBoxListModule: AWCheckBoxListModule,
        AWHyperlinkModule: AWHyperlinkModule,
        AWChooserModule: AWChooserModule,
        AWDropdownModule: AWDropdownModule,
        AWCurrencyModule: AWCurrencyModule,
        AWDateAndTimeModule: AWDateAndTimeModule,
        AWDialogModule: AWDialogModule,
        AWGenericChooserModule: AWGenericChooserModule,
        AWRadioButtonModule: AWRadioButtonModule,
        AWRadioButtonListModule: AWRadioButtonListModule,
        AWOutlineForModule: AWOutlineForModule,
        AWTextAreaModule: AWTextAreaModule,
        AWPageNotificationModule: AWPageNotificationModule,
        AWPageWrapperModule: AWPageWrapperModule,
        AWRichTextAreaModule: AWRichTextAreaModule,
        AWSectionModule: AWSectionModule,
        AWStepperModule: AWStepperModule,
        AWDatatable2Module: AWDatatable2Module,
        AWConfirmationModule: AWConfirmationModule,
        AWScrollableContainerModule: AWScrollableContainerModule,
        AWListModule: AWListModule,
        WizardProgressModule: WizardProgressModule,
        ToggleSwitchModule: ToggleSwitchModule,
        BasicNavigatorComponent: BasicNavigatorComponent,
        ButtonComponent: ButtonComponent,
        CheckBoxListComponent: CheckBoxListComponent,
        CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
        ChooserComponent: ChooserComponent,
        ChooserState: ChooserState,
        DefaultSelectionState: DefaultSelectionState,
        ChooserSelectionState: ChooserSelectionState,
        ChooserDataSource: ChooserDataSource,
        isDSChooserInitParams: isDSChooserInitParams,
        CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
        CurrencyComponent: CurrencyComponent,
        Money: Money,
        DateAndTimeComponent: DateAndTimeComponent,
        DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
        DialogComponent: DialogComponent,
        DialogHeaderComponent: DialogHeaderComponent,
        DialogFooterComponent: DialogFooterComponent,
        ConfirmationComponent: ConfirmationComponent,
        ConfirmationHeaderComponent: ConfirmationHeaderComponent,
        ConfirmationFooterComponent: ConfirmationFooterComponent,
        OverlayComponent: OverlayComponent,
        DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
        DropdownComponent: DropdownComponent,
        GCChooserState: GCChooserState,
        GenericChooserComponent: GenericChooserComponent,
        HyperlinkComponent: HyperlinkComponent,
        INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
        InputFieldComponent: InputFieldComponent,
        RadioButtonListComponent: RadioButtonListComponent,
        StringComponent: StringComponent,
        TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
        TextAreaComponent: TextAreaComponent,
        CardComponent: CardComponent,
        CardZoneTitleComponent: CardZoneTitleComponent,
        CardZoneTopComponent: CardZoneTopComponent,
        CardZoneBottomComponent: CardZoneBottomComponent,
        OutlineForComponent: OutlineForComponent,
        OutlineControlComponent: OutlineControlComponent,
        OutlineState: OutlineState,
        isOutlineNode: isOutlineNode,
        PageContentComponent: PageContentComponent,
        PageNotificationComponent: PageNotificationComponent,
        PageNotification: PageNotification,
        PageInitialized: PageInitialized,
        PageDestroyed: PageDestroyed,
        PageWrapper: PageWrapper,
        PageLifeCycleService: PageLifeCycleService,
        ObjectPageWrapperComponent: ObjectPageWrapperComponent,
        PageHeaderComponent: PageHeaderComponent,
        PageMenuItem: PageMenuItem,
        UserNotification: UserNotification,
        PageFooterComponent: PageFooterComponent,
        SidenavComponent: SidenavComponent,
        PageActionsComponent: PageActionsComponent,
        SectionComponent: SectionComponent,
        SubSectionComponent: SubSectionComponent,
        SectionActionsComponent: SectionActionsComponent,
        EditorType: EditorType,
        RichTextAreaComponent: RichTextAreaComponent,
        CheckboxComponent: CheckboxComponent,
        RadioButtonComponent: RadioButtonComponent,
        StepperComponent: StepperComponent,
        StepComponent: StepComponent,
        ScrollableContainerComponent: ScrollableContainerComponent,
        HoverCardComponent: HoverCardComponent,
        ListComponent: ListComponent,
        Datatable2Component: Datatable2Component,
        DTHeaderComponent2: DTHeaderComponent2,
        DTColumn2Component: DTColumn2Component,
        DTDetailRowComponent: DTDetailRowComponent,
        Datatable2State: Datatable2State,
        isDTInitParams: isDTInitParams,
        DT2DataSource: DT2DataSource,
        DetailRowExpansionState: DetailRowExpansionState,
        DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
        WizardProgressComponent: WizardProgressComponent,
        ToggleSwitchComponent: ToggleSwitchComponent,
        DomHandler: primeng.DomHandler,
        TreeDragDropService: primeng.TreeDragDropService,
        ConfirmationService: primeng.ConfirmationService,
        Header: primeng.Header,
        Footer: primeng.Footer,
        PrimeTemplate: primeng.PrimeTemplate,
        Column: primeng.Column,
        Row: primeng.Row,
        HeaderColumnGroup: primeng.HeaderColumnGroup,
        FooterColumnGroup: primeng.FooterColumnGroup,
        SharedModule: primeng.SharedModule,
        AccordionTab: primeng.AccordionTab,
        Accordion: primeng.Accordion,
        AccordionModule: primeng.AccordionModule,
        AUTOCOMPLETE_VALUE_ACCESSOR: primeng.AUTOCOMPLETE_VALUE_ACCESSOR,
        AutoComplete: primeng.AutoComplete,
        AutoCompleteModule: primeng.AutoCompleteModule,
        BlockUI: primeng.BlockUI,
        BlockUIModule: primeng.BlockUIModule,
        Breadcrumb: primeng.Breadcrumb,
        BreadcrumbModule: primeng.BreadcrumbModule,
        ButtonDirective: primeng.ButtonDirective,
        Button: primeng.Button,
        ButtonModule: primeng.ButtonModule,
        Captcha: primeng.Captcha,
        CaptchaModule: primeng.CaptchaModule,
        CALENDAR_VALUE_ACCESSOR: primeng.CALENDAR_VALUE_ACCESSOR,
        Calendar: primeng.Calendar,
        CalendarModule: primeng.CalendarModule,
        Card: primeng.Card,
        CardModule: primeng.CardModule,
        Carousel: primeng.Carousel,
        CarouselModule: primeng.CarouselModule,
        UIChart: primeng.UIChart,
        ChartModule: primeng.ChartModule,
        CHECKBOX_VALUE_ACCESSOR: primeng.CHECKBOX_VALUE_ACCESSOR,
        Checkbox: primeng.Checkbox,
        CheckboxModule: primeng.CheckboxModule,
        CHIPS_VALUE_ACCESSOR: primeng.CHIPS_VALUE_ACCESSOR,
        Chips: primeng.Chips,
        ChipsModule: primeng.ChipsModule,
        CodeHighlighter: primeng.CodeHighlighter,
        CodeHighlighterModule: primeng.CodeHighlighterModule,
        COLORPICKER_VALUE_ACCESSOR: primeng.COLORPICKER_VALUE_ACCESSOR,
        ColorPicker: primeng.ColorPicker,
        ColorPickerModule: primeng.ColorPickerModule,
        ConfirmDialog: primeng.ConfirmDialog,
        ConfirmDialogModule: primeng.ConfirmDialogModule,
        ContextMenuSub: primeng.ContextMenuSub,
        ContextMenu: primeng.ContextMenu,
        ContextMenuModule: primeng.ContextMenuModule,
        DataGrid: primeng.DataGrid,
        DataGridModule: primeng.DataGridModule,
        DataList: primeng.DataList,
        DataListModule: primeng.DataListModule,
        DataScroller: primeng.DataScroller,
        DataScrollerModule: primeng.DataScrollerModule,
        DTRadioButton: primeng.DTRadioButton,
        DTCheckbox: primeng.DTCheckbox,
        ColumnHeaders: primeng.ColumnHeaders,
        ColumnFooters: primeng.ColumnFooters,
        TableBody: primeng.TableBody,
        ScrollableView: primeng.ScrollableView,
        DataTable: primeng.DataTable,
        DataTableModule: primeng.DataTableModule,
        DeferredLoader: primeng.DeferredLoader,
        DeferModule: primeng.DeferModule,
        Dialog: primeng.Dialog,
        DialogModule: primeng.DialogModule,
        Draggable: primeng.Draggable,
        Droppable: primeng.Droppable,
        DragDropModule: primeng.DragDropModule,
        DROPDOWN_VALUE_ACCESSOR: primeng.DROPDOWN_VALUE_ACCESSOR,
        Dropdown: primeng.Dropdown,
        DropdownModule: primeng.DropdownModule,
        EDITOR_VALUE_ACCESSOR: primeng.EDITOR_VALUE_ACCESSOR,
        Editor: primeng.Editor,
        EditorModule: primeng.EditorModule,
        Fieldset: primeng.Fieldset,
        FieldsetModule: primeng.FieldsetModule,
        FileUpload: primeng.FileUpload,
        FileUploadModule: primeng.FileUploadModule,
        Galleria: primeng.Galleria,
        GalleriaModule: primeng.GalleriaModule,
        GMap: primeng.GMap,
        GMapModule: primeng.GMapModule,
        Growl: primeng.Growl,
        GrowlModule: primeng.GrowlModule,
        InplaceDisplay: primeng.InplaceDisplay,
        InplaceContent: primeng.InplaceContent,
        Inplace: primeng.Inplace,
        InplaceModule: primeng.InplaceModule,
        INPUTMASK_VALUE_ACCESSOR: primeng.INPUTMASK_VALUE_ACCESSOR,
        InputMask: primeng.InputMask,
        InputMaskModule: primeng.InputMaskModule,
        INPUTSWITCH_VALUE_ACCESSOR: primeng.INPUTSWITCH_VALUE_ACCESSOR,
        InputSwitch: primeng.InputSwitch,
        InputSwitchModule: primeng.InputSwitchModule,
        InputText: primeng.InputText,
        InputTextModule: primeng.InputTextModule,
        InputTextarea: primeng.InputTextarea,
        InputTextareaModule: primeng.InputTextareaModule,
        KEYFILTER_VALIDATOR: primeng.KEYFILTER_VALIDATOR,
        KeyFilter: primeng.KeyFilter,
        KeyFilterModule: primeng.KeyFilterModule,
        Lightbox: primeng.Lightbox,
        LightboxModule: primeng.LightboxModule,
        LISTBOX_VALUE_ACCESSOR: primeng.LISTBOX_VALUE_ACCESSOR,
        Listbox: primeng.Listbox,
        ListboxModule: primeng.ListboxModule,
        MegaMenu: primeng.MegaMenu,
        MegaMenuModule: primeng.MegaMenuModule,
        MenuItemContent: primeng.MenuItemContent,
        Menu: primeng.Menu,
        MenuModule: primeng.MenuModule,
        MenubarSub: primeng.MenubarSub,
        Menubar: primeng.Menubar,
        MenubarModule: primeng.MenubarModule,
        Messages: primeng.Messages,
        MessagesModule: primeng.MessagesModule,
        UIMessage: primeng.UIMessage,
        MessageModule: primeng.MessageModule,
        MULTISELECT_VALUE_ACCESSOR: primeng.MULTISELECT_VALUE_ACCESSOR,
        MultiSelect: primeng.MultiSelect,
        MultiSelectModule: primeng.MultiSelectModule,
        OrderList: primeng.OrderList,
        OrderListModule: primeng.OrderListModule,
        OrganizationChartNode: primeng.OrganizationChartNode,
        OrganizationChart: primeng.OrganizationChart,
        OrganizationChartModule: primeng.OrganizationChartModule,
        OverlayPanel: primeng.OverlayPanel,
        OverlayPanelModule: primeng.OverlayPanelModule,
        Paginator: primeng.Paginator,
        PaginatorModule: primeng.PaginatorModule,
        Panel: primeng.Panel,
        PanelModule: primeng.PanelModule,
        BasePanelMenuItem: primeng.BasePanelMenuItem,
        PanelMenuSub: primeng.PanelMenuSub,
        PanelMenu: primeng.PanelMenu,
        PanelMenuModule: primeng.PanelMenuModule,
        Password: primeng.Password,
        PasswordModule: primeng.PasswordModule,
        PickList: primeng.PickList,
        PickListModule: primeng.PickListModule,
        ProgressBar: primeng.ProgressBar,
        ProgressBarModule: primeng.ProgressBarModule,
        ProgressSpinner: primeng.ProgressSpinner,
        ProgressSpinnerModule: primeng.ProgressSpinnerModule,
        RADIO_VALUE_ACCESSOR: primeng.RADIO_VALUE_ACCESSOR,
        RadioButton: primeng.RadioButton,
        RadioButtonModule: primeng.RadioButtonModule,
        RATING_VALUE_ACCESSOR: primeng.RATING_VALUE_ACCESSOR,
        Rating: primeng.Rating,
        RatingModule: primeng.RatingModule,
        Schedule: primeng.Schedule,
        ScheduleModule: primeng.ScheduleModule,
        ScrollPanel: primeng.ScrollPanel,
        ScrollPanelModule: primeng.ScrollPanelModule,
        SELECTBUTTON_VALUE_ACCESSOR: primeng.SELECTBUTTON_VALUE_ACCESSOR,
        SelectButton: primeng.SelectButton,
        SelectButtonModule: primeng.SelectButtonModule,
        SlideMenuSub: primeng.SlideMenuSub,
        SlideMenu: primeng.SlideMenu,
        SlideMenuModule: primeng.SlideMenuModule,
        SLIDER_VALUE_ACCESSOR: primeng.SLIDER_VALUE_ACCESSOR,
        Slider: primeng.Slider,
        SliderModule: primeng.SliderModule,
        Sidebar: primeng.Sidebar,
        SidebarModule: primeng.SidebarModule,
        SPINNER_VALUE_ACCESSOR: primeng.SPINNER_VALUE_ACCESSOR,
        Spinner: primeng.Spinner,
        SpinnerModule: primeng.SpinnerModule,
        SplitButton: primeng.SplitButton,
        SplitButtonModule: primeng.SplitButtonModule,
        Steps: primeng.Steps,
        StepsModule: primeng.StepsModule,
        TabViewNav: primeng.TabViewNav,
        TabPanel: primeng.TabPanel,
        TabView: primeng.TabView,
        TabViewModule: primeng.TabViewModule,
        TabMenu: primeng.TabMenu,
        TabMenuModule: primeng.TabMenuModule,
        Terminal: primeng.Terminal,
        TerminalModule: primeng.TerminalModule,
        TieredMenuSub: primeng.TieredMenuSub,
        TieredMenu: primeng.TieredMenu,
        TieredMenuModule: primeng.TieredMenuModule,
        TOGGLEBUTTON_VALUE_ACCESSOR: primeng.TOGGLEBUTTON_VALUE_ACCESSOR,
        ToggleButton: primeng.ToggleButton,
        ToggleButtonModule: primeng.ToggleButtonModule,
        Toolbar: primeng.Toolbar,
        ToolbarModule: primeng.ToolbarModule,
        Tooltip: primeng.Tooltip,
        TooltipModule: primeng.TooltipModule,
        UITreeNode: primeng.UITreeNode,
        Tree: primeng.Tree,
        TreeModule: primeng.TreeModule,
        TreeTableService: primeng.TreeTableService,
        TreeTable: primeng.TreeTable,
        TTBody: primeng.TTBody,
        TTScrollableView: primeng.TTScrollableView,
        TTSortableColumn: primeng.TTSortableColumn,
        TTSortIcon: primeng.TTSortIcon,
        TTResizableColumn: primeng.TTResizableColumn,
        TTReorderableColumn: primeng.TTReorderableColumn,
        TTSelectableRow: primeng.TTSelectableRow,
        TTSelectableRowDblClick: primeng.TTSelectableRowDblClick,
        TTContextMenuRow: primeng.TTContextMenuRow,
        TTCheckbox: primeng.TTCheckbox,
        TTHeaderCheckbox: primeng.TTHeaderCheckbox,
        TTEditableColumn: primeng.TTEditableColumn,
        TreeTableCellEditor: primeng.TreeTableCellEditor,
        TreeTableToggler: primeng.TreeTableToggler,
        TreeTableModule: primeng.TreeTableModule,
        TRISTATECHECKBOX_VALUE_ACCESSOR: primeng.TRISTATECHECKBOX_VALUE_ACCESSOR,
        TriStateCheckbox: primeng.TriStateCheckbox,
        TriStateCheckboxModule: primeng.TriStateCheckboxModule
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWOverlayModule = (function () {
        function AWOverlayModule() {
        }
        AWOverlayModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OverlayComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            primeng.OverlayPanelModule
                        ],
                        entryComponents: [
                            OverlayComponent
                        ],
                        exports: [
                            OverlayComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] },
        ];
        return AWOverlayModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWHoverCardModule = (function () {
        function AWHoverCardModule() {
        }
        AWHoverCardModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HoverCardComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWOverlayModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            HoverCardComponent
                        ],
                        exports: [
                            HoverCardComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWHoverCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Component module is core module for the common layouts and widgets libraries.
     *
     * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
     * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
     * not much option with angular.
     *
     */
    var AribaComponentsModule = (function () {
        function AribaComponentsModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            core$1.AribaCoreModule,
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            WizardProgressModule,
                            ToggleSwitchModule,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.SharedModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.AccordionModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule,
                            primeng.TreeModule
                        ],
                        declarations: [
                            SpyLifeCycleHooksDirective,
                        ],
                        bootstrap: [],
                        entryComponents: [
                            primeng.Checkbox,
                            primeng.Dialog
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            SpyLifeCycleHooksDirective,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            EmbeddedItemDirective,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            WizardProgressModule,
                            ToggleSwitchModule,
                            primeng.SharedModule,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule
                        ]
                    },] },
        ];
        return AribaComponentsModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * This module is used mainly for tests as importing a module with all the components and you
     * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
     * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
     *
     * I havent noticed anything similar in application its only jasmine/karma that needs to init
     * components for every test.
     *
     */
    var AribaComponentsTestProviderModule = (function () {
        function AribaComponentsTestProviderModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsTestProviderModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsTestProviderModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents$1,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsTestProviderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: []
                    },] },
        ];
        return AribaComponentsTestProviderModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents$1(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.ErrorMessagesComponent = ErrorMessagesComponent;
    exports.ModalContainer = ModalContainer;
    exports.ModalService = ModalService;
    exports.ModalComponent = ModalComponent;
    exports.CurrencyFormatPipe = CurrencyFormatPipe;
    exports.BaseComponent = BaseComponent;
    exports.WidgetSizeColumns = WidgetSizeColumns;
    exports.DomUtilsService = DomUtilsService;
    exports.EmbeddedItemDirective = EmbeddedItemDirective;
    exports.EmbededItem = EmbededItem;
    exports.ErrorManagerService = ErrorManagerService;
    exports.GenericContainerComponent = GenericContainerComponent;
    exports.IncludeComponentDirective = IncludeComponentDirective;
    exports.ComponentRegistry = ComponentRegistry;
    exports.AWCoreComponentModule = AWCoreComponentModule;
    exports.BaseFormComponent = BaseFormComponent;
    exports.DataTypeProviderRegistry = DataTypeProviderRegistry;
    exports.DataProvider = DataProvider;
    exports.DataProviders = DataProviders;
    exports.DataFinders = DataFinders;
    exports.DataFinder = DataFinder;
    exports.QueryType = QueryType;
    exports.FullTextArrayDataFinder = FullTextArrayDataFinder;
    exports.DATA_SOURCE = DATA_SOURCE;
    exports.ArrayDataProvider = ArrayDataProvider;
    exports.NgForSetDirective = NgForSetDirective;
    exports.AwNameDirective = AwNameDirective;
    exports.AwNameStore = AwNameStore;
    exports.FormTableComponent = FormTableComponent;
    exports.FormRowComponent = FormRowComponent;
    exports.TopZoneComponent = TopZoneComponent;
    exports.LeftZoneComponent = LeftZoneComponent;
    exports.MiddleZoneComponent = MiddleZoneComponent;
    exports.RightZoneComponent = RightZoneComponent;
    exports.BottomZoneComponent = BottomZoneComponent;
    exports.AWFormTableModule = AWFormTableModule;
    exports.BasicNavigatorComponent = BasicNavigatorComponent;
    exports.ButtonComponent = ButtonComponent;
    exports.CheckBoxListComponent = CheckBoxListComponent;
    exports.CHOOSER_CONTROL_VALUE_ACCESSOR = CHOOSER_CONTROL_VALUE_ACCESSOR;
    exports.ChooserComponent = ChooserComponent;
    exports.ChooserState = ChooserState;
    exports.DefaultSelectionState = DefaultSelectionState;
    exports.ChooserSelectionState = ChooserSelectionState;
    exports.CURRENCY_CONTROL_VALUE_ACCESSOR = CURRENCY_CONTROL_VALUE_ACCESSOR;
    exports.CurrencyComponent = CurrencyComponent;
    exports.Money = Money;
    exports.DateAndTimeComponent = DateAndTimeComponent;
    exports.DATETIME_CONTROL_VALUE_ACCESSOR = DATETIME_CONTROL_VALUE_ACCESSOR;
    exports.DialogComponent = DialogComponent;
    exports.DialogHeaderComponent = DialogHeaderComponent;
    exports.DialogFooterComponent = DialogFooterComponent;
    exports.ConfirmationComponent = ConfirmationComponent;
    exports.ConfirmationHeaderComponent = ConfirmationHeaderComponent;
    exports.ConfirmationFooterComponent = ConfirmationFooterComponent;
    exports.OverlayComponent = OverlayComponent;
    exports.DropdownComponent = DropdownComponent;
    exports.GCChooserState = GCChooserState;
    exports.GenericChooserComponent = GenericChooserComponent;
    exports.HyperlinkComponent = HyperlinkComponent;
    exports.INPUT_CONTROL_VALUE_ACCESSOR = INPUT_CONTROL_VALUE_ACCESSOR;
    exports.InputFieldComponent = InputFieldComponent;
    exports.RadioButtonListComponent = RadioButtonListComponent;
    exports.StringComponent = StringComponent;
    exports.TEXTAREA_CONTROL_VALUE_ACCESSOR = TEXTAREA_CONTROL_VALUE_ACCESSOR;
    exports.TextAreaComponent = TextAreaComponent;
    exports.OutlineForComponent = OutlineForComponent;
    exports.OutlineControlComponent = OutlineControlComponent;
    exports.PageActionsComponent = PageActionsComponent;
    exports.PageContentComponent = PageContentComponent;
    exports.PageFooterComponent = PageFooterComponent;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageMenuItem = PageMenuItem;
    exports.UserNotification = UserNotification;
    exports.PageNotificationComponent = PageNotificationComponent;
    exports.PageNotification = PageNotification;
    exports.PageInitialized = PageInitialized;
    exports.PageDestroyed = PageDestroyed;
    exports.PageWrapper = PageWrapper;
    exports.PageLifeCycleService = PageLifeCycleService;
    exports.ObjectPageWrapperComponent = ObjectPageWrapperComponent;
    exports.SectionComponent = SectionComponent;
    exports.SubSectionComponent = SubSectionComponent;
    exports.RichTextAreaComponent = RichTextAreaComponent;
    exports.EditorType = EditorType;
    exports.CheckboxComponent = CheckboxComponent;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.StepperComponent = StepperComponent;
    exports.StepComponent = StepComponent;
    exports.AWInputFieldModule = AWInputFieldModule;
    exports.AWStringFieldModule = AWStringFieldModule;
    exports.AWBasicNavigatorModule = AWBasicNavigatorModule;
    exports.AWButtonModule = AWButtonModule;
    exports.AWHyperlinkModule = AWHyperlinkModule;
    exports.AWCardModule = AWCardModule;
    exports.AWCheckBoxModule = AWCheckBoxModule;
    exports.AWCheckBoxListModule = AWCheckBoxListModule;
    exports.AWChooserModule = AWChooserModule;
    exports.AWDropdownModule = AWDropdownModule;
    exports.AWCurrencyModule = AWCurrencyModule;
    exports.AWDateAndTimeModule = AWDateAndTimeModule;
    exports.AWDialogModule = AWDialogModule;
    exports.AWGenericChooserModule = AWGenericChooserModule;
    exports.AWRadioButtonModule = AWRadioButtonModule;
    exports.AWRadioButtonListModule = AWRadioButtonListModule;
    exports.AWTextAreaModule = AWTextAreaModule;
    exports.AWPageNotificationModule = AWPageNotificationModule;
    exports.AWPageWrapperModule = AWPageWrapperModule;
    exports.AWRichTextAreaModule = AWRichTextAreaModule;
    exports.AWSectionModule = AWSectionModule;
    exports.AWStepperModule = AWStepperModule;
    exports.ScrollableContainerComponent = ScrollableContainerComponent;
    exports.AWScrollableContainerModule = AWScrollableContainerModule;
    exports.AWConfirmationModule = AWConfirmationModule;
    exports.ChooserDataSource = ChooserDataSource;
    exports.isDSChooserInitParams = isDSChooserInitParams;
    exports.HoverCardComponent = HoverCardComponent;
    exports.ListComponent = ListComponent;
    exports.AWListModule = AWListModule;
    exports.CardComponent = CardComponent;
    exports.OutlineState = OutlineState;
    exports.Datatable2Component = Datatable2Component;
    exports.DTColumn2Component = DTColumn2Component;
    exports.DTHeaderComponent2 = DTHeaderComponent2;
    exports.DTDetailRowComponent = DTDetailRowComponent;
    exports.DetailRowExpansionState = DetailRowExpansionState;
    exports.Datatable2State = Datatable2State;
    exports.isDTInitParams = isDTInitParams;
    exports.DT2DataSource = DT2DataSource;
    exports.DTMultiSelectColumnComponent = DTMultiSelectColumnComponent;
    exports.AWDatatable2Module = AWDatatable2Module;
    exports.WizardProgressComponent = WizardProgressComponent;
    exports.isOutlineNode = isOutlineNode;
    exports.AWOutlineForModule = AWOutlineForModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.WizardProgressModule = WizardProgressModule;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.AribaComponentsModule = AribaComponentsModule;
    exports.AribaComponentsTestProviderModule = AribaComponentsTestProviderModule;
    exports.SpyLifeCycleHooksDirective = SpyLifeCycleHooksDirective;
    exports.p = registerComponents;
    exports.q = registerComponents$1;
    exports.y = BaseComponent;
    exports.a = DataSource;
    exports.r = InfiniteScrollComponent;
    exports.h = CardZoneTitleComponent;
    exports.g = CardZoneBottomComponent;
    exports.f = CardZoneTopComponent;
    exports.b = AWCardModule;
    exports.c = CB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.m = CB_CONTROL_VALUE_ACCESSOR;
    exports.u = DTDetailRowExpanderComponent;
    exports.v = DTSingleSelectColumnComponent;
    exports.x = SetCellMaxWidthDirective;
    exports.w = DTDraggableRowDirective;
    exports.t = DTWrapper;
    exports.d = DD_CONTROL_VALUE_ACCESSOR;
    exports.ba = AWHoverCardModule;
    exports.o = LB_CONTROL_VALUE_ACCESSOR;
    exports.i = InitNestingDirective;
    exports.z = AWOverlayModule;
    exports.j = SidenavComponent;
    exports.e = RB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.n = RAB_CONTROL_VALUE_ACCESSOR;
    exports.l = EDITOR_CONTROL_VALUE_ACCESSOR;
    exports.k = SectionActionsComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2VtYmVkZGVkLWl0ZW0udHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9nZW5lcmljLWNvbnRhaW5lci5jb21wb25lbnQudHMiLG51bGwsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Jhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvb24tbmdmb3Itc2V0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RvbS11dGlscy5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb3JlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9hcnJheS1kYXRhLXByb3ZpZGVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RhdGEvZGF0YS1maW5kZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9idXR0b24vYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRlLWFuZC10aW1lLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWZvb3Rlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtc3RhdGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1ldmVudHMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1saWZlY3ljbGUuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtZm9vdGVyL3BhZ2UtZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9vYmplY3QtcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtYWN0aW9ucy9wYWdlLWFjdGlvbnMuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtY29udGVudC9wYWdlLWNvbnRlbnQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0ZXBwZXIvc3RlcC9zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9hdy1kYXRhdGFibGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3dpemFyZC1wcm9ncmVzcy93aXphcmQtcHJvZ3Jlc3MuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2guY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdG9nZ2xlLXN3aXRjaC90b2dnbGUtc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvYXJpYmEuY29tcG9uZW50Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQucHJvdmlkZXIubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBXaGVuIHdlIGhhdmUgYSBjdXN0b20gY29tcG9uZW50IGxpa2UgZHJvcGRvd24sIHJhZGlvYnV0dG9ubGlzdCBhbmRcbiAqIG1hbnkgbW9yZSB3ZSB3YW50IHRvIHByb3ZpZGUgYSBjdXN0b20gY29udGVudCB0byBpdCBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICogV2hvIGVsc2Ugd291bGQga25vdyBob3cgdG8gcmVuZGVyIGxpc3Qgb2Ygb2JqZWN0cy4uXG4gKlxuICogQnV0IGl0cyBub3QgcG9zc2libGUgaW4gY3VycmVudCBmb3JtLiBpZiBJIGRvIG5vdCBwcm92aWRlIEFuZ3VsYXIgc29tZSBhcyB0aGV5IGNhbGwgaXQgdGhpc1xuICogc3ludGFjdGljIHN1Z2FyICosXG4gKlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biAqbXlTdWdlckRpcmVjdGl2ZT0uLi4uLj5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICogYGBgXG4gKlxuICpcbiAqIHRoZW4gYW5ndWxhciB3aWxsIG5vdCBrbm93ICBpbnNpZGUgaXMgYSB0ZW1wbGF0ZSBhbmQgSSB3b250IGJlIGFibGUgdG8gZ2V0IGhvbGQgb2YgVGVtcGxhdGVSZWZcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50XG4gKlxuICogU28gdGhlIG9ubHkgd2F5IEkgZm91bmQgKGV4cGVjdGluZyBJIGRvIG5vdCB3YW50IHRvIGNoYW5nZSBhbnl0aGluZyBpbiB0ZXJtcyBvZiBiaW5kaW5ncyBhbmQgdGhlXG4gKiBzaWduYXR1cmUgSSB1c2UgaXQuIEkgaGF2ZSB0byB1c2UgaXQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtPiB7e2l0ZW0udXNlck5hbWV9fTwvbmctdGVtcGxhdGU+XG4gKlxuICogICA8YXctZHJvcGRvd25cbiAqXG4gKiBgYGBcbiAqXG4gKiAgVGhpcyB3YXkgaXQgY291bGQgd29yay4gU2luY2UgSSBhbSBpbnNpZGUgbmdGb3IgSSB3YW50IHRvIHJlbmRlciB0aGUgaXRlbSBpbnRvIHRoZSBjb3JyZWN0XG4gKiB2aWV3Q29udGFpbmVyIG9mIG5nRm9yJ3MgY3VycmVudCBpdGVtLlxuICpcbiAqICBUaGlzIHdheSBJIGNhbiBhbHNvIGV4cG9zZSBpdGVtIG91dHNpZGUgdXNpbmcgQW5ndWxhcidzIHNwZWNpYWwgbG9jYWwgdmFyaWFibGUgY2FsbGVkOlxuICogJGltcGxpY2l0LlxuICpcbiAqIFRoaXMgZ2V0cyBldmVuIG1vcmUgY29tcGxleCBpZiB3ZSB0cnkgdG8gcGFzcyB0aGlzIHRlbXBsYXRlIDIgbGV2ZWxzIGRvd24sIGxpa2UgaW4gY2FzZSBvZlxuICogUmFkaW9CdXR0b25MaXN0LiBCdXQgbGF0ZXIgb24gSSBtaWdodCB3YW50IHRvIHJlZmFjdG9yIHRoaXMgaW50byBjdXN0b20gTkcgRk9SXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbmdUZW1wbGF0ZU91dGxldCAod2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tlbWJlZGRlZEl0ZW1dJ30pXG5leHBvcnQgY2xhc3MgRW1iZWRkZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzXG57XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgd2Ugd2FudCB0byByZW5kZXIgTi1UaW1lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1iZWRkZWRJdGVtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFZhbHVlID0gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbXBsaWNpdFZhbHVlOiBhbnk7XG4gICAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fdmlld1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZW1iZWRkZWRJdGVtKSkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgRW1iZWRlZEl0ZW0odGhpcy5faW1wbGljaXRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5lbWJlZGRlZEl0ZW0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgQW5ndWxhcidzIEVtYmVkZGVkVmlld1JlZi5jb250ZXh0KClcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWJlZGVkSXRlbVxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ6IGFueSlcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpcyB1c2VkIGJ5IGluY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZSB0byBkeW5hbWljYWxseSBjcmVhdGUgYW5cbiAqIEhUTUxFbGVtZW50IGFuZCB1c2UgdGhpcyBlbGVtZW50IHRvIHdyYXAgYSBjaGlsZCBjb21wb25lbnQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvXG4gKiBtb2RpZnkgYSBjaGlsZCBieSB3cmFwcGluZyBpdCB3aXRoIGEgYm9yZGVyLCBhIGJhY2tncm91bmQsIG9yIGJvbGQgaXRzIHRleHQuXG4gKlxuICogVGhlIHdyYXBwZXIgZWxlbWVudCBpcyBkeW5hbWljYWxseSBjcmVhdGVkLiBJdCdzIGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ5IHRoZSB0YWdOYW1lIHByb3BlcnR5IGluXG4gKiB0aGUgYmluZGluZ3MgQElucHV0LlxuICpcbiAqICAjIyMgRXhhbXBsZS4gIERpcmVjdGx5IGluIGh0bWxcbiAqXG4gKiAgIGFwcC5odG1sXG4gKiAgICAgIDxhdy1nZW5lcmljLWNvbnRhaW5lciB0YWdOYW1lPVwidGFnTmFtZVwiIGJpbmRpbmdzPVwiYmluZGluZ3NcIj5cbiAqICAgICAgICAgIDxteS1jb21wb25lbnQgLi5iaW5kaW5ncy4uPjwvbXktY29tcG9uZW50PlxuICogICAgICA8L2F3LWdlbmVyaWMtY29udGFpbmVyPlxuICpcbiAqICAgYXBwLmNvbXBvbmVudC50c1xuICpcbiAqICAgICAgIHRhZ05hbWUgPSAoYkJvbGQpID8gJ2gxJyA6ICdzcGFuJztcbiAqICAgICAgIGJpbmRpbmdzID0geyAgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrXG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRhZ05hbWUgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW5zaWRlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IERlZmF1bHRUYWdOYW1lID0gJ2Rpdic7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kaW5ncyB0byBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSB0YWdOYW1lIGVsZW1lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gYmUgY3JlYXRlZCB0aGF0IHdyYXBzIGl0J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhZ05hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByb290IGVsZW1lbnQuIFBvaW50cyB0byA8YXctZ2VuZXJpYy1jb250YWluZXI+XG4gICAgICovXG4gICAgcHJpdmF0ZSBuYXRpdmVFbGVtZW50OiBOb2RlO1xuXG4gICAgcHJpdmF0ZSBjaGlsZEVsZW1lbnQ6IE5vZGU7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgaXMgdXNlZCB0byBjcmVhdGUgJ3RhZ05hbWUnIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiwgdmVyaWZ5IHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlucHV0LCB0aGlzIGNvbXBvbmVudCB3b3VsZG4ndCBrbm93IHdoYXQgdG8gZG8gYW5kIHRocm93IGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5iaW5kaW5ncykgJiYgaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW5wdXQgYmluZGluZ3Mgb3IgdGFnTmFtZSAnICtcbiAgICAgICAgICAgICAgICAnaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGFnTmFtZSBpcyBibGFuaywgdGhlIGdldCBpdCBmcm9tIGJpbmRpbmdzLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0aGlzLmJpbmRpbmdzLmdldCgndGFnTmFtZScpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IEdlbmVyaWNDb250YWluZXJDb21wb25lbnQuRGVmYXVsdFRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGZpcnN0IGFkZGVkXG4gICAgICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY2hpbGRFbGVtZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBjb250ZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiBDcmVhdGUgdGhlIHRhZ05hbWUgZWxlbWVudC4gQXBwbHkgYWxsIHRoZSBiaW5kaW5ncyBvbiB0b1xuICAgICAqIHRoZSBlbGVtZW50IGFzIGF0dHJpYnV0ZS4gRmluYWxseSwgbW92ZSB0aGUgY2hpbGQgZWxlbWVudCwgPG5nLWNvbnRlbnQ+LCB0byBpbnNpZGUgdGhlXG4gICAgICogd3JhcHBlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlbmRlcigpXG4gICAge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXRpdmVFbGVtZW50LCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBiaW5kaW5ncyBhbmQgYWRkIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUodGhpcy5iaW5kaW5ncykuZm9yRWFjaCgodiwgaykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoaXMgZGl2RWxlbWVudC5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgIH1cblxuXG59XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEb0NoZWNrLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FwcENvbmZpZywgRW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogIEJhc2UgY29tcG9uZW50IHNoYXJlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBhbW9uZyBhbGwgdGhlIGNvbXBvbmVudHMgKGxheW91dHMsIHdpZGdldHMpLlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgRG9DaGVjaywgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGRpc2FibGVkIGZsYWcgdG8gdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBXZWF0aGVyIHRoaXMgY29tcG9uZW50IGlzIHZpc2libGVcbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlO1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGVsbCAgdGhlIGNvbXBvbmVudCBpZiB3ZSBhcmUgaW4gZWRpdGluZyBtb2RlLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0YWJsZT86IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRXZlcnkgY29tcG9uZW50IGhhdmUgb3B0aW9uIHRvIHNldCBhIGN1c3RvbSB3aXRoXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHdpZHRoOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSBjb21wb25lbnQgaGF2ZSBvcHRpb24gdG8gc2V0IGEgY3VzdG9tIHdpdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlaWdodDogYW55O1xuXG4gICAgLyoqXG4gICAgICogb3B0aW9uYWwgY3NzIGNsYXNzIHdoaWNoIGNhbiBiZSB1dGlsaXplZCBieSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0eWxlQ2xhc3M6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcGFkZGluZyBmcm9tIHRoZSBjb21wb25lbnQuIFVzdWFsbHkgdXNlZCB3aGVuIHdlIGFyZSBuZXN0aW5nIG90aGVyIGNvbXBvbmVudCB3aXRoXG4gICAgICogaXRzIG93biBncmlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb21pdFBhZGRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGV4dGVuc2lvbiBzdXBwb3J0IHJlZ2lzdGVyIGhlcmUgYW55IGR5bmFtaWMgZmllbGQgdGhhdCBkb2VzIG5vdCBleGlzdGluZyBvbiB0aGVcbiAgICAgKiBjbGFzcy9jb21wb25lbnRcbiAgICAgKi9cbiAgICBleHRCaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUHJlZml4IGZvciB0aGUgY29ycmVjdCBhc3NldCBwYXRoXG4gICAgICovXG4gICAgYXNzZXRGb2xkZXI6IHN0cmluZyA9ICdhc3NldHMnO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudj86IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5leHRCaW5kaW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICAgIHRoaXMub21pdFBhZGRpbmcgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuYXNzZXRGb2xkZXIgPSB0aGlzLmVudi5nZXRWYWx1ZShBcHBDb25maWcuQXNzZXRGb2xkZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50LCBub29wLCB1dWlkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Zm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFBpcGVUcmFuc2Zvcm0sIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBGb3JtR3JvdXB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogeC1zbWFsbCA9ID4gMTIlICA9ID4gY29sLTFcbiAqIHNtYWxsID0gPiBgXG4gKiBtZWRpdW0gPSA+IDUwJSAgID0gPiBjb2wtNlxuICogbGFyZ2UgPSA+IDc1JSAgICA9ID4gY29sLTlcbiAqIGxhcmdlID0gPiAxMDAlICAgPSA+IGNvbC0xMlxuICpcbiAqL1xuZXhwb3J0IHR5cGUgV2lkZ2V0U2l6ZSA9ICd4LXNtYWxsJyB8ICdzbWFsbCcgfCAnbWVkaXVtJyB8ICdsYXJnZScgfCAneC1sYXJnZSc7XG5cbmV4cG9ydCBlbnVtIFdpZGdldFNpemVDb2x1bW5zXG57XG4gICAgeHNtYWxsID0gMSxcbiAgICBzbWFsbCA9IDMsXG4gICAgbWVkaXVtID0gNixcbiAgICBsYXJnZSA9IDksXG4gICAgeGxhcmdlID0gMTJcbn1cblxuXG4vKipcbiAqICBCYXNlRm9ybUNvbXBvbm5ldCBleHRlbmRzIEJhc2VDb21wb25lbnQgZm9yIGFkZCBzcGVjaWZpYyBmb3JtIGJlaGF2aW9yXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUZvcm1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3JcbntcbiAgICAvKlxuICAgICAqICBTdXBwb3J0ZWQgbGF5b3V0IGNvbnN0YW50cy4gSXQgaXMgZXhwZWN0ZWQgdGhlcmUgd2lsbCBiZSBtb3JlIG9wdGlvbnMgYXMgd2UgY3VycmVudGx5XG4gICAgICogIHN1cHBvcnQgb25seSB0aGVzZSB0d28gdGhlcmUgd2lsbCBiZSBvdGhlciB2YXJpYXRpb25zIG9mIGl0LiBlLmcuIGZvciBzdGFja2VkIGl0IHdpbGwgbm90XG4gICAgICogIGJlIDEgY29sdW1ucyBsaWtlIGl0IGlzIG5vdyBidXQgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IExheW91dFN0YWNrZWQgPSAnc3RhY2tlZCc7XG4gICAgc3RhdGljIHJlYWRvbmx5IExheW91dElubGluZSA9ICdpbmxpbmUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgbmFtZSBhdHRyaWJ1dGUuIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5hbWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IElkLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIGN1cnJlbnQgZWxlbWVudCB2aXNpYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRkZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gcGFzcyBpbiBmb3JtR3JvdXAgd2hpY2ggd2lsbCBiZSB1c2VkIHdpdGggaW4gdGhlIGZvcm1cbiAgICAgKlxuICAgICAqIEBJbnB1dCgpIC0gc2VlIGdldHRlclxuICAgICAqL1xuICAgIHByaXZhdGUgX2Zvcm1Hcm91cDogRm9ybUdyb3VwO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJlcXVpcmVkIGZsZXggYXJvdW5kIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVxdWlyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogIGEgdGV4dCBkaXNwbGF5ZWQgd2hlbiB2YWx1ZSBpcyBlbXB0eSBvciBOVUxMXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwbGFjZUhvbGRlcjogU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSBpZiB0aGlzIGNvbnRyb2wgaXMgdXNlZCBkaXJlY3RseSBvciBpZiBpdHMgcGFydCBvZiBzb21lIG90aGVyIGNvbnRyb2xcbiAgICAgKiBlLmcuIEdlbmVyaWNDaG9vc2VyIGFuZCBtYW5hZ2VkIGJ5IHRoaXMgY29udHJvbC5cbiAgICAgKiBNZWFuaW5nIFN0YXRlIGlzIG1hbmFuZ2VkIG91dHNpZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNTdGFuZGFsb25lOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybSBDb250cm9sIGZvciB0aGUgY29tcG9uZW50LiBJdHMgZWl0aGVyIGluaGVyaXRlZCBzaW5jZSBpdCB3YXMgcHJlY3JlYXRlZCBpbiBwYXJlbnRcbiAgICAgKiBjb21wb25lbnQgb3IgaXRzIGNyZWF0ZWQgYmFzZWQgb24gcGFzc2VkICduYW1lJyBhbmQgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZm9ybUdyb3VwJ1xuICAgICAqXG4gICAgICogV2hlbiAgaW5pdGlhbGl6ZSBGb3JtQ29udHJvbCB3ZSBkbyBzZXRWYWx1ZSB3aXRoIG9ubHlTZWxmOnRydWUgZmxhZyBhbmQgd2UgZG8gbm90IGVtaXQgYW55XG4gICAgICogZXZlbnQgb3V0c2lkZVxuICAgICAqXG4gICAgICovXG4gICAgZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdGhhdCBjYW4gYmUgYXNzaWduIHRvIHRoZSBjb21wb25lbnQgaW4gb3JkZXIgdG8gZm9ybWF0IGl0cyBpbnB1dFxuICAgICAqL1xuICAgIGZvcm1hdHRlcjogUGlwZVRyYW5zZm9ybTtcblxuXG4gICAgcHJvdGVjdGVkIG9uTW9kZWxDaGFuZ2VkOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcbiAgICBwcm90ZWN0ZWQgb25Nb2RlbFRvdWNoZWQ6IChfOiBhbnkpID0+IHZvaWQgPSBub29wO1xuXG5cbiAgICAvKipcbiAgICAgKiBTb21lIG9mIHRoZSBCYXNlRm9ybUNvbXBvbmVudCBjYW4gd3JhcCBvdGhlciBjb21wb25lbnQgYW5kIGluIHRoZXNlIGNhc2VzIHdlIHdhbnQgdG9cbiAgICAgKiBpbmhlcml0IHNvbWUgb2YgdGhlIGJlaGF2aW9yIGZyb20gcGFyZW50XG4gICAgICpcbiAgICAgKiBASW5qZWN0KEVudmlyb25tZW50KSBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCA6IGlzIHRlbSBhIHdvcmthcm91bmQgYXMgd2l0aG91dCBpbmplY3RcbiAgICAgKiBvbiB0aGlzIHNwZWNpZmljIGNvbXBvbmVudCBpdCBjb21wbGFpbnMgdGhhdCBFbnZpcm9ubWVudCBpcyB1bnJlc29sdmVkIHN5bWJvbFxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKEBJbmplY3QoRW52aXJvbm1lbnQpIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtR3JvdXAgPSB0aGlzLnBhcmVudENvbnRhaW5lci5mb3JtR3JvdXA7XG4gICAgICAgICAgICB0aGlzLmVkaXRhYmxlID0gdGhpcy5wYXJlbnRDb250YWluZXIuZWRpdGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrSW5pdEZvcm0oKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYXZhaWxhYmxlIGZvcm1Hcm91cCBhbmQgTmFtZSBhbmQgSURcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjaGVja0luaXRGb3JtICgpXG4gICAge1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZW52LmN1cnJlbnRGb3JtKSkge1xuICAgICAgICAgICAgdGhpcy5lbnYuY3VycmVudEZvcm0gPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2RvOiBSaWdodCBub3cgSSBqdXN0IG5lZWQgdG8gaW5pdGlhbGl6ZSBuYW1lICwgYnV0IGlkZWFsbHkgaXQgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICAgICAqIG51bWJlciBiYXNlZG9uIHNvbWUgc2VtYW50aWNzIGFwcC5wYWdlLmNvbXBvbmVudCBpZiB0aGVyZSBhcmUgbW9yZSBjb21wb25lbnQgb24gdGhlIHBhZ2VcbiAgICAgICAgICogdGhlbiBhcHAucGFnZS5jb21wb25lbnROdW1iZXIuIFNpbXBsZSBzb2x1dGlvbiBpcyB0byBpcyB0byBnZXQgRWxlbWVudHJlZiBhbmQgcXVlcnkgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB1dWlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmlkKSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHV1aWQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGRvUmVnaXN0ZXIgKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSk6IEZvcm1Db250cm9sXG4gICAge1xuXG4gICAgICAgIGxldCBmQ29udHJvbDogRm9ybUNvbnRyb2w7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV0pKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Hcm91cC5yZWdpc3RlckNvbnRyb2wobmFtZSwgbmV3IEZvcm1Db250cm9sKHZhbHVlKSk7XG4gICAgICAgICAgICBmQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZDb250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tuYW1lXTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkVmFsdWU6IGFueSA9IGlzUHJlc2VudChmQ29udHJvbC52YWx1ZSkgPyBmQ29udHJvbC52YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgZkNvbnRyb2wucGF0Y2hWYWx1ZSh1cGRhdGVkVmFsdWUsIHtvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmQ29udHJvbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBGb3JtcyB0aGlzIGlzIGEgaGVscGVyIG1ldGhvZCB0byByZWdpc3RlciBjb250cm9sXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZhdWx0IHZhbHVlIHRvIGJlIHByZS1zZXRcbiAgICAgKi9cbiAgICByZWdpc3RlckZvcm1Db250cm9sICh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IHRoaXMuZG9SZWdpc3Rlcih0aGlzLm5hbWUsIHZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIEBJbnB1dCgpIGdldCBmb3JtR3JvdXAgKCk6IEZvcm1Hcm91cFxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9mb3JtR3JvdXApID8gdGhpcy5fZm9ybUdyb3VwIDogdGhpcy5lbnYuY3VycmVudEZvcm07XG4gICAgfVxuXG4gICAgc2V0IGZvcm1Hcm91cCAodmFsdWU6IEZvcm1Hcm91cClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Zvcm1Hcm91cCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB3ZSBjYW4gcGFzcyBmaWVsZCB0eXBlIGFzIGEgYmluZGluZyB0byB0aGUgY29tcG9uZW50cy4gZS5nLiBJbnB1dEZpZWxkIG5lZWRcbiAgICAgKiBzdWNoIHR5cGUgdG8gY29ycmVjdGx5IHJlbmRlciBpbnB1dCB0eXBlPXRleHQsIG51bWJlclxuICAgICAqXG4gICAgICogdG9kbzogaXMgdGhpcyBuZWVkZWQ/IGNhbiB3ZSBtYXliZSBwYXNzIHRoaXMgdG8gdGhlIGZvcm1Sb3c/XG4gICAgICovXG4gICAgY2FuU2V0VHlwZSAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgd3JpdGVWYWx1ZSAodmFsdWU6IGFueSlcbiAgICB7XG5cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlIChmbjogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkIChmbjogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEb21TYW5pdGl6ZXJ9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIGNvbXBvbmVudCByZW5kZXJpbmcgdmFsdWVzIGluIHRoZSByZWFkIG9ubHkgbW9kZS4gSnVzdCBuZWVkZWQgc29tZSBjb21wb25lbnQgdXNlZFxuICogdG8gcmVuZGVyIFN0cmluZ3MgaW4gcmVhZCBvbmx5IG1vZGVcbiAqXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKlxuICogVXNpbmcgaXQgaW5zaWRlIGZvcm0gY29udGFpbmVyIGFsb25nIHdpdGggbGFiZWxcbiAqXG4gKlxuICogIGBgYFxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgc2VsZWN0b3I6ICd1c2VySW5mbycgLFxuICogICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS10YWJsZSBbZWRpdGFibGVdPVwiZmFsc2VcIiA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtuYW1lXT1cImZpZWxkTmFtZVwiICBbbGFiZWxdPVwibGFiZWxcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0cmluZyBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiID48L2F3LXN0cmluZz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgIH0pXG4gKiAgICAgICAgICBleHBvcnQgY2xhc3MgVXNlclByb2ZpbGVDb21wb25lbnRcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqICAgICAgICAgICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogICAgICAgICAgICAgIGZpZWxkTmFtZTogc3RyaW5nID0gJ2ZpcnN0TmFtZSc7XG4gKiAgICAgICAgICAgICAgbGFiZWw6IHN0cmluZyA9ICdNeSBOYW1lJztcbiAqICAgICAgICAgICAgICByZXF1aXJlZDogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgICAgICAgICAgZWRpdGluZzogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgICAgICAgICAgbGFiZWxzT25Ub3A6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICB9XG4gKlxuICogIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGh0bWwgdGFncy5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3RyaW5nJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiBjbGFzcz1cInctc3RyaW5nLWZpZWxkXCIgW2lubmVySFRNTF09XCJ2YWx1ZVwiPjwvc3Bhbj5cbiAgICBgLFxuICAgIHN0eWxlczogW2Audy1zdHJpbmctZmllbGR7ZGlzcGxheTppbmxpbmUtYmxvY2t9YF1cbn0pXG5leHBvcnQgY2xhc3MgU3RyaW5nQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiAgVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIF92YWx1ZTogc3RyaW5nID0gJyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIHNhbml0aXplcjogRG9tU2FuaXRpemVyLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICB9XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCh0aGlzLl92YWx1ZSk7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzU3RyaW5nTWFwfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIEEgY2xhc3MgaG9sZGluZyBhIHJlZmVyZW5jZXMgdG8gY29tcG9uZW50cy4gVGhlIG1ldGhvZHMgYXJlIHNlbGYtZXhwbGFuYXRvcnkuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50UmVnaXN0cnlcbntcbiAgICBwcml2YXRlIF9uYW1lVG9UeXBlOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplKHJlZmVyZW5jZXM6IGFueSk6IFByb21pc2U8YW55PlxuICAgIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclR5cGVzKHJlZmVyZW5jZXMpO1xuICAgICAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gbmV3IFByb21pc2UoKHJlc29sdmU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuXG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGUobmFtZTogc3RyaW5nLCB0eXBlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMubmFtZVRvVHlwZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWVUb1R5cGUuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGVzKHJlZmVyZW5jZXM6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNTdHJpbmdNYXAocmVmZXJlbmNlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHJlZmVyZW5jZXMpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclR5cGUobmFtZSwgcmVmZXJlbmNlc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZ2V0IG5hbWVUb1R5cGUoKTogTWFwPHN0cmluZywgYW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVUb1R5cGU7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnksXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIGlzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1N0cmluZ0NvbXBvbmVudH0gZnJvbSAnLi4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbXBvbmVudFJlZmVyZW5jZX0gZnJvbSAnLi9jb21wb25lbnQtcmVmZXJlbmNlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG4vKipcbiAqIHRoaXMgaXMgc3BlY2lmaWMgaW1wb3J0IHRvIHdlIGNhbiB1c2UgY29tcG9uZW50cyBhcyBjb21wb25lbnRzW3R5cGVuYW1lXSBhbmQgIGdldCBiYWNrIGFcbiAqIHR5cGUuXG4gKiBJIGNvdWxkIG5vdCBmaW5kIGFueSBiZXR0ZXIgZHluYW1pYyB3YXkgdXAgdG8gbm93XG4gKi9cbi8qKlxuICogIGBJbmNsdWRlQ29tcG9uZW50YCBkaXJlY3RpdmUgZHluYW1pY2FsbHkgaW5zdGFudGlhdGUgYW5kIGluc2VydCBhIGNvbXBvbmVudHMgaW50byB0aGUgc2NyZWVuXG4gKiBiYXNlZCBvbiB0aGUgbmFtZS4gSXQgY2FuIGFjY2VwdHMgYmluZGluZ3MgYXMgd2VsbCB3aGljaCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYm91bmQgYW5kIGFwcGxpZWRcbiAqIHRvIHRoZSBjb21wb25lbnRcbiAqXG4gKiAgIyMjIHVzYWdlOlxuICpcbiAqICBJbnN0ZWFkIG9mIGluc2VydGluZyBjb21wb25lbnQgaW4gdGhlIHdheTpcbiAqXG4gKiAgYGBgXG4gKiAgICA8dGV4dGZpZWxkIHZhbHVlPVwic29tZSB2YWx1ZVwiPlxuICpcbiAqICBgYGBcbiAqXG4gKiAgeW91IGNhbiBkbyBzbyBkeW5hbWljYWxseSBsaWtlIHRoaXM6XG4gKlxuICogYGBgXG4gKiAgPGF3LWluY2x1ZGUtY29tcG9uZW50ICdUZXh0ZmllbGRDb21wb25lbnQnIFtiaW5kaW5nc109YmluZGluZ3MgPjwvYXctaW5jbHVkZS1jb21wb25lbnQ+XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGJ1aWxkaW5nIGJsb2NrIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBVSS5cbiAqXG4gKlxuICogVG9kbzogQ3VycmVudGx5IHRoZSB3YXkgQW5ndWxhciBBUEkgd29yayBhbmQgd2UgdXNlIGl0IHRvIGNyZWF0ZSBwcm9ncmFtYXRpY2FsbHkgY29tcG9uZW50c1xuICogaXMgdG9vIGNvbXBsZXh0IHdlIG5lZWQgdG8gY3JlYXRlIGV2ZXJ5dGhpbmcgMyBkaWZmZXJlbnQgY2FsbHMgdG8gcGxhY2UgYSBjb21wb25lbnQgdG8gdGhlXG4gKiBjb250YWluZXIuIFdoYXQgSSB3YW50IGlzIGlzIHRvIGNyZWF0ZSBzb21lIGtpbmQgb2YgcmVwcmVzZW50YXRpb24gb2YgQ29udGFpbmVyRWxlbWVudCBhbmQgdGhpc1xuICogY2FuIGJlIGFsc28gcGFyZW50IGZvciBvdXIgQmFzZUNvbXBvbmVudCB3aXRoIG1ldGhvZCBhZGQgYW5kIHJlbW92ZSBjb250ZW50LiBUaGVuIHdlIGNvdWxkIGhhdmVcbiAqIHNvbWUgQVdDb250ZW50LlxuICpcbiAqIGUuZy46IHRvIHJlcGxhY2UgYXBwbHlDb250ZW50RWxlbWVudElmQW55IHdoZXJlIHdlIGhhdmUgc2V2ZXJhbCBjYWxscyB0byBjcmVhdGUgYW5kIGFkZFxuICogY29tcG9uZW50IHRvIHRoZSB2aWV3LlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBBV0NvbmNyZXRlVGVtcGxhdGUodmlld0NvbnRhaW5lciwgZmFjdG9yeVJlc29sdmVyKVxuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKCdDbGNrIE1lJylcbiAqIGBgYFxuICpcbiAqIFRvIGFzc2VtYmxlIGRpZmZlcmVudCBjb21wb25lbnRzIHRvZ2V0aGVyIC0gbm90IG9ubHkgYWRkaW5nIHN0cmluZyBjb250ZW50XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoQnV0dG9uQ29tcG9uZW50LCBiaW5kaW5nc01hcClcbiAqICBjb250ZW50LmFkZCgnQ2xpY2sgTWUnKTtcbiAqICBjb250YWluZXJFbGVtZW50LmFkZChjb250ZW50KVxuICpcbiAqIGBgYFxuICpcbiAqIGFkZCBtb3JlIGNvbXBvbmVudCBoaWVyYXJjaHk6XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoSG92ZXJDYXJkQ29tcG9ubmV0cywgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoY3JlYXRlTGF5b3V0KCk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5jbHVkZS1jb21wb25lbnQnXG59KVxuZXhwb3J0IGNsYXNzIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIHN0YXRpYyByZWFkb25seSBOZ0NvbnRlbnQgPSAnbmdjb250ZW50JztcbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50RWxlbWVudCA9ICduZ2NvbnRlbnRFbGVtZW50JztcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgY29tcG9uZW50IG5hbWUgZS5nLjogRHJvcGRvd25Db21wb25lbnQgd2hpY2ggaXMgZ29pbmcgdG8gYmUgaW5zZXJ0ZWQuIFdlIG5lZWQgdG8gdGFrZVxuICAgICAqIHRoaXMgbmFtZSBhbmQgdHJhbnNsYXRlIGl0IGludG8gYWN0dWFsIFRZUEUuIEluIG9yZGVyIHRvIGRvIHRoaXMgd2UgdXNlIGEgdHJpY2sgd2hlcmUgd2VcbiAgICAgKiBhY2Nlc3MgYW4gSU1QT1JURUQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi4vY29tcG9uZW50cyc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGVuIHlvdSBjYW4gcmV0cmlldmUgYSB0eXBlIGJ5IGp1c3QgY29tcG9uZW50c1s8U3RyaW5nIExpdGVyYWwgPl0gPT4gQ29tcG9uZW50IFRZUEVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGJpbmRpbmdzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIGNvbXBvbmVudCB3aGVuIGluc3RhbnRpYXRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIGJpbmRpbmdzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjcmVhdGVkIGNvbXBvbmVudCByZWZlcmVuY2UgdXNpbmcgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLiBXZSB1c2UgdGhpcyB0byBhY2Nlc3NcbiAgICAgKiB0aGUgYWN0dWFsIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgRWxlbWVudCBSZWZlcmVuY2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3VycmVudENvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBJIHVzZSB0aGlzIGZsYWcgdG8gaWRlbnRpZnkgdGhhdCBjb21wb25lbnQgaXMgcmVuZGVyaW5nIGZvciBmaXJzdCB0aW1lIG9yIGl0cyB1cGRhdGVkIGR1cmluZ1xuICAgICAqIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTm90IHN1cmUgaWYgd2UgbmVlZCB0aGlzLCBidXQgd2FudCB0byBrZWVwIGl0IGhlcmUgb3IgbWF5YmUgbW92ZSBpdCB0byBzb21lIHNlcnZpY2Ugc28gd2VcbiAgICAgKiBjYW4gY2FjaGUgY3JlYXRlZCBjb21wb25lbnRzIGFuZCBtYXliZSByZXVzZSB0aGVtLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZXM6IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4gPVxuICAgICAgICBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50UmVmZXJlbmNlPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNhY2hlIHRoZSByZXNvbHZlZCBjb21wb25lbnQgcmVmZXJlbmNlIHNvIHdlIGRvbnQgY2FsbCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBldmVyeXRoaW5nIHdlIHdhbnQgdG8gcmVmcmVzaCBhIHNjcmVlblxuICAgICAqL1xuICAgIHJlc29sdmVkQ29tcG9uZW50UmVmOiBDb21wb25lbnRSZWZlcmVuY2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KVxuICAgIHtcblxuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyB0b2RvOiBjaGVjayBpZiB0aGlzIHRoZSByaWdodCBsaWZlY3ljbGUgY2FsbGJhY2ssIHRoaXMgaXMgY2FsbGVkIG9ubHkgb25jZSBhbmQgeW91IHdhbnRcbiAgICAgICAgLy8gdG8gcHJvYmFibHkgbGlzdGVuIGZvciBjaGFuZ2VzLCBhbmQgY2hhbmdlIGRlY3Rpb24gZGVjaWRlIHRoZXJlIGlzIHNvbWUgY2hhbmdlIGFuZCB3ZVxuICAgICAgICAvLyBuZWVkIHRvIHJlLWRyYXcgdGhlIHZpZXdcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ25hbWUnXSkgJiZcbiAgICAgICAgICAgIChjaGFuZ2VzWyduYW1lJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyduYW1lJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5kb1JlbmRlckNvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhbmQgcmVwb3NpdGlvbiBET00gZWxlbWVudCBib3RoIGZvciB3cmFwcGVyIGFuZFxuICAgICAgICAvLyBjb250ZW50XG4gICAgICAgIHRoaXMuY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGNvbXBvbmVudCBhbmQgd3JhcCB0aGUgY3VycmVudCBvbmUuXG4gICAgICogSnVzdCBsaWtlIHJlYXRlQ29udGVudEVsZW1lbnRJZkFueSgpIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbFxuICAgICAqIGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIChpbnNpZGUgdGhlIG5nQWZ0ZXJWaWV3SW5pdCgpIClcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVXcmFwcGVyRWxlbWVudElmQW55KCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGNvbXBvbmVudCBpbnRvIGFjdHVhbCBWaWV3IENvbnRhaW5lci4gVGhlIHByb2Nlc3MgZ29lcyBhcyB0aGlzLlxuICAgICAqICAxLiBXZSByZXRyaWV2ZSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IG5hbWUsIHdoaWNoIGNyZWF0ZXMgY29tcG9uZW50UmVmXG4gICAgICogIDIuIFBsYWNlIHRoZSBjb21wb25lbnQgb250byB0aGUgc2NyZWVuXG4gICAgICogIDMuIFJlYWQgY29tcG9uZW50IG1ldGFkYXRhLCBtYWlubHkgSU5QVVRzIGFuZCBhcHBseSBiaW5kaW5ncyBmb3IgZWFjaCBvZiB0aGVtXG4gICAgICogIDQuIE1hbnVhbGx5IHNwaW4gY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgdGhlIHNjcmVlbi4gTWFpbmx5IGZvciBjYXNlIHdoZXJlIEkgbmVlZCB0b1xuICAgICAqIHJlZHJhdyBhIHNjcmVlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb1JlbmRlckNvbXBvbmVudCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBsYWNlVGhlQ29tcG9uZW50KCk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRhY2goKTtcblxuICAgICAgICB0aGlzLmFwcGx5QmluZGluZ3ModGhpcy5jb21wb25lbnRSZWZlcmVuY2UoKSwgdGhpcy5jdXJyZW50Q29tcG9uZW50LCB0aGlzLmJpbmRpbmdzKTtcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50Q29tcG9uZW50LmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICAvLyBTdGlsbCBub3Qgc3VyZSBhYm91dCB0aGlzIHdoYXQgYWxsIEkgc2hvdWxkIHJlbGVhc2UgaGVyZS5cbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50Lm9uRGVzdHJveSgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5jb21wb25lbnRSZWZlcmVuY2VzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGFjZSBhY3R1YWwgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlbiB1c2luZyBWaWV3Q29udGFpbmVyUmVmXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGxhY2VUaGVDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHJlZmVyZW5jZSA9IHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVDb21wb25lbnQocmVmZXJlbmNlLnJlc29sdmVkQ29tcEZhY3RvcnkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbnNlcnRpbmcgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gaGF2ZSBhIGNvbnRlbnQgbGlrZSBlLmcuIGh5cGVybGluayBvciBidXR0b25cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgPGJ1dHRvbj4gTVkgTkcgQ09OVEVOVCA8L2J1dHRvbj5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICB0aGlzIG1ldGhvZCBhcHBsaWVzIGFuZCBpbnNlcnQgYSBjaGlsZCBjb250ZW50IGludG8gdGhlIG1haW4gY29tcG9uZW50LiBUaGlzIG1ldGhvZCBpbnNlcnRcbiAgICAgKiBhIHNpbXBsZSBzdHJpbmcuIFdlIGFyZSBub3Qgd3JhcHBpbmcgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggYW5vdGhlciBjb21wb25lbnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gbmVlZCB0byBydW4gZGV0ZWN0IGNoYW5nZXMgPyBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTogYm9vbGVhblxuICAgIHtcblxuICAgICAgICBsZXQgZGV0ZWN0Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgbmdDb250ZW50ID0gdGhpcy5uZ0NvbnRlbnQoKTtcbiAgICAgICAgbGV0IG5nQ29udGVudEVsZW1lbnQgPSB0aGlzLm5nQ29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29tcG9uZW50ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoU3RyaW5nQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGF3Q29udGVudENvbXBvbmVudCwgMCk7XG5cbiAgICAgICAgICAgICg8U3RyaW5nQ29tcG9uZW50PmNvbXBvbmVudC5pbnN0YW5jZSkudmFsdWUgPSBuZ0NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGF3Q29udGVudENvbnRhaW5lci5hcHBlbmRDaGlsZChjb21wb25lbnQubG9jYXRpb24ubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGRldGVjdENoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbnRlbnQgRWxlbWVudDogJywgbmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV0ZWN0Q2hhbmdlcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmUgYSBORyBDb250ZW50IGZyb20gYmluZGluZyBsaXN0IGFuZCByZW1vdmUgaXQgc28gaXQgaXRzIG5vdCBwcmVwYWdhdGVkIGRvd24gd2hlblxuICAgICAqIGFwcGx5aW5nIG90aGVyIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG5nQ29udGVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cblxuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnRFbGVtZW50KCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IGNvbnRlbnQ6IGFueTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjb250ZW50ID0gdGhpcy5iaW5kaW5ncy5nZXQoSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZS5OZ0NvbnRlbnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjb252ZXJ0IGEgY29tcG9uZW50IG5hbWUgdG8gYWN0dWFsIGEgdHlwZSBhbmQgdGhlbiB1c2UgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogdG8gaW5zdGFudGlhdGUgYSBhIGNvbXBvbmVudCBhbmQgc2F2ZSBpdHMgaW5mb3JtYXRpb24gaW50byBvdXIgY29tcG9uZW50IHJlZmVyZW5jZXMuIFRoZVxuICAgICAqIHJlYXNvbiB3aHkgd2UgaGF2ZSB0aGlzIGNvbXBvbmVudCByZWZlcmVuY2UgaXMgd2UgbmVlZCB0byBzdG9yZSBBbmd1bGFyJ3MgY29tcG9uZW50IG1ldGFkYXRhXG4gICAgICogc28gd2UgY2FuIGl0ZXJhdGUgdGhydSBhbGwgdGhlIGlucHV0cyBhbmQgYmluZCB0aGVtIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogcmV0dXJucyB7Q29tcG9uZW50UmVmZXJlbmNlfSBhIHJlZmVyZW5jZSByZXByZXNlbnRpbmcgYSBjb21wb2VudCBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVmZXJlbmNlKCk6IENvbXBvbmVudFJlZmVyZW5jZVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJUeXBlID0gdGhpcy5yZXNvbHZlQ29tcG9uZW50VHlwZSgpO1xuICAgICAgICBsZXQgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjdXJyVHlwZSk7XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudE1ldGE6IENvbXBvbmVudCA9IHRoaXMucmVzb2x2ZURpcmVjdGl2ZShjb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgbGV0IGNvbXBSZWZlcmVuY2U6IENvbXBvbmVudFJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb21wb25lbnRNZXRhLFxuICAgICAgICAgICAgcmVzb2x2ZWRDb21wRmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGN1cnJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IGNvbXBSZWZlcmVuY2U7XG4gICAgICAgIHJldHVybiBjb21wUmVmZXJlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocnUgQ29tcG9uZW50TWV0YWRhdGEgQElucHV0cygpIGFuZCBjaGVjayBpZiB3ZSBoYXZlIGF2YWlsYWJsZSBiaW5kaW5nIGluc2lkZSB0aGVcbiAgICAgKiAndGhpcy5iaW5kaW5ncydcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYXBwbHlCaW5kaW5ncyhjUmVmOiBDb21wb25lbnRSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnRSZWY8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55Pik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbnB1dHM6IHN0cmluZ1tdID0gY1JlZi5tZXRhZGF0YS5pbnB1dHM7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXRzKSB8fCBpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHdlIGRvIGFueSB0eXBlIGNvbnZlcnNpb24/XG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUoYmluZGluZ3MpLmZvckVhY2goKHYsIGspID0+XG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQuaW5zdGFuY2Vba10pKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIGNvbXBvbmVudCBUeXBlIGJhc2VkIG9uIHRoZSBzdHJpbmcgbGl0ZXJhbFxuICAgICAqXG4gICAgICogQHJldHVybnMgY29tcG9uZW50IHR5cGUgdXNlZCBieSBgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyYFxuICAgICAqXG4gICAgICogdG9kbzogcmVuYW1lIHRoZSBtZXRob2Qgc28gaXRzIGNsZWFyIHRoYXQgaXQgcmV0dXJucyBjb21wb25lbnQgdHlwZSBiYXNlZCBvbiBzdHJpbmcuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVDb21wb25lbnRUeXBlKCk6IGFueVxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmNvbXBSZWdpc3RyeS5uYW1lVG9UeXBlLmdldCh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIHRoaXMubmFtZSArICcgY29tcG9uZW50IGRvZXMgbm90IGV4aXN0cy4gQ3JlYXRlIER1bW15IENvbXBvbmVudCBpbnN0ZWFkJyArXG4gICAgICAgICAgICAgICAgJyBvZiB0aHJvd2luZyB0aGlzIGVycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFR5cGU7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZURpcmVjdGl2ZShjb21wRmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+KTogQ29tcG9uZW50XG4gICAge1xuICAgICAgICBsZXQgY29tcE1ldGE6IENvbXBvbmVudCA9IHtcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29tcEZhY3RvcnkuaW5wdXRzKSAmJiBjb21wRmFjdG9yeS5pbnB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEuaW5wdXRzLnB1c2goaW5wdXQucHJvcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5Lm91dHB1dHMpICYmIGNvbXBGYWN0b3J5Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5vdXRwdXRzLmZvckVhY2goKG91dHB1dDoge3Byb3BOYW1lOiBzdHJpbmcsIHRlbXBsYXRlTmFtZTogc3RyaW5nfSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wTWV0YS5vdXRwdXRzLnB1c2gob3V0cHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wTWV0YTtcbiAgICB9XG5cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXJyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgZGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogRXJyb3IgTWFuYWdlciBpcyBhIHNlcnZpY2UgdXNlZCBieSBGb3JtcyBjb21wb25lbnRzIHRvIG1hcCBlcnJvciBjb2RlcyBpbnRvIG1lYW5pbmdmdWwgbWVzc2FnZXMuXG4gKiBDdXJyZW50bHkgaXQgZG9lcyBub3QgaGF2ZSBtdWNoIGJ1dCBvbmNlIHdlIHBsdWcgaW4gbG9jYWxpemF0aW9uIGl0IHdpbGwgbWFrZSBtb3JlIHNlbnNlXG4gKlxuICpcbiAqIHRvZG86IE9uY2UgbmctdHJhbnNsYXRlIGlzIGltcGxlbWVudGVkIHJlcGxhY2UgdGhpcyB3aXRoIG5nLXRyYW5zbGF0ZSBmdW5jdGlvbmFsaXR5IHNvIHdlIGNhblxuICogZXh0ZXJuYWxpemUgdGhlc2UgbWVzc2FnZXMgaW50byBsb2NhbGUgZmlsZXMuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyU2VydmljZVxue1xuICAgIG1lc3NhZ2VzOiB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAgICAgICAncmVxdWlyZWQnOiAnUmVxdWlyZWQgZmllbGQnLFxuICAgICAgICAgICAgJ21pbmxlbmd0aCc6ICdGaWVsZCBkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoJyxcbiAgICAgICAgICAgICdtYXhsZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtYXhpbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnY3VzdG9tTXNnJzogJyVzJyxcbiAgICAgICAgICAgICdtZXRhdmFsaWQnOiAnJXMnXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBlcnJvck1lc3NhZ2UodmFsaWRhdG9yTmFtZTogc3RyaW5nLCB2YWxpZGF0b3JWYWx1ZT86IGFueSlcbiAgICB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1t2YWxpZGF0b3JOYW1lXTtcbiAgICAgICAgaWYgKFN0cmluZ1dyYXBwZXIuY29udGFpbnMobWVzc2FnZSwgJyVzJykpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHVzZSBuZy10cmFuc2xhdGUgd2l0aCBwcm9wZXIgbWVzc2FnZSBmb3JtYXR0aW5nXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2UobWVzc2FnZSwgJyVzJywgdmFsaWRhdG9yVmFsdWUubXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkluaXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5cbi8qKlxuICogRXJyb3JNZXNzYWdlc0NvbXBvbmVudCBpcyB1c2VkIGJ5IGZvcm0ncyBjb21wb25lbnQgbGlrZSBGb3JtUm93IHRvIHByaW50IGl0cyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqIEl0cyAgYmFzZWQgb24gTW9kZWxEcml2ZW4gKFJlYWN0aXZlIGZvcm1zKSBhbmQgaXQgcmVhZHMgZXJyb3JzIGZyb20gRm9ybUNvbnRyb2xcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhLWVycm9yLW1lc3NhZ2VzJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNtYWxsICpuZ0lmPVwiaGFzTWVzc2FnZSgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidWktZy0xMiB1aS1tZXNzYWdlIHVpLW1lc3NhZ2VzLWVycm9yIHVpLWNvcm5lci1hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVycm9yTXNnIH19XG4gICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHN0eWxlczogW2BgXVxufSlcbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2VzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGZvcm0gRm9ybUNvbnRyb2xsIHRvIGNoZWNrIGZvciBFcnJvcnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVyck1hbmFnZXI6IEVycm9yTWFuYWdlclNlcnZpY2UpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICB9XG5cblxuICAgIGhhc01lc3NhZ2UoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IG1zZyA9IHRoaXMuZXJyb3JNc2c7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQobXNnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1lc3NhZ2VzIGlmIGFueSByZWdpc3RlcmVkIGJ5IGFkZGVkIHZhbGlkYXRvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBlcnJvck1zZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5TmFtZSBpbiB0aGlzLmNvbnRyb2wuZXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmVycm9ycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIHRoaXMuY29udHJvbC50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyTWFuYWdlci5lcnJvck1lc3NhZ2UocHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wuZXJyb3JzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaG93IGVycm9ycz8gV2UgY3VycmVudGx5IHNob3dzIGVycm9ycyBpZiB0aGUgY29udHJvbCBpcyBub3QgdmFsaWQsIGl0IHdhcyB0b3VjaGVkIGJ5IHVzZXIuXG4gICAgICogTW9zdCBvZiB0aGUgdHlwZSBvbiBibHVyIGV2ZW50ICBhbmQgYXQgbGFzdCBpdHMgbm90IHByaXN0aW5lIGFueW1vcmUgKGl0cyBkaXJ0eSlcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dFcnJvcnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRyb2wudmFsaWQgJiYgIXRoaXMuY29udHJvbC5wcmlzdGluZSAmJiB0aGlzLmNvbnRyb2wudG91Y2hlZDtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgSW5qZWN0YWJsZSxcbiAgICBUeXBlLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogTW9kYWwgc2VydmljZSBpcyB1c2VkIHRvIHRvIGNyZWF0ZSBtb2RhbCBkaWFsb2dzLiBJdCBjcmVhdGVzIG1vZGFsIGRpYWxvZ3MgZHluYW1pY2FsbHkuXG4gKiBUaGUgc2VydmljZSBhbHNvIGtlZXBzIHRyYWNrIG9mIHRoZSBjcmVhdGVkIG1vZGFsIGRpYWxvZyBhbmQgY2FuIGNsb3NlIGl0IGJ5IGNhbGxpbmcgdGhlXG4gKiBzZXJ2aWNlJ3MgY2xvc2UoKVxuICpcbiAqIE1vZGFsIHNlcnZpY2UgcmVxdWlyZXMgYSBWaWV3Q29udGFpbmVyIHRvIGluc2VydCBuZXdseSBjcmVhdGVkIG1vZGFscy4gVGhpcyBpcyB0YWtlbiBjYXJlXG4gKiBieSB0aGUgTW9kYWxDb21wb25lbnQuXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgQWRkICAgPGF3LW1vZGFsPjwvYXctbW9kYWw+ICBpbnRvIHlvdXIgYXBwbGljYXRpb24gbWFpbiBodG1sLiBJdCBuZWVkcyB0byBiZSBvbiBldmVyeVxuICogICAgIHBhZ2Ugd2hlcmUgYSBtb2RhbCBkaWFsb2cgd2lsbCBhcHBlYXIuXG4gKlxuICogICAgMS4gIFBvcHVwIGEgZGlhbG9nIHdpdGhvdXQgY3JlYXRpbmcgeW91ciBvd24gY29tcG9uZW50LlxuICogICAgICAgIFVzZSB0aGUgZXhpc3RpbmcgRGlhbG9nQ29tcG9uZW50IGluIHdpZGdldHMuXG4gKlxuICogICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxEaWFsb2dDb21wb25lbnQ+KERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBDcmVhdGluZyB5b3VyIG93biBEaWFsb2cgQ29tcG9uZW50IHRvIHBvcHVwLlxuICpcbiAqICAgICAgICAgbGV0IGNvbXBvbmVudFJlZiA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48TXlEaWFsb2dDb21wb25lbnQ+KE15RGlhbG9nQ29tcG9uZW50LFxuICoge2lucHV0c30pO1xuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1teWRpYWxvZycgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2cgKG9uQ2xvc2UpPVwiY2xvc2VQb3B1cCgpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI3RpdGxlVGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVudmlyYVwiID48L2k+VGhpcyBpcyBteVxuICogICAgIFRpdGxlIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JvZHlUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtZW52aXJhXCIgPjwvaT5UaGlzIGlzIG15XG4gKiAgICAgQm9keSA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2c+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeURpYWxvZ0NvbXBvbmVudCBleHRlbmRzIERpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNsb3NlUG9wdXAoKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5jbG9zZSgpO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb2RhbFNlcnZpY2VcbntcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgc3RhdGljIGxpc3Qgb2Ygb3V0cHV0IHBhcmFtZXRlciBmcm9tIERpYWxvZywgQ29uZmlybWF0aW9uIGNvbXBvbmVudHNcbiAgICAgKiB0aGF0IG5lZWRzIHRvIGJlIGhhbmRsZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBPVVRQVVRfUEFSQU1FVEVSUzogc3RyaW5nW10gPSBbJ29uQ2xvc2UnLCAnb25Db25maXJtJywgJ29uQ2FuY2VsJ107XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgbW9kYWwuIFRoaXMgaXMgcGFzc2VkIGluIHRocm91Z2ggdGhlXG4gICAgICogcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKCkuXG4gICAgICovXG4gICAgcHJpdmF0ZSB2Y1JlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNyZWF0ZWQgbW9kYWwgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbnN0YW5jZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogREkgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGJlIHVzZWQgdG8gY3JlYXRlIG1vZGFsIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZnJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUGxhY2VIb2xkZXIgZm9yIG1vZGFsIHRvIGJlIGluc2VydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZjUmVmXG4gICAgICovXG4gICAgcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHZjUmVmOiBWaWV3Q29udGFpbmVyUmVmKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy52Y1JlZiA9IHZjUmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBtb2RhbCBkaWFsb2cgYnkgZHluYW1pY2FsbHkgY3JlYXRpbmcgdGhlIGNvbXBvbmVudCBhbmQgYWRkaW5nIGl0IHRvIHZjUmVmLlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbjxUPihjb21wb25lbnQ6IFR5cGU8VD4sIHBhcmFtZXRlcnM/OiBhbnkpOiBDb21wb25lbnRSZWY8VD5cbiAgICB7XG4gICAgICAgIGNvbnN0IGNmOiBDb21wb25lbnRGYWN0b3J5PFQ+ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgbGV0IGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPFQ+ID0gdGhpcy52Y1JlZi5jcmVhdGVDb21wb25lbnQoY2YpO1xuXG4gICAgICAgIC8vIEF1dG8gc2V0IHZpc2libGl0eSB0byB0cnVlLiBTbyB0aGF0IHRoZSBEaWFsb2cgd2lsbCBkaXNwbGF5XG4gICAgICAgIHBhcmFtZXRlcnMgPSAocGFyYW1ldGVycykgPyBwYXJhbWV0ZXJzIDoge307XG4gICAgICAgIHBhcmFtZXRlcnNbJ3Zpc2libGUnXSA9IHRydWU7XG5cbiAgICAgICAgLy8gSGFuZGxlIG91dHB1dCBwYXJhbWV0ZXJzLlxuICAgICAgICBNb2RhbFNlcnZpY2UuT1VUUFVUX1BBUkFNRVRFUlMuZm9yRWFjaCgocGFyYW0pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICg8YW55PmNvbXBvbmVudFJlZi5pbnN0YW5jZSlbcGFyYW1dLnN1YnNjcmliZShwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtZXRlcnNbcGFyYW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFJlZi5pbnN0YW5jZSwgcGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gaGFkIHRvIGNhc3QgaXQgaW4gb3JkZXIgdG8gYXZvaWQgYW55IGluZGV4IEVycm9yXG4gICAgICAgIC8vIEF0dGFjaCBhIGRlc3Ryb3kgbWV0aG9kIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudC5cbiAgICAgICAgKDxhbnk+Y29tcG9uZW50UmVmLmluc3RhbmNlKVsnZGVzdHJveSddID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW5zdGFuY2UsIHNvIGl0IGNhbiBiZSBkZXN0cm95ZWQgbGF0ZXIuXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjb21wb25lbnRSZWY7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIGNsb3NlKCkgd2lsbCByZW1vdmUgdGhlIG1vZGFsIGZyb20gdmlldy5cbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIE9uSW5pdCwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuLi9tb2RhbC5zZXJ2aWNlJztcblxuXG4vKipcbiAqIFBsYWNlIGhvbGRlciBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFRoaXMgY29tcG9uZW50IHdvcmtzIHdpdGggdGhlIG1vZGFsU2VydmljZSBieSBwcm92aWRpbmdcbiAqIGEgcGxhY2UgaG9sZGVyIGZvciBpdCB0byBpbmplY3QgRGlhbG9nIGNvbXBvbmVudCBpbnRvLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1vZGFsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgI21vZGFsPjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgYF1cbn0pXG5leHBvcnQgY2xhc3MgTW9kYWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIEBWaWV3Q2hpbGQoJ21vZGFsJywge3JlYWQ6IFZpZXdDb250YWluZXJSZWZ9KVxuICAgIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5yZWdpc3RlclZpZXdDb250YWluZXJSZWYodGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgY3VycmVuY3kgZm9ybWF0dGVyIHdpbGwgaWdub3JlIG51bGwgYW5kIGVtcHR5IHN0cmluZyBmb3IgdmFsdWUuXG4gKiBJc3N1ZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzg2OTQgIERJIGZhaWxzIHdoZW4gZXh0ZW5kcyBvdGhlciBjbGFzc2VzXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnY3VycmVuY3lGb3JtYXQnLFxuICAgIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIEN1cnJlbmN5Rm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm1cbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY3VycmVuY3lQaXBlOiBDdXJyZW5jeVBpcGUpXG4gICAge1xuICAgIH1cblxuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IGFueVxuICAgIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlc1xuICAgICAgICBsZXQgY3VycmVuY3lDb2RlID0gJ1VTRCcsIHN5bWJvbERpc3BsYXkgPSB0cnVlLCBkaWdpdHMgPSAnMS4wLTInO1xuXG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmIChjb2RlICYmIGNvZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5Q29kZSA9IGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVBpcGUudHJhbnNmb3JtKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cyk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICovXG5pbXBvcnQge0RpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIHV0aWxpdHkgZGlyZWN0aXZlIHRoYXQgaXMgdXNlZCBieSBORyBGb3IgY3ljbGUgaW4gc2l0dWF0aW9uIHdoZXJlIHdlIG5lZWQgdG8gY2FsbCBhXG4gKiBvciBleGVjdXRlIHNvbWUgbG9naWMgYWZ0ZXIgZWFjaCBpdGVyYXRpb25cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbmdGb3JTZXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBOZ0ZvclNldERpcmVjdGl2ZVxue1xuXG4gICAgQE91dHB1dCgpXG4gICAgb25JdGVtOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm9uSXRlbS5lbWl0KCctLScpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIGNvbnZlbmllbnQgc2VydmljZSB0byB3b3JrIHdpdGggdGhlIGRvbS4gQWxsIHRoZSBmdXR1cmUgbG9naWMgcmVsYXRlZCB0byBET00gbWFuaXB1bGF0aW9uXG4gKiBvciB0cmF2ZXJzYWwgc2hvdWxkIGJlIHB1dCBpbnRvIHRoaXMgc2VydmljZVxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvbVV0aWxzU2VydmljZVxue1xuXG4gICAgY29uc3RydWN0b3IgKClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ29lcyBhbGwgdGhlIHdheSB1cCB0byB0aGUgYm9keSBhbmQgY2hlY2tzIGlmIHRoZXJlIGlzIGEgZWxlbWVudCBpZGVudGlmaWVkIGJ5IGEgJ3NlbGVjdG9yJ1xuICAgICAqXG4gICAgICovXG4gICAgaGFzUGFyZW50IChuYXRpdmVFbGVtZW50OiBhbnksIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY2xvc2VzdChuYXRpdmVFbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFRyYXZlbHMgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIEJPRFkgYW5kIHJldHJpZXZlIGVsZW1lbnQgaWRlbnRpZmllZCBieSAnc2VsZWN0b3InIG9yIE5VTEwgaWZcbiAgICAgKiBub3QgZm91bmRcbiAgICAgKlxuICAgICAqL1xuICAgIGNsb3Nlc3QgKG5hdGl2ZUVsZW1lbnQ6IGFueSwgc2VsZWN0b3I6IHN0cmluZyk6IGFueVxuICAgIHtcbiAgICAgICAgbGV0IGZpcnN0Q2hhciA9IHNlbGVjdG9yLmNoYXJBdCgwKTtcblxuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5hdGl2ZUVsZW1lbnQ7XG5cblxuICAgICAgICB3aGlsZSAoaXNQcmVzZW50KChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09ICcuJyAmJiBwYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhzZWxlY3Rvci5zdWJzdHIoMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09ICcjJyAmJiBwYXJlbnROb2RlLmlkID09PSBzZWxlY3Rvci5zdWJzdHIoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgaXMgYSB0YWdcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW5ndWxhciBjb21wb25lbnQgaXMgcmVuZGVyZWQgYWxvbmcgd2l0aCBOR0NvbnRlbnQgaXQgaGFzIGl0cyBvd24gX25nQ29udGVudF9JTkRFWFxuICAgICAqIHdoaWNoIGFsd2F5cyBjb3JyZXNwb25kcyB3aXRoIF9uZ2hvc3RfSU5ERVgsIHRoaXMgd29ya3MgZmluZSBpZiB3ZSBoYXZlIGFjdHVhbCBjb21wb25lbnRcbiAgICAgKiB0aGF0IGlzIGFscmVhZHkgcmVuZGVyZWQuIElmIHdlIGFyZSBjcmVhdGluZyBjb21wb25lbnQgcHJvZ3JhbWF0aWNhbGx5IHRoZXJlIGlzIG5vIHdheSB0b1xuICAgICAqIGlkZW50aWZ5IHdoZXJlIHRoZSBhY3R1YWwgbmctY29udGVudCBpcyBwbGFjZWQgd2l0aGluIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIGUuZy4gQ29uc2lkZXIgZm9sbG93aW5nIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKlxuICAgICAqIEJ1dHRvbiBDb21wb25lbnQgVGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgPHNwYW4gY2xhc3M9bXlidXR0b25UaXRsZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlbiB5b3UgdXNlIGJ1dHRvbiBjb21wb25lbnQgYXMgPGF3LWJ1dHRvbj5DbGlja01lPC9hdy1idXR0b24+ICB0aGVuIGl0cyByZW5kZXJlZCBhc1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGF3LWJ1dHRvbiBfbmdob3N0XzEyMz5cbiAgICAgKiAgPHNwYW4gX25nY29udGVudF8xMjMgY2xhc3M9bXlidXR0b25UaXRsZT5DbGlja01lPC9zcGFuPlxuICAgICAqIDwvYXctYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQnV0IHdpdGggcHJvZ3JhbW1hdGljIEFQSSB5b3UgaW5zdGFudGlhdGUgQnV0dG9uIGFuZCBzaW5jZSBpdCBjcmVhdGVkIHdpdGhvdXQgYSBDb250ZW50IGl0XG4gICAgICogbG9va3MgbGlrZSB0aGlzO1xuICAgICAqXG4gICAgICogIGBgYFxuICAgICAqIDxhdy1idXR0b24gX25naG9zdF8xMjM+XG4gICAgICogIDxzcGFuIGNsYXNzPW15YnV0dG9uVGl0bGU+PC9zcGFuPlxuICAgICAqIDwvYXctYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlcmUgZG8geW91IHBsYWNlIHlvdSBjaGlsZCAoY29udGVudCBjb21wb25lbnQpPyBUaGVyZWZvcmUgdXRpbGl0eSBjc3MgY2xhc3Mgd2FzIGNyZWF0ZWRcbiAgICAgKiB0byB3cmFwIDxuZy1jb250ZW50PiB0byBnZXQgYXJvdW5kIHRoaXMgbGltaXRhdGlvbi5cbiAgICAgKlxuICAgICAqICBgYGBcbiAgICAgKiAgIDxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj5cbiAgICAgKiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgIDwvc3Bhbj5cbiAgICAgKiAgYGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0SW50b1BhcmVudE5nQ29udGVudCAocGFyZW50TmF0aXZlRWw6IGFueSwgY2hpbGROYXRpdmVFbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyB0byBpbnNlcnQgaXQgYXMgY2hpbGQgdG8gcGFyZW50TmF0aXZlRWxcbiAgICAgICAgbGV0IG5nQ29udGVudFBhcmVudCA9IHBhcmVudE5hdGl2ZUVsO1xuXG4gICAgICAgIGxldCBmb3VuZE5nQ29udGVudCA9IHBhcmVudE5hdGl2ZUVsLnF1ZXJ5U2VsZWN0b3IoJy51LW5nY29udGVudCcpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGZvdW5kTmdDb250ZW50KSkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY292ZXIgYSBjYXNlIHdoZXJlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG5nY29udGVudHNcbiAgICAgICAgICAgIG5nQ29udGVudFBhcmVudCA9IGZvdW5kTmdDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIG5nQ29udGVudFBhcmVudC5hcHBlbmRDaGlsZChjaGlsZE5hdGl2ZUVsKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgY3VycmVudCBicm93c2VyIHdpbmRvdyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICpcbiAgICAgKi9cbiAgICBicm93c2VyRGltZW50aW9ucyAoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgICAgICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSxcbiAgICAgICAgICAgIGhlaWdodDogKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlcyBlbGVtZW1lbnRzIGRpbWVuc2lvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIGVsZW1lbnREaW1lbnNpb25zIChlbGVtZW50OiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBVbmRlciBAb3JpZ2luYWwtbGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgRHJpZnR5IENvLlxuICogaHR0cDovL2RyaWZ0eS5jb20vXG4gKlxuICogIE1JVCBMaWNlbnNlXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4gKiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqXG4gKiBDcmVkaXQgdG8gZHJpZnR5IGZvciB0aGlzIGV4Y2VsbGVudCBjb21wb25lbnQuIFdlIGhhdmUgYSBzdHJvbmcgbmVlZHMgZm9yIGdvb2QgaW5maW5pdGVcbiAqIHNjcm9sbGluZyBjb21wb25lbnQgc28gdGhpcyBpcyBkZXJpdmVkIHdvcmsgYmFzZWQgb24gdGhpcyBkcmlmdHkgY29tcG9uZW50IGFzIHdlIGNhbiBub3QgcmVhbGx5XG4gKiBicmluZyBpbiB3aG9sZSBmcmFtZXdvcmsgYW5kIHRoZWlyIGNvbXBvbmVudC9BUEkuIEl0IHdvdWxkIGJlIHRvbyBoZWF2eVxuICpcbiAqIENvbXBvbmVudCBpcyB1cGRhdGVkIHdpdGggbmF0aXZlIERPTSBBUEkuIHBsdXMgc2ltcGxpZmllZCBieSByZW1vdmluZyB0aGluZ3NcbiAqIHRoYXQgYXJlIG5vdCBuZWNlc3NhcnkgZm9yIG91ciB1c2VjYXNlLiBVcGRhdGVkIGRpcmVjdGl2ZSBwcmVmaXggdG8gbWF0Y2ggb3VyIGd1aWRlbGluZXNcbiAqXG4gKlxuICpcbiAqL1xuXG5cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLCBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5cbi8qKlxuICogVGhlIEluZmluaXRlIFNjcm9sbCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gYW4gYWN0aW9uIHdoZW4gdGhlIHVzZXJcbiAqIHNjcm9sbHMgYSBzcGVjaWZpZWQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tIG9yIHRvcCBvZiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgZXhwcmVzc2lvbiBhc3NpZ25lZCB0byB0aGUgYGluZmluaXRlYCBldmVudCBpcyBjYWxsZWQgd2hlblxuICogdGhlIHVzZXIgc2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIGRpc3RhbmNlLiBXaGVuIHRoaXMgZXhwcmVzc2lvblxuICogaGFzIGZpbmlzaGVkIGl0cyB0YXNrcywgaXQgc2hvdWxkIGNhbGwgdGhlIGBjb21wbGV0ZSgpYCBtZXRob2RcbiAqIG9uIHRoZSBpbmZpbml0ZSBzY3JvbGwgaW5zdGFuY2UuXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxkaXYgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX0gPC9kaXY+XG4gKiAgIDxhdy1pbmZpbml0ZS1zY3JvbGwgKG9uTG9hZCk9XCJkb0luZmluaXRlKCRldmVudClcIj5cbiAqICA8L2F3LWluZmluaXRlLXNjcm9sbD5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogWW91IGNhbiBhbHNvIHNldCBhIHRocmVzaG9sZCB0byBjaGFuZ2UgdGhlIGRpc3RhbmNlIHdoZW4gdGhlIGxhenkgbG9hZCBraWNrc1xuICogaW4uXG4gKiAjIyBVc2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiAgPGRpdiAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fSA8L2Rpdj5cbiAqICAgPGF3LWluZmluaXRlLXNjcm9sbCAob25Mb2FkKT1cImRvSW5maW5pdGUoJGV2ZW50KVwiICBbZGlzdGFuY2VdPVwiJzE1JSdcIj5cbiAqICA8L2F3LWluZmluaXRlLXNjcm9sbD5cbiAqXG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1pbmZpbml0ZS1zY3JvbGwnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctaW5maW5pdGUtbG9hZGVyLXBhbmVsXCIgKm5nSWY9XCJpc0xvYWRpbmcoKVwiPlxuICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1zeW5jaHJvbml6ZSB1LXNwaW4taWNvblwiPjwvc3Bhbj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnctaW5maW5pdGUtbG9hZGVyLXBhbmVse2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwcHg7ei1pbmRleDozMDA7Ym90dG9tOjEwMHB4fS53LWluZmluaXRlLWxvYWRlci1wYW5lbCBzcGFue2NvbG9yOiM0YTRhNGE7Zm9udC1zaXplOjJlbX1gXSxcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXRcbntcbiAgICBfbGFzdENoZWNrOiBudW1iZXIgPSAwO1xuICAgIF9sYXN0U2Nyb2xsVG9wOiBudW1iZXIgPSAwO1xuICAgIF9zY0xzbjogYW55O1xuICAgIF90aHI6IHN0cmluZyA9ICcxMCUnO1xuICAgIF90aHJQeDogbnVtYmVyID0gMDtcbiAgICBfdGhyUGM6IG51bWJlciA9IDAuMTA7XG4gICAgX2luaXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIF9jb250ZW50OiBhbnk7XG4gICAgX2RvY0JvZHk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRlOiBzdHJpbmcgPSBTVEFURV9FTkFCTEVEO1xuXG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSB0aHJlc2hvbGQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tXG4gICAgICogb2YgdGhlIGNvbnRlbnQgdG8gY2FsbCB0aGUgYG9uTG9hZGAgb3V0cHV0IGV2ZW50IHdoZW4gc2Nyb2xsZWQuXG4gICAgICogVGhlIHRocmVzaG9sZCB2YWx1ZSBjYW4gYmUgZWl0aGVyIGEgcGVyY2VudCwgb3JcbiAgICAgKiBpbiBwaXhlbHMuIEZvciBleGFtcGxlLCB1c2UgdGhlIHZhbHVlIG9mIGAxMCVgIGZvciB0aGUgYGluZmluaXRlYFxuICAgICAqIG91dHB1dCBldmVudCB0byBnZXQgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIHNjcm9sbGVkIDEwJVxuICAgICAqIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVXNlIHRoZSB2YWx1ZSBgMTAwcHhgIHdoZW4gdGhlXG4gICAgICogc2Nyb2xsIGlzIHdpdGhpbiAxMDAgcGl4ZWxzIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5cbiAgICAgKiBEZWZhdWx0IGlzIGAxNSVgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGRpc3RhbmNlICgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aHI7XG4gICAgfVxuXG4gICAgc2V0IGRpc3RhbmNlICh2YWw6IHN0cmluZylcbiAgICB7XG4gICAgICAgIHRoaXMuX3RociA9IHZhbDtcbiAgICAgICAgaWYgKHZhbC5pbmRleE9mKCclJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyUHggPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGhyUGMgPSAocGFyc2VGbG9hdCh2YWwpIC8gMTAwKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGhyUHggPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICB0aGlzLl90aHJQYyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Jvb2xlYW59IElmIHRydWUsIFdoZXRoZXIgb3Igbm90IHRoZSBpbmZpbml0ZSBzY3JvbGwgc2hvdWxkIGJlXG4gICAgICogZW5hYmxlZCBvciBub3QuIFNldHRpbmcgdG8gYGZhbHNlYCB3aWxsIHJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogYW5kIGhpZGUgdGhlIGRpc3BsYXkuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgZW5hYmxlZCAoc2hvdWxkRW5hYmxlOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5lbmFibGUoc2hvdWxkRW5hYmxlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBvdXRwdXQge2V2ZW50fSBFbWl0dGVkIHdoZW4gdGhlIHNjcm9sbCByZWFjaGVzXG4gICAgICogdGhlIHRocmVzaG9sZCBkaXN0YW5jZS4gRnJvbSB3aXRoaW4geW91ciBpbmZpbml0ZSBoYW5kbGVyLFxuICAgICAqIHlvdSBtdXN0IGNhbGwgdGhlIGluZmluaXRlIHNjcm9sbCdzIGBjb21wbGV0ZSgpYCBtZXRob2Qgd2hlblxuICAgICAqIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Mb2FkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICBAVmlld0NoaWxkKCdsb2FkaW5QYW5lbCcpXG4gICAgbG9hZFBhbmVsOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExhenkgbG9hZCBjdXJyZW50IG51bWJlcnMuIHRlbGwgdGhlIGFwcCBzdGFydGluZyBwb2ludCBhbmQgd2hhdCBpcyB0aGUgc2l6ZSBvZiBsb2FkZWRcbiAgICAgKiBsaXN0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZldGNoU2l6ZTogbnVtYmVyID0gMDtcblxuICAgIGxvYWRPZmZzZXQ6IG51bWJlciA9IDA7XG5cblxuICAgIGNvbnN0cnVjdG9yIChwcml2YXRlIF9yZW5kZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZilcbiAgICB7XG5cblxuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlci5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnaGFzLWluZmluaXRlLXNjcm9sbCcpO1xuXG4gICAgfVxuXG4gICAgX29uU2Nyb2xsIChldjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG11c3QgdGhyb3R0bGUgdGhlIGNsYXNzIGJ5IDEwMG1zXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Q2hlY2sgKyAxMDAgPiBldi50aW1lU3RhbXApIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gY2hlY2sgbGVzcyB0aGFuIGV2ZXJ5IFhYbXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhc3RDaGVjayA9IGV2LnRpbWVTdGFtcDtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgbGV0IHdpbkhlaWdodCA9IHRoaXMuZG9tVXRpbHMuYnJvd3NlckRpbWVudGlvbnMoKS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMuX2RvY0JvZHkuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9kb2NCb2R5Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHdpbkhlaWdodCwgdGhpcy5fY29udGVudC5zY3JvbGxIZWlnaHQsIHRoaXMuX2NvbnRlbnQub2Zmc2V0SGVpZ2h0KTtcblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaGVpZ2h0IG9mIHRoaXMgZWxlbWVudCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJQYyA/IChoZWlnaHQgKiB0aGlzLl90aHJQYykgOiB0aGlzLl90aHJQeDtcbiAgICAgICAgbGV0IGRpc3RhbmNlRnJvbUluZmluaXRlID0gdGhpcy5fY29udGVudC5zY3JvbGxIZWlnaHQgLSB3aW5IZWlnaHQgLSBzY3JvbGxUb3AgLSB0aHJlc2hvbGQ7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RvY3VtZW50IGhlaWdodCAoJyArIGhlaWdodCArICcpICwgRGlzdGFuY2UgZnJvbSBib3R0b20gJ1xuICAgICAgICAvLyArIGRpc3RhbmNlRnJvbUluZmluaXRlICsgJywgID0+IHRocmVzaG9sZCA9ICcgK1xuICAgICAgICAvLyAgICAgdGhpcy5kaXN0YW5jZSArICcgKCcgKyB0aHJlc2hvbGQgKyAnKScpO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZUZyb21JbmZpbml0ZSA8IDAgJiYgdGhpcy5fbGFzdFNjcm9sbFRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5TG9hZCgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFNjcm9sbFRvcCA+IHNjcm9sbFRvcCAmJiBzY3JvbGxUb3AgPCB3aW5IZWlnaHRcbiAgICAgICAgICAgICYmIHRoaXMubG9hZE9mZnNldCAhPT0gdGhpcy5mZXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eVVuTG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2RvOiByZWZhY3RvciB0byBvbmUgbWV0aG9kXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaXJlT25MYXp5TG9hZCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcgJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfTE9BRElORztcblxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpc0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmZldGNoU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxvYWRPZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvbiB0aGUgbmV4dCByZWNvcmRcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRPZmZzZXQgKz0gdGhpcy5mZXRjaFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBmaXJlT25MYXp5VW5Mb2FkICgpXG4gICAge1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORyAmJiB0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9MT0FESU5HO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb24gdGhlIG5leHQgcmVjb3JkXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkT2Zmc2V0ID0gdGhpcy5mZXRjaFNpemU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMuZmV0Y2hTaXplLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubG9hZE9mZnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgc2Nyb2xsVG9wICgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IHRoaXMuX2NvbnRlbnQuc2Nyb2xsVG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBjb21wbGV0ZSgpYCB3aXRoaW4gdGhlIGBpbmZpbml0ZWAgb3V0cHV0IGV2ZW50IGhhbmRsZXIgd2hlblxuICAgICAqIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuIEZvciBleGFtcGxlLCB0aGUgYGxvYWRpbmdgXG4gICAgICogc3RhdGUgaXMgd2hpbGUgdGhlIGFwcCBpcyBwZXJmb3JtaW5nIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24sXG4gICAgICogc3VjaCBhcyByZWNlaXZpbmcgbW9yZSBkYXRhIGZyb20gYW4gQUpBWCByZXF1ZXN0IHRvIGFkZCBtb3JlIGl0ZW1zXG4gICAgICogdG8gYSBkYXRhIGxpc3QuIE9uY2UgdGhlIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIFVJIHVwZGF0ZWQsIHlvdVxuICAgICAqIHRoZW4gY2FsbCB0aGlzIG1ldGhvZCB0byBzaWduaWZ5IHRoYXQgdGhlIGxvYWRpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNoYW5nZSB0aGUgaW5maW5pdGUgc2Nyb2xsJ3Mgc3RhdGUgZnJvbSBgbG9hZGluZ2BcbiAgICAgKiB0byBgZW5hYmxlZGAuXG4gICAgICovXG4gICAgY29tcGxldGUgKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9FTkFCTEVEO1xuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHRyaWdnZXIgZXh0cmEgZGV0ZWN0IGNoYW5nZXMgdG8gcmVyZW5kZXIgbG9hZGluZyBpY29uXG4gICAgICAgICAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBlbmFibGUoZmFsc2UpYCB0byBkaXNhYmxlIHRoZSBpbmZpbml0ZSBzY3JvbGwgZnJvbSBhY3RpdmVseVxuICAgICAqIHRyeWluZyB0byByZWNlaXZlIG5ldyBkYXRhIHdoaWxlIHNjcm9sbGluZy4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXG4gICAgICogd2hlbiBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0aGF0IGNhbiBiZSBhZGRlZCwgYW5kXG4gICAgICogdGhlIGluZmluaXRlIHNjcm9sbCBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqIEBwYXJhbSBzaG91bGRFbmFibGUgIElmIHRoZSBpbmZpbml0ZSBzY3JvbGwgc2hvdWxkIGJlXG4gICAgICogZW5hYmxlZCBvciBub3QuIFNldHRpbmcgdG8gYGZhbHNlYCB3aWxsIHJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogYW5kIGhpZGUgdGhlIGRpc3BsYXkuXG4gICAgICovXG4gICAgZW5hYmxlIChzaG91bGRFbmFibGU6IGJvb2xlYW4pXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gKHNob3VsZEVuYWJsZSA/IFNUQVRFX0VOQUJMRUQgOiBTVEFURV9ESVNBQkxFRCk7XG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhzaG91bGRFbmFibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gbmF0aXZlIHdpbmRvd3Mgc2Nyb2xsIGV2ZW50XG4gICAgICovXG4gICAgX3NldExpc3RlbmVycyAoc2hvdWxkTGlzdGVuOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXQpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRMaXN0ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NjTHNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NMc24gPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3NjTHNuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2NMc24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY0xzbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjTHNuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGlzTG9hZGluZyAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNUQVRFX0xPQURJTkc7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0ICgpXG4gICAge1xuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZG9jQm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlMb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3kgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhmYWxzZSk7XG4gICAgfVxuXG59XG5cblxuY29uc3QgU1RBVEVfRU5BQkxFRCA9ICdlbmFibGVkJztcbmNvbnN0IFNUQVRFX0RJU0FCTEVEID0gJ2Rpc2FibGVkJztcbmNvbnN0IFNUQVRFX0xPQURJTkcgPSAnbG9hZGluZyc7XG4iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXdOYW1lU3RvcmUge1xuXG4gICAgcHJpdmF0ZSBzdG9yZTogTWFwPHN0cmluZywgYW55PjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFkZChuYW1lOiBzdHJpbmcsIGVsOiBhbnkpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGlkZXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSBpcyBub3QgdW5pcXVlIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnNldChuYW1lLCBlbCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKG5hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5kZWxldGUobmFtZSk7XG4gICAgfVxuXG4gICAgY29sbGlkZXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmhhcyhuYW1lKTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5jbGVhcigpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBEaXJlY3RpdmUsXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBBcHBDb25maWdcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbmltcG9ydCB7XG4gICAgQXdOYW1lU3RvcmVcbn0gZnJvbSAnLi9hdy1uYW1lLnN0b3JlJztcblxuLyoqXG4gKiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIGF0dGFjaGVzIGEgaWRlbnRpZmllciB0byBkZWNvcmF0ZWQgZWxlbWVudCB0byBhaWQgc2VsZWN0b3JzIGZvciB0ZXN0aW5nXG4gKiBwdXJwb3Nlcy4gVGhlICdhd05hbWUnIGRpcmVjdGl2ZSB0cmllcyB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGJhc2VkIG9uIGNvbnRleHR1YWwgZGF0YVxuICogYW5kIGluaGVyYW50IGltbXV0YWJsZSBlbGVtZW50IGF0dHJpYnV0ZXMuXG4gKlxuICogKipHZW5lcmF0aW5nIHRoZSBCYXNlIE5hbWUqKlxuICpcbiAqIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgZ2VuZXJhdGVzIGEgYmFzZSBuYW1lIGZyb20gZWxlbWVudCB0YWcgbmFtZSBhbmQgYXR0cmlidXRlcyB3aGljaCBhcmVcbiAqIHN0YXRpYyBieSBuYXR1cmUuXG4gKlxuICogICAgIEV4YW1wbGU6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgYXdOYW1lPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgYXduYW1lPVwiYnV0dG9uX29yZGVyXCI+XG4gKlxuICogSWYgdGhlIGVsZW1lbnQgaGFzIGFuICdpZCcsIHRoYXQgdmFsdWUgdGFrZXMgcHJlY2VkZW50IGFuZCBpcyB1c2VkIGluc3RlYWQgb2YgYSBnZW5lcmF0ZWRcbiAqIG5hbWUuXG4gKlxuICogICAgIEV4YW1wbGU6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgaWQ9XCJteU9yZGVyQnV0dG9uXCIgYXdOYW1lPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgaWQ9XCJteU9yZGVyQnV0dG9uXCIgYXduYW1lPVwiYnV0dG9uX215T3JkZXJCdXR0b25cIj5cbiAqXG4gKlxuICogKipSZXBlYXRlZCBFbGVtZW50cyBhbmQgdGhlICdleHQnIFBhcmFtZXRlcioqXG4gKlxuICogVGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgZWxlbWVudHMgYXJlIGdlbmVyYXRlZCBkeW5hbWljYWxseSBpbiB0aGUgY29kZSBhcyBsaXN0cyBvciB0YWJsZXMuXG4gKiBJbiBzdWNoIGNhc2VzLCBpdCBtYXkgbm90IGJlIGVhc3kgdG8gZGlzdGluZ3Vpc2ggaW5kaXZpZHVhbCBlbGVtZW50cyBieSBzdGFuZGFyZCBIVE1MXG4gKiBhdHRyaWJ1dGVzLCBzbyB0aGUgJ2F3TmFtZScgZGlyZWN0aXZlIGFsbG93cyBjdXN0b20gZXh0ZW50aW9ucyB0byB0aGUgYmFzZSBuYW1lIHRvIGJlIHByb3ZpZGVkXG4gKiB1c2luZyB0aGUgJ2V4dCcgYXR0cmlidXRlLlxuICpcbiAqICAgIEV4YW1wbGU6XG4gKiAgICAgICAgZnJ1aXRzID0gWydhcHBsZScsICdiYW5hbmEnLCAnb3JhbmdlJ107XG4gKlxuICogICAgICAgIDx1bD5cbiAqICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBmcnVpdCBvZiBmcnVpdHNcIiBhd05hbWUgZXh0PVwie3tmcnVpdH19XCI+e3tmcnVpdH19PC9saT5cbiAqICAgICAgICA8L3VsPlxuICpcbiAqICAgUmVzdWx0OlxuICogICAgICAgPHVsPlxuICogICAgICAgICAgIDxsaSBhd25hbWU9XCJsaV9hcHBsZVwiPmFwcGxlPC9saT5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfYmFuYW5hXCI+YmFuYW5hPC9saT5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfb3JhbmVcIj5vcmFuZ2U8L2xpPlxuICogICAgICAgPC91bD5cbiAqXG4gKiAqKkFkZGluZyBDb250ZXh0IFRocm91Z2ggQW5jZXN0b3IgSW5zcGVjdGlvbioqXG4gKlxuICogSW4gb3JkZXIgdG8gcHJvdmlkZSBjb250ZXh0IHRvIHRoZSBlbGVtZW50IG5hbWluZywgdGhlICdhd05hbWUnIGRpcmVjdGl2ZSBsb29wcyB0aHJvdWdoIHRoZVxuICogcGFyZW50IGFuY2VzdHJ5IGFuZCBzZWFyY2hlcyBmb3IgYW55IHVuaXF1ZSBlbGVtZW50ICdpZCcgdG8gcHJlcGVuZCB0byB0aGUgYmFzZSBuYW1lLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8Zm9ybSBpZD1cImFwcGxpY2FudFwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZmlyc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqICAgICAgICAgPGZvcm0gaWQ9XCJzcG91c2VcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICA8L2Zvcm0+XG4gKlxuICogICAgIFJlc3VsdDpcbiAqICAgICAgICAgPGZvcm0gaWQ9XCJhcHBsaWNhbnRcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3bmFtZT1cImFwcGxpY2FudF9pbnB1dF9maXJzdE5hbWVcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXduYW1lPVwiYXBwbGljYW50X2lucHV0X2xhc3ROYW1lXCI+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqICAgICAgICAgPGZvcm0gaWQ9XCJzcG91c2VcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3bmFtZT1cInNwb3VzZV9pbnB1dF9maXJzdE5hbWVcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXduYW1lPVwic3BvdXNlX2lucHV0X2xhc3RuYW1lXCI+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqXG4gKiAqKlVuaXF1ZW5lc3MgQ2hlY2sqKlxuICpcbiAqICdhd05hbWUnIGtlZXBzIHRyYWNrIG9mIHRoZSBuYW1lcyBpdCBjcmVhdGVzIGJ5IGFkZGluZyB0aGVtIHRvIGEgbWFwIHN0b3JlLiBXaGVuZXZlciBpdFxuICogY3JlYXRlcyBhIG5ldyBuYW1lIGR1cmluZyB0aGUgYG5nT25Jbml0YCBwaGFzZSBpdCBjaGVja3MgaXQgYWdhaW5zdCB0aGUgZXhpc3RpbmcgbWFwLFxuICogYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXQgZW5jb3VudGVycyBhIGR1cGxpY2F0ZS4gTW9yZW92ZXIgZHVyaW5nIHRoZSBlbGVtZW50IGRlc3RydWN0aW9uXG4gKiBwaGFzZSwgYG5nT25EZXN0cm95YCwgJ2F3TmFtZScgcmVtb3ZlcyB0aGUgZ2VuZXJhdGVkIG5hbWUgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICpcbiAqICoqSW4gUHJvZHVjdGlvbioqXG4gKlxuICogVXNpbmcgJ2F3TmFtZScgYWRkcyBhIHNtYWxsIGJpdCBvZiByZW5kZXJpbmcgb3ZlcmhlYWQgZm9yIGVhY2ggZWxlbWVudCBpdCBpcyB1c2VkIG9uLiBJblxuICogYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCAnYXdOYW1lJyBzZXJ2ZXMgbm8gZnVuY3Rpb25hbGl0eSB0byB0aGUgZW5kIHVzZXIsIGJ1dCBtYXkgaGF2ZVxuICogYSBwZXJmb3JtYW5jZSBpbXBhY3Qgb24gdGhlIGFwcGxpY2F0aW9uLiBBcyBzdWNoLCAnYXdOYW1lJyB0YWtlcyBpbnRvIGFjY291bnQgdGhlXG4gKiBgQXBwQ29uZmlnYCBzZXR0aW5ncyBhbmQgZGlzYWJsZXMgbmFtZSBnZW5lcmF0aW9uIHdoZW4gYEFwcENvbmZpZy5pc1Byb2R1Y3Rpb25Nb2RlKClgXG4gKiBpcyBgdHJ1ZWAuXG4gKlxuICogSW4geW91ciBhcHBsaWNhdGlvbiwgeW91IGNhbiB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSBieSBzZXR0aW5nIGBkZXZtb2RlLmVuYWJsZWRgIHRvXG4gKiBgZmFsc2VgIHdoZW4gY29uZmlndXJpbmcgYEFyaWJhQ29yZU1vZHVsZWA6XG4gKlxuICogICAgIEFyaWJhQ29yZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgICAgJ2Rldm1vZGUuZW5hYmxlZCc6IGZhbHNlXG4gKiAgICAgfSlcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2F3TmFtZV0nLFxufSlcbmV4cG9ydCBjbGFzcyBBd05hbWVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBleHQ6IHN0cmluZztcblxuICAgIHByaXZhdGUgbmFtZTogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBzZXBhcmF0b3I6IHN0cmluZyA9ICdfJztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIHN0b3JlOiBBd05hbWVTdG9yZSxcbiAgICAgICAgcHJpdmF0ZSBjb25maWc6IEFwcENvbmZpZ1xuICAgICkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlzUHJvZHVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jcmVhdGVOYW1lKHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50VG9TdG9yZSh0aGlzLm5hbWUsIHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXduYW1lJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3JlLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlbGVtZW50IG5hbWUvaWQgYW5kIHJlZmVyZW5jZSB0byBtYXAgc3RvcmUuIElmIG5hbWUvaWQgYWxyZWFkeVxuICAgICAqIGV4aXN0cyBpbiBzdG9yZSB0aGVuIGl0IHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEVsZW1lbnRUb1N0b3JlKG5hbWU6IHN0cmluZywgZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5hZGQobmFtZSwgZWxlbSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlICsgYC4gXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2UuYCwgZWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG5hbWUvaWQgZm9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICogQHJldHVybiBTdHJpbmcgTmFtZS9JRFxuICAgICAqL1xuICAgIGNyZWF0ZU5hbWUoZWxlbTogRWxlbWVudFJlZikge1xuXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLmdldFRhZ05hbWUoZWxlbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcnJheSBvZiBzdHJpbmcgcGFydHNcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5kIGFuY2VzdG9yIHRhZyBpZCwgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGNvbnN0IHBhcmVudElEID0gdGhpcy5nZXRBbmNlc3RvcklkKGVsZW0pO1xuICAgICAgICBpZiAocGFyZW50SUQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50SUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHRhZyB0eXBlXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IHRoaXMuZ2V0UGFyZW50TmFtZShlbGVtKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0YWduYW1lXG4gICAgICAgIHBhcnRzLnB1c2godGFnTmFtZSk7XG5cbiAgICAgICAgLy8gQ2hvb3NlIGlkIHByb3BlcnR5IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoZWxlbS5uYXRpdmVFbGVtZW50LmlkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5pZCk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGJ1aWxkIGV4dGVuc2lvbiBmcm9tIHRhZyBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZWxlbS5uYXRpdmVFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdmFsdWUgYXR0cmlidXRlIGlmICdvcHRpb24nIHRhZ1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZShlbGVtLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBleHRlbnNpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLmV4dCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZSh0aGlzLmV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4odGhpcy5zZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0YWcgbmFtZSBmcm9tIGVsZW1lbnQgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VGFnTmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGVsZW1lbnQgYW5jZXN0cnkgYW5kIHJldHVybiBmaXJzdCBpZCBhdHRyaWJ1dGVcbiAgICAgKiBlbmNvdW50ZXJlZC5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEFuY2VzdG9ySWQoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIGxldCBpZCA9ICcnO1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFpZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgIGlkID0gcGFyZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBuYW1lIGF0dHJpYnV0ZSBmcm9tIHBhcmVudCBpZiBuYW1lIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRQYXJlbnROYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiAocGFyZW50Lm5hbWUgJiYgIXBhcmVudC5pZCkgPyBwYXJlbnQubmFtZSA6IG51bGw7XG4gICAgfVxuXG4gICAgc3BhY2VzVG9VbmRlcnNjb3JlKHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKy9nLCAnXycpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtFbWJlZGRlZEl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vZW1iZWRkZWQtaXRlbSc7XG5pbXBvcnQge0dlbmVyaWNDb250YWluZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7SW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZX0gZnJvbSAnLi9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtFcnJvck1lc3NhZ2VzQ29tcG9uZW50fSBmcm9tICcuL2Vycm9yLW1lc3NhZ2VzL2Vycm9yLW1lc3NhZ2VzLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7Q3VycmVuY3lGb3JtYXRQaXBlfSBmcm9tICcuL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlJztcbmltcG9ydCB7TmdGb3JTZXREaXJlY3RpdmV9IGZyb20gJy4vb24tbmdmb3Itc2V0LmRpcmVjdGl2ZSc7XG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50fSBmcm9tICcuL2luZml0ZS1zY3JvbGwvaW5maXRlLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBd05hbWVEaXJlY3RpdmV9IGZyb20gJy4vYXctbmFtZS9hdy1uYW1lLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUsXG4gICAgICAgIEdlbmVyaWNDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgIEVycm9yTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBDdXJyZW5jeUZvcm1hdFBpcGUsXG4gICAgICAgIE5nRm9yU2V0RGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCxcbiAgICAgICAgQXdOYW1lRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NvcmVDb21wb25lbnRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIG5vb3B9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgbW9kYWwgZGlhbG9ncy4gUHJvdmlkZXMgZGVmYXVsdHMgZnVuY3Rpb25hbGl0eSBmb3IgYWxsIG1vZGFscy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGFsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzdHJveTogKCkgPT4gdm9pZCA9IG5vb3A7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRoYXQgY2xvc2VzIHRoZSBkaWFsb2cgYnkgY2FsbGluZyBkZXN0cm95IG9uIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqIE1ldGhvZCBpbmhlcml0ZWQgYnkgYWxsIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjbG9zZU1vZGFsKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBpc1N0cmluZ01hcCwgaXNUeXBlLCBvYmplY3RUb05hbWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5cbi8qKlxuICogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5IGFnZ3JlZ2F0ZXMgZGlmZmVyZW50IERhdGFQcm92aWRlcnMgcGVyIHR5cGUuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnlcbntcblxuICAgIC8qKlxuICAgICAqIE1hcHMgY2xhc3MgbmFtZSB0byBEYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5QnlQcm92aWRlcjogTWFwPHN0cmluZywgRGF0YVByb3ZpZGVyPGFueT4+O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3MgTmFtZSAgdG8gYWN0dWFsIHR5cGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5TmFtZVRvQ2xhc3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0cnlCeVByb3ZpZGVyID0gbmV3IE1hcDxzdHJpbmcsIERhdGFQcm92aWRlcjxhbnk+PigpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBldmVyeSBzaW5nbGUgcmVnaXN0ZXJlZCBEYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb24gd2UgYWxzbyBuZWVkIHN0b3JlIGl0cyBwcm90b3R5cGVcbiAgICAgKiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHN1cHBvcnQgc29tZSBraW5kIG9mIGluaGVyaXRhbmNlLiBZb3UgY2FuIHJlZ2lzdGVyIGEgcHJvdmlkZXIgZm9yXG4gICAgICogYSBwYXJlbnQgY2xhc3MgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlclByb3ZpZGVyPFQ+KHRhcmdldDogYW55LCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGFyZ2V0KSB8fCAoIWlzU3RyaW5nTWFwKHRhcmdldCkgJiYgIWlzVHlwZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcgQ2Fubm90IHJlZ2lzdGVyIG5vbi1vYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuYW1lID0gaXNUeXBlKHRhcmdldCkgPyB0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuc2V0KG5hbWUsIHByb3ZpZGVyKTtcblxuICAgICAgICBsZXQgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlOYW1lVG9DbGFzcy5zZXQobmFtZSwgcHJvdG90eXBlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgYmVzdCBtYXRjaGluZyBwcm92aWRlci4gSWYgbm90IGZvdW5kIHRoZW4gdXNlIG9iamVjdCBwcm90b3R5cGUgdG8gZ2V0IGhvbGQgb2YgaXRzXG4gICAgICogcGFyZW50IGFuZCBzZWUgaWYgdGhlcmUgaXMgYSBwcm92aWRlciByZWdpc3RlcmVkIG9uIHRoaXMgbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvckNsYXNzPFQ+KGNsYXNzTmFtZTogc3RyaW5nKTogRGF0YVByb3ZpZGVyPFQ+XG4gICAge1xuICAgICAgICBsZXQgcmVnaXN0ZXJlZENsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgbGV0IGNsYXNzUHJvdG8gPSB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3MuZ2V0KGNsYXNzTmFtZSk7XG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChyZWdpc3RlcmVkQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4gPSB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlci5nZXQocmVnaXN0ZXJlZENsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIudHlwZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIHVwIHRvIHBhcmVudFxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjbGFzc1Byb3RvKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudE5hbWUgPSBvYmplY3RUb05hbWUoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIChpc1ByZXNlbnQocGFyZW50TmFtZSkgJiYgcGFyZW50TmFtZSAhPT0gcmVnaXN0ZXJlZENsYXNzTmFtZSkgPyBwYXJlbnROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgYmVzdE1hdGNoRm9yQ2xhc3MoKSB3aXRoIHRoZSBkaWZmZXJlbmNlIHRvIHBhc3MgYSB0eXBlLiBJZiB5b3Ugd2FudCB0b1xuICAgICAqIHN1cHBvcnQgb2JqZWN0IGluaGVyaXRhbmNlIHlvdSBuZWVkIHRoaXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvclR5cGU8VD4odHlwZTogVHlwZTxUPik6IERhdGFQcm92aWRlcjxUPlxuICAgIHtcbiAgICAgICAgbGV0IG5hbWU6IHN0cmluZyA9IG9iamVjdFRvTmFtZSh0eXBlKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3Muc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5iZXN0TWF0Y2hGb3JDbGFzczxUPihuYW1lKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBQcm92aWRlciBpcyBhIGRhdGEgZHJpdmVyIHRoYXQgY2FuIGFjY2VzcyBkYXRhIGFuZCByZXRyaWV2ZSB0aGVtLiBJdCBrbm93cyBob3cgdG8gZ2V0IDFcbiAqIG9yIG1vcmUgcmVjb3JkcywgbWF5YmUgZG8gcGFnaW5nIGFuZCBzb21lIG90aGVyIHRoaW5ncy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhUHJvdmlkZXI8VD5cbntcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1cnJlbnQgdHlwZSBmb3IgdGhpcyBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICB0eXBlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgdGhlIGxpc3RlbmVycyBpbiBjYXNlIG9mIGRhdGEgYXJlIGF2YWlsYWJsZSBvciBpZiB0aGV5IGNoYW5nZWQgZHVlIHRvIHNvbWUgdXNlclxuICAgICAqIGludGVyYWN0aW9uICAoc2VhcmNoLCBhZGRpbmcgb3IgcmVtb3ZpbmcpLlxuICAgICAqXG4gICAgICovXG4gICAgZGF0YUNoYW5nZXM6IEJlaGF2aW9yU3ViamVjdDxUW10+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUW10+KFtdKTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZGF0YSBzb3VyY2UgcG9wdWxhdGVkIGJ5IGZldGNoIG9yIHNlYXJjaC4gSlMgYXBwbGljYXRpb24gY2FuIGhvbGQgbGFyZ2UgYW1vdW50IG9mXG4gICAgICogcmVjb3JkcyB3aXRob3V0IGdvaW5nIGJhY2sgdG8gdGhlIFJFU1Qgc2VydmVyLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhY2hlIHNlYXJjaCByZXN1bHQgb25cbiAgICAgKiB0aGUgY2xpZW50IHNpdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvZmZTY3JlZW5EYXRhOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBzaXplIG9mIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGVjdGVkQ291bnQocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRm9yIHVzZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvIHJldHJpZXZlIGRhdGEgYmFzZWQgb24gc29tZSBjcml0ZXJpYSBlLmcuXG4gICAgICpcbiAgICAgKiAgLSBtYXggbnVtYmVyIG9mIHJlY29yZHNcbiAgICAgKiAgLSBzdXBwb3J0IHBhZ2luZyB3aXRoIG9mZnNldCBhbmQgbGltaXRcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGJ5IGZldGNoXG4gICAgICovXG4gICAgYWJzdHJhY3QgZGF0YUZvclBhcmFtcyhwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBBcnJheTxUPjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIGRhdGEgZnJvbSB1bmRlcmx5aW5nIGRhdGFQcm92aWRlci5cbiAgICAgKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciBkYXRhZm9yUGFyYW1zXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmZXRjaChwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBPYnNlcnZhYmxlPFRbXT47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgbm9uLWFzeW5jIGN1cnJlbnQgc3RhdGUgb2YgZGF0YVxuICAgICAqL1xuICAgIGRhdGEoKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGlzIERhdGFQcm92aWRlciBzdXBwb3J0cyBJTlNFUlQsIFJFTU9WRVxuICAgICAqXG4gICAgICovXG4gICAgY2FuQ1JVRCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGlzIERhdGFQcm92aWRlciBzdXBwb3J0cyBxdWVyeSBjYXBhYmlsaXR5XG4gICAgICpcbiAgICAgKi9cbiAgICBjYW5RdWVyeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgaW5zZXJ0aW9uLiBBZnRlciByZWNvcmQgaXMgaW5zZXJ0ZWQgZW1pdCBldmVudCBmb3IgZGF0YUNoYW5nZXMgdG9cbiAgICAgKiBpbmZvcm0gYWxsIHN1YnNjcmliZXJzXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgcmVjb3JkIHJlbW92YWwuIEFmdGVyIHJlY29yZCBpcyByZW1vdmVkIGVtaXQgZXZlbnQgZm9yIGRhdGFDaGFuZ2VzIHRvXG4gICAgICogaW5mb3JtIGFsbCBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZShvYmo6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gbG93IGxldmVsIHNlYXJjZyBBUEkuXG4gICAgICpcbiAgICAgKi9cbiAgICBxdWVyeShwYXJhbXM6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkXG4gICAge1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0ZpZWxkUGF0aCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5RGF0YVByb3ZpZGVyPFQ+IGV4dGVuZHMgRGF0YVByb3ZpZGVyPFQ+XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgIHZhbHVlczogQXJyYXk8VD4pXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBBcnJheTtcblxuICAgICAgICB0aGlzLm9mZlNjcmVlbkRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMudmFsdWVzKTtcbiAgICB9XG5cbiAgICBleHBlY3RlZENvdW50KHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZlNjcmVlbkRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGRhdGFGb3JQYXJhbXMocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXJhbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZTY3JlZW5EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5vZmZTY3JlZW5EYXRhO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQocGFyYW1zKSAmJiBwYXJhbXMuaGFzKCdvZmZzZXQnKSAmJiBwYXJhbXMuaGFzKCdsaW1pdCcpKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcGFyYW1zLmdldCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBsZXQgbGltaXQgPSBwYXJhbXMuZ2V0KCdsaW1pdCcpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAob2Zmc2V0ICsgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oYXMoJ29yZGVyYnknKSAmJiBwYXJhbXMuaGFzKCdzZWxlY3RvcicpKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQoZGF0YSwgcGFyYW1zLmdldCgnb3JkZXJieScpLCBwYXJhbXMuZ2V0KCdzZWxlY3RvcicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cblxuICAgIGZldGNoKHBhcmFtczogTWFwPHN0cmluZywgYW55Pik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmRhdGFGb3JQYXJhbXMocGFyYW1zKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBzb3J0aW5nIGN1cnJlbnQgZGF0YXNldCBieSBvbmUgY29sdW1uIC8ga2V5XG4gICAgICpcbiAgICAgKiBmb3Igc29ydE9yZGVyaW5nIHBsZWFzZSBzZWUgRGF0YXRhYmxlIGFuZCBpdHMgc29ydE9yZGVyaW5nRm9yTnVtYmVyKClcbiAgICAgKlxuICAgICAqICAgICAgMSAgPSBhc2NlbmRpbmdcbiAgICAgKiAgICAgIC0xID0gZGVzY2VuZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgc29ydChhcnJheVRvU29ydDogYW55W10sIGtleTogc3RyaW5nLCBzb3J0T3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGFycmF5VG9Tb3J0LnNvcnQoKGRhdGExOiBhbnksIGRhdGEyOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZTEgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMSwga2V5KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTIgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMiwga2V5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxICE9IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZTEgPT0gbnVsbCAmJiB2YWx1ZTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZTEgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUxLmxvY2FsZUNvbXBhcmUodmFsdWUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHZhbHVlMSA8IHZhbHVlMikgPyAtMSA6ICh2YWx1ZTEgPiB2YWx1ZTIpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoc29ydE9yZGVyICogcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXIsIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQXJyYXksIGlzU3RyaW5nfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QXJyYXlEYXRhUHJvdmlkZXJ9IGZyb20gJy4vYXJyYXktZGF0YS1wcm92aWRlcic7XG5cblxuLyoqXG4gKiBQcm92aWRlcyB0b3AgbGV2ZWwgYWNjZXNzb3IgY2xhc3MgaW4gb3JkZXIgdG8gbWFrZSB7QGxpbmsgRGF0YVByb3ZpZGVyfSByZXRyaWV2YWwgcHJvY2VzcyBlYXNpZXIuXG4gKiBVc2luZyB7QGxpbmsgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSB3ZSBlaXRoZXIgcmV0cmlldmUgcmVnaXN0ZXJlZCBpbnN0YW5jZSBvZiBjb25jcmV0ZVxuICogcHJvdmlkZXIgb3IgaW5zdGFudGlhdGUgb3VyIGltcGxpY2l0IHByb3ZpZGVyIGZvciBuYXRpdmUgdHlwZXMgc3VjaCBhcyBBcnJheS5cbiAqXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVByb3ZpZGVyc1xue1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZ2lzdHJ5OiBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnkpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nICBEYXRhUHJvdmlkZXIgb3IgY3JlYXRlIG5ldyBvbmUgaW4gY2FzZSBvZiBBcnJheVxuICAgICAqIE1vcmUgcm9vbSB0byByZWdpc3RlciBhbmQgaW5zdGFudGlhdGUgc29tZSBvdGhlciBpbXBsaWNpdCBQcm92aWRlcnNcbiAgICAgKi9cbiAgICBmaW5kKHRhcmdldDogYW55KTogRGF0YVByb3ZpZGVyPGFueT5cbiAgICB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlEYXRhUHJvdmlkZXIodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5iZXN0TWF0Y2hGb3JDbGFzcyh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yVHlwZSh0YXJnZXQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIG5ldyBwcm92aWRlciB3aXRoaW4gRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlcjxUPih0YXJnZXQ6IGFueSwgcHJvdmlkZXI6IERhdGFQcm92aWRlcjxUPik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih0YXJnZXQsIHByb3ZpZGVyKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0FycmF5LFxuICAgIGlzQmxhbmssXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc0pzT2JqZWN0LFxuICAgIGlzUHJlc2VudCxcbiAgICBvYmplY3RUb05hbWUsXG4gICAgb2JqZWN0VmFsdWVzLFxuICAgIHVuaW1wbGVtZW50ZWRcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuaW1wb3J0IHtPdXRsaW5lTm9kZX0gZnJvbSAnLi4vLi4vd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogUHJvdmlkZXMgYSByZWdpc3RyeSBvZiBkaWZmZXJlbnQgZGF0YSBGaW5kZXJzIHVzZWQgbW9zdGx5IGJ5IERhdGFTb3VyY2VzLiBBbGwgRmluZGVycyBhcmVcbiAqIHJlZ2lzdGVyZWQgYnkgdGhpcyBjbGFzcyBhcyB3ZSBkb24ndCBoYXZlIGFueSBuZWVkcyByaWdodCBub3cgdG8gZXhwb3NlIHRoaXMgdG8gZGV2ZWxvcGVyLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFGaW5kZXJzXG57XG5cbiAgICBwcml2YXRlIGZpbmRlcnNCeVR5cGU6IE1hcDxEYXRhRmluZGVyLCBUeXBlPERhdGFGaW5kZXI+PiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdEZpbmRlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBEYXRhRmluZGVyIGJhc2VkIG9uIHRoZSBvYmplY3QgdHlwZSBhbmQgcXVlcnlUeXBlLlxuICAgICAqL1xuICAgIGZpbmQoZm9yUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+LCBmb3JUeXBlOiBRdWVyeVR5cGUpOiBEYXRhRmluZGVyXG4gICAge1xuXG4gICAgICAgIGxldCBmaW5kZXJNYXRjaDogVHlwZTxEYXRhRmluZGVyPjtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLmZvckVhY2goKHY6IFR5cGU8RGF0YUZpbmRlcj4sIGs6IERhdGFGaW5kZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrLmFjY2VwdHMoZm9yUHJvdmlkZXIsIGZvclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyTWF0Y2ggPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGZpbmRlck1hdGNoKSkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgZmluZGVyTWF0Y2goKTtcbiAgICAgICAgICAgIGNvcHkuZm9yRGF0YShmb3JQcm92aWRlcik7XG4gICAgICAgICAgICByZXR1cm4gY29weTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgZmluZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlcjxUPihwcm90b3R5cGU6IERhdGFGaW5kZXIsIHR5cGU6IFR5cGU8RGF0YUZpbmRlcj4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmZpbmRlcnNCeVR5cGUuc2V0KHByb3RvdHlwZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0RmluZGVycygpXG4gICAge1xuICAgICAgICAvLyBjcmVhdGUgYSBwcm90b3R5cGUgZm9yIGVhY2hcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChuZXcgRnVsbFRleHRBcnJheURhdGFGaW5kZXIoKSwgRnVsbFRleHRBcnJheURhdGFGaW5kZXIpO1xuICAgICAgICB0aGlzLmZpbmRlcnNCeVR5cGUuc2V0KG5ldyBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIoKSxcbiAgICAgICAgICAgIE91dGxpbmVGdWxsVGV4dEFycmF5RGF0YUZpbmRlcik7XG5cbiAgICB9XG59XG5cbi8qKlxuICogV2UgaGF2ZSBkaWZmZXJlbnQgb3B0aW9ucyBob3cgdG8gcXVlcnkgZGF0YS4gRnVsbFRleHQgdXNlcyBhIHN0cmluZyB3aGVyZSBwcmVkaWNhdGUgaXNcbiAqIHVzaW5nIGtleTp2YWx1ZSBwYWlyIHRvIGJ1aWx0IGEgcXVlcnlcbiAqL1xuZXhwb3J0IGVudW0gUXVlcnlUeXBlXG57XG4gICAgRnVsbFRleHQsXG4gICAgRnVsbFRleHRPdXRsaW5lLFxuICAgIFByZWRpY2F0ZSxcbiAgICBGdWxsVGV4dEFuZFByZWRpY2F0ZVxufVxuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtYXRjaGluZyBjYXBhYmlsaXR5IGZvciBnaXZlbiBEYXRhUHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhRmluZGVyXG57XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTG9va3VwIGtleSB0byBhcHBseSB3aGVuIHJ1bm5pbmcgbWF0Y2guIElkZWFsbHkgeW91ciBEUyBzaG91bGQgYmUgYWJsZSB0byBzZXQgbG9va3VwS2V5XG4gICAgICogZWl0aGVyIGdsb2JhbGx5IGZvciBnaXZlbiBkYXRhUHJvdmlkZXIgb3IgbG9jYWxseSBldmVyeSB0aW1lIHlvdSBydW4gc2VhcmNoLiBUaGlzIGlzIGluXG4gICAgICogY2FzZSB5b3UgaGF2ZSBtYW55IGNob29zZXJzIGZvciB0aGUgc2FtZSB0eXBlIGFuZCB5b3Ugd2FudCB0aGVtIHRvIGhhdmUgZGlmZmVyZW50IGxvb2t1cFxuICAgICAqIGtleS5cbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXQgbG9va3VwS2V5KGtleTogc3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIGZpbmQgY29uY3JldGUgRGF0YUZpbmRlciB3ZSBuZWVkIHRvIGtub3cgdGhlIHRhcmdldCB0eXBlIGFuZCB0aGUgcXVlcnkgdHlwZVxuICAgICAqXG4gICAgICovXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0cyBhIERhdGFQcm92aWRlciBmb3IgRGF0YUZpbmRlclxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBEYXRhRmluZGVyO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBNYXRjaGluZyBtZXRob2RzIHdoaWNoIGFyZSBlaXRoZXIgYXN5bmMgb3Igc3luY1xuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgaW5zdGFudE1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogVFtdO1xuXG4gICAgYWJzdHJhY3QgaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uc0Zvck1hdGNoOiBhbnlbXSwgcXVlcnk6IGFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG51bWJlcik6IFRbXTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBRdWVyeSBjYW4gYmUgYSBzaW1wbGUgc3RyaW5nIGxpdGVyYWwgb3IgYSBtYXAgaGF2aW5nIGRpZmZlcmVudCBrZXkgdmFsdWUgcGFpciBhcyBhXG4gICAgICogZmlsdGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBtYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlciA9IC0xKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFNpbXBsZSBGdWxsVGV4dCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBpbmZpeCBzdHJpbmcgbWF0Y2hpbmcgd2hpY2ggd29ya3Mgb24gdG9wIG9mXG4gKiBBcnJheURhdGFQcm92aWRlci5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBGdWxsVGV4dEFycmF5RGF0YUZpbmRlciBleHRlbmRzIERhdGFGaW5kZXJcbntcbiAgICAvKipcbiAgICAgKiAgSWYgbGlzdCB2YWx1ZSBpcyBvYmplY3Qgc2V0IGtleVBhdGggdG8gZ2V0IHRoZSBvYmplY3QgdmFsdWVcbiAgICAgKi9cbiAgICBfa2V5UGF0aDogRmllbGRQYXRoO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBEYXRhUHJvdmlkZXIgdXNlZCB0byBhY2Nlc3MgZGF0YVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuXG4gICAgc2V0IGxvb2t1cEtleShrZXk6IHN0cmluZylcbiAgICB7XG4gICAgICAgIHRoaXMuX2tleVBhdGggPSBpc1ByZXNlbnQoa2V5KSA/IG5ldyBGaWVsZFBhdGgoa2V5KSA6IG51bGw7XG4gICAgfVxuXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZvckRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGFQcm92aWRlciAmJiBmb3JUeXBlID09PSBRdWVyeVR5cGUuRnVsbFRleHQ7XG4gICAgfVxuXG4gICAgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBGdWxsVGV4dEFycmF5RGF0YUZpbmRlclxuICAgIHtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zdGFudE1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogVFtdXG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuX3Byb3ZpZGVyKSwgJ01pc3NpbmcgRGF0YVByb3ZpZGVyJyk7XG5cbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLl9wcm92aWRlci5kYXRhRm9yUGFyYW1zKG5ldyBNYXAoKS5zZXQoJ2xpbWl0JywgbWF4KSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KGxpc3QsIHF1ZXJ5LCBtYXgpO1xuICAgIH1cblxuICAgIGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBzdHJpbmcsIG1heDogbnVtYmVyKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5fcHJvdmlkZXIpLCAnTWlzc2luZyBEYXRhUHJvdmlkZXInKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25zRm9yTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDogYW55W10gPSBbXTtcbiAgICAgICAgbGV0IHRvTG93ZXJQYXR0ZXJuID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbnNGb3JNYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBzZWxlY3Rpb25zRm9yTWF0Y2hbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzKGl0ZW0sIHRvTG93ZXJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IElmIHlvdSBkb250IHN1cHBseSBzZWFyY2ggS2V5IGFuZCB5b3Ugd2FudCBmdWxsdGV4dCBzZWFyY2ggYW5kIHlvdSB1c2UgdGhpc1xuICAgICAqIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYmUgYXdhcmUgdGhhdCBpdCBjYW4gIHBlcmZvcm0gcG9vcmx5IGFzIGl0IGlzIG5haXZlIGltcGxlbWVudGFpb25cbiAgICAgKiB0aGF0IGRvZXMgbm90IGRvIGRlZXAgY29tcGFyZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG1hdGNoZXM8VD4oaXRlbTogYW55LCBwYXR0ZXJuOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgdmFsID0gKGlzUHJlc2VudCh0aGlzLl9rZXlQYXRoKSkgPyB0aGlzLl9rZXlQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSkgOiBpdGVtO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuY2FsbChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0pzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPYmplY3RWYWx1ZShpdGVtLCBwYXR0ZXJuKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmxhbmsocGF0dGVybikgfHxcbiAgICAgICAgICAgICAgICBpc1ByZXNlbnQodmFsKSAmJiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocGF0dGVybikgPiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YodGhpcy5pbnN0YW50TWF0Y2gocXVlcnksIG1heCkpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnMoc2VsZWN0aW9ucywgcXVlcnksIG1heCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYXNPYmplY3RWYWx1ZShvYmo6IGFueSwgcGF0dGVybjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IG9iamVjdFZhbHVlcyhvYmopO1xuICAgICAgICBsZXQgcGFyZW50T2JqID0gb2JqZWN0VG9OYW1lKG9iaik7XG4gICAgICAgIGxldCBsZW5ndGgyID0gdmFsdWVzLmZpbHRlcigodmFsdWU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0pzT2JqZWN0KHZhbHVlKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocGF0dGVybikgIT09IC0xO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSnNPYmplY3QodmFsdWUpICYmIG9iamVjdFRvTmFtZSh2YWx1ZSkgIT09IHBhcmVudE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc09iamVjdFZhbHVlKHZhbHVlLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGgyID4gMDtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBFeHRlbmRzIGJhc2ljIEluZml4IGltcGxlbWVudGF0aW9uIHRvIHdvcmsgb24gdG9wIG9mIE91dGxpbmVOb2Rlcy4gSXQgZmlyc3QgY2hlY2tzIGFsbCB0aGVcbiAqIGNoaWxkcmVuIG9uIGxvd2VzdCBsZXZlbCBhbmQgbW92aW5nIHVwIHRvIHRoZSByb290IGFuZCBtYXJraW5nIG5vZGVzIHRoYXQgY2FuIGJlIHJlbW92ZWQuXG4gKlxuICogIEZvciBzaW1wbGUgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggb3BlcmF0ZXMgb24gbG9jYWwgYXJyYXkgdGhpcyBzaG91bGQgYmUgZ29vZCBlbm91Z2ggd2UgdGhpc1xuICogIGNhbiBuZXZlciBtYXRjaCB3aXRoIHJlYWwgREIgZnVsbCB0ZXh0IHNlYXJjaC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIgZXh0ZW5kcyBGdWxsVGV4dEFycmF5RGF0YUZpbmRlclxue1xuXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZvckRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGFQcm92aWRlciAmJiBmb3JUeXBlID09PSBRdWVyeVR5cGUuRnVsbFRleHRPdXRsaW5lO1xuICAgIH1cblxuXG4gICAgaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uc0Zvck1hdGNoOiBhbnlbXSwgcXVlcnk6IHN0cmluZywgbWF4OiBudW1iZXIpOiBBcnJheTxUPlxuICAgIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbnNGb3JNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9Mb3dlclBhdHRlcm4gPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGxldCBzb3VyY2VUb1NlYXJjaCA9IHNlbGVjdGlvbnNGb3JNYXRjaC5zbGljZSgpO1xuICAgICAgICB0aGlzLnJvbGx1cChzb3VyY2VUb1NlYXJjaCwgdG9Mb3dlclBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFrZShzb3VyY2VUb1NlYXJjaCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdvaW5nIHRocnUgdGhlIHRyZWUgZnJvbSBib3R0b20gdXAgYW5kIG1hcmsgYWxsIHRoYXQgbWF0Y2hlcyBxdWVyeVxuICAgICAqXG4gICAgICovXG4gICAgcm9sbHVwKG5vZGVzOiBPdXRsaW5lTm9kZVtdLCBxdWVyeTogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoaXRlbTogT3V0bGluZU5vZGUpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGZyb20gYm90dG9tIHVwIGFuZCBjYXB0dXJlIGhvdyBtYW55IG9jY3VycmVuY2VzIGlzIGZvdW5kIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtLmNoaWxkcmVuKSAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbk1hdGNoID0gdGhpcy5yb2xsdXAoaXRlbS5jaGlsZHJlbiwgcXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS52aXNpYmxlID0gaGFzQ2hpbGRyZW5NYXRjaCB8fCB0aGlzLm1hdGNoZXMoaXRlbSwgcXVlcnkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9kZXMuc29tZSgoaXRlbTogT3V0bGluZU5vZGUpID0+IGl0ZW0udmlzaWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG91dCBhbGwgdGhlIG5vZGVzIHRoYXQgYXJlIG1hcmtlZCBhcyB2aXNpYmxlID0gZmFsc2UgYW5kIG1ha2Ugc3VyZSBhbmRcbiAgICAgKiBkb24ndCBtb2RpZnkgb3JpZ2luYWwgbGlzdFxuICAgICAqXG4gICAgICovXG4gICAgc2hha2Uobm9kZXM6IE91dGxpbmVOb2RlW10pOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzXG4gICAgICAgICAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS52aXNpYmxlKVxuICAgICAgICAgICAgLm1hcChub2RlID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpc0V4cGFuZGVkOiBub2RlLnZpc2libGUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4gJiYgdGhpcy5zaGFrZShub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtJbmplY3Rpb25Ub2tlbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3VuaW1wbGVtZW50ZWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcblxuXG5leHBvcnQgY29uc3QgREFUQV9TT1VSQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48RGF0YVNvdXJjZT4oJ0RBVEFfU09VUkNFJyk7XG5cbi8qKlxuICogRGF0YVNvdXJjZSBkZXNjcmliZXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgaGFuZGxpbmcgc3RyZWFtIG9mIGRhdGEgc3BlY2lmaWMgdG8gY29tcG9uZW50XG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBEYXRhU291cmNlIHdpbGwgYmUgZGVmaW5lZCBhcyBjb21wb25lbnQgcHJvdmlkZXIgdXNpbmdcbiAqXG4gKiBAQ29tcG9uZW50cyAoe1xuICogICAgICAuLi5cbiAqICAgICAgcHJvdmlkZXJzOltcbiAqXG4gKiAgICAgICAgICBwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IENob29zZXJEYXRhU291cmNlUGxhaW5BcnJheUV4YW1wbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdXG4gKiAgICAgIF1cbiAqXG4gKiB9KVxuICpcbiAqXG4gKiBzbyBhbGwgdGhlIGRlcGVuZGVuY2llcyAoRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnMpIGFyZSBwcm9wZXJseSBpbmplY3RlZC5cbiAqXG4gKiBEYXRhUHJvdmlkZXIgdXNlcyBvcGVuKCkgbWV0aG9kIHRvIGJyb2FkY2FzdCBjaGFuZ2VzIHRvIGFsbCB0aGUgc3Vic2NyaWJlcnMgaW4gcmVhY3RpdmUgd2F5LlxuICogT3IgeW91IGNhbiB1c2UgaW5zdGFudCgpIG1ldGhvZCB0byByZXRyaWV2ZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgRGF0YVNvdXJjZSAoc3luYylcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhU291cmNlXG57XG4gICAgc3RhdGljIHJlYWRvbmx5IE1heExlbmd0aCA9IDEwO1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhSZWNlbnRTZWxlY3RlZCA9IDU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEVhY2ggRGF0YVNvdXJjZSBoYXZlIGluamVjdGVkIERhdGFQcm92aWRlcnMgYW5kIERhdGFGaW5kZXJzIHRvIHJldHJpZXZlIGNvbmNyZXRlXG4gICAgICogaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkYXRhUHJvdmlkZXJzPzogRGF0YVByb3ZpZGVycywgcHJvdGVjdGVkIGZpbmRlcnM/OiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gaW5pdGlhbGl6ZSBkYXRhIHNvdXJjZSBhbmQgcGFzcyBzb21lIGFkZGl0aW9uYWwgdmFsdWVzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRGF0YVByb3ZpZGVycyB3b3JrcyB3aXRoIHN0cmVhbSBvZiBkYXRhIGFuZCB0aGlzIG9wZW5zIHVwIHRoZSBjaGFubmVsIGluIG9yZGVyIHRvXG4gICAgICogbGlzdGVuIGFuZCByZWFjdCBmb3IgYW55IGNoYW5nZXMgdGhhdCBjb3VsZCBoYXBwZW4gaW5zaWRlIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGFic3RyYWN0IG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHN1YnNjcmlwdGlvbiB0byBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBjbG9zZSgpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGF0YSBpbnN0YW50bHkgZnJvbSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgaW5zdGFudDxUPigpOiBUW11cbiAgICB7XG5cbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERTSW5pdFBhcmFtc1xue1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdmFsdWVzIG9yIHRoZSBvYmplY3QgdHlwZSBuYW1lIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgb2JqPzogYW55O1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggZmluZCB3ZSB3YW50IHRvIGxvYWQgRnVsbFRleHQgb3IgUHJlZGljYXRlXG4gICAgICovXG4gICAgcXVlcnlUeXBlOiBRdWVyeVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gc3BlY2lmeSBsb29rdXAgS2V5IHRvIG5hcnJvdyBkb3duIHRoZSBzZWFyY2ggdG8gc3BlY2lmaWMgZmllbGQuIElmIGxvb2t1cCBrZXkgaXNcbiAgICAgKiBudWxsLCBpdGVtcyBhcmUgYXNzdW1lZCB0byBiZSBzdHJpbmdzXG4gICAgICovXG4gICAgbG9va3VwS2V5Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIENob29zZXIgaXMgc2luZ2xlIG9yIG11bHRpIHNlbGVjdFxuICAgICAqL1xuICAgIG11bHRpc2VsZWN0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFQcm92aWRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YVByb3ZpZGVycyB0byBmaW5kIG1hdGNoXG4gICAgICovXG4gICAgZGF0YVByb3ZpZGVyPzogRGF0YVByb3ZpZGVyPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gRGF0YUZpbmRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YUZpbmRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFGaW5kZXI/OiBEYXRhRmluZGVyO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmd9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFdlIGFyZSB1c2luZyB0aGVzZSBjb21wb25lbnRzIGFzIGEgYmV0dGVyIHdheSBzZWxlY3RvcnMuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXRvcCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBUb3Bab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktZy1ub3BhZCAnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbGVmdCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBMZWZ0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbWlkZGxlJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIE1pZGRsZVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1tZC02IHVpLWxnLTQgdWktZy1ub3BhZCc7XG59XG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJpZ2h0JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIFJpZ2h0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xuXG59XG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ib3R0b20nLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQm90dG9tWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FzeW5jVmFsaWRhdG9yRm4sIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyLCBTdHJpbmdXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Rm9ybVRhYmxlQ29tcG9uZW50fSBmcm9tICcuLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50LCBXaWRnZXRTaXplQ29sdW1uc30gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuLyoqXG4gKiBVc2VkIGJ5IEZvcm1UYWJsZSB0byBsYXlvdXQgZmllbGRzIGludG8gUm93cy4gRWFjaCBGb3JtVGFibGUgcm93IGlzIHJlYXNvbmFibGUgZm9yIG5vdCBvbmx5IHRvXG4gKiBpbmNsdWRlIGFjdHVhbCBjb21wb25lbnQgc3VjaCBpcyBEcm9wRG93biBvciBJbnB1dEZpZWxkIGJ1dCBtYWlubHkgcHJvdmlkZXMgYSBlbm91Z2ggY29udGV4dCBmb3JcbiAqIHRoZSBjb21wb25lbnQgdG8gc3BlY2lmeSB0aGUgc2l6ZSwgaG93IGl0IHNob3VsZCBsYXlvdXQsIHdoZXRoZXIgd2UgbmVlZCB0byBzaG93IHJlcXVpcmVkIGZsYWcsXG4gKiB0byBzaG93L2hpZGUgbGFiZWxzIGluIGNhc2UgaWYgd2UgaGF2ZSBubyBsYWJlbCBsYXlvdXQgYW5kIG11Y2ggbW9yZS5cbiAqXG4gKiBGb3JtUm93IGNvbXBvbmVudCBhbHNvIHJlZ2lzdGVycyBhbmd1bGFyIHZhbGlkYXRvciBmb3IgdGhlIGN1cnJlbnQgcm93L2ZpZWxkLiBBcyBhbHJlYWR5XG4gKiBtZW50aW9uZWQgV2UgdHJlYXQgb3VyIHdpZGdldHMgd2l0aCBtaW5pbWFsIHJlc3BvbnNpYmlsaXR5IGFzIHBvc3NpYmxlIHRvIHByZXNlbnQgYW5kIHJldHJpdmVcbiAqIGluZm9ybWF0aW9uIHRvL2Zyb20gdXNlciBhbmQgbGV0IHNvbWVib2R5IGVsc2UgdG8gZmlndXJlIG91dCB3aGVyZSBpdCBhcHBlYXIgYW5kIGhvdy5cbiAqXG4gKiB0b2RvOiBNb3ZlIHVuZGVyIEZvcm1UYWJsZVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWZvcm0tcm93JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCIhaGlkZGVuXCJcbiAgICAgY2xhc3M9XCJ3LWZvcm0tcm93IHVpLWdcIlxuICAgICBbY2xhc3MuaGlnaGxpZ2h0LXJvd109XCJoaWdobGlnaHRSb3dcIlxuICAgICBbY2xhc3MucmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICBbY2xhc3MubGFiZWwtb24tdG9wXT1cImxhYmVsc09uVG9wXCJcbiAgICAgW2NsYXNzLmxhYmVsLW9uLXNpZGVdPVwiIWxhYmVsc09uVG9wXCJcbiAgICAgW2NsYXNzLmhhcy1kYW5nZXJdPVwiIWZvcm1Db250cm9sLnZhbGlkICYmICFmb3JtQ29udHJvbC5wcmlzdGluZSBcIlxuICAgICBbbmdDbGFzc109XCJzdHlsZUNsYXNzXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1sYWJlbCB1aS1nLTEyIHVpLWctbm9wYWRcIlxuICAgICAgICAgKm5nSWY9XCIhbm9MYWJlbExheW91dFwiXG4gICAgICAgICBbY2xhc3MudWktbWQtM109XCIhbGFiZWxzT25Ub3BcIj5cbiAgICAgICAgPGxhYmVsIFtjbGFzcy5zci1vbmx5XT1cIm5vTGFiZWxMYXlvdXRcIj57e2xhYmVsfX08L2xhYmVsPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtdmFsdWUgdWktZy1ub3BhZFwiIFtuZ0NsYXNzXT1cInNpemVcIlxuICAgICAgICAgW2NsYXNzLnJlYWQtb25seV09XCIhZWRpdGFibGVcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8YS1lcnJvci1tZXNzYWdlcyBbY29udHJvbF09XCJmb3JtQ29udHJvbFwiPjwvYS1lcnJvci1tZXNzYWdlcz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnJlcXVpcmVkIGxhYmVsOmFmdGVye2NvbnRlbnQ6XCIqXCI7Y29sb3I6cmVkfS9kZWVwLyAuaGlnaGxpZ2h0LXJvd3tiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y4ZmF9LnctZm9ybS1yb3cuaGlnaGxpZ2h0LXJvd3tiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y4ZmF9LnctZm9ybS1yb3cubGFiZWwtb24tdG9we3BhZGRpbmctYm90dG9tOjEzcHh9LnctZm9ybS1yb3cubGFiZWwtb24tdG9wIC5jb250cm9sLWxhYmVsLC53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC12YWx1ZXtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjB9LnctZm9ybS1yb3cubGFiZWwtb24tdG9wIC5jb250cm9sLWxhYmVse3BhZGRpbmctYm90dG9tOjEycHh9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVle3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIDo6bmctZGVlcCAudy1zdHJpbmctZmllbGQsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZSA6Om5nLWRlZXAgLnctc3RyaW5nLWZpZWxke2xpbmUtaGVpZ2h0OjM2cHh9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCA6Om5nLWRlZXAgLnNhcC1pY29uLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgOjpuZy1kZWVwIC5zYXAtaWNvbntsaW5lLWhlaWdodDoyNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgbGFiZWwsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZSBsYWJlbHtsaW5lLWhlaWdodDozNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgLmZhLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgLmZhe2xpbmUtaGVpZ2h0OjE4cHh9LmNvbnRyb2wtbGFiZWx7Y29sb3I6IzYzNjM2M30udS12YWxpZGF0aW9uLWVycm9ye2JvcmRlci1jb2xvcjpyZWR9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtUm93Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vTGFiZWxMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgcm93IHdpdGggaGlnaGxpZ2h0ZWQgYmFja2dyb3VuZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWdobGlnaHRSb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEZpZWxkIGxhYmVsIHRoYXQgc2hvdWxkIGFwcGVhciBhYm92ZSBvciBuZXh0IHRvIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtYXhpbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogIEZvciBpbnB1dHMgdHlwZSBmaWVsZHMgcHJvdmlkZXMgZGVmYXVsdCBhbmd1bGFyIHZhbGlkYXRvcnMsIG1pbmltYWwgbGVuZ3RoIG9mIHRoZSBmaWVsZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciBmb3JtYXR0ZXJzLiBIb3cgdGhlIGlucHV0IGZpZWxkcyBzaG91bGQgYmVcbiAgICAgKiBmb3JtYXR0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXN0b20gYXN5bmMgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21Bc3luY1ZhbGlkYXRvcnM6IEFzeW5jVmFsaWRhdG9yRm5bXTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tICB2YWxpZGF0b3JzIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIENvbnRyb2xcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1c3RvbVZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGlzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGZpZWxkLiBDdXJyZW50IHdlIHN1cHBvcnQgNCBkaWZmZXJlbnQgc2l6ZXM6IHgtc21hbGwsIHNtYWxsLFxuICAgICAqIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zaXplOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvciBzaW5nbGUgY29sdW1uIGxheW91dCB3aXRob3V0IHpvbmVzIHdlIG5lZWQgdG8gYXBwbHkgZ3JpZCBkaXJlY3RseSB0byB0aGUgRm9ybVJvdyB0YWdcbiAgICAgKiBzbyB3ZSBkb24ndCBuZWVkIHRvIGludHJvZHVjZSBleHRyYSBkaXYgbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICcnO1xuXG5cbiAgICBwcml2YXRlIF9sYWJlbHNPblRvcDogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIC8vIEV2ZW50IHRoaXMgY3JlYXRlcyBDSSBkZXBlbmRzLiBOZWVkIHRvIGhhdmUgYSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gSSBuZWVkIHRvIHJlZmFjdG9yIG1vcmUgcGFyZW50IHRvIG5vdCB1c2UgdGhpcyBjaGlsZCBhbmQgcmVmYWN0b3IgbGF5b3V0aW5nXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1UYWJsZUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogRm9ybVRhYmxlQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIFdpZGdldFNpemVDb2x1bW5zLm1lZGl1bTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IG5vdyB3ZSBqdXN0IGluaXRpYWxpemUgdGhpcyBvbmNlIGFuZCB1c2UgdGhlIHZhbHVlcyB3ZSBkbyBub3QgZXhwZWN0IG5vdyB0byByZWFjdCB0b1xuICAgICAqIGNoYW5nZXNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbChudWxsKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFsaWRhdG9ycygpO1xuXG4gICAgICAgIHRoaXMub21pdFBhZGRpbmcgPSB0aGlzLnBhcmVudENvbnRhaW5lci5vbWl0UGFkZGluZztcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgKz0gaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSA/ICcgdWktZy0xMiAnIDogJyc7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5oaWdobGlnaHRSb3cgPyB0aGlzLmNsYXNzTGlzdCArICcgaGlnaGxpZ2h0LXJvdyAnIDogdGhpcy5jbGFzc0xpc3Q7XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgPSB0aGlzLm9taXRQYWRkaW5nID8gdGhpcy5jbGFzc0xpc3QgKyAnIHVpLWctbm9wYWQgJyA6IHRoaXMuY2xhc3NMaXN0O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSnVzdCBhIHNpemUgZ2V0dGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQSBzaXplIHNldHRlciB3ZSB0cmFuc2xhdGUgY3VzdG9tIHNpemVzIGludG8gYWN0dWFsIGJvb3RzdHJhcCBncmlkIHN5c3RlbS4gV2UgdXNlIG1lZGl1bVxuICAgICAqIHJpZ2h0IG5vdy4gYnV0IHdlIHNob3VsZCBleHRlbmQgdGhpcyBmb3Igb3RoZXIgc2NyZWVuIHNpemVzXG4gICAgICpcbiAgICAgKiAgdG9kbzogcHJvdmlkZSBtYXBwaW5nIGFuZCBhZGQgb3RoZXIgZ3JpZCBjbGFzc2VzIGZvciBvdGhlciBzaXplcyB4cywgc20sIGxnLCB4bFxuICAgICAqXG4gICAgICogIEFsc28gY2hlY2sgaWYgdGhpcyBpcyBkeW5hbWljIHNpemUgdGhhdCBzaG91bGQgdmFyeSBiYXNlZCBvbiB0aGUgaG93IG1hbnkgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiB3ZSBoYXZlLiBlLmcuIERhdGUgd2lkZ2V0cyBpcyBieSBkZWZhdWx0IHNtYWxsLCBidXQgaW4gMiwgMyBjb2x1bW5zIGxheW91dCB0aGlzIHNtYWxsIGlzIHRvb1xuICAgICAqIHNtYWxsLlxuICAgICAqL1xuXG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNpemUodmFsdWU6IHN0cmluZykge1xuXG4gICAgICAgIGxldCBpc0R5blZhbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLnN0YXJ0c1dpZHRoKHZhbHVlLCAnZC0nKSkge1xuICAgICAgICAgICAgaXNEeW5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMiwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IGRTaXplID0gdGhpcy5keW5TaXplKHZhbHVlLCBpc0R5blZhbCk7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpICYmIHRoaXMuZWRpdGFibGUgIT09IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRhYmxlID0gdGhpcy5wYXJlbnRDb250YWluZXIuZWRpdGFibGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBvZiBib3ggYW5ndWxhciB2YWxpZGF0b3IgYXMgd2VsbCBhcyBjdXN0b20gb25lIHRvIGN1cnJlbnQgRm9ybUNvbnRyb2xcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdGVyVmFsaWRhdG9ycygpIHtcbiAgICAgICAgbGV0IHZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW10gPSBbXTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWF4TGVuZ3RoKHRoaXMubWF4TGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWluTGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWluTGVuZ3RoKHRoaXMubWluTGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucmVxdWlyZWQpICYmIHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMucGF0dGVybih0aGlzLnBhdHRlcm4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tVmFsaWRhdG9ycykpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCh2YWxpZGF0b3JzLCB0aGlzLmN1c3RvbVZhbGlkYXRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnModmFsaWRhdG9yc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWRhdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycykgJiYgdGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEbyB3ZSBoYXZlIGxhYmVscyBvbiBUT1AsIHRyeSB0byByZWFkIHRoaXMgZnJvbSBQYXJlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBsYWJlbHNPblRvcCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fbGFiZWxzT25Ub3ApICYmIGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoPEZvcm1UYWJsZUNvbXBvbmVudD50aGlzLnBhcmVudENvbnRhaW5lcikuaXNMYWJlbHNPblRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FuIHJlZmFjdG9yIGFsbCBpbnRvIDEgbGluZSBidXQgaXRzIGhhcmQgdG8gZGVidWcgc28gdGhpcyBpcyBqdXN0IGZvciByZWFkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGR5blNpemUodmFsdWU6IHN0cmluZywgaXNEeW5WYWx1ZTogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgICAgIGxldCBub3JtYWxpemVTaXplID0gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCctJywgJycpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpICYmXG4gICAgICAgICAgICAoPEZvcm1UYWJsZUNvbXBvbmVudD50aGlzLnBhcmVudENvbnRhaW5lcikuaGFzVHdvQ29sdW1uICYmIGlzRHluVmFsdWUpIHtcblxuICAgICAgICAgICAgbGV0IGVudW1WYWx1ZXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMoV2lkZ2V0U2l6ZUNvbHVtbnMpO1xuICAgICAgICAgICAgbm9ybWFsaXplU2l6ZSA9IGVudW1WYWx1ZXNbZW51bVZhbHVlcy5pbmRleE9mKG5vcm1hbGl6ZVNpemUpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8YW55PldpZGdldFNpemVDb2x1bW5zKVtub3JtYWxpemVTaXplXTtcblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1xuICAgIEJvdHRvbVpvbmVDb21wb25lbnQsXG4gICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgVG9wWm9uZUNvbXBvbmVudFxufSBmcm9tICcuLi9maXZlLXpvbmUtbGF5b3V0LmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4vZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBGb3JtVGFibGUgaXMgYSBzcGVjaWZpYyBsYXlvdXQgY29tcG9uZW50IGZvciByZW5kZXJpbmcgTGFiZWxzIGFuZCBpdHMgY29udHJvbHMgaW4gdHdvIGNvbHVtbnNcbiAqIGFuZCA1IGRpZmZlcmVudCB6b25lcy5cbiAqXG4gKiBXZSBzdXBwb3J0IExFRlQsIE1JRERMRSwgUklHSFQsIFRPUCwgQk9UVE9NIHpvbmUgd2hlcmUgd2UgY2FuIHBsYWNlIG91ciBjb21wb25lbnQgb3Igd2lkZ2V0cy5cbiAqIFRoaXNcbiAqIGNvbXBvbmVudCBpcyB1c2VkIGFzIHByaW1hcnkgbGF5b3V0IHRvIHdyYXAgYWxsIHRoZSBjb21tb24gdXNlIGNhc2VzLiBFLmcuIFdoZW4gd2UgbGF5IG91dFxuICogZmllbGRzIGluIHRoZSBmb3JtIEkgZG8gbm90IHdhbnQgY29udHJvbHMgdG8gYmUgYXdhcmUgb2YgZXJyb3IgdmFsaWRhdGlvbiwgc2l6ZSwgbGFiZWxzLCBhbmRcbiAqIHNvbWUgb3RoZXIgdGhpbmdzLiBDb250cm9sIHN1Y2ggSU5QVVQgaXMganVzdCByZXNwb25zaWJsZSBmb3IgcmV0cmlldmUgdXNlciB2YWx1ZSBidXQgbm90IGhvdyBpdFxuICogYXBwZWFyIG9uIHRoZSBwYWdlLlxuICpcbiAqIFRoaXMgd2F5IHdlIGNhbiBiZSBmbGV4aWJsZSBob3cgd2UgdHJlYXQgd2lkZ2V0cyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIHNpdHVhdGlvbiBkZXBlbmRpbmdcbiAqIHdoZXJlIHRoZXkgYXBwZWFyXG5cbiAqIEZvcm1UYWJsZSBqdXN0IGxpa2UgdGhlIHJlc3Qgb2YgdGhlIGNvbXBvbmVudHMgYXJlIHVzaW5nIE1vZGVsIGRyaXZlbiBhcHByb2FjaCBob3cgdG8gd29yayB3aXRoXG4gKiBkYXRhLCBtZWFuIHdlIGFyZSB1c2luZyBGb3JtR3JvdXAsIEZvcm1Db250cm9sIGV0Yy4gRm9ybUdyb3VwIGNhbiBiZSBwYXNzZWQgaW50byB0aGUgRm9ybVRhYmxlLFxuICogb3RoZXJ3aXNlIGl0cyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgd2hlbiB0aGUgRm9ybVRhYmxlIGlzIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBGb3JtR3JvdXAgaXMgc2F2ZWQgaW5zb2RlIEVudmlyb25tZW50IHdoZXJlIHdlIGFyZSB1c2luZyB0aGlzIHRvIHBhc3MgdGhpcyBhcm91bmQgdGhlIHBhZ2VzIGFuZFxuICogY29tcG9uZW50cy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFNpbXBsZSBMYXlvdXQgZmllbGRzIGFuZCBpdHMgY29udHJvbFxuICpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnd3JhcHBlci1jb21wJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgXG4gKiAgXHRcdFx0PGF3LWZvcm0tdGFibGUgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiAob25TdWJtaXQpPT5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ25hbWUnXCIgW25hbWVdPVwiJ25hbWUnXCI+XG4gKiAgXHRcdFx0XHRcdDxhdy1pbnB1dC1maWVsZCBbdHlwZV09XCInc3RyaW5nJ1wiPjwvYXctaW5wdXQtZmllbGQ+XG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICpcbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1ByZWZlcnJlZCBDb2xvcnMnXCIgW25hbWVdPVwiJ215Q29sb3JzJ1wiPlxuICogIFx0XHRcdFx0XHQ8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIlxuICogIFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICBbbGF5b3V0XT1cIidpbmxpbmUnXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrKCRldmVudClcIj5cbiAqICBcdFx0XHRcdFx0PC9hdy1jaGVja2JveC1saXN0PlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0dlbmRlcidcIiBbbmFtZV09XCInZ2VuZGVyJ1wiPlxuICpcbiAqICBcdFx0XHRcdFx0PGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJWYWx1ZXNcIiBbc2VsZWN0aW9uXT1cInJiU2VsZWN0aW9uXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gKlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ015IGJpcnRoZGF0ZSdcIiBbbmFtZV09XCInYmlydGhEYXRlJ1wiIFtzaXplXT1cIidzbWFsbCdcIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIj5cbiAqICBcdFx0XHRcdFx0PC9hdy1kYXRlLXRpbWU+XG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICogIFx0XHRcdDwvYXctZm9ybS10YWJsZT5cbiAqICAgIGBcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBTaG93VXNlckluZm9Db21wb25lbnRcbiAqICB7XG4gKiAgICAgICBjaGVja0JveExpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdyZWQnICwgJ3llbGxvdycgLCAnb3JhbmdlJyAsICd3aGl0ZScgLCAnc2lsdmVyJ1xuICogICAgICwgJ2JsYWNrJyAsICdHcmVlbidcbiAqICAgICAsICdHcmF5JyAsICdOYXZ5JyAsXG4gKiAgICAgICAgICAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICogICAgICBzZWxlY3RlZFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqICAgICAgcmJWYWx1ZXM6IHN0cmluZ1tdID0gWydtYWxlJyAsICdmZW1hbGUnICwgJ290aGVyJ107XG4gKiAgICAgIHJiU2VsZWN0aW9uOiBzdHJpbmcgPSAnbWFsZSc7XG4gKiAgICAgIGVkaXRhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAqICAgICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICpcbiAqICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICBvbkNCQ2xpY2sgKGV2ZW50KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgfVxuICpcbiAqICAgICAgb25TdWJtaXQgKG1vZGVsOiBhbnkpOiB2b2lkXG4gKiAgICAgIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cobW9kZWwpXG4gKlxuICogICAgICAgICAvLyB3aWxsIHByaW50IHsgbmFtZTpudWxsLCBteUNvbG9yczpbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXSwgZ2VuZGVyOlxuICogICAgIG1hbGV9XG4gKiAgICAgIH1cbiAqXG4gKiAgfVxuICpcbiAqICBgYGBcbiAqXG4gKiAgT3IgeW91IGNhbiB1c2Ugem9uZSB0byBsYXlvdXQgdGhlc2UgZmllbGRzIGludG8gdHdvIGNvbHVtbnM6XG4gKlxuICogIEN1cnJlbnQgem9uZXMgYXJlIGltcGxlbWVudCB3aXRoIDxuZy1jb250ZW50IFNFTEVDVD4gd2hpY2ggaXMganVzdCBhIHNlbGVjdG9yIHRvIHNlYXJjaGVzIGZvclxuICogICAgIHNwZWNpZmljIHBhdHRlcm4uIEluIG91ciBjYXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgZXh0cmEgd3JhcHBlciBjdXN0b20gY29tcG9uZW50IHVzZSBzaW1wbGVcbiAqICAgICBDU1MgY2xhc3NcbiAqXG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctZm9ybS10YWJsZSAjbWV0YUZvcm1UYWJsZSBbZWRpdGFibGVdPVwiZWRpdGluZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgW3VzZUZpdmVab25lXT1cImlzRml2ZVpvbmVMYXlvdXRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvblN1Ym1pdCk9XCJvblNhdmVBY3Rpb24oJGV2ZW50KVwiPlxuICpcbiAqICAgICAgICAgICAgICAgIDxhdy1sZWZ0ICAqbmdJZj1cImNhblNob3dab25lKCd6TGVmdCcpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIiduYW1lJ1wiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWlucHV0LWZpZWxkIFt0eXBlXT1cIidzdHJpbmcnXCI+PC9hdy1pbnB1dC1maWVsZD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1ByZWZlcnJlZCBDb2xvcnMnXCIgW25hbWVdPVwiJ215Q29sb3JzJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbnNdPVwic2VsZWN0ZWRWYWx1ZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbGF5b3V0XT1cIidpbmxpbmUnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGljaygkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWNoZWNrYm94LWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICA8L2F3LWxlZnQ+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgIDxhdy1yaWdodCAgKm5nSWY9XCJjYW5TaG93Wm9uZSgnelJpZ2h0JylcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInR2VuZGVyJ1wiIFtuYW1lXT1cIidnZW5kZXInXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJWYWx1ZXNcIiBbc2VsZWN0aW9uXT1cInJiU2VsZWN0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInTXkgYmlydGhkYXRlJ1wiIFtuYW1lXT1cIidiaXJ0aERhdGUnXCJcbiAqICAgICBbc2l6ZV09XCInc21hbGwnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAqICAgICBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGF0ZS10aW1lPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgPC88YXctcmlnaHQ+XG4gKiAgICAgICAgICAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgYGBgXG4gKlxuICogIHRvZG86IHJlbW92ZSBteSBjc3Mgc2VsZWN0b3JzIGZvciB6b25lcyBhbmQgcmVwbGFjZSBpdCB3aXRoIHJlYWwgY29tcG9uZW50IGV2ZW4ganVzdCBhIHRhZ1xuICogIHRvZG86IHdvdWxkIHdvcmsgZmlsZVxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1mb3JtLXRhYmxlJyxcbiAgICB0ZW1wbGF0ZTogYDxmb3JtIGNsYXNzPVwidy1mb3JtLXRhYmxlIHVpLWcgdWktZmx1aWRcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiXG4gICAgICBbbmdDbGFzc109XCJzdHlsZUNsYXNzXCJcbiAgICAgIChuZ1N1Ym1pdCk9XCJvblN1Ym1pdEZvcm0oZm9ybUdyb3VwLnZhbHVlKVwiIG5vdmFsaWRhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1nLW5vcGFkXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cbjwvZm9ybT5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtY29udGFpbmVyPmZvcm17bWFyZ2luLXRvcDoxZW19LnctZm9ybS10YWJsZSBidXR0b257ZmxvYXQ6cmlnaHR9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybVRhYmxlQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1UYWJsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdGhlIGZvcm0gbGF5b3V0IHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBsYWJlbHMgc3RhY2tlZCAgb3Igc2lkZSBieSBzaWRlIG5leHQgdG9cbiAgICAgKiB0aGUgY29udHJvbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbHNPblRvcD86IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyB0aGlzIGEgNCB6b25lIGxheW91dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VGaXZlWm9uZT86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZvciBjZXJ0YWluIHVzZWNhc2Ugd2UgZG9udCB3YW50IHRvIHNldCBhdXRvbWF0aWNhbGx5IHRoaXMgdG8gYWxsIGNoaWxkcmVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0YWJpbGl0eUNoZWNrOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqICBUcmlnZ2VycyB3aGVuIHRoZSA8Zm9ybT4gaXMgc3VibWl0dGVkLiBvblN1Ym1pdCB3ZSBlbWl0IHRoZSB3aG9sZSBmb3JtQ29udHJvbGxlciBvYmplY3RzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU3VibWl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyByZXByZXNlbnQgaW5kaXZpZHVhbCB6b25lcyBhbmQgd2UgdXNlIHRoZW0gdG8gYWRqdXN0IG91ciBjb2x1bW4gZ3JpZFxuICAgICAqIGxheW91dFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoTGVmdFpvbmVDb21wb25lbnQpIGxlZnRab25lOiBMZWZ0Wm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoTWlkZGxlWm9uZUNvbXBvbmVudCkgbWlkZGxlWm9uZTogTWlkZGxlWm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoUmlnaHRab25lQ29tcG9uZW50KSByaWdodFpvbmU6IFJpZ2h0Wm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoVG9wWm9uZUNvbXBvbmVudCkgdG9wWm9uZTogVG9wWm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoQm90dG9tWm9uZUNvbXBvbmVudCkgYm90dG9tWm9uZTogQm90dG9tWm9uZUNvbXBvbmVudDtcblxuXG4gICAgQENvbnRlbnRDaGlsZHJlbihCYXNlRm9ybUNvbXBvbmVudCwge2Rlc2NlbmRhbnRzOiB0cnVlfSlcbiAgICBmb3JtRmllbGRzOiBRdWVyeUxpc3Q8QmFzZUZvcm1Db21wb25lbnQ+O1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpLCB7ZGVzY2VuZGFudHM6IHRydWV9KVxuICAgIHJvd3M6IFF1ZXJ5TGlzdDxGb3JtUm93Q29tcG9uZW50PjtcblxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzIHdoZW4gaW5pdCB0aGlzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgaGFzT25lQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGFzVHdvQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGFzVGhyZWVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIG51bGwpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlc1snZWRpdGFibGUnXSkgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2VkaXRhYmxlJ10ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1snZWRpdGFibGUnXS5jdXJyZW50VmFsdWUpIHtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtRmllbGRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG9uU3VibWl0Rm9ybShldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vblN1Ym1pdC5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFyZSBsYWJlbHMgb24gdG9wXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0xhYmVsc09uVG9wKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc09uVG9wO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IGNoaWxkIGNvbXBvbmVudCB0byBpbmhlcml0IGVkaXRhYmlsaXR5XG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Zvcm1FZGl0YWJsZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0YWJsZTtcbiAgICB9XG5cblxuICAgIGFwcGx5Q29sdW1ucygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMudXNlRml2ZVpvbmUgJiYgdGhpcy5oYXNBbnlab25lcygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmVzIGRldGVjdGVkIGluIHRoZSBGb3JtVGFibGUgYnV0IHVzZUZpdmVab25lIG9wdGlvbiBpcyBmYWxzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNPbmVDb2x1bW4gPSAhaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSAmJiAhaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG4gICAgICAgIHRoaXMuaGFzVHdvQ29sdW1uID0gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpICYmIGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiZcbiAgICAgICAgICAgICFpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcblxuICAgICAgICB0aGlzLmhhc1RocmVlQ29sdW1uID0gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpICYmIGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiZcbiAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1R3b0NvbHVtbiAmJiAhdGhpcy5pc1R3b1pvbmVSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNic7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTYnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVGhyZWVDb2x1bW4gJiYgIXRoaXMuaXNUaHJlZVpvbmVSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNCc7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTQnO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGhhc0FueVpvbmVzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5sZWZ0Wm9uZSkgfHwgaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSB8fCBpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKVxuICAgICAgICAgICAgfHwgaXNQcmVzZW50KHRoaXMudG9wWm9uZSkgfHwgaXNQcmVzZW50KHRoaXMuYm90dG9tWm9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBhbHJlYWR5IGluaXRpYWxpemVkIHRoZSBjbGFzc0xpc3QuXG4gICAgICogdGhlXG4gICAgICpcbiAgICAgKiBUT0RPOiBQcm9iYWJseSBzdHJpbmcgYXJyYXkgd291bGQgYmUgZWFzaWVyXG4gICAgICovXG4gICAgaXNUd29ab25lUmVhZHkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTYnKSA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTYnKSA+IDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhlIGNsYXNzTGlzdC5cbiAgICAgKiB0aGVcbiAgICAgKlxuICAgICAqIFRPRE86IFByb2JhYmx5IHN0cmluZyBhcnJheSB3b3VsZCBiZSBlYXNpZXJcbiAgICAgKi9cbiAgICBpc1RocmVlWm9uZVJlYWR5KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy00JykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy00JykgPiAwO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBwcm9ibGVtIHNpbmNlIEFuZ3VsYXIgNC4yLCBuZ0FmdGVyQ29udGVudEluaXRcbiAgICAgICAgLy8gd2l0aG91dCB0aGlzIEkgZ2V0IGVycm9yIHRoYXQgdmFsdWUgd2FzIGNoYW5nZWQgYWZ0ZXIgdmlldyB3YXMgY2hlY2tlZFxuICAgICAgICAvLyB0b2RvOiByZWZhY3RvciAgLSBtYWlubHkgb3VyIHpvbmVzIGxlZnQsIHJpZ2h0IG1pZGRsZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDb2x1bW5zKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1GaWVsZHMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0TGF5b3V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSB1cGRhdGVGb3JtRmllbGRzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmlsaXR5Q2hlY2sgJiYgaXNQcmVzZW50KHRoaXMuZm9ybUZpZWxkcykgJiYgdGhpcy5mb3JtRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUZpZWxkcy5mb3JFYWNoKChpdGVtOiBCYXNlRm9ybUNvbXBvbmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLmVkaXRhYmxlID0gdGhpcy5lZGl0YWJsZTtcbiAgICAgICAgICAgICAgICAvLyBpdGVtLmZvcm1Hcm91cCA9IHRoaXMuZm9ybUdyb3VwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIGlmIHdlIGFyZSAyIG9yIDMgb3IgMSBjb2x1bW4gbGF5b3V0IHdlIG5lZWQgdG8gYWRqdXN0IHdpZGdldHMgd2lkdGggd2l0aGluIHRoZVxuICAgICAqIGZvcm0gcm93LlxuICAgICAqL1xuICAgIHByaXZhdGUgYWRqdXN0TGF5b3V0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yb3dzKSAmJiB0aGlzLnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVGhyZWVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaCgoaXRlbTogRm9ybVJvd0NvbXBvbmVudCkgPT4gaXRlbS5zaXplID0gJ2xhcmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0L2lucHV0dGV4dCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybVRhYmxlQ29tcG9uZW50fSBmcm9tICcuL2Zvcm0tdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBCb3R0b21ab25lQ29tcG9uZW50LFxuICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgIFRvcFpvbmVDb21wb25lbnRcbn0gZnJvbSAnLi4vZml2ZS16b25lLWxheW91dC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZvcm1UYWJsZUNvbXBvbmVudCxcbiAgICAgICAgRm9ybVJvd0NvbXBvbmVudCxcbiAgICAgICAgVG9wWm9uZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICAgICAgQm90dG9tWm9uZUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEZvcm1UYWJsZUNvbXBvbmVudCxcbiAgICAgICAgRm9ybVJvd0NvbXBvbmVudCxcbiAgICAgICAgVG9wWm9uZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICAgICAgQm90dG9tWm9uZUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFXRm9ybVRhYmxlTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnQsIFZhbHVlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEZWNpbWFsUGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlcHJlc2VudCBhIElucHV0IGZpZWxkIGFuZCBpdCBjYW4gIGFjY2VwdCBkaWZmZXJlbnQgdHlwZXMgb2YgdmFsdWVzIHN1Y2ggYXNcbiAqIHRleHQsIG51bWJlci5cbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1pbnB1dC1maWVsZCBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFt0eXBlXT1cImlucHV0VHlwZVwiPjwvYXctaW5wdXQtZmllbGQ+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIFRlc3RJbnB1dENvbXBvbmVudFxuICogIHtcbiAqICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKlxuICogICAgICAvLyBieSBkZWZhdWx0IGlucHV0IHR5cGUgaXMgdGV4dCwgeW91IGNhbiBwYXNzIHN0cmluZywgU3RyaW5nLCBvciB0ZXh0XG4gKiAgICAgIGlucHV0VHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG4gKiAgfVxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogIyMjIEV4YW1wbGUgd2hlciBpbnB1dCBmaWVsZCBpcyBpbml0aWFsaXplZCB3aXRoIG5nTW9kZWxcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnd3JhcHBlci1jb21wJyAsXG4gKiAgICAgIHRlbXBsYXRlOiAnPGF3LWlucHV0LWZpZWxkIFt2YWx1ZV09XCJpbnB1dFZhbHVlXCIgWyhuZ01vZGVsKV09XCJpbnB1dFR5cGVcIj48L2F3LWlucHV0LWZpZWxkPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBUZXN0SW5wdXRDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICpcbiAqICAgICAgLy8gYnkgZGVmYXVsdCBpbnB1dCB0eXBlIGlzIHRleHQsIHlvdSBjYW4gcGFzcyBzdHJpbmcsIFN0cmluZywgb3IgdGV4dFxuICogICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiAgTm90ZTogaWYgeW91IGFyZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgRm9ybVRhYmxlIHBsZWFzZSBwcm92aWRlIHlvdXIgb3duIEZvcm1Hcm91cFxuICpcbiAqL1xuXG5cblxuZXhwb3J0IGNvbnN0IElOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpZWxkQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWlucHV0LWZpZWxkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJlZGl0YWJsZVwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgY2xhc3M9XCJ3LWlucHV0LXdyYXBwZXJcIj5cblxuICAgIDxpbnB1dCBwSW5wdXRUZXh0XG4gICAgICAgICAgICNpbnB1dEZpZWxkVmFsdWVcbiAgICAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgICAgICAgICAgY2xhc3M9XCJ3LWlucHV0LWZpZWxkXCJcbiAgICAgICAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4gICAgICAgICAgIFtjbGFzcy5oYXMtaWNvbl09XCJpY29uXCJcbiAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e3BsYWNlSG9sZGVyfX1cIlxuICAgICAgICAgICBbY2xhc3MudS12YWxpZGF0aW9uLWVycm9yXT1cIiEoZm9ybUNvbnRyb2wudmFsaWQgfHwgKGZvcm1Db250cm9sLnByaXN0aW5lKSlcIlxuICAgICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJ7e25hbWV9fVwiXG4gICAgICAgICAgIChrZXlkb3duKT1cIm9uS2V5RG93bihpbnB1dEZpZWxkVmFsdWUpXCJcbiAgICAgICAgICAgKGJsdXIpPVwib25CbHVyKGlucHV0RmllbGRWYWx1ZSlcIlxuICAgICAgICAgICBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCI+XG4gICAgPHNwYW4gKm5nSWY9XCJpY29uXCIgY2xhc3M9XCJzYXAtaWNvblwiIFtuZ0NsYXNzXT1cImljb25cIj48L3NwYW4+XG48L2Rpdj5cblxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLnctaW5wdXQtd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZX0udy1pbnB1dC1maWVsZHtwYWRkaW5nLXJpZ2h0OjM1cHh9LnctaW5wdXQtZmllbGR+c3Bhbnt0b3A6MTNweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxNXB4fWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIElOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG5cbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpZWxkQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0RmllbGRDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIHVzZWQgdG8gc2F2ZSBhbmQgcmVhZCAgd2hlbiByZW5kZXJpbmcgYW5kIHVwZGF0aW5nIGEgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB1c2VkIHRvIGZvcm1hdCB0aGUgbnVtYmVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJlY2lzaW9uOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBCaWdEZWNpbWFsIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB2YWx1ZSBhbmQgbG9jYWxlLlxuICAgICAqIElmIHRoaXMgb2JqZWN0IGlzIHNldCwgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmlnRGVjaW1hbDogQmlnRGVjaW1hbDtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgY3VzdG9tIGljb24gdGhhdCBpcyBwbGFjZWQgaW50byB0aGUgaW5wdXQgZmllbGQuXG4gICAgICpcbiAgICAgKiBUb2RvOiBhZGQgZXh0cmEgYmluZGluZyB0aGF0IHdpbGwgYWxsb3cgZGV2ZWxvcGVyIHRvIHRlbGwgcG9zaXRpb24sIGxlZnQgcmlnaHRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGljb246IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZGVjaW1hbCBwaXBlIGlzIHVzZWQgdG8gZm9ybWF0IG91ciBudW1iZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGRlY2ltYWxQaXBlOiBEZWNpbWFsUGlwZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0dGVkIGRlY2ltYWwgdmFsdWUuIFVzZXMgYW5ndWxhciBkZWNpbWFsUGlwZSB0byBmb3JtYXQgYmFzZWQgb24gbG9jYWxlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nID0gJyc7XG4gICAgLyoqXG4gICAgICogSnVzdCB0byBjbGVhbiB1cCBzdWJzY3JpYmVyIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHByaXZhdGUgdmNoU3Vic2NyaWJlcjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgICAgICB0aGlzLmRlY2ltYWxQaXBlID0gbmV3IERlY2ltYWxQaXBlKGVudi5sb2NhbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IGZpZWxkIHR5cGUuIEN1cnJlbnRseSB3ZSBzdXBwb3J0IGVpdGhlciBOdW1iZXIgb3IgdGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgX3R5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuXG4gICAgZ2V0IHR5cGUoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIGdlbmVyYXRlZCBzZXR0ZXIgdG8gY2hlY2sgZm9yIHZhbHVlIGFuZCBub3JtYWxpemluZyBpbnRvIGV4cGVjdGVkIGVpdGhlciBudW1iZXIgb3IgdGV4dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdHlwZSh2YWx1ZTogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdHJpbmcnIHx8IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdudW1iZXInO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLmJpZ0RlY2ltYWwpO1xuXG4gICAgICAgIHRoaXMudmNoU3Vic2NyaWJlciA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh2YWwgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5iaWdEZWNpbWFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuYmlnRGVjaW1hbC5hbW91bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuU2V0VHlwZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvbktleURvd24oZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CbHVyKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYmlnRGVjaW1hbCA9IG5ldyBCaWdEZWNpbWFsKE51bWJlcihlbC52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdE51bWJlcih0aGlzLmJpZ0RlY2ltYWwuYW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmRpc3BsYXlWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwge29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIG51bWJlciBvYmplY3QgYWNjb3JkaW5nIHRvIGl0cyBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBmb3JtYXROdW1iZXIodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgYmlnRGVjaW1hbCB2YWx1ZSBmb3IgZGlzcGxheS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnByZWNpc2lvbikgJiZcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPT09ICdudW1iZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBwcmVjaXNpb24gaXMgMi4gRm9yIGV4YW1wbGUsIDEwLjIzLlxuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgZGlnaXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmNoU3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHRoaXMudmNoU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEJpZ0RlY2ltYWwgb2JqZWN0IGlzIHJlcHJlc2VudGVkIGFzIGEgdmFsdWUsIGxvY2FsZSwgYW5kIGN1cnJlbmN5Q29kZVxuICovXG5leHBvcnQgY2xhc3MgQmlnRGVjaW1hbCBpbXBsZW1lbnRzIFZhbHVlXG57XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKVxuICAgIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxlOiBTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGFzc05hbWUoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gJ0JpZ0RlY2ltYWwnO1xuICAgIH1cblxuICAgICRwcm90bygpOiBCaWdEZWNpbWFsXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoMSwgJ2VuX1VTJyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnQgKyAnLCBsb2NhbGU6ICcgKyB0aGlzLmxvY2FsZTtcbiAgICB9XG5cblxuICAgIGNsb25lKGRhdGE6IHsgYW1vdW50PzogbnVtYmVyLCBsb2NhbGU/OiBzdHJpbmcgfSA9IHt9KTogQmlnRGVjaW1hbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuYW1vdW50KSA/IGRhdGEuYW1vdW50IDogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZSk7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U3RyaW5nQ29tcG9uZW50fSBmcm9tICcuL3N0cmluZy5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTdHJpbmdGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0lucHV0RmllbGRDb21wb25lbnR9IGZyb20gJy4uL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnQsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSW5wdXRGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICpcbiAqIGJhc2ljIG5hdmlnYXRpb24gYmFyIHByb3ZpZGUgYSBtYWluIGFjdGlvbiBidXR0b25zIGZvciBpdHMgY29udGVudCAocGFnZSBsZXZlbCBidXR0b25zKS5cbiAqIFRoaXMgaXMgbm90IHRoZSBUb3AgbGV2ZWwgYXBwbGljYXRpb24gbmF2aWdhdGlvbi4gVGhpcyBjb21wb25lbnQgcHJvdmlkZXMgYnkgZGVmYXVsdCBhY3Rpb24gT0ssXG4gKiBDQU5DRUwgYW5kIHlvdSBhcmUgZnJlZSB0byBtb2RpZnkgaG93IHRoZSBPSyBvciBDQU5DRUwgd2lsbCBiZSBjYWxsIGFzIHdlbGwgYXMgc3Vic2NyaWJlIHRvIHRoZVxuICogZXZlbnQuIE9yIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBidXR0b25zIHRlbXBsYXRlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoaXMgZGVmYXVsdFxuICogb25lLlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAxOlxuICpcbiAqIEluIG9yZGVyIHRvIHVzZSBuYXZpZ2F0aW9uIGJhciBpbiBpdHMgYmFzaWMgdXNhZ2UgeW91IGNhbiBkbyBmb2xsb3dpbmc6XG4gKiB0aGlzIHdpbGwgcmVuZGVyIGJ1dHRvbnMgb24gdGhlIHRvcCBhcyB3ZWxsIGFzIG9uIHRoZSBib3R0b20gYXJvdW5kIHRoZSBjb250ZW50LlxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgICAgPGF3LWJhc2ljLW5hdmlnYXRvciBbYnJhbmRJbWddPVwiJ2ltZy9hcmliYWxvZ29iYWwucG5nJ1wiPlxuICpcbiAqICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICogICAgICAgICAgICAgICAgPGZvcm0+XG4gKiAgICAgICAgICAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT10ZXh0IHZhbHVlPVwicGV0ZXIucGFuXCI+XG4gKiAgICAgICAgICAgICAgICA8Lzxmb3JtPj5cbiAqICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctYmFzaWMtbmF2aWdhdG9yPlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgaWYgeW91IGRvIG5vdCB3YW50IGJ1dHRvbiBvbiB0aGUgdG9wIG9yIGJvdHRvbSB5b3UgY2FuIHNheSB0aGkgdXNpbmcgYmluZGluZyBzaG93VG9wIG9yXG4gKiBzaG93Qm90dG9tLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAyOlxuICogIEluIHRoaXMgZXhhbXBsZSB3ZSBhcmUgcHJvdmlkaW5nIGN1c3RvbSBidXR0b25zIGFzIHdlbGwgYXMgYnJhbmsgc2VjdGlvblxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqXG4gKiAgICAgIDxhdy1iYXNpYy1uYXZpZ2F0b3IgW2JyYW5kSW1nXT1cIidpbWcvYXJpYmFsb2dvYmFsLnBuZydcIj5cbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNidXR0b25zPlxuICogICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXYgZmxvYXQtbWQtcmlnaHQgY29sbGFwc2UgbmF2YmFyLXRvZ2dsZWFibGUteHNcIj5cbiAqICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25TYXZlQWN0aW9uKCRldmVtdClcIj5DYW5jZWw8L2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGFjdGl2ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25DYW5jZWxBY3Rpb24oJGV2ZW50KVwiPiBTYXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gKiAgICAgICAgICAgICAgICA8L3VsPlxuICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNicmFuZD5cbiAqICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYnJhbmQtdGl0bGVcIj5BcmliYTwvc3Bhbj5cbiAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gKiAgICAgICAgICAgICAgICA8Zm9ybT5cbiAqICAgICAgICAgICAgICAgICAgICBVc2VyIG5hbWU6IDxpbnB1dCB0eXBlPXRleHQgdmFsdWU9XCJwZXRlci5wYW5cIj5cbiAqICAgICAgICAgICAgICAgIDwvPGZvcm0+PlxuICogICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1iYXNpYy1uYXZpZ2F0b3I+XG4gKlxuICpcbiAqIGBgYFxuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWJhc2ljLW5hdmlnYXRvcicsXG4gICAgdGVtcGxhdGU6IGA8cC10b29sYmFyICpuZ0lmPVwic2hvd1RvcFwiIFtjbGFzc109XCIndy1iYXNpYy1uYXZpZ2F0b3InXCI+XG4gICAgPGRpdiBjbGFzcz1cInVpLXRvb2xiYXItZ3JvdXAtbGVmdFwiPlxuXG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWJyYW5kXCIgaHJlZj1cIiNcIiAqbmdJZj1cInNob3dCcmFuZFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNCcmFuZFRlbXBsYXRlKClcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cInt7YXNzZXRGb2xkZXJ9fS97e2JyYW5kSW1nfX1cIiBoZWlnaHQ9XCIzMFwiIGFsdD1cIlwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmF2LWJyYW5kLXRpdGxlXCI+QXJpYmE8L3NwYW4+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJicmFuZFRlbXBsYXRlXCIgW2l0ZW1dPVwiY29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCcmFuZFRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2E+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aS10b29sYmFyLWdyb3VwLXJpZ2h0XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQnV0dG9uVGVtcGxhdGUoKVwiPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uICpuZ0lmPVwic2hvd0NhbmNlbEJ1dHRvblwiIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiXG4gICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DYW5jZWxBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tjYW5jZWxBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiAoYWN0aW9uKT1cIm9uT0tBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tva0FjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYnV0dG9uc1RlbXBsYXRlXCIgW2l0ZW1dPVwiY29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0J1dHRvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG48L3AtdG9vbGJhcj5cblxuPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG48cC10b29sYmFyICpuZ0lmPVwic2hvd0JvdHRvbVwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLXRvb2xiYXItZ3JvdXAtcmlnaHRcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNCdXR0b25UZW1wbGF0ZSgpXCI+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gKm5nSWY9XCJzaG93Q2FuY2VsQnV0dG9uXCIgW3N0eWxlXT1cIidzZWNvbmRhcnknXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNhbmNlbEFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e2NhbmNlbEFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uIChhY3Rpb24pPVwib25PS0FjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e29rQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImJ1dHRvbnNUZW1wbGF0ZVwiIFtpdGVtXT1cImNvbnRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCdXR0b25UZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuPC9wLXRvb2xiYXI+XG5cblxuXG5gLFxuICAgIHN0eWxlczogW2BhLm5hdi1icmFuZHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bGluZS1oZWlnaHQ6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMmQzNTNjfWEubmF2LWJyYW5kOmZvY3VzLGEubmF2LWJyYW5kOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfWEubmF2LWJyYW5kIHNwYW57dmVydGljYWwtYWxpZ246bWlkZGxlfS5uYXYtYnJhbmQgaW1ne2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtwYWRkaW5nOjNweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBCYXNpY05hdmlnYXRvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgdG9wXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RvcDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgYm90dG9tXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JvdHRvbTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBicmFuZCBzZWN0aW9uIHRoYXQgaXMgb24gdGhlIGxlZnQgc2lkZSBhbmQgb25seSBpbiB0aGUgdG9wIGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JyYW5kOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBhdGggdG8gYSBpbWFnZS4gSW1hZ2VzIGFyZSBzYXZlZCBpbnNpZGUgYXNzZXRzIGZvbGRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYnJhbmRJbWc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIE9LIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2tBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBhbiBvYmplY3Qgd2hpY2ggaXMgcmVuZGVyZWQgaW5zaWRlIG5hdi1iYXIgY29udGVudC4gU29tZXRpbWVzIHRoZXJlIGFyZSBzaXR1YXRpb25cbiAgICAgKiB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21lIGluZm9ybWF0aW9uIGZyb20gdGhlIG9iamVjdCBpbnNpZGUgbmF2aWdhdGlvbiBiYXIuIFNvIHlvdSBhcmVcbiAgICAgKiBmcmVlIHRvIHBhc3MgYSBjb250ZXh0IG9iamVjdCBhbmQgdGhlbiBhY2Nlc3MgaXQgaW5zaWRlIHlvdXIgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqIGBgYEhUTUxcbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYnJhbmQgbGV0LWl0ZW0+XG4gICAgICogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJicmFuZC10aXRsZVwiPnt7aXRlbS5maXJzdE5hbWV9fTwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzaG93Q2FuY2VsQnV0dG9uOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFdmVudEVtaXR0ZXIgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB5b3UgY2xpY2sgb24gZGVmYXVsdCBPSyBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT0tBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50RW1pdHRlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjbGljayBvbiBkZWZhdWx0IENBTkNFTCBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnV0dG9ucyB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdidXR0b25zJylcbiAgICBidXR0b25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnJhbmQgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYnJhbmQnKVxuICAgIGJyYW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuXG4gICAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgYXBwQ29uZmlnOiBBcHBDb25maWcpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHRvZG86IGxvYWQgdGhpcyBmcm9tIHJlc291cmNlIGZpbGUgdXNpbmcgbmdUcmFuc2xhdGUgc2VydmljZVxuICAgICAgICB0aGlzLm9rQWN0aW9uTGFiZWwgPSAnT0snO1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbkxhYmVsID0gJ0NhbmNlbCc7XG4gICAgICAgIHRoaXMuYnJhbmRJbWcgPSAnaW1hZ2VzL2FyaWJhbG9nb2JhbC5wbmcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2hvd0NhbmNlbEJ1dHRvbikpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NhbmNlbEJ1dHRvbiA9IHRoaXMuZWRpdGFibGUgfHwgKHRoaXMub25DYW5jZWxBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9uT0tBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGJ1dHRvbnNUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0J1dHRvblRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5idXR0b25zVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYnJhbmRUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0JyYW5kVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJyYW5kVGVtcGxhdGUpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEJ1dHRvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEJ1dHRvbiBjYW4gYmUgcmVuZGVyZWQgZWl0aGVyIGFzXG4gKiBhIGJ1dHRvbiBvciBhcyBhIGxpbmsuIEl0IGNvdWxkIGJlIHN0YW5kYWxvbmUgb3IgYmUgcGFydCBvZiBhIGZvcm0uXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICA8YXctZm9ybS10YWJsZSA+XG4gKiAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidBbW91bnQnXCIgW25hbWVdPVwiJ2Ftb3VudCdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ3N1Ym1pdCdcIiBbbmFtZV09XCInYnV0dG9uJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DbGlja2VkKCRldmVudClcIiBbdmFsdWVdPVwiY29tbWFuZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInd2FybmluZydcIiA+QnV0dG9uPC9hdy1idXR0b24+XG4gKiAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQodmFsdWU6c3RyaW5nKSB7XG4gKiAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gKiAgICAgICAgICAgICAgLy8gc3VibWl0IGZvcm0uXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPGJ1dHRvblxuICAgIHBCdXR0b25cbiAgICBbYXR0ci50eXBlXT1cInR5cGVcIlxuICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgW25nQ2xhc3NdPVwiYnV0dG9uQ2xhc3NcIlxuICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgW2F0dHIudmFsdWVdPVwidmFsdWVcIlxuICAgIChjbGljayk9XCJjbGlja2VkKCRldmVudClcIj5cblxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvYnV0dG9uPlxuYCxcbiAgICBzdHlsZXM6IFtgLnVpLWJ1dHRvbi1saW5re2NvbG9yOiMzMzdhYjc7Zm9udC13ZWlnaHQ6NDAwO2JvcmRlci1yYWRpdXM6MDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS51aS1idXR0b24tbGluaywudWktYnV0dG9uLWxpbmsuYWN0aXZlLC51aS1idXR0b24tbGluazphY3RpdmUsLnVpLWJ1dHRvbi1saW5rOmZvY3VzLC51aS1idXR0b24tbGluazpob3ZlciwudWktYnV0dG9uLWxpbmtbZGlzYWJsZWRde2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudH0udWktYnV0dG9uLWxpbms6Zm9jdXMsLnVpLWJ1dHRvbi1saW5rOmhvdmVye2NvbG9yOiMzMzdhYjc7LXdlYmtpdC10ZXh0LWRlY29yYXRpb246IzMzN2FiNzt0ZXh0LWRlY29yYXRpb246IzMzN2FiNztiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS51aS1idXR0b24tbGlua1tkaXNhYmxlZF06Zm9jdXMsLnVpLWJ1dHRvbi1saW5rW2Rpc2FibGVkXTpob3Zlcntjb2xvcjojMjM5OWU1O3RleHQtZGVjb3JhdGlvbjpub25lfS51aS1idXR0b257bWFyZ2luLXJpZ2h0OjVweH0uYnRuLW1pZHtoZWlnaHQ6MzZweDtwYWRkaW5nOjVweCAxMHB4fS5idG4tbGd7aGVpZ2h0OjQycHg7Zm9udC1zaXplOjE2cHg7cGFkZGluZzo1cHggMTJweH0uYnRuLXNte2hlaWdodDozMHB4O2ZvbnQtc2l6ZToxMnB4O3BhZGRpbmc6NXB4IDEwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXRcbntcblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiB0eXBlcyAgWyBidXR0b24gfCBzdWJtaXQgfCByZXNldCBdXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZyA9ICdidXR0b24nO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBmb3IgdGhpcyBidXR0b24uIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5hbWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3R5bGluZyBmb3IgdGhpcyBidXR0b24uIFNlZSBCdXR0b25TdHlsZSBmb3IgYWxsIHN1cHBvcnRlZCBzdHlsZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZTogQnV0dG9uU3R5bGUgPSAncHJpbWFyeSc7XG5cblxuICAgIC8qKlxuICAgICAqIHNpemluZyBmb3IgdGhpcyBidXR0b24uIFtsYXJnZSwgbm9ybWFsLCBzbWFsbF0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaXplOiBCdXR0b25TaXplID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSB0YXJnZXQgb2YgdGhlIGJ1dHRvbi4gW19ibGFuayB8IF9zZWxmIHwgX3BhcmVudCB8IF90b3AgfCBmcmFtZW5hbWUgXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byBiZSBzZW5kIHRvIHNlcnZlciB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBQcmltZU5nIGJ1dHRvbiBzaW1wbHkgZG9lcyBub3Qgc3VwcG9ydCBjb250ZW50IHNvIHdlIG5lZWQgdG8gZ2V0IGFyb3VuZCBpdFxuICAgICAqL1xuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBDU1MgY2xhc3MgdGhhdCBzdHlsZXMgdGhpcyBidXR0b24gYmFzZWQgb24gaW5wdXQgJ3N0eWxlJyBhbmQgJ3NpemUnXG4gICAgICovXG4gICAgYnV0dG9uQ2xhc3M6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBidXR0b24gY2xhc3MgaXMgc2Vjb25kYXJ5LlxuICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi1zZWNvbmRhcnknO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZGlzYWJsZWRcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIEhvdyB0byBzdHlsZSB0aGlzIGJ1dHRvbi5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUgPT09ICdwcmltYXJ5Jykge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgLnVpLWJ1dHRvbiBhbmQgLnVpLWJ1dHRvbi1wcmltYXJ5IGdldCB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgICAgICAgICAvLyAudWktYnV0dG9uLXByaW1hcnkgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYnV0dG9uIHN0eWxlIGNhbiBiZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpbmNsdWRlZCBpbnNpZGUgb3RoZXIgd2lkZ2V0cy4gU28gc3BlY2lmeSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tcHJpbWFyeSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLScgKyB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBidXR0b24gY2xhc3MgYmFzZWQgb24gaW5wdXQgc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhcmdlJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tbGcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1taWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLXNtJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgbGl0dGxlIGhhY2t5IGhhY2tpdHkgaGFjayBhcyBjdXJyZW50bHkgcHJpbWVuZyBidXR0b24gZGlyZWN0aXZlIGRvZXMgbm90IHdvcmsgd2l0aFxuICAgICAqIG5nY29udGVudCBwcm9qZWN0aW9uIGJ1dCBpdCBoYXMgYSBsYWJlbCBiaW5kaW5ncywgd2hpY2ggaXMgbm90IHRoZSB3YXkgZGV2ZWxvcGVycyB3b3JrIHdpdGhcbiAgICAgKiBidXR0b24uIHlvdSB3YW50IHRvXG4gICAgICpcbiAgICAgKiA8YnV0dG9uPiBNWSBDT05URU5UPC9idXR0b24gaW5zdGVhZCBvZiA8YnV0dG9uIGxhYmVsPSdNeUNvbnRlbnQnPjwvYnV0dG9uPlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAVG9kbzogQ2hhbmdlIHRoaXMgdW50aWwgdGhlIHRpbWUga2VlcCBhIHRlc3QgdGhhdCBjaGVjayB0aGF0IHRoZXkgYXJlIHN0aWxsIHVzaW5nIHVpLWJ1dHRvblxuICAgICAqICAgICB0aGF0IHdlIGFyZSBleHBlY3RpbmcgYW5kIHJlcGxhY2luZ1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgIGxldCBidXR0b25UaXRsZSA9IGJ1dHRvbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIGJ1dHRvbi5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd1aS1idXR0b24nLCAnJykucmVwbGFjZSgndWktYnRuJywgJycpO1xuXG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgndWktYnV0dG9uLXRleHQtZW1wdHknKTtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGJ1dHRvblRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBY3Rpb24gY2xpY2tlZC4gQ2FsbCBwYXJlbnQgYWN0aW9uLlxuICAgICAqL1xuICAgIGNsaWNrZWQoJGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGlzQmxhbmsodGhpcy52YWx1ZSkgPyAkZXZlbnQgOiB0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTdXBwb3J0ZWQgQnV0dG9uIFN0eWxlXG4gKi9cbmV4cG9ydCB0eXBlIEJ1dHRvblN0eWxlID0gJ2luZm8nIHwgJ3ByaW1hcnknIHwgJ3NlY29uZGFyeScgfCAnd2FybmluZycgfCAnc3VjY2VzcycgfCAnZGFuZ2VyJyB8XG4gICAgJ2xpbmsnO1xuXG4vKipcbiAqIFN1cHBvcnRlZCBCdXR0b24gU2l6ZVxuICovXG5leHBvcnQgdHlwZSBCdXR0b25TaXplID0gJ2xhcmdlJyB8ICdub3JtYWwnIHwgJ3NtYWxsJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QnV0dG9uQ29tcG9uZW50fSBmcm9tICcuL2J1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtCdXR0b25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0J1dHRvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QmFzaWNOYXZpZ2F0b3JDb21wb25lbnR9IGZyb20gJy4vYmFzaWMtbmF2aWdhdG9yLmNvbXBvbmVudCc7XG5pbXBvcnQge1Rvb2xiYXJNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdCYXNpY05hdmlnYXRvck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC10b3BgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC16dG9wJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVUb3BDb21wb25lbnRcbntcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLWJvdHRvbWAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXpib3R0b20nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxue1xufVxuXG4vKipcbiAqXG4gKiBDYXJkIGNvbXBvbmVudCBpcyBhIGNvbnRhaW5lciByZW5kZXJpbmcgaXRzIGNvbnRlbnQgaW5zaWRlIDMgZGlmZmVyZW50IHpvbmVzLlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgVElUTEUgICAgICAgICAgICAgICAgICAgICAgIHwgQUNUSU9OIHxcbiAqICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgVE9QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgQk9UVE9NICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKlxuICogIFRoZXJlIGFyZSAzIHpvbmVzICArIDEgcGxhY2Vob2xkZXIgZm9yIHRoZSBhY3Rpb25JY29uXG4gKlxuICogIENhcmRzIGNhbiBiZSBzZWxlY3RhYmxlIHdoaWNoIG1lYW5zIHdoZW4geW91IGNsaWNrIG9uIGl0IHRoZXJlIHdpbGwgYmUgcmVuZGVyZWQgYSBib3JkZXIgd2l0aFxuICogIGEgY2hlY2sgbWFyayBpbnNpZGUgQWN0aW9uIHpvbmUgKHRoaXMgaXMgZGVmYXVsdCBiZWhhdmlvcikuXG4gKiAgWW91IGNhbiB1c2UgW3NlbGVjdGFibGVdIGJpbmRpbmcgdG8gZGlzYWJsZSB0aGlzLCBpbiBzdWNoIGNhc2UgY2FyZCB3aWxsIGhhdmUganVzdCBhIGJvcmRlclxuICogIHdpdGhvdXQgYW55IGNoZWNrIG1hcmsuXG4gKlxuICogIENhcmRzIGNhbiBhbHNvIGNvbnRhaW4gY3VzdG9tIEFjdGlvbiB3aGljaCBpcyByZW5kZXJlZCBpbnNpZGUgQUNUSU9OIHpvbmUgYW5kIG9uIHRoZVxuICogIGFwcGxpY2F0aW9uIGxldmVsIHlvdSBjYW4gbGlzdGVuIGZvciAoY2xpY2spIGV2ZW50cyBhcyB3ZWxsIGFzIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBhY3Rpb25cbiAqICBpY29uXG4gKlxuICogIEJlc2lkZXMgQUNUSU9OLCBUSVRMRSwgVE9QIGFuZCBCT1RUT00gY29udGVudCB6b25lcyBjYXJkcyBzdXBwb3J0IGhvdmVyIG92ZXJsYXkgZWZmZWN0IGFuZFxuICogIHdoZW4gaXRzIGFjdGl2YXRlZCB0aGVyZSBpcyBhIG92ZXJsYXkgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY2FyZCB3aXRoIEljb24gaW4gdGhlIG1pZGRsZS5cbiAqICBQbGVhc2Ugbm90ZSB3aGVuIFtoYXNIb3Zlcl0gaXMgVFJVRSBhbGwgdGhlIGFjdGlvbnMgYW5kIHNlbGVjdGFiaWxpdHkgYXJlIGRpc2FibGVkIGFzIHRoZXJlIGlzXG4gKiAgb25seSBvbmUgYWN0aW9uIHdoaWNoIGNsaWNrIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICpcbiAqXG4gKiAjIyNleGFtcGxlIDE6XG4gKiAgQmFzaWMgaG92ZXIgY2FyZCB3aGljaCBieSBkZWZhdWx0IHN1cHBvcnQgc2VsZWN0YWJsZSBtb2RlXG4gKlxuICogYGBgXG4gKiAgICAgICAgICA8YXctY2FyZCAjY2FyZDEgW2hhc0FjdGlvbl09XCJmYWxzZVwiIFt3aWR0aF09XCInMjAycHgnXCIgW2hlaWdodF09XCInMTU0cHgnXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICogICMjI2V4YW1wbGUgMjpcbiAqICAgSG92ZXIgY2FyZCB3aXRoIGN1c3RvbSBhY3Rpb24uIHdoZW4gdW5zZWxlY3RlZCBhY3Rpb24gd2lsbCBhcHBlYXIgYW5kIHVzZXIgY2FuIGNsaWNrIG9uIGl0LlxuICpcbiAqIGBgYFxuICogICAgICAgICAgPGF3LWNhcmQgI2NhcmQxIFtzZWxlY3RhYmxlXT1cInRydWVcIiBbYWN0aW9uSWNvbl09XCInaWNvbi1xdWVzdGlvbi1tYXJrJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChvbkFjdGlvbik9XCJvbkFjdGlvbigzLCAkZXZlbnQpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2FyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1jYXJkXCIgW3N0eWxlLndpZHRoXT1cIndpZHRoXCIgW3N0eWxlLmhlaWdodF09XCJoZWlnaHRcIlxuICAgICBbY2xhc3MudS1pcy1ob3Zlcl09XCJoYXNIb3ZlclwiXG4gICAgIChtb3VzZWVudGVyKT1cIm9uSG92ZXIodHJ1ZSlcIlxuICAgICAobW91c2VsZWF2ZSk9XCJvbkhvdmVyKGZhbHNlKVwiXG4gICAgIFtjbGFzcy51LWNhcmQtc2VsZWN0ZWRdPVwic2VsZWN0ZWRcIlxuICAgICBbY2xhc3MudS1jYXJkLXVuc2VsZWN0ZWRdPVwiIXNlbGVjdGVkXCJcbiAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5IHVpLWdcIiAgKm5nSWY9XCIhc2hvd0JvZHlUZW1wbGF0ZSgpXCI+XG4gICAgICAgIDwhLS0gSG92ZXIgZWxlbWVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBtb3VzZWVudGVyLCBtb3VzZWxlYXZlIGV2ZW50cy0tPlxuICAgICAgICA8ZGl2ICNob3ZlckRpdiAqbmdJZj1cImhhc0hvdmVyXCIgY2xhc3M9XCJ1LWNhcmQtaG92ZXJcIiAoY2xpY2spPVwib25Ib3ZlckFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgIDxzcGFuIFtzdHlsZS53aWR0aF09XCInMTAwJSdcIiBjbGFzcz1cInNhcC1pY29uXCIgW25nQ2xhc3NdPVwiaG92ZXJJY29uXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCEtLSBIRUFERVIgSEFWSU5HIFRJVExFIEFORCBJQ09OUy9BQ1RJT05TLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLWctbm9wYWQgdy1jYXJkLWhlYWRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctY2FyZC16dGl0bGUgdWktZy1ub3BhZFwiIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieyd1aS1nLTknOiBoYXNBY3Rpb24gfHwgc2VsZWN0YWJsZSwgJ3VpLWctMTEnOiAhaGFzQWN0aW9uICYmICFzZWxlY3RhYmxlfVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNhcmQtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhhc0FjdGlvbiB8fCBzZWxlY3RhYmxlXCIgY2xhc3M9XCJ3LWNhcmQtemFjdGlvbiB1aS1nLW5vcGFkIHVpLWctM1wiPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzZWxlY3RlZCAmJiBzZWxlY3RhYmxlXCIgY2xhc3M9XCJzYXAtaWNvbiBzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLWFjdGlvbi1iZ109XCJzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJzZWxlY3RlZEljb25cIj48L3NwYW4+XG5cblxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzQWN0aW9uICYmICghc2VsZWN0ZWQgfHwgIXNlbGVjdGFibGUpIFwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzYXAtaWNvbiBhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25BY3Rpb25DbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJhY3Rpb25JY29uXCJcbiAgICAgICAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwhLS1UT1AgQ0FSRCBTRUNUSU9OLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWNhcmQtenRvcCB1aS1nLW5vcGFkIHVpLWctMTIgXCJcbiAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlU2VsZWN0KCRldmVudClcIlxuICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCI+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jYXJkLXRvcFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZCB3LWNhcmQtbGluZS1kaXZpZGVyICBcIiAqbmdJZj1cInNob3dCb3R0b21TZWN0aW9uKClcIj48L2Rpdj5cbiAgICAgICAgPCEtLUJPVFRPTSBDQVJEIFNFQ1RJT04tLT5cbiAgICAgICAgPGRpdiAqbmdJZj1cInNob3dCb3R0b21TZWN0aW9uKClcIiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZCB3LWNhcmQtemJvdHRvbVwiXG4gICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInNlbGVjdGFibGVcIlxuICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY2FyZC1ib3R0b21cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiAqbmdJZj1cInNob3dCb2R5VGVtcGxhdGUoKVwiIGNsYXNzPVwidy1jYXJkLXVzZXItY250XCIgPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVRlbXBsYXRlXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWNhcmR7Ym9yZGVyOjJweCBzb2xpZCAjMDA3NmNiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtjb2xvcjojNjM2MzYzO2JveC1zaXppbmc6Ym9yZGVyLWJveH0udy1jYXJkLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzBweDtwYWRkaW5nLWxlZnQ6MWVtfS53LWNhcmQtenRpdGxle2hlaWdodDoxMDAlO3BhZGRpbmctdG9wOjNweH0udy1jYXJkLXp0aXRsZSA6Om5nLWRlZXAgLnctY2FyZC10aXRsZXtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleH0udy1jYXJkLXp0aXRsZSA6Om5nLWRlZXAgLnctY2FyZC10aXRsZT4qe2ZsZXg6MCAxfS53LWNhcmQtemFjdGlvbntoZWlnaHQ6MTAwJTtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOnJpZ2h0fS53LWNhcmQtemFjdGlvbiAuc2FwLWljb257d2lkdGg6MjlweDtoZWlnaHQ6MjlweDt0ZXh0LWFsaWduOmNlbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6MS41ZW07bGluZS1oZWlnaHQ6MS40ZW19LnctY2FyZC16YWN0aW9uIC5zYXAtaWNvbi5zZWxlY3Rpb257Y29sb3I6I2ZmZn0udy1jYXJkLXphY3Rpb24gLnNhcC1pY29uLmFjdGlvbntjb2xvcjojOTY5Njk2fS53LWNhcmQtemJvdHRvbSwudy1jYXJkLXp0b3B7cGFkZGluZzoxZW19LnctY2FyZC1saW5lLWRpdmlkZXJ7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q2ZDZkNjttYXJnaW46MCAxNHB4fS53LWNhcmQtdXNlci1jbnR7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWV9LnUtY2FyZC1ob3Zlcntwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO29wYWNpdHk6MDt0cmFuc2l0aW9uOi41cyBlYXNlO2JhY2tncm91bmQtY29sb3I6IzAwNzZjYjt6LWluZGV4OjEwMH0udS1jYXJkLWhvdmVyIC5zYXAtaWNvbnt0ZXh0LWFsaWduOmNlbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6NGVtO2NvbG9yOiNmZmY7cG9zaXRpb246cmVsYXRpdmU7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS51LWNhcmQtYWN0aW9uLWJne2JhY2tncm91bmQ6IzAwNzZjYn0udS1pcy1ob3Zlcntwb3NpdGlvbjpyZWxhdGl2ZX0udS1jYXJkLXNlbGVjdGVke2JvcmRlci1jb2xvcjojMDA3NmNifS51LWNhcmQtdW5zZWxlY3RlZHtib3JkZXItY29sb3I6I2Q3ZDdkN30udS1jYXJkLWhvdmVyLC51LWNhcmQtcG9pbnRlcntjdXJzb3I6cG9pbnRlcn1gXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHNob3VsZCBleHBsaWNpdGx5IGhpZGUgdGhlIGFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoYXNBY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgc2VsZWN0YWJsZSBtb2RlIHN1cHBvcnRlZD8gU2F5aW5nIFllcywgY2FyZCB3aWxsIGhhdmUgYnkgZGVmYXVsdCBjaGVjay1tYXJrIGluIHRoZVxuICAgICAqIEFDVElPTiB6b25lIHdoZW4gc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gXCJDYXJkIFNlbGVjdGVkXCIgSWNvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZEljb246IHN0cmluZyA9ICdpY29uLWFjY2VwdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlIGZvciBhY3Rpb24gaWNvbiwgd2hlbiBhcHBsaWNhdGlvbiB3YW50IHRvIGFkZCBhY3Rpb24gdG8gdGhlIGNhcmRcbiAgICAgKiBpdCBtdXN0IGFsc28gcHJvdmlkZSBhIGljb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uSWNvbjogc3RyaW5nO1xuXG4gICAgLypcbiAgICAgKiBFbmFibGUgYW5kIGRpc2FibGVzIGhvdmVyIGVmZmVjdCBvbiB0b3Agb2YgdGhlIGNhcmRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhhc0hvdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHQgaWNvbiBuYW1lIGZvciB0aGUgaG92ZXIgb3ZlcmxheS4gVGhpcyBpY29ucyBzaG93cyB1cCBpbiB0aGUgbWlkZGxlIG92ZXIgdGhlIGNhcmRcbiAgICAgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgY2VudGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaG92ZXJJY29uOiBzdHJpbmcgPSAnaWNvbi1hZGQnO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU2VsZWN0aW9uIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2FyZCBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYWN0aW9uIGljb24gaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Ib3ZlckFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcXVlcnkgaXMgdXNlZCB0byBzYXZlIHRoZSBjb250ZW50IHJlZmVyZW5jZSB0byBib3R0b20gc2VjdGlvbiBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENhcmRab25lQm90dG9tQ29tcG9uZW50KVxuICAgIGJvdHRvbTogQ2FyZFpvbmVCb3R0b21Db21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGN1c3RvbSB0ZW1wbGF0ZSBmb3IgdGhlIGJvZHkgd2hpY2ggaXMgdW5kZXIgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNvbnRyb2wuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAVmlld0NoaWxkKCdob3ZlckRpdicpXG4gICAgaG92ZXJEaXY6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBVc3VhbGx5IHdoZW4gdGVtcGxhdGUgaXMgcHJvdmlkZWQgd2Ugd2FudCB0byB1c2UgaXQgYW5kIHJlcGxhY2UgaW50ZXJuYWwgb25lIGJ1dCBpbiB0aGlzXG4gICAgICogY2FzZSBpdCB3aWxsIGJlIGFsd2F5cyBjb25kaXRpb25hbCBhbmQgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNhbiBzd2l0Y2ggYmV0d2VlbiBkZWZhdWx0XG4gICAgICogdGVtcGxhdGUgd2l0aCB6b25lcyBhbmQgY3VzdG9tIG9uZSBwcm92aWRlZCBieSBkZXZlbG9wZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICB1c2VCb2R5VGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHNldHMgZGVmYXVsdCB2YWx1ZVxuICAgICAgICB0aGlzLndpZHRoID0gJzIwMnB4JztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTU0cHgnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gSWYgYXBwbGljYXRpb24gd2FudHMgdG8gdXNlIGFjdGlvbiBpdCBtdXN0IHByb3ZpZGUgYWN0aW9uSWNvblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmFjdGlvbkljb24pICYmIHRoaXMuaGFzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYWN0aW9uIGljb24nKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNob3dCb3R0b21TZWN0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib3R0b20pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogZmlyZXMgc2VsZWN0IGFuZCB1bnNlbGVjdCBldmVudC5cbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3QoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT25seSBmaXJlZCB3aGVuIGFjdGlvbiBpcyByZW5kZXJlZCBhbmQgdXNlciBjbGlja3Mgb24gY3VzdG9tIGFjdGlvbkljb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQWN0aW9uQ2xpY2soZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhc0FjdGlvbiAmJiAoIXRoaXMuc2VsZWN0ZWQgfHwgIXRoaXMuc2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpb24uZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCAgd2hlbiBob3ZlciBlZmZlY3QgaXMgb24gKyB1c2VyIGNsaWNrIG9uIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhvdmVyKGlzRW50ZXI6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaG92ZXJEaXYpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyRGl2Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGlzRW50ZXIgPyAwLjUgOiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGltcGxpY2l0IGNhcmQgdGVtcGxhdGUgd2l0aCBvdXIgem9uZXMgb3JcbiAgICAgKiB1c2VyIHByb3ZpZGVkIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93Qm9keVRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib2R5VGVtcGxhdGUpICAmJiB0aGlzLnVzZUJvZHlUZW1wbGF0ZTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIE1hcHMgb3VyIGludGVybmFsIGFsaWdubWVudCB2YWx1ZSB0byByZWFsIGNzcyB2YWx1ZXNcbiAqXG4gKi9cbmNvbnN0IFZBbGlnbk1hcCA9IHtcbiAgICAndG9wLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1jZW50ZXInOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnY2VudGVyLWxlZnQnOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICdjZW50ZXItcmlnaHQnOiAnY2VudGVyJyxcbiAgICAnYm90dG9tLWxlZnQnOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLXJpZ2h0JzogJ2ZsZXgtZW5kJ1xufTtcblxuXG5jb25zdCBIQWxpZ25NYXAgPSB7XG4gICAgJ3RvcC1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICd0b3AtY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2NlbnRlci1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdjZW50ZXItY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2JvdHRvbS1yaWdodCc6ICdmbGV4LWVuZCdcbn07XG5cblxuLyoqXG4gKiBUaXRsZSB6b25lIHByb3ZpZGVzIGEgY29udGVudCBwbGFjZWhvbGRlciBmb3IgdGhlIFRpdGxlIEFyZWEuIFRoaXMgem9uZSBpcyBhZGRpbmcgYWJpbGl0eVxuICogdG8gYWxpZ24gaXRzIGNvbnRlbnQgaW50byA5IGRpZmZlcmVudCBwb3NpdGlvbi5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIFRpdGxlIHpvbmUgd2l0aGluIDxhdy1jYXJkPiBhczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8YXctY2FyZCAgW3dpZHRoXT1cIicyMDJweCdcIiBbaGVpZ2h0XT1cIicxNTRweCdcIiBbaGFzSG92ZXJdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwiZmFsc2VcIiBbaGFzQWN0aW9uXT1cImZhbHNlXCJcbiAqICAgICAgICAgICAgICAgICAgKG9uSG92ZXJBY3Rpb24pPVwib25BY3Rpb24oNywgJGV2ZW50KVwiID5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImEtc3VwcGxpZXItdGFnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgIDwvYXctY2FyZC10aXRsZT5cbiAqXG4gKiAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqIERlZmF1bHQgYWxpZ25tZW50IGlzIHRvcC1sZWZ0XG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtdGl0bGVgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC10aXRsZSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBwcm9wZXJ0eSB3aGljaCBpcyB1c2VkIHRvIGFwcGx5IGZsZXggcHJvcGVydGllcyBmb3IgYWxpZ25pbmcgY29udGVudCB2ZXJ0aWNhbGx5XG4gICAgICogYXMgd2VsbCBhcyBob3Jpem9udGFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ246IENhcmRUaXRsZUFsaWdubWVudCA9ICd0b3AtbGVmdCc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWxlbTogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9IFZBbGlnbk1hcFt0aGlzLmFsaWduXTtcbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBIQWxpZ25NYXBbdGhpcy5hbGlnbl07XG4gICAgfVxufVxuXG5cbi8qKlxuICogTWFrZSBzdXJlIHdlIGRvbnQgYWNjZXB0IGFueSB1bnN1cHBvcnRlZCB2YWx1ZXMuIFRoZXNlIHZhbHVlcyBtYXBzIHRvIHRoZSBIQWxpZ25NYXAgYW5kXG4gKiBWQWxpZ25NYXAgaW4gb3JkZXIgdG8gZ2V0IHJlYWwgY3NzIHZhbHVlIGZvciB0aGUgZmxleCBhbGlnbm1lbnRcbiAqL1xuZXhwb3J0IHR5cGUgQ2FyZFRpdGxlQWxpZ25tZW50ID0gJ3RvcC1sZWZ0JyB8ICd0b3AtY2VudGVyJyB8ICd0b3AtcmlnaHQnIHwgJ2NlbnRlci1sZWZ0JyB8XG4gICAgJ2NlbnRlci1jZW50ZXInICB8ICdjZW50ZXItcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tY2VudGVyJyB8ICdib3R0b20tcmlnaHQnO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtDYXJkQ29tcG9uZW50LCBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudCwgQ2FyZFpvbmVUb3BDb21wb25lbnR9IGZyb20gJy4vY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtDYXJkWm9uZVRpdGxlQ29tcG9uZW50fSBmcm9tICcuL2NhcmQtdGl0bGUvY2FyZC10aXRsZS5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDYXJkQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRpdGxlQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRvcENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVCb3R0b21Db21wb25lbnRcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENhcmRDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVGl0bGVDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVG9wQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NhcmRNb2R1bGVcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQm9vbGVhbiwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiAgQ2hlY2tib3hUeXBlIGRlc2NyaWJlcyB3aGF0IHR5cGUgb2YgY2hlY2tib3ggaXMgdGhpczpcbiAqXG4gKiAtIEZvcm0gdHlwZTogdGhhdCBpcyB3cml0aW5nIGFuZCByZWFkaW5nIGEgdmFsdWUgZnJvbS90byBtb2RlbCBib3RoIHVzaW5nIEZvcm1Hcm91cCBhcyB3ZWxsXG4gKiAgICAgICAgICAgICAgYXMgbmdNb2RlbFxuICogLSBBY3Rpb24gdHlwZTogIG9ubHkgZmlyZXMgYWN0aW9uIGFuZCBkb2VzIG5vdCB3cml0ZSB2YWx1ZSB0byBtb2RlbC5cbiAqXG4gKlxuICovXG5leHBvcnQgdHlwZSBDaGVja2JveFR5cGUgPSAnZm9ybScgfCAnYWN0aW9uJztcblxuLyoqXG4gKlxuICogSW1wbGVtZW50cyBzdGFuZGFyZCBIVE1MIGNoZWNrYm94IG9uIHRvcCBvZiBQcmltZU5HLiBUaGVyZSBhcmUgMiB0eXBlcyBvZlxuICoge0BsaW5rIENoZWNrYm94Q29tcG9uZW50fTogZm9ybSBhbmQgYWN0aW9uIGNoZWNrYm94IGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqXG4gKlxuICogVXNhZ2U6IEJhc2ljIGV4YW1wbGUgaGF2aW5nIHJlZCBjaGVja2JveCBjaGVja2VkXG4gKlxuICogYGBgSFRNTFxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICA8L2F3LWNoZWNrYm94PlxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgPC9hdy1jaGVja2JveD5cbiAqXG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICpcbiAqXG4gKiAgIGNsYXNzIENCQmFzaWNXaXRoTmdNb2RlbENvbXBvbmVudFxuICogICB7XG4gKlxuICogICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICB7XG4gKiAgICAgICB9XG4gKiAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcyBwbGVhc2Ugc2VlIGEgcGxheWdyb3VuZCBvciB1bml0IHRlc3QuXG4gKlxuICovXG5leHBvcnQgY29uc3QgQ0JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNoZWNrYm94JyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidy1jaGVja2JveFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlICYmIGlzRm9ybVR5cGUoKVwiPlxuICAgICAgICA8cC1jaGVja2JveCBbbmFtZV09XCJuYW1lXCIgW3ZhbHVlXT1cInZhbHVlXCIgW2xhYmVsXT1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgIFtiaW5hcnldPVwiaXNCaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LXZhbGlkYXRpb24tZXJyb3JdPVwiIShmb3JtQ29udHJvbC52YWxpZCB8fCAoZm9ybUNvbnRyb2wucHJpc3RpbmUpKVwiXG4gICAgICAgID5cbiAgICAgICAgPC9wLWNoZWNrYm94PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNGb3JtVHlwZSgpXCI+XG4gICAgICAgIDxwLWNoZWNrYm94IFtiaW5hcnldPVwiaXNCaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgPC9wLWNoZWNrYm94PlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvc3Bhbj5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktY2hrYm94IC51aS1jaGtib3gtYm94e3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9L2RlZXAvIC51aS1jaGtib3ggLnBpe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojMTk5ZGUwO2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjA3ZW07bGluZS1oZWlnaHQ6MS40MmVtfS9kZWVwLyAudWktY2hrYm94IC5waS5waS1jaGVjazpiZWZvcmV7Y29udGVudDonXFxcXGUwNWInfWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNoZWNrYm94XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBjaGVja2JveC4gRm9ybSBiYXNlZCB1cGRhdGVzIG1vZGVsIGFuZCBBY3Rpb24gYmFzZWQgb25seSBmaXJlcyBjbGljayBldmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogQ2hlY2tib3hUeXBlID0gJ2Zvcm0nO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgY2hlY2tib3hcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogUHJpbWVORyBoYXMgdGhpcyB0eXBlIGNhbGxlZCBiaW5hcnkgd2hpY2ggd29ya3Mgb25seSB3aXRoIEJvb2xlYW4gbWVhbmluZyBpdCBkb2VzIG5vdCBhZGQgb3JcbiAgICAgKiByZW1vdmUgdmFsdWVzLlxuICAgICAqXG4gICAgICogSW4gb3VyIGNhc2UgQ2hlY2t0eXBlID0gQWN0aW9uIGlzIGFsd2F5cyBiaW5hcnkgb3Igd2hlbiB0aGlzLnZhbHVlIGlzIGJvb2xlYW5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzQmluYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCBmb3IgY2hlY2tib3hcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLmFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCA/ICdhY3Rpb24nIDogdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29udHJvbCBmcm9tIHBhcmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB2YWx1ZSBpcyBib29sZWFuIHdlIGFyZSBkZWFsaW5nIHdpdGggUHJpbWVOZyBCaW5hcnkgY2hlY2tib3hcbiAgICAgICAgLy8gd2hpY2ggb25seSBzZXRzIFRSVUUvRkFMU0UgYW5kIGRvZXMgbm90IGFkZCBvciByZW1vdmUgdmFsdWVzXG4gICAgICAgIHRoaXMuaXNCaW5hcnkgPSBpc0Jvb2xlYW4odGhpcy52YWx1ZSk7XG5cbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ3ZhbHVlJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ3ZhbHVlJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBjaGFuZ2VzWyd2YWx1ZSddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBDaGVja2JveCBpcyBjbGlja2VkIGFuZCBpdCBlaXRoZXIgZmlyZSBhY3Rpb24gb3IgdXBkYXRlcyB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb3JtVHlwZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGwgaWYgd2UgYXJlIHVzaW5nIEZvcm0gQ2hlY2tib3guIFRoaXMgaXMgdXNlZCByZW1vdmUgc29tZSBvZiB0aGUgYmluZGluZ3MgdGhhdCBhcmUgbm90XG4gICAgICogYXBwbGljYWJsZSBmb3IgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtVHlwZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnZm9ybSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCAmJiB0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hlY2tib3hDb21wb25lbnR9IGZyb20gJy4vY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7Q2hlY2tib3hNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hlY2tib3hDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NoZWNrQm94TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqICBDaGVja2JveCBsaXN0IGlzIGEgd3JhcHBlciBjbGFzcyBhcm91bmQgJ0NoZWNrYm94JyBjb21wb25lbnQgdG8gc2ltcGx5IGFzc2VtYmx5IG9mIG11bHRpIGNob2ljZVxuICogY29tcG9uZW50XG4gKlxuICogSW4gQWRkaXRpb24gaXQgYWRkcyBhYmlsaXR5IHRvIHdvcmsgd2l0aCBjb21wbGV4IG9iamVjdC4gUHJpbWVORyBjaGVja2JveGVzIHdvcmsgb25seSB3aXRoXG4gKiBwcmltaXRpdmUgdmFsdWVzLlxuICpcbiAqIEBzZWUge0BsaW5rIGNoZWNrLWJveC9jaGVjay1ib3guY29tcG9uZW50LnRzfVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqXG4gKiAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgIHNlbGVjdG9yOiAnc2hvd0NoZWNrQm94TGlzdCcgLFxuICogICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIiBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKlxuICogICAgICAgICAgICBbbmFtZV09XCInbXlDb2xvcnMnXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrXCI+XG4gKiAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgYFxuICpcbiAqICAgICAgIH0pXG4gKiAgICAgICAgY2xhc3MgTXlTaG93Q0xDb21wb25lbnRcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIGNoZWNrQm94TGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ3JlZCcgLCAneWVsbG93JyAsICdvcmFuZ2UnICwgJ3doaXRlJyAsXG4gKiAgICAgJ3NpbHZlcicgLCAnYmxhY2snICxcbiAqICAgICAgICAgICAgJ0dyZWVuJyAsICdHcmF5JyAsICdOYXZ5JyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKlxuICogICAgICAgICAgICBzZWxlY3RlZFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqXG4gKlxuICogICAgICAgICAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICpcbiAqXG4gKiAgICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNCQ2xpY2sgPSAnICsgZXZlbnQpO1xuICogICAgICAgICAgICB9XG4gKlxuICogICAgICAgIH1cbiAqKlxuICovXG5cblxuXG5cbmV4cG9ydCBjb25zdCBDQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja0JveExpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hlY2tib3gtbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGxpc3Q7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInVpLWdcIj5cblxuICAgIDwhLS0gaW4gdGhlIGZ1dHVyZSB3ZSBzaG91bGQgYmUgYWJsZSB0byB0byBzdXBwb3J0IGlubGluZSBhbmQgc3RhY2stLT5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMlwiPlxuICAgICAgICA8YXctY2hlY2tib3ggWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImlcIlxuICAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cImxhYmVsVmFsdWUoaXRlbSlcIj5cblxuICAgICAgICA8L2F3LWNoZWNrYm94PlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0JfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrQm94TGlzdENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja0JveExpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyB1c2VkIHRvIHJlbmRlciBjaGVja2JveGVzLiBFdmVuIHdlIGhhdmUgaGVyZSB0eXBlIGFzIEFOWSB3ZSBpbnRlcm5hbGx5XG4gICAgICogc3VwcG9ydCBvbmx5IHN0cmluZyBhdCB0aGUgbW9tZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogIFNlbGVjdGlvbnMgYXJlIGRlZmF1bHQgQ0hFQ0tFRCB2YWx1ZXMgcGFzc2VkLiBlLmcuIFdoZW4gcmVuZGVyaW5nIGZpZWxkIGZhdm9yaXRlIGNvbG9yczpcbiAgICAgKiBibHVlLCByZWQsIHllbGxvdyB5b3Ugd2lsbCBwYXNzIGluIGhlcmUgYmx1ZSwgcmVkLCB0aGVuIGNoZWNrYm94ZXMgd2l0aCB2YWx1ZSBibHVlLCByZWQgd2lsXG4gICAgICogYmUgcmVuZGVyZWQgYXMgY2hlY2sgYW5kIHllbGxvdyB1bmNoZWNrZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbnM6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgZXZlbnQgd2hlbiBjaGVja2JveCBpcyBzZWxlY3RlZC9jbGlja2VkLiBFbWl0cyBjdXJyZW50IGNsaWNrZWQgY2hlY2tib3hlZC4gbm90IHRoZVxuICAgICAqIGFjdHVhbGwgaW50ZXJuYWwgbW9kZWwgdmFsdWUgaW4gdGhpcyBjYXNlIGFycmF5IG9mIGNob2ljZXNcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogc3BlY2lhbCBleHByZXNzaW9uIHRvIGZvcm1hdCBsYWJlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxGb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsXG4gICAgICovXG4gICAgbW9kZWw6IGFueSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb25zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuc2VsZWN0aW9ucyk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb25zKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnlbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMubW9kZWwuZm9yRWFjaCgoaW5kZXg6IG51bWJlcikgPT4gdXBkYXRlZE1vZGVsLnB1c2godGhpcy5saXN0W2luZGV4XSkpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIGlzIGV4dHJhY3RlZCBpbnRvIHRoaXMgbWV0aG9kIHNvIGluIHRoZSBmdXR1cmUgd2UgY2FuIHBsYXkgbW9yZSBob3cgd2Ugd2FudCB0byBkaXNwbGF5XG4gICAgICogdGhlIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgbGFiZWwgd2lsbCBsb29rIGxpa2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBsYWJlbFZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxhYmVsRm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgdmVyc2lvbiBvZiBjaGVja2JveGVzIHdlIHN0aWxsIGV4cGVjdCBvbmx5IHByaW1pdGl2ZSB0eXBlcy4gS2VlcCB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBpbiBleHRyYSBtZXRob2Qgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBldmVuIG5vdyB3ZSBqdXN0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrXG4gICAgICovXG4gICAgdmFsdWUoaXRlbTogYW55KTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBldmVudCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50IGFuZCBjb252ZXJ0IGluZGV4ZWQgbW9kZWwgdG8gb3JpZ2luYWwgb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueVtdID0gW107XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mb3JFYWNoKChpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVkTW9kZWwucHVzaCh0aGlzLmxpc3RbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggY29tcGxleCBvYmplY3Qgc3RvcmUgb25seSBJTkRFWGVzIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VyY2VMaXN0OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNvdXJjZUxpc3QuZm9yRWFjaCgoaXRlbTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxpc3QuZmluZEluZGV4KChlbGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyhpdGVtLCBlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wdXNoKGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vZGVsKSAmJiBpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbmV3TW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWwobmV3TW9kZWwpO1xuXG4gICAgICAgICAgICAvLyB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaGVja0JveExpc3RDb21wb25lbnR9IGZyb20gJy4uL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENoZWNrQm94TGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlXG4gICAgXSxcblxuXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaGVja0JveExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaGVja0JveExpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEh5cGVybGluayBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEh5cGVybGluayBzdXBwb3J0cyBhbGwgb2YgdGhlXG4gKiBuYXRpdmUgbGluayBmdW5jdGlvbmFsaXR5LiBJbiBhZGRpdGlvbiwgaXQgc3VwcG9ydHMgbmF2aWdhdGlvbiB0byBjb21wb25lbnRzIHRocm91Z2ggdGhlIGFjdGlvblxuICogYmluZGluZy5cbiAqXG4gKlxuICogZm9yIG1vcmUgaW5mbyBwbGVhc2Ugc2VlIGNsYXNzIERvYyBvZiB0aGU6XG4gKiAgQHNlZSB7QGxpbmsgYnV0dG9uL2J1dHRvbi5jb21wb25lbnQudHN9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgICAgIDxhdy1oeXBlcmxpbmsgIFt0eXBlXT1cIid0ZXh0L2h0bWwnXCIgW25hbWVdPVwiJ2xpbmsnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNsaWNrZWQoJGV2ZW50KVwiIFt2YWx1ZV09XCJjdXN0b21lcklkXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3NpemVdPVwiJ2xhcmdlJ1wiID5teSBsaW5rPC9hdy1oeXBlcmxpbms+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQoY3VzdG9tZXJJZDpzdHJpbmcpIHtcbiAqICAgICAgICAgICBpZiAoY3VzdG9tZXJJZCkge1xuICogICAgICAgICAgICAgIC8vIGRpc3BsYXkgY3VzdG9tZXIgZGV0YWlscyBjb21wb25lbnQuXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1oeXBlcmxpbmsnLFxuICAgIHRlbXBsYXRlOiBgPGEgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgIFthdHRyLmhyZWZdPVwiaHJlZlwiXG4gICBbYXR0ci5yZWxdPVwicmVsXCJcbiAgIFthdHRyLnRhcmdldF09XCJ0YXJnZXRcIlxuICAgW25nQ2xhc3NdPVwibGlua0NsYXNzXCJcbiAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAoY2xpY2spPVwiY2xpY2tlZCgkZXZlbnQpXCI+XG5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2E+XG5gLFxuICAgIHN0eWxlczogW2AubGlua3tjb2xvcjojMDI3NWQ4O2N1cnNvcjpwb2ludGVyfS5saW5rLmxpbmstYmh7Y29sb3I6IzAyNzVkOH0ubGluay5saW5rLWJoOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Y3Vyc29yOnBvaW50ZXJ9Lmxpbmstc217Zm9udC1zaXplOi44NzVlbX0ubGluay1taWR7Zm9udC1zaXplOjFlbX0ubGluay1sZ3tmb250LXNpemU6MS4yNWVtfS5saW5rLmRpc2FibGVke3BvaW50ZXItZXZlbnRzOm5vbmU7Y3Vyc29yOmRlZmF1bHQ7Y29sb3I6I2RkZH1gXVxufSlcbmV4cG9ydCBjbGFzcyBIeXBlcmxpbmtDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiAgICBTcGVjaWZpZXMgdGhlIG1lZGlhIHR5cGUgb2YgdGhlIGxpbmtlZCBkb2N1bWVudC4gTWltZSB0eXBlXG4gICAgICogICAgZXg6IFt0ZXh0L2h0bWwgfCB0ZXh0L2NzdiB8IGltYWdlL3BuZyB8IGF1ZGlvLzNncHAgfCAuLi4uXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogdXJsIGZvciB0aGlzIGh5cGVybGluay4gQ2FuIGJlIHVzZWQgdG8gbmF2aWdhdGUgdG8gYSBjb21wb25lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBocmVmOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiByZWwgZm9yIHRoaXMgaHlwZXJsaW5rLiBTcGVjaWZ5IHRoZSByZWxhdGlvbnNoaXAgb2YgdGhlIGN1cnJlbnQgZG9jdW1lbnQgYW5kIGxpbmtlZCBkb2N1bWVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHNpemluZyBmb3IgdGhpcyBsaW5rLiBbbGFyZ2UsIG5vcm1hbCwgc21hbGxdLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2l6ZTogTGlua1NpemUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHRhcmdldCBvZiB0aGUgaHlwZXJsaW5rLiBbX2JsYW5rIHwgX3NlbGYgfCBfcGFyZW50IHwgX3RvcCB8IGZyYW1lbmFtZSBdXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YXJnZXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIGJlIHNlbmQgdG8gc2VydmVyIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBDU1MgY2xhc3MgdGhhdCBzdHlsZXMgdGhpcyBoeXBlcmxpbmsgYmFzZWQgb24gaW5wdXQgJ3NpemUnXG4gICAgICovXG4gICAgbGlua0NsYXNzOiBzdHJpbmcgPSAnbGluayc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgbGluayBjbGFzcyBiYXNlZCBvbiBpbnB1dCBzaXplLlxuICAgICAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhcmdlJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1sZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstbWlkJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLXNtJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBJIGhhdmUgYW4gYWN0aW9uIHRhZywgYW5kIG5vIGhyZWYuIFdlIGFkZCBkZWZhdWx0IHN0eWxpbmcgYW5kIGJlaGF2aW9yLlxuICAgICAgICBpZiAodGhpcy5hY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1iaCc7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBY3Rpb24gY2xpY2tlZC4gQ2FsbCBwYXJlbnQgYWN0aW9uLlxuICAgICAqL1xuICAgIGNsaWNrZWQoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnRlZCBMaW5rIFNpemVcbiAqL1xuZXhwb3J0IHR5cGUgTGlua1NpemUgPSAnbGFyZ2UnIHwgJ25vcm1hbCcgfCAnc21hbGwnO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIeXBlcmxpbmtDb21wb25lbnR9IGZyb20gJy4vaHlwZXJsaW5rLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdIeXBlcmxpbmtNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7dW5pbXBsZW1lbnRlZH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTZWxlY3Rpb24gU3RhdGUgZm9yIHRoZSBjaG9vc2VyIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gY29tdW5pY2F0ZSB3aXRoIHRoZSBwYXJlbnQgb2JqZWN0IHVzaW5nIGFcbiAqIGNob29zZXIuIElmIEkgd291bGQgaGF2ZSB0byBtYW5hZ2Ugb25seSBzaW5nbGUgdmFsdWVzIHdpdGggbm8gYWRkaW9uYWwgbWV0aG9kcyBpIHdvdWxkIHVzZXJcbiAqIGVtaXR0ZXJzIHRvIGRvIHRoZSBqb2IsIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0aGlzIGludGVyZmFjZSAoYWJzdHJhY3QgY2xhc3MpIGJldHdlZW4gYVxuICogY2hvb3NlciBhbmQgYWN0dWFsIG9iamVjdC5cbiAqXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG57XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXQgc2VsZWN0aW9uIHN0YXRlIGlzIHVzdWFsbHkgdHJpZ2dlcmVkIGJ5IHNlbGVjdGluZyBhbmQgdW5zZWxlY3RpbmcgYSBpdGVtIChpbiBjYXNlIG9mXG4gICAgICogbXVsdGlzZWxlY3QpIGFuZCBpdCBzaG91bGQgdXBkYXRlIGl0cyBsaXN0IG9mIG9iamVjdHMgd2l0aCBlaXRoZXIgc2V0dGluZ3MvYWRkaW5nIGl0ZW0gb3JcbiAgICAgKiByZW1vdmluZyBpdC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIC4gTnVsbCBpZiBsYXN0IGFjdGlvbiB3YXMgYSBkZXNlbGVjdGlvbi4gVXN1YWxseSB1c2VkIGJ5IENob29zZXJcbiAgICAgKiBvciBDaG9vc2VyU3RhdGUgdG8gZ2V0IGN1dXJlbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgc2VsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgaXRlbSBzZWxlY3Rpb24gaXRlbXMgaXMgaW4gdGhlIHNlbGVjdGVkT2JqZWN0c1xuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDaG9vc2VyU2VsZWN0aW9uU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IHtEYXRhU291cmNlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuXG4vKipcbiAqIENob29zZXJTdGF0ZSBtYW5hZ2VzIGNvbXBsZXRlIGxpZmVjeWNsZSBmb3IgdGhlIENob29zZXIgQ29tcG9uZW50LiBJdCBrZWVwcyB0cmFjayBvZiBjdXJyZW50XG4gKiBzZWxlY3Rpb24gYXMgd2VsbCBhcyBpdCBjYW4gYnJvYWRjYXN0IGFueSB1cGRhdGVzLlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDaG9vc2VyU3RhdGVcbntcblxuICAgIC8qKlxuICAgICAqICBDYWxsYmFjayB0byB0aGUgcGFyZW50IG9iamVjdCB0byBzdG9yZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXRlOiBDaG9vc2VyU2VsZWN0aW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiBXZSBkbyBub3QgbmVlZGVkIHRoaXMgISFcbiAgICAgKi9cbiAgICBjdXJyZW50SXRlbTogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBwYXR0ZXJuLiBVc2VyIGxhdGVzdCBpbnB1dCB0byB0aGUgY2hvb3NlciBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogTGFzdCBzdWNjZXNzZnVsbCBwYXR0ZXJuIHRoYXQgcmV0cmlldmVkIHNvbWUgZGF0YVxuICAgICAqL1xuICAgIGxhc3RGdWxsTWF0Y2hQYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbWF0Y2hlZCBpdGVtcyB1c2luZyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbiAgICAgKi9cbiAgICBtYXRjaGVzOiBBcnJheTxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG11bHRpc2VsZWN0IGNob29zZXJcbiAgICAgKi9cbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBjYW4gc2V0IGxvb2t1cCBrZXkgdG8gbmFycm93IHRoZSBzZWFyY2guIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggb2JqZWN0XG4gICAgICogeW91IHNob3VsZCBzZXQgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cEtleTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBwcmV2aW91cyBkaXNwbGF5IHZhbHVlIGlzIHNldCB3aGVuIHRoZSBkaXNwbGF5IHZhbHVlIGlzIHJlbmRlcmVkIG9uIHRoZSBjaG9vc2VyLiB3ZSBjYWNoZVxuICAgICAqIHRoZSBVSSB2YWx1ZSB0byBjb21wYXJlIHdpdGggdGhlIGluYm91bmQgdmFsdWUgbGF0ZXIgaW5zdGVhZCBvZiB0aGUgdmFsdWUgZnJvbSB1bmRlcmx5aW5nXG4gICAgICogb2JqZWN0IGJlY2F1c2UgYnVzaW5lc3MgbG9naWMgbGV2ZWwgY29kZSBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIHVuZGVybHlpbmcgb2JqZWN0J3MgdmFsdWVcbiAgICAgKlxuICAgICAqIHRvZG86IGRvIEkgc3RpbGwgbmVlZCB0aGlzP1xuICAgICAqL1xuICAgIHByZXZEaXNwbGF5VmFsdWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZXJlIGFyZSBhbnkgdmFsaWRhdGlvbiBsaWtlIGVudGVyZWQgdmFsdWUgZG9lcyBub3QgbXVjaCB3aXRoIHRoZSBzb3VyY2UgbGlzdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW52YWxpZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCB3ZSBzdGFydGVkIHRvIHNvbWUgZWRpdGluZyBlLmcuIHN0YXJ0aW5nIHRvIHR5cGUgaW4gc29tZXRoaW5nIGludG8gdGhlXG4gICAgICogZmlsdGVyLCBvciByZW1vdmluZyBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICovXG4gICAgYWRkTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICByZWNlbnRTZWxlY3RlZERpc3BsYXllZDogbnVtYmVyID0gMDtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIG9wdGlvbiBpcyBhY3RpdmUgd2UgZG8gbm90IHNob3cgYWxsIHNlbGVjdGVkIGl0ZW1zLCBidXQgbWF4IG51bWJlciB0aGF0IGlzXG4gICAgICogZGVmaW5lZC4gVXNlciBpcyBhYmxlIHRvIHRvZ2dsZSB0byBleHBhbmQgdGhlIHZpZXcgdG8gc2VlIGFsbCBzZWxlY3Rpb25zIGFuZCBoaWRlIHRoZW0gYXNcbiAgICAgKiB3ZWxsXG4gICAgICovXG4gICAgc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IoY2hvb3NlclNlbGVjdGlvblN0YXRlPzogQ2hvb3NlclNlbGVjdGlvblN0YXRlLCBpc011bHRpOiBib29sZWFuID0gdHJ1ZSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZSA9IGNob29zZXJTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5tdWx0aXNlbGVjdCA9IGlzTXVsdGk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb25TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUgPSBuZXcgRGVmYXVsdFNlbGVjdGlvblN0YXRlKHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEl0IHdpbGwgc2VsZWN0IGFuZCBwZXJzaXN0IGFuIGl0ZW0gdXNpbmcgQ2hvb3NlclNlbGVjdGlvblN0YXRlIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSB0aGlzLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3RzID0gdGhpcy5zZWxlY3RlZE9iamVjdHMoKTtcblxuXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRNb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0ZWRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGVkT2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sICFMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgoc2VsZWN0ZWRPYmplY3RzLCBpdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0ZWRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0ZWRPYmplY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2VyIHNlbGVjdGlvbiBpcyBsYXJnZSB3ZSB1c2UgdGhpcyBtZXRob2QgdG8gY2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGFsbCBzZWxlY3RlZFxuICAgICAqIGl0ZW1zIG9yIG9ubHkgTWF4UmVjZW50U2VsZWN0ZWRcbiAgICAgKi9cbiAgICB0b2dnbGVBbGxTZWxlY3RlZCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkID0gIXRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlbmRlcnMgdXNlcidzIHNlbGVjdGlvbiB1bmRlciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCByZWNlbnRTZWxlY3RlZE9iamVjdHMoKTogQXJyYXkgPGFueT5cbiAgICB7XG5cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVjZW50U2VsZWN0ZWRPYmplY3RzOiBhbnlbXSA9IFtdO1xuICAgICAgICB0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkID0gMDtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgICAgIGxldCBzaXplID0gc2VsZWN0ZWRPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heENvdW50ID0gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZDtcbiAgICAgICAgaWYgKHNpemUgPiBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkICYmICF0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBtYXhDb3VudCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBtYXhDb3VudCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gc2l6ZSAtIDE7IGkgPj0gMCAmJiAodGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCA8IG1heENvdW50KTsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gc2VsZWN0ZWRPYmplY3RzW2ldO1xuICAgICAgICAgICAgcmVjZW50U2VsZWN0ZWRPYmplY3RzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWNlbnRTZWxlY3RlZE9iamVjdHM7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZWxlY3RlZE9iamVjdCgpO1xuICAgIH1cblxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXRlLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIER1bW15IGltcGxlbWVudGF0aW9uIENob29zZXJTZWxlY3Rpb25TdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG57XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRPYmplY3Q6IGFueTtcbiAgICBwcml2YXRlIF9zZWxlY3RlZE9iamVjdHM6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtdWx0aVNlbGVjdDogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE9iamVjdCA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0ICYmICFMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgodGhpcy5zZWxlY3RlZE9iamVjdHMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRPYmplY3RzKCkucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KHRoaXMuc2VsZWN0ZWRPYmplY3RzKCksIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE9iamVjdDtcbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fc2VsZWN0ZWRPYmplY3RzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRPYmplY3RzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkT2JqZWN0cztcbiAgICB9XG5cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVNvdXJjZSwgRFNJbml0UGFyYW1zfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBEYXRhRmluZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7Q2hvb3NlclN0YXRlfSBmcm9tICcuL2Nob29zZXItc3RhdGUnO1xuaW1wb3J0IHthc3NlcnQsIGlzQXJyYXksIGlzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIENvbmNyZXRlIERhdGFTb3VyY2UgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBDaG9vc2VyIGNvbXBvbmVudC4gVGhlcmUgYXJlIHR3byB3YXlzIGhvdyB0byB1c2UgaXQ6XG4gKlxuICogMSkgWW91IGNhbiB1c2UgZGVmYXVsdCBEYXRhU291cmNlIGluamVjdGVkIGluc2lkZSBjb21wb25lbnQgY29uc3RydWN0b3IgYW5kIGp1c3QgY2FsbFxuICogaW5pdGlhbGl6ZSB0byBjb25maWd1cmUgaXQgd2l0aCBjb3JyZWN0IERhdGFQcm92aWRlciBhbmQgRGF0YUZpbmRlcjpcbiAqXG4gKlxuICogYGBgXG4gKiAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAqICAgICAgICAgICAgICAgb2JqOiB0aGlzLmxpc3QsXG4gKiAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICogICAgICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAqICAgICAgICAgICB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBhbmQgdGhlbiB5b3UgY2FuIHVzZSBpdCB0byBzaW1wbHkgcmV0cmlldmUgZGF0YSBvciBydW4gcXVlcmllcy5cbiAqXG4gKiAyKSBZb3Ugd2lsbCBpbnN0YW50aWF0ZSB5b3VyIG93biBEYXRhU291cmNlIGFuZCBwYXNzIGl0IGludG8gdGhlIGNvbXBvbmVudCB1c2luZyBbZGF0YVNvdXJjZV1cbiAqIGJpbmRpbmdcbiAqXG4gKiBgYGBcbiAqXG4gKiAgIHRoaXMuZHMgPSBuZXcgQ2hvb3NlckRhdGFTb3VyY2UodGhpcy5kYXRhLCB0aGlzLmZpbmRlcnMpO1xuICogICB0aGlzLmRzLmluaXQoe1xuICogICAgICAgICAgICAgICBvYmo6IHRoaXMubGlzdCxcbiAqICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gKiAgICAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICogICAgICAgICAgIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDaG9vc2VyRGF0YVNvdXJjZSBleHRlbmRzIERhdGFTb3VyY2VcbntcblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIGRhdGFQcm92aWRlcnMgYW5kIGZpbmRlcnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGRhdGFQcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT47XG4gICAgcHJpdmF0ZSBkYXRhRmluZGVyOiBEYXRhRmluZGVyO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIG9iamVjdCB0byBrZWVwIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBjaG9vc2VyXG4gICAgICovXG4gICAgc3RhdGU6IENob29zZXJTdGF0ZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGFQcm92aWRlcnM6IERhdGFQcm92aWRlcnMsIHB1YmxpYyBmaW5kZXJzOiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgICAgIHN1cGVyKGRhdGFQcm92aWRlcnMsIGZpbmRlcnMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVG8gaW5pdGlhbGl6ZSB0aGlzIERhdGFTb3VyY2Ugd2l0aCBjdXJyZW50IERhdGFGaW5kZXIgYW5kIFByb3ZpZGVyIGFzIHdlbGwgYXMgc3RhdGUgd2UgdXNlXG4gICAgICogYW4gaW50ZXJmYWNlIERTQ2hvb3NlckluaXRQYXJhbXMgdG8gaGF2ZSBhbGwgaW5pdCB2YWx1ZXMgdHlwZWQgY2hlY2tlZFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoYXJncykgfHwgYXJncy5sZW5ndGggIT09IDEgJiYgIWlzRFNDaG9vc2VySW5pdFBhcmFtcyhhcmdzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbml0aWFsaXplIERTIHdpdGggKERTQ2hvb3NlckluaXRQYXJhbXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXQ6IERTQ2hvb3NlckluaXRQYXJhbXMgPSBhcmdzWzBdO1xuXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YVByb3ZpZGVyKSA/IGluaXQuZGF0YVByb3ZpZGVyXG4gICAgICAgICAgICA6IHRoaXMuZGF0YVByb3ZpZGVycy5maW5kKGluaXQub2JqKTtcblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhRmluZGVyKSA/IGluaXQuZGF0YUZpbmRlclxuICAgICAgICAgICAgOiB0aGlzLmZpbmRlcnMuZmluZCh0aGlzLmRhdGFQcm92aWRlciwgaW5pdC5xdWVyeVR5cGUpO1xuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kYXRhUHJvdmlkZXIpICYmIGlzUHJlc2VudCh0aGlzLmRhdGFGaW5kZXIpLFxuICAgICAgICAgICAgJ0RhdGFTb3VyY2UgaW5jb3JyZWN0bHkgaW5pdGlhbGl6ZWQuIChEYXRhUHJvdmlkZXIsIERhdGFGaW5kZXIpIG1pc3NpbmcuICcpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoaW5pdC5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpbml0LnN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBDaG9vc2VyU3RhdGUobnVsbCwgaW5pdC5tdWx0aXNlbGVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuc3RhdGUubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgfVxuXG5cbiAgICBmaW5kKHBhdHRlcm46IHN0cmluZywgbWF4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmxhc3RGdWxsTWF0Y2hQYXR0ZXJuID0gcGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyonKSB7IC8vIHF1ZXJ5IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIHBhdHRlcm4gPSAnJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRhdGFGaW5kZXIgaGFzIGV4cGVjdGVkIGxvb2t1cCBrZXlcbiAgICAgICAgbGV0IG9yaWdLZXkgPSB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5O1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gdGhpcy5zdGF0ZS5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5mb3JEYXRhKHRoaXMuZGF0YVByb3ZpZGVyKS5tYXRjaDxhbnk+KHBhdHRlcm4sIG1heClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlc3VsdDogYW55W10pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYXRjaGVzID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKClbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KHRoaXMuc3RhdGUubWF0Y2hlcywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gb3JpZ0tleTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBtdWx0aXNlbGVjdCB0aGlzIG1ldGhvZCBjaGVja3MgaWYgd2UgbmVlZCB0byBzaG93IFNIT1cgTU9SRSBsYWJlbCB1bmRlciB0aGUgc2VsZWN0ZWRcbiAgICAgKiBpdGVtcy4gV2UgZG8gbm90IHdhbnQgc2hvdyBlLmcuIDUwIHNlbGVjdGlvbiB1bmRlciB0aGUgY2hvb3NlciB0aGF0IHdvdWxkIHRha2UgdXAgd2hvbGVcbiAgICAgKiBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgc2hvd01vcmVTZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGggPj0gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZDtcbiAgICB9XG5cbiAgICBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaW5zdGFudDxUPigpOiBUW11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGl0ZW1zOiBhbnlbXSA9IHZhbHVlO1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gdGhpcy5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5hZGRNb2RlID0gZmFsc2U7XG5cbiAgICB9XG5cblxuICAgIGdldCBsb29rdXBLZXkoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleTtcbiAgICB9XG59XG5cbi8qIGlzIFwiaW5pdFwiIHR5cGUgb2YgRFNDaG9vc2VySW5pdFBhcmFtcyBpbnRlcmZhY2UgPyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRFNDaG9vc2VySW5pdFBhcmFtcyhpbml0OiBEU0Nob29zZXJJbml0UGFyYW1zKTogaW5pdCBpcyBEU0Nob29zZXJJbml0UGFyYW1zXG57XG4gICAgcmV0dXJuIGlzUHJlc2VudChpbml0Lm9iaikgfHwgaXNQcmVzZW50KGluaXQucXVlcnlUeXBlKTtcbn1cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEU0Nob29zZXJJbml0UGFyYW1zIGV4dGVuZHMgRFNJbml0UGFyYW1zXG57XG4gICAgLyoqXG4gICAgICogQ2hvb3NlciBzdGF0ZSBrZWVwaW5nIGluZm9ybWF0aW9uIHdoYXQgaXMgY3VycmVudGx5IHNlbGVjdGVkICwgcmVzdWx0IG9mIHRoZSBsYXN0IG1hdGNoXG4gICAgICovXG4gICAgc3RhdGU/OiBDaG9vc2VyU3RhdGU7XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0F1dG9Db21wbGV0ZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtDaG9vc2VyRGF0YVNvdXJjZX0gZnJvbSAnLi9jaG9vc2VyLWRhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZSwgRGVmYXVsdFNlbGVjdGlvblN0YXRlfSBmcm9tICcuL2Nob29zZXItc3RhdGUnO1xuXG5cbi8qKlxuICogVHlwZWFoZWFkIGNob29zZXIgdGhhdCBzdXBwb3J0cyBib3RoIHNpbmdsZSBhbmQgbXVsdGktc2VsZWN0LiBOb3QgbGlrZSBEcm9wZG93biwgdGhpcyBjaG9vc2VyXG4gKiByZXF1aXJlcyBsaXR0bGUgYml0IGRpZmZlcmVudCBzZXR1cC4gSXQgcmVxdWlyZXMgYXQgbWluaW11bSBASW5wdXQgZGF0YVNvdXJjZSBvclxuICogZGVzdGluYXRpb25DbGFzc1xuICpcbiAqXG4gKiBCeSBkZWZhdWx0IGNob29zZXIgaXMgbXVsdGktc2VsZWN0LiBJZiB5b3Ugd2FudCBzaW5nbGUgc2VsZWN0IHRoZW4geW91IG11c3QgcHJvdmlkZSBtdWx0aS1zZWxlY3RcbiAqIHdpdGggQElucHV0LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogSW4gc2ltcGxlIHNjZW5hcmlvIHlvdSBjYW4gdXNlIENob29zZXIgbGlrZSBzbzpcbiAqXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnY2hvb3Nlci1hcHAnICxcbiAqICAgICAgdGVtcGxhdGU6IGA8YXctY2hvb3NlciAgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiBuYW1lPVwiY29sb3JcIidcbiAqICAgICAgICAgICAgICAgICAgICAgIFtkYXRhU291cmNlXT1cImRzXCI+PC9hdy1jaG9vc2VyPmBcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBNeUNob29zZXJBcHBcbiAqICB7XG4gKlxuICogICAgICBkczogQ2hvb3NlckRhdGFTb3VyY2U7XG4gKlxuICogICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogRGF0YVByb3ZpZGVycywgcHJpdmF0ZSBmaW5kZXJzOiBEYXRhRmluZGVycyl7XG4gKiAgICAgICAgICB0aGlzLmRzID0gbmV3IENob29zZXJEYXRhU291cmNlKHRoaXMuZGF0YSwgdGhpcy5maW5kZXJzKTtcbiAqXG4gKiAgICAgICB0aGlzLmRzLmluaXQoe1xuICogICAgICAgICAgIG9iajogWydibHVlJywgJ3JlZCcsICd5ZWxsb3cnXSwgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICBtdWx0aXNlbGVjdDogdHJ1ZVxuICogICAgICAgfSk7XG4gKlxuICogICAgIH1cbiAqICB9XG4gKlxuICogYGBgYFxuICogIEFib3ZlIGV4YW1wbGUgd2lsbCB1c2UgcHJvdmlkZWQgZGF0YVNvdXJjZSBhbmQgcmVuZGVyIG11bHRpLXNlbGVjdCBjaG9vc2VyLiBXaXRoIGRlZmF1bHRcbiAqICBpbXBsZW1lbnRhdGlvbiAgc2VsZWN0ZWQgdmFsdWVzIHdpbGwgYXBwZWFyIGFzIGEgdGFncyB1bmRlciB0aGUgaW5wdXQgYm94XG4gKlxuICpcbiAqXG4gKiAqICMjIyBFeGFtcGxlXG4gKlxuICogIEluIHRoaXMgZXhhbXBsZSB3ZSBwcm92aWRlIGN1c3RvbSB0ZW1wbGF0ZSB0byBjaGFuZ2UgdGhlIHdheSBob3cgY2hvb3NlcidzIE1lbnVJdGVtIGFyZVxuICogICAgIHJlbmRlcmVkIGFzIHdlbGwgYXMgdGVtcGxhdGUgZm9yIHRoZSBzZWxlY3Rpb24gaXRlbSBsb29rcyBsaWtlXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnY2hvb3Nlci1hcHAnICxcbiAqICAgICAgdGVtcGxhdGU6IGA8YXctY2hvb3NlciAgbmFtZT1cImNvbW1vZGl0eVwiJyBbZGF0YVNvdXJjZV09XCJkc1wiPlxuICpcbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjbWVudUl0ZW0gbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICBcdDxzcGFuPlxuICogICAgICAgICAgICAgXHRcdDxpIGNsYXNzPVwiZmEgZmEtZW52aXJhIFwiID48L2k+XG4gKiAgICAgICAgICAgICBcdFx0e3tpdGVtfX1cbiAqICAgICAgICAgICAgIFx0PC9zcGFuPlxuICpcbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlICNzZWxlY3Rpb25JdGVtIGxldC1pdGVtPlxuICogICAgICAgICAgICAgXHQ8c3BhbiBjbGFzcz1cInRhZyB0YWctY2lyY2xlXCI+XG4gKiAgICAgICAgICAgICBcdFx0aXRlbToge3tpdGVtIH19XG4gKiAgICAgICAgICAgICBcdFx0PGkgY2xhc3M9XCJmYSBmYS1jbG9zZVwiIChjbGljayk9XCJjaG9vc2VyLnJlbW92ZVZhbHVlKGl0ZW0pXCI+PC9pPlxuICogICAgICAgICAgICAgXHQ8L3NwYW4+XG4gKlxuICpcbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgIDwvYXctY2hvb3Nlcj5cbiAqICAgICAgYFxuICogICAgICBzdHlsZTogW2BcbiAqICAgICAgICAgICAgICAudGFnLWNpcmNsZSB7XG4gKiAgICAgICAgICAgICAgXHRib3JkZXItcmFkaXVzOiA2cmVtO1xuICogICAgICAgICAgICAgIFx0aGVpZ2h0OiA3cmVtO1xuICogICAgICAgICAgICAgIFx0Y29sb3I6ICNlOGVlZjE7XG4gKiAgICAgICAgICAgICAgXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDUzLCA1NiwgNTgsIDAuNjcpO1xuICogICAgICAgICAgICAgIFx0bGluZS1oZWlnaHQ6IDZyZW07XG4gKiAgICAgICAgICAgICAgfVxuICogICAgICBgXVxuICogIH0pXG4gKlxuICogYGBgYFxuICpcbiAqICBJbiBhYm92ZSBleGFtcGxlIHdlIGNoYW5nZSBob3cgdGhlIGNob29zZXIncyBtZW51IGl0ZW0gbG9vayBsaWtlIGFzIHdlbGwgYXMgd2UgZGVmaW5lIGN1c3RvbVxuICogICAgIHRlbXBsYXRlIGZvciBzZWxlY3Rpb24gaXRlbSB0byB0dXJuIGFsbCBzZWxlY3Rpb24gdG8gY2lyY2xlcyB3aXRoIHRleHQgaW4gdGhlIG1pZGRsZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5leHBvcnQgY29uc3QgQ0hPT1NFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hvb3NlckNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jaG9vc2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWNob29zZXIgXCI+XG5cbiAgICA8cC1hdXRvQ29tcGxldGUgI2F1dG9Db21wcGxldGUgWyhuZ01vZGVsKV09XCJpbnRlcm5hbENob29zZXJNb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdWdnZXN0aW9uc109XCJkYXRhU291cmNlLnN0YXRlLm1hdGNoZXNcIlxuICAgICAgICAgICAgICAgICAgICBbbXVsdGlwbGVdPVwiZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIFtkcm9wZG93bl09XCIhZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIFttaW5MZW5ndGhdPVwibWluTGVuRm9yU2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2RlbGF5XT1cImRlbGF5XCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uRHJvcGRvd25DbGljayk9XCJvbkRyb3Bkb3duQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChjb21wbGV0ZU1ldGhvZCk9XCJtYXRjaCgkZXZlbnQucXVlcnkpXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0KT1cInNlbGVjdEl0ZW0oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChvblVuc2VsZWN0KT1cInJlbW92ZVZhbHVlKCRldmVudClcIj5cblxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBsZXQtaW50ZXJuYWxDaG9vc2VyTW9kZWwgcFRlbXBsYXRlPVwiaXRlbVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNNZW51VGVtcGxhdGUoKVwiPlxuICAgICAgICAgICAgICAgIHt7IGRpc3BsYXlJdGVtKGludGVybmFsQ2hvb3Nlck1vZGVsKSB9fVxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cIm1lbnVUZW1wbGF0ZVwiIFtpdGVtXT1cImludGVybmFsQ2hvb3Nlck1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc01lbnVUZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3AtYXV0b0NvbXBsZXRlPlxuXG4gICAgPCEtLVxuICAgICAgICBXcmFwIHdob2xlIHNlbGVjdGlvbiB3aXRoIG9uZSBleHRyYSBlbGVtZW50IHNvIHdlIGNhbiBtb3ZlIGl0IGFyb3VuZFxuXG4gICAgICAgICBzZWU6IHNlbGVjdGlvbkFwcGVuZFRvXG4gICAgLS0+XG4gICAgPHNwYW4gI3NlbGVjdGlvblZpZXc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWNob29zZXItc2VsZWN0aW9uc1wiXG4gICAgICAgICAgICAgKm5nSWY9XCJtdWx0aXNlbGVjdCAmJiBkYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkT2JqZWN0cy5sZW5ndGggPiAwXCI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gbm8gc2VsZWN0aW9uIHRlbXBsYXRlIHJlbmRlciBpdCBhcyBpdCBpcyBmcm9tIENPUkUtLT5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7J3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktc3RhdGUtZm9jdXMnOmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c31cIj5cblxuICAgICAgICAgICAgICAgIDxsaSAjdG9rZW4gKm5nRm9yPVwibGV0IGl0ZW0gb2YgZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZE9iamVjdHNcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS10b2tlbiB1aS1zdGF0ZS1oaWdobGlnaHQgdWktY29ybmVyLWFsbFwiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIChrZXl1cC5kZWxldGUpPVwicmVtb3ZlVmFsdWUoaXRlbSlcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5dXAuYmFja3NwYWNlKT1cInJlbW92ZVZhbHVlKGl0ZW0pXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtdG9rZW4taWNvbiBzYXAtaWNvbiBpY29uLWRlY2xpbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwicmVtb3ZlVmFsdWUoaXRlbSlcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidWktYXV0b2NvbXBsZXRlLXRva2VuLWxhYmVsXCI+e3sgZGlzcGxheUl0ZW0oaXRlbSkgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwhLS1ZZXMgdGhlcmUgaXMgc2VsZWN0aW9uIHRlbXBsYXRlIGxldCdzIGl0ZXJhdGUgYW5kIHB1c2ggZWFjaCBpdGVtIHRvIGJlIHJlbmRlcmVkLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBbbmdGb3JPZl09XCJkYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkT2JqZWN0c1wiIGxldC1pdGVtPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwic2VsZWN0aW9uVGVtcGxhdGVcIiBbaXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc1NlbGVjdGlvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJkYXRhU291cmNlLnNob3dNb3JlU2VsZWN0ZWQoKVwiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJtb3JlLXNlbGVjdGVkXCI+XG5cdFx0XHRcdDxhdy1oeXBlcmxpbmsgW3NpemVdPVwiJ3NtYWxsJ1wiIChhY3Rpb24pPVwiZGF0YVNvdXJjZS5zdGF0ZS50b2dnbGVBbGxTZWxlY3RlZCgpXCI+XG5cdFx0XHRcdFx0e3ttb3JlU2VsZWN0U3RyaW5nKCl9fVxuXHRcdFx0XHQ8L2F3LWh5cGVybGluaz5cblx0XHRcdDwvc3Bhbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgICA8L3NwYW4+XG5cblxuPC9kaXY+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktZmx1aWQgLnVpLWF1dG9jb21wbGV0ZS51aS1hdXRvY29tcGxldGUtZGQgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dCwvZGVlcC8gLnVpLWZsdWlkIC51aS1hdXRvY29tcGxldGUudWktYXV0b2NvbXBsZXRlLWRkIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVye3dpZHRoOjEwMCV9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZXtsaW5lLWhlaWdodDpub3JtYWx9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dHt3aWR0aDoxMDAlfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9ue3JpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MzBweDtiYWNrZ3JvdW5kOjAgMH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbiAucGl7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiM3Njc2NzY7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuNGVtO21hcmdpbi1sZWZ0Oi0uODVlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbiAucGktY2FyZXQtZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9uIGlucHV0e3BhZGRpbmctcmlnaHQ6MzBweH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2Vue3BhZGRpbmc6MDttYXJnaW46MDt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZTt3aWR0aDppbmhlcml0fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gLmZhe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojNzY3Njc2O2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjJlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIC5mYS1zZWFyY2g6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMDBkJ30vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIGlucHV0e3dpZHRoOmluaGVyaXQ7cGFkZGluZy1yaWdodDoyNXB4fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gc3Bhbntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDo1cHg7dG9wOjA7cGFkZGluZy10b3A6LjZlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3due2hlaWdodDozNnB4fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtcGFuZWwgLnVpLWF1dG9jb21wbGV0ZS1saXN0LWl0ZW17cGFkZGluZzouNjVlbSAyZW0gLjY1ZW0gLjY0ZW07bWFyZ2luOjB9L2RlZXAvIGJvZHkgLnVpLWF1dG9jb21wbGV0ZS51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXJ7cGFkZGluZzouNGVtIC41ZW0gLjRlbSAxZW19LnctY2hvb3Nlci1zZWxlY3Rpb25ze21hcmdpbi10b3A6MnB4fS53LWNob29zZXItc2VsZWN0aW9ucyB1bHttYXJnaW46MDtwYWRkaW5nOjB9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVye2JvcmRlcjowfS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAudWktYXV0b2NvbXBsZXRlLXRva2Vue2ZvbnQtc2l6ZTouODVlbTtsZXR0ZXItc3BhY2luZzouMXB4O2ZvbnQtd2VpZ2h0OjQwMDtwYWRkaW5nOjA7YmFja2dyb3VuZDojZTBmMmZmO21hcmdpbi1yaWdodDo1cHg7bWFyZ2luLWJvdHRvbTo1cHh9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC51aS1hdXRvY29tcGxldGUtdG9rZW4tbGFiZWx7cGFkZGluZzo0cHggMjFweCA0cHggNXB4fS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAudWktYXV0b2NvbXBsZXRlLXRva2VuLWljb257Zm9udC1zaXplOi43OGVtO3BhZGRpbmctcmlnaHQ6LjI4ZW19LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC5zYXAtaWNvbntsaW5lLWhlaWdodDppbmhlcml0fS53LWNob29zZXItc2VsZWN0aW9ucyAubW9yZS1zZWxlY3RlZHtkaXNwbGF5OmlubGluZS1ibG9ja31gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0hPT1NFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG5cbn0pXG5leHBvcnQgY2xhc3MgQ2hvb3NlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0IHtcblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyID0gMTA7XG5cblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbkZvclNlYXJjaDogbnVtYmVyID0gMTtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHVzZWQgdG8gZm9ybWF0IGVhY2ggc2VsZWN0aW9uIGFuZCBzZWxlY3RlZCBvYmplY3QgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlVHJhbnNmb3JtZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG11bHRpc2VsZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpc2VsZWN0OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBDaG9vc2VyRGF0YVNvdXJjZSB3aWxsIGJlIGNyZWF0ZWQgYnV0IHRoZXJlIGlzIGEgb3B0aW9uIHRvIHNldFxuICAgICAqIGN1c3RvbSBvbmUgb24gYXBwbGljYXRpb24gbGV2ZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGFTb3VyY2U6IENob29zZXJEYXRhU291cmNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIHdhbnQgdG8gY2hhbmdlIHRoZSBwbGFjZSB3aGVyZSBzZWxlY3Rpb24gaXMgcmVuZGVyZWQgdXNlIHRoaXMgYXBwZW5kVG8gcHJvcGVydHlcbiAgICAgKiBhbmQgaXQgd2lsbCB1c2UgRE9NIG9wZXJhdGlvbiBhcHBlbmRDaGlsZCgpIHRvIG1vdmUgc2VsZWN0aW9uVmlldyB1bmRlciBkaWZmZXJlbnQgcGFyZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25BcHBlbmRUbzogRWxlbWVudFJlZjtcblxuXG4gICAgQElucHV0KClcbiAgICBkZWxheTogbnVtYmVyID0gMzAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgdHlwZSB0byByZW5kZXIuIERhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1vZGVsIHRvIGxpc3RlbiBmb3IgSW5wdXQgdmFsdWUgY2hhbmdlc1xuICAgICAqL1xuICAgIGludGVybmFsQ2hvb3Nlck1vZGVsOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIEVtYmVkZGVkIHRlbXBsYXRlIGRlZmluZWQgYnkgdXNlci4gSWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFueSB0ZW1wbGF0ZSB0aGVuIHdoZW4gcmVuZGVyaW5nXG4gICAgICogYW4gaXRlbSB3ZSBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBwcmltaXRpdmUgdHlwZXMgYW5kIGNhbGwgb24gZWFjaCBpdGVtIHRvU3RyaW5nKCksIGlmXG4gICAgICogd2UgYXJlIGRlYWxpbmcgd2l0aCBvYmplY3QsIHRoZW4gd2UgZXhwZWN0IHVzZXIgdG8gcHJvdmlkZSBhIHRlbXBsYXRlIGFuZCB0ZWxsIHRoZSBjaG9vc2VyXG4gICAgICogaG93IGl0ZW1zIHNob3VsZHMgYmUgaGFuZGxlZCBvciBhdCBsZWFzdCB2YWx1ZVRyYW5zZm9ybWVyIHNvIHdlIGtub3cgaG93IHRvIGNvbnZlcnQgdGhpc1xuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogRWFjaCBvYmplY3QgY2FuIHByb3ZpZGUgaXRzIG93biB0b1N0cmluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ21lbnVJdGVtJylcbiAgICBtZW51VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBDb250ZW50Q2hpbGQoJ3NlbGVjdGlvbkl0ZW0nKVxuICAgIHNlbGVjdGlvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnYXV0b0NvbXBwbGV0ZScpXG4gICAgYXV0b0NvbXBsZXRlQ29tcG9uZW50OiBBdXRvQ29tcGxldGU7XG5cbiAgICBAVmlld0NoaWxkKCdzZWxlY3Rpb25WaWV3JylcbiAgICBzZWxlY3Rpb25WaWV3RWxlbTogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgc2VsZWN0aW9uIGlzID4gbWF4IHNlbGVjdGlvbiwgdGhlbiBzaG93IGhpZGUgbGluay5cbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVMaW5rOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBlbGVtZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHJpdmF0ZSBfZGVmYXVsdERTOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnBsYWNlSG9sZGVyKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5wbGFjZUhvbGRlciA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLnBsYWNlSG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnBsYWNlSG9sZGVyID0gJ1NlYXJjaCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5oaWRlTGluayA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLmhpZGVTZWxlY3Rpb24nKTtcbiAgICAgICAgdGhpcy5oaWRlTGluayA9ICdIaWRlJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRhdGFTb3VyY2UpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuX2RlZmF1bHREUztcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbCkgJiYgaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodGhpcy5mb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG5cblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIFNlYXJjaCBpY29uIGluIGNhc2Ugb2YgbXVsdGlzZWxlY3QuXG4gICAgICogdG9kbzogT25jZSBQcmltZU5HIHdpbGwgcHJvdmlkZSBhIHRlbXBsYXRlIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IgcmVtb3ZlIGl0XG4gICAgICpcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbicpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoc2VhcmNoSW5wdXQpKSB7XG4gICAgICAgICAgICBsZXQgaWNvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSAnc2VhcmNoLWljb24tcmlnaHQgZmEgZmEtZncgZmEtc2VhcmNoJztcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25BcHBlbmRUbykgJiYgaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uVmlld0VsZW0pKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWxlbSA9IHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8gaW5zdGFuY2VvZiBFbGVtZW50UmVmID9cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvO1xuXG4gICAgICAgICAgICBwYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uVmlld0VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNoYW5nZSBjdXJyZW50IGJlaGF2aW9yIHNpbmNlIHdlIHdhbnQgdG8gc2hvdyBzZWxlY3Rpb24gdW5kZXIgdGhlIGNob29zZXIuIEtcbiAgICAgKlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZSAudWktYXV0b2NvbXBsZXRlLXRva2VuJyk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW5zKSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9rZW5zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiB2YWx1ZSBpcyBlbnRlcmVkIGludG8gc2VhcmNoIGJveCwgd2UgYXNrIG91ciBEYXRhU291cmNlIHRvIG1hdGNoIHRoaXMgcGF0dGVyblxuICAgICAqIGFnYWluc3QgZGF0YSByZXBvc2l0b3J5LiBJdCB3aWxsIHJldHJpZXZlIGFsbCBwb3NzaWJsZSBtYXRjaGVzIGxpbWl0ZWQgYnkgTWF4TGVuIGFuZCB0aGlzXG4gICAgICogaXMgYWdhaW4gZmlsdGVyZWQgc28gaXQgZG9lcyBub3QgaW5jbHVkZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogIHRoZSBtYXRjaGVkIHJlc3VsdGVkIGlzIHNhdmVkIGluIHRoZTogdGhpcy5kYXRhU291cmNlLnN0YXRlLm1hdGNoZXNcbiAgICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IG1heExlbiA9IHRoaXMubWF4TGVuZ3RoID8gdGhpcy5tYXhMZW5ndGggOiBDaG9vc2VyRGF0YVNvdXJjZS5NYXhMZW5ndGg7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5maW5kKHBhdHRlcm4sIG1heExlbik7XG5cblxuICAgICAgICAvLyBmaXg6IGZvciB0ZXN0czogSW4gdmVyc2lvbiA0IHdlIG5lZWQgdG8gZXhwbGljaXRseSBmb2N1cyBpbnB1dCBvdGhlcndpc2UgYXV0b2NvbXBsZXRlXG4gICAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBhbnkgcG9wdXAgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMuZW52LmluVGVzdCAmJiBpc1ByZXNlbnQodGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c0lucHV0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW52b2tlZCBieSBEcm9wZG93biBidXR0b24gaW4gY2FzZSBvZiBzaW5nbGUgc2VsZWN0IGFuZCBoZXJlIHdlIHdhbnQgdG8gaW52b2tlIG1hdGNoXG4gICAgICogdG8gcmV0cmlldmUgYWxsIHN1Z2dlc3Rpb25zIHdpdGhvdXQgYW55IGZpbHRlclxuICAgICAqXG4gICAgICovXG4gICAgb25Ecm9wZG93bkNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXRjaCgnKicpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goJyonKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENob29zZXIgc3RhdGUgaXMgdXBkYXRlZCAgd2l0aCB1c2VyIHNlbGVjdGlvbi4gUGxlYXNlIHNlZSB3cml0ZVZhbHVlLiBXaGVuIGRvIG5vdCBuZWVkXG4gICAgICogY2FsbCBhbnl0aGluZyBhZGRpdGlvbmFsIGFzIGludGVybmFsQ2hvb3Nlck1vZGVsIGFuZCB0aGlzLmNob29zZXJTdGF0ZS5zZWxlY3RlZE9iamVjdHMoKVxuICAgICAqIHNoYXJlcyB0aGUgc2FtZSByZWZlcmVuY2VzIHNvIGl0cyBpbXBvcnRhbnQgdGhhdCB3ZSBmaXJzdCBzYXZlIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoaXMuY2hvb3NlclN0YXRlLnNlbGVjdGVkT2JqZWN0cygpIGFuZCB0aGVuIGJhY2sgdG8gaW50ZXJuYWxDaG9vc2VyTW9kZWxcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuaW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlID1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlJdGVtKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVuc2VsZWN0IGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZVZhbHVlKGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzSW5wdXQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDb252ZXJ0IGEgb2JqZWN0IGlmIGFueSBpbnRvIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIHRvZG86IGltcGxlbWVudCBiZXR0ZXIgd2F5IGhvdyB0byB3b3JrIHdpdGggb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheUl0ZW0oaXRlbTogYW55KSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuY3VycmVudEl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UubG9va3VwS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5kYXRhU291cmNlLmxvb2t1cEtleV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBsYWJlbCB0aGF0IGlzIHNob3duIHVuZGVyIHRoZSBzZWxlY3RlZCBpdGVtIHdoZW4gdXNlciBzZWxlY3Rpb24gaXMgPlxuICAgICAqIE1heFJlY2VudFNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3JlU2VsZWN0U3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBtb3JlU2VsZWN0ZWQgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoIC1cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZERpc3BsYXllZDtcbiAgICAgICAgaWYgKG1vcmVTZWxlY3RlZCA8IDIgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUxpbms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vcmVTZWxlY3RlZH0gbW9yZSBzZWxlY3RlZC4uLmA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIG9mIG11bHRpc2VsZWN0ID0gZmFsc2UgY2hlY2sgaWYgd2Ugd2FudCB0byBzaG93IGEgc2VsZWN0ZWQgdmFsdWUgaW5zaWRlIHRoZSBpbnB1dFxuICAgICAqIGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBzaW5nbGVWYWx1ZVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlLnN0YXRlLmN1cnJlbnRJdGVtKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlO1xuICAgIH1cblxuICAgIGhhc01lbnVUZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1lbnVUZW1wbGF0ZSk7XG4gICAgfVxuXG5cbiAgICBoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblRlbXBsYXRlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICogQXMgd2UgYXJlIHVzaW5nIERhdGFTb3VyY2UgaW50ZXJuYWxseSBmb3IgWyhuZ01vZGVsKV0gY2FzZSB3ZSBuZWVkIHRvIGRlZmZlciBEYXRhU291cmNlXG4gICAgICogaW5pdGlhbGl6YXRpb24gb25jZSB3ZSBoYXZlIGEgdmFsdWUgYW5kIHdlIG9ubHkgYWNjZXB0IFtdXG4gICAgICpcbiAgICAgKlxuICAgICAqID8gU2hvdWxkIHdlIGRvIHNvbWUgZGVlcGVyIGNvbXBhcmlzaW9uP1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxTdGF0ZTogRGVmYXVsdFNlbGVjdGlvblN0YXRlID0gbmV3IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSh0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIGxldCBjaFN0YXRlOiBDaG9vc2VyU3RhdGUgPSBuZXcgQ2hvb3NlclN0YXRlKHNlbFN0YXRlLCB0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoY2hTdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG4gICAgfVxuXG4gICAgaW5pdERhdGFzb3VyY2UoY2hvb3NlclN0YXRlPzogQ2hvb3NlclN0YXRlKTogdm9pZCB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSxcbiAgICAgICAgICAgICdZb3UgbmVlZCB0byBwcm92aWRlIGRlc3RpbmF0aW9uQ2xhc3Mgb3IgY3VzdG9tIERhdGFTb3VyY2UnKTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICBvYmo6IHRoaXMuZGVzdGluYXRpb25DbGFzcyxcbiAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgbG9va3VwS2V5OiB0aGlzLmZpZWxkLFxuICAgICAgICAgICAgc3RhdGU6IGNob29zZXJTdGF0ZSxcbiAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBuZ09uSW5pdCBhbmQgV3JpdGUgdmFsdWUgdG8gcmVhZCBzdGF0ZSBmcm9tIENob29zZXJTdGF0ZSBhbmQgc2V0IGl0IHRvIGludGVybmFsXG4gICAgICogbmdNb2RlbCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0SW50ZXJuYWxNb2RlbCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaG9vc2VyQ29tcG9uZW50fSBmcm9tICcuL2Nob29zZXIuY29tcG9uZW50JztcbmltcG9ydCB7QXV0b0NvbXBsZXRlTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi4vaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hvb3Nlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtTZWxlY3RJdGVtfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqIEEgcG9wdXAgbGlrZSBjb21wb25lbnQgcmVuZGVyaW5nIGxpc3Qgb2YgdmFsdWVzIGFzLiBCYXNlZCBvbiBQcmltZU5HIGNvbXBvbmVudCBhbmQgb25lIG9mIHRoZVxuICogbWFpbiByZWFzb24gd2h5IHdlIG5lZWQgdG8gd3JhcCB0aGlzIGlzIHRvIGV4dGVuZCBpdHMgY2FwYWJpbGl0aWVzIHRvIGFjY2VwdCBhbG1vc3QgYW55XG4gKiBkYXRhIHR5cGUgd2l0aG91dCB1c2luZyBQcmltZW5zJ3Mgc3BlY2lmaWMgU2VsZWN0SXRlbSB0eXBlLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3Nob3dEcm9wRG93bicgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1kcm9wZG93biBbbGlzdF09XCJ0ZXN0SXRlbVNtYWxsXCJcbiAqICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPjwvYXctZHJvcGRvd24+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIE15RHJvcENvbXBvbmVudFxuICogIHtcbiAqICAgICAgdGVzdEl0ZW1TbWFsbDogc3RyaW5nW10gPSBbJ3ZpZXcnICwgJ2VkaXQnXTtcbiAqXG4gKiAgICAgIC8vIHdoZW4geW91IHN3aXRjaCBsaXN0IGJpbmRpbmcgdG8gcmVmZXJ0IHRvIGxhcmdlIGl0ZW0gZmlpbHRlciBhdXRvbWF0aWNhbGx5IGlzIHNob3duIGFuZFxuICogICAgIG1heCAxMCBpdGVtcyBhcmVcbiAqICAgICAgLy8gdmlzaWJsZVxuICogICAgICB0ZXN0SXRlbUxhcmdlOiBzdHJpbmdbXSA9IFsndmlldycgLCAnZWRpdCcgLCAnZnJhbmsnICwgJ2tvbGFyJyAsICdUaGUgU3VuJyAsICdEb2cnICxcbiAqICAgICAnQ29tcHV0ZXInICwgJ0EgRGVzaycgLFxuICogICAgICAnTXkgQ2FyJyAsICdQZW5jaWwnICwgJ1RoaXMgUGFnZScgLCAnWWVzdGVyZGF5JyAsICdNb25kYXknICwgJ1R1ZXNkYXknICwgJ0JNVyBSMTIwMCBHUycgLFxuICogICAgICdDemVjaCBSZXB1YmxpYycgLFxuICogICAgICAnTGFzdCBJdGVtJ107XG4gKlxuICpcbiAqICAgICAgaXRlbVNlbGVjdGVkOiBzdHJpbmcgPSAndmlldyc7XG4gKiAgICAgIGl0ZW1TZWxlY3RlZExnOiBzdHJpbmcgPSAnTW9uZGF5JztcbiAqXG4gKiAgICAgIG5vc2VsU3RyaW5nOiBzdHJpbmcgPSAnKG5vIHNlbGVjdGlvbiknO1xuICpcbiAqXG4gKiAgICAgIG9uU2VsZWN0aW9uIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgdGhpcy5pdGVtU2VsZWN0ZWQgPSBldmVudDtcbiAqXG4gKiAgICAgIH1cbiAqICB9XG4gKlxuICogIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBERF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcGRvd25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHJvcGRvd24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctZHJvcGRvd25cIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzU3RhbmRhbG9uZVwiPlxuICAgICAgICA8cC1kcm9wZG93biBbb3B0aW9uc109XCJpbnRlcm5hbExpc3RcIlxuICAgICAgICAgICAgICAgICAgICBbZm9ybUNvbnRyb2xOYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwibm9TZWxlY3Rpb25TdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbYXV0b1dpZHRoXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJzaG93RmlsdGVyKClcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25JdGVtU2VsZWN0aW9uKCRldmVudClcIj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtIHBUZW1wbGF0ZT1cIml0ZW1cIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cbiAgICAgICAgICAgICAgICAgICAge3tpdGVtLmxhYmVsIH19XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cIml0ZW1UZW1wbGF0ZVwiIFtpdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cblxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICAgICAgPC9wLWRyb3Bkb3duPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L2Rpdj5cblxuXG48IS0tIG5vIGZvcm1Db250cm9sIE5hbWUgaGVyZS4gbmdNb2RlbCBjYW5ub3QgaGF2ZSBmb3JtR3JvdXAgYXJvdW5kIC0tPlxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc1N0YW5kYWxvbmVcIj5cbiAgICA8ZGl2IGNsYXNzPVwidy1kcm9wZG93blwiPlxuICAgICAgICA8cC1kcm9wZG93biBbb3B0aW9uc109XCJpbnRlcm5hbExpc3RcIlxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJub1NlbGVjdGlvblN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvV2lkdGhdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cInNob3dGaWx0ZXIoKVwiXG4gICAgICAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkl0ZW1TZWxlY3Rpb24oJGV2ZW50KVwiPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbGV0LWl0ZW0gcFRlbXBsYXRlPVwiaXRlbVwiPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNFbWJlZGRlZFRlbXBsYXRlKCkgJiYgaXRlbUV4aXN0KGl0ZW0pXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7aXRlbS5sYWJlbCB9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiaXRlbVRlbXBsYXRlXCIgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzRW1iZWRkZWRUZW1wbGF0ZSgpICYmIGl0ZW1FeGlzdChpdGVtKVwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3AtZHJvcGRvd24+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24taXRlbXMtd3JhcHBlcnttYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50fS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWl0ZW17cGFkZGluZzouNjVlbSAyZW0gLjY1ZW0gLjY0ZW07bWFyZ2luOjB9L2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24tZmlsdGVyLWNvbnRhaW5lcnt3aWR0aDoxMDAlfS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWZpbHRlci1jb250YWluZXIgLmZhe3RvcDoxLjJlbX0vZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1saXN0e3BhZGRpbmc6MWVtIDB9L2RlZXAvIC53LWRyb3Bkb3duOm5vdCgubmctZGlydHkpIGxhYmVse2NvbG9yOiM5Njk2OTZ9L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi10cmlnZ2VyLnVpLWNvcm5lci1yaWdodHtib3JkZXItbGVmdDpub25lO2NvbG9yOiM5Njk2OTZ9L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi10cmlnZ2VyIC5waXtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6Izc2NzY3NjtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS40ZW07bWFyZ2luLWxlZnQ6LS44NWVtfS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tdHJpZ2dlciAucGktY2FyZXQtZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tbGFiZWx7cGFkZGluZy1yaWdodDoyLjRlbX1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRERfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEcm9wZG93bkNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIHN0YXRpYyByZWFkb25seSBNYXhOdW1TaG93biA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogT3JkZXJlZCBsaXN0IG9mIGl0ZW1zIHJlbmRlcmVkIGFzIGEgcG9wdXAgbWVudVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBJdGVtcyB3aGljaCB3YXMgc2VsZWN0ZWQgYXMgYSBkZWZhdWx0IHZhbHVlIG9yIGJ5IHVzZWQgaW4gdGhlIHBvcHVwIG1lbnUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb246IGFueTtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZW5kZXJlZCBhcyBmaXJzdCB2YWx1ZSBpbiB0aGUgcG9wdXAgd2hpY2ggbGV0IHRoZSB1c2VyIHRvIG1ha2UgJ25vIHNlbGVjdGlvbicgZnJvbVxuICAgICAqIGF2YWlsYWJsZSBsaXN0IG9mIHZhbHVlcy4gV2hlbiB0aGlzIG9wdGlvbiBpcyBhY3RpdmUgYW5kIHVzZSBtYWtlIHRoaXMgc2VsZWN0aW9uIHdlIHNhdmUgYVxuICAgICAqIE5VTEwgdmFsdWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vU2VsZWN0aW9uU3RyaW5nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGludGVybmFsIGxpc3QgdGhhdCBoaWRlcyBQcmltZU5HIHNwZWNpZmljcyB3aGVyZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBzcGVjaWFsXG4gICAgICogdHlwZTogU2VsZWN0SXRlbS4gT3VyIGV4cGVjdGF0aW9uIGlzIHRoYXQgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBwYXNzIHJlZ3VsYXIgc3RyaW5nIHZhbHVlc1xuICAgICAqIG9yIGZ1bGwgb2JqZWN0IGFuZCBub3QgdHJ5aW5nIHRvIHdyYXAgaXQgaW50byBleHRyYSBsYXllci5cbiAgICAgKlxuICAgICAqL1xuICAgIGludGVybmFsTGlzdDogU2VsZWN0SXRlbVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBFbWJlZGRlZCB0ZW1wbGF0ZSBkZWZpbmVkIGJ5IHVzZXIuIElmIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhbnkgdGVtcGxhdGUgYW5kIHdoaWxlIHJlbmRlcmluZ1xuICAgICAqIGl0ZW0gd2UgYXNzdW1lIHdlIGFyZSBkZWFsaW5nIHdpdGggcHJpbWl0aXZlIHR5cGVzIGFuZCBjYWxsIG9uIGVhY2ggaXRlbSB0b1N0cmluZygpLCBpZiB3ZVxuICAgICAqIGFyZSBkZWFsaW5nIHdpdGggb2JqZWN0LCB0aGVuIHdlIGV4cGVjdCB1c2VyIHRvIHByb3ZpZGUgYSB0ZW1wbGF0ZSBhbmQgdGVsbCB0aGUgZHJvcGRvd24gb2ZcbiAgICAgKiBlYWNoIGl0ZW0gc2hvdWxkIGJlIGhhbmRsZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2l0ZW1UZW1wbGF0ZScpXG4gICAgaXRlbVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCB1c2VkIGZvciBlbWJlZGRlZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIG1vZGVsOiBTZWxlY3RJdGVtO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZG86IFB1dCBiYWNrIHRoZSBzY3JvbGxpbmcgb3B0aW9uIG9uY2Ugd2UgZGVjaWRlIHNvLiBDdXJyZW50bHkgdGhlIHJlcXVpcmVtZW50cyBhcmVcbiAgICAgKiBzaG93IG9ubHkgMTAgaXRlbXMgbWF4LCBubyBzY3JvbGxpbmcuIEZ1bmN0aW9uYWxpdHkgY29tbWVudGVkIG91dCBjYW4gc2hvdyBzY3JvbGxiYXIgd2l0aFxuICAgICAqIHNlYXJjaCBmaWx0ZXIuXG4gICAgICovXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIGEgdmFsdWUgdG8gUHJpbWVOZyBGb3JtYXQsIHdlIGFyZSBub3QgcmVhbGx5IGJlIHVzaW5nIGEgbGFiZWwgZmllbGQgb25seSBhXG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IFtdO1xuICAgICAgICAvLyBpZiAoaXNQcmVzZW50KHRoaXMubm9TZWxlY3Rpb25TdHJpbmcpKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmludGVybmFsTGlzdC5wdXNoKHtcbiAgICAgICAgLy8gICAgICAgICBsYWJlbDogdGhpcy5ub1NlbGVjdGlvblN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMubm9TZWxlY3Rpb25TdHJpbmc7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgdGhpcy5saXN0Lmxlbmd0aCA+PSBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bikge1xuXG4gICAgICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IHRoaXMubGlzdC5zbGljZSgwLCBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bikubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogaXRlbS50b1N0cmluZygpLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3Quc2xpY2UoMCkubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogaXRlbS50b1N0cmluZygpLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaGFzRW1iZWRkZWRUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuaXRlbVRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBwcmV2ZW50IEVtcHR5IGl0ZW0gdG8gYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqIHRvZG86IFJlcG9ydCB0aGlzIG9uIFByaW1lTmdcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW1FeGlzdChpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGl0ZW0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkcm9wZG93biBsaXN0IGlzIG1vcmUgdGhlbiBkZWZpbmVkIGNvbnN0YW50IE1heE51bVNob3duICgxMCkgYXV0b21hdGljYWxseSBzaG93IGZpbHRlclxuICAgICAqIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgc2hvd0ZpbHRlcigpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHJldHVybiBpc1ByZXNlbnQodGhpcy5saXN0KSAmJiB0aGlzLmxpc3QubGVuZ3RoID4gRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGVzIGludGVybmFsIG1vZGVscyBvZiBjdXJyZW50IHNlbGVjdGlvbnMgYW5kIHRyaWdnZXJzIG9uU2VsZWN0aW9uIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBvbkl0ZW1TZWxlY3Rpb24odmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWUudmFsdWU7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh2YWx1ZS52YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHZhbHVlLnZhbHVlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5SXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGl0ZW0pID8gaXRlbS5sYWJlbCA6ICdObyBTZWxlY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIWVxdWFscyh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24pKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Ryb3Bkb3duQ29tcG9uZW50fSBmcm9tICcuL2Ryb3Bkb3duLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Ryb3Bkb3duTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEcm9wZG93bk1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudCwgVmFsdWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cbi8qKlxuICogTGlnaHR3ZWlnaHQgYW5kIGNvbmZpZ3VyYWJsZSBDdXJyZW5jeSBjb21wb25lbnQgYmFzZWQgb24gdGhlIG5nIGJvb3RzdHJhcCBkaXJlY3RpdmUuIFRoaXNcbiAqIGNvbXBvbmVudCBjb21iaW5lcyBhbiBpbnB1dCBhbmQgY3VycmVuY3kgY29kZSBkcm9wZG93bi5cbiAqXG4gKlxuICogZm9yIG1vcmUgaW5mbyBwbGVhc2Ugc2VlIGNsYXNzIERvYyBvZiB0aGU6XG4gKiAgQHNlZSB7QGxpbmsgY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnYW1vdW50JyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgPGF3LWN1cnJlbmN5IFttb25leV09XCJwcmljZVwiIFtjdXJyZW5jaWVzXT1cImN1cnJlbmNpZXNcIiBbbmFtZV09XCInY3VycmVuY3knXCI+XG4gKiAgICAgIDwvYXctY3VycmVuY3k+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGFtb3VudDogbnVtYmVyID0gMTAwMDtcbiAqICAgICAgICBjdXJyZW5jaWVzOiBzdHJpbmdbXSA9IFsnVVNEJywgJ0NOWScsICdBVUQnLCAnRVVSJywgJ0dCUCddO1xuICogICAgICAgIGN1cnJlbmN5Q29kZTogc3RyaW5nID0gdGhpcy5jdXJyZW5jaWVzWzBdO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cblxuZXhwb3J0IGNvbnN0IENVUlJFTkNZX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXJyZW5jeUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jdXJyZW5jeScsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGVcIj5cbiAgICA8ZGl2IGNsYXNzPVwidy1jdXJyZW5jeS1maWVsZCB1aS1mbHVpZFwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nIFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctOCB1aS1nLW5vcGFkIFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCAjY3VycmVuY3lJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICBwSW5wdXRUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ3LXRleHQtZmllbGQgY3VycmVuY3ktZm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGZvY3VzKT1cIm9uRm9jdXMoY3VycmVuY3lJbnB1dClcIlxuICAgICAgICAgICAgICAgICAgICAgICAoYmx1cik9XCJvbkJsdXIoY3VycmVuY3lJbnB1dClcIlxuICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctNCB1aS1nLW5vcGFkIHctY2MtZmllbGRcIj5cbiAgICAgICAgICAgICAgICA8YXctZHJvcGRvd24gKm5nSWY9XCIhcmVhZG9ubHlDdXJyZW5jeUNvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCIgW2xpc3RdPVwiY3VycmVuY2llc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwibW9uZXkuY3VycmVuY3lcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuXG4gICAgICAgICAgICAgICAgPC9hdy1kcm9wZG93bj5cbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwicmVhZG9ubHlDdXJyZW5jeUNvZGVcIiBjbGFzcz1cInctY2MtcmVhZG9ubHktZmllbGRcIj57e21vbmV5LmN1cnJlbmN5fX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gY3VycmVuY3k6J1VTRCc6dHJ1ZSAtLT5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgdmFsdWU9XCJ7e2Rpc3BsYXlWYWx1ZX19IHt7IGdldE1vbmV5Q3VycmVuY3koKSB9fVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWN1cnJlbmN5LWZpZWxkIFtyZWFkb25seV0sLnctY3VycmVuY3ktdHlwZS1maWVsZCBbcmVhZG9ubHlde2JhY2tncm91bmQtY29sb3I6I2ZmZn0udy1jdXJyZW5jeS1maWVsZCBpbnB1dCwudy1jdXJyZW5jeS10eXBlLWZpZWxkIGlucHV0e21pbi13aWR0aDo4MHB4fS53LWN1cnJlbmN5LWZpZWxkIGkuZmEsLnctY3VycmVuY3ktdHlwZS1maWVsZCBpLmZhe2N1cnNvcjpwb2ludGVyfS53LWN1cnJlbmN5LWZpZWxke21hcmdpbi10b3A6MH0udy1jdXJyZW5jeS1maWVsZCAvZGVlcC8gLnVpLWRyb3Bkb3due21pbi13aWR0aDo4MHB4fS53LWNjLWZpZWxke2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnctY2MtcmVhZG9ubHktZmllbGR7cGFkZGluZy1sZWZ0OjVweDtjb2xvcjojOTY5Njk2fS5uby1ndXR0ZXI+W2NsYXNzKj11aS1nLV17cGFkZGluZy1yaWdodDowO3BhZGRpbmctbGVmdDowfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDVVJSRU5DWV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1cnJlbmN5Q29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgQ3VycmVuY3lDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIE1vbmV5IG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB2YWx1ZSwgbG9jYWxlLCBjdXJyZW5jeSBjb2RlLlxuICAgICAqIElmIHRoaXMgb2JqZWN0IGlzIHNldCwgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbW9uZXk6IE1vbmV5O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB1c2VyIHRvIGNoYW5nZSBNb25leSdzIGN1cnJlbmN5IGNvZGUgYW5kIHN0aWxsXG4gICAgICogYWxsb3cgdXNlciB0byBlZGl0IE1vbmV5J3MgYW1vdW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVhZG9ubHlDdXJyZW5jeUNvZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW5jeSB0aGF0J3Mgc2VsZWN0ZWQgZm9yIHRoaXMgY3VycmVuY3kgZmllbGQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW5jeVNlbGVjdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHVzZWQgdG8gZm9ybWF0IHRoZSBtb25leSBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjdXJyZW5jaWVzIHRoYXQgdGhpcyBjdXJyZW5jeSB3aWRnZXQgc3VwcG9ydC4gVGhlIGZvcm1hdCBmb3IgZWFjaCBlbnRyeSBzaG91bGQgYmVcbiAgICAgKiBbY3VycmVuY3ktY29kZSAtIGRlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIF9jdXJyZW5jaWVzOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZS4gVXNlcyBhbmd1bGFyIGN1cnJlbmN5UGlwZSB0byBmb3JtYXQgYmFzZWQgb24gY291bnRyeSBjb2RlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbmN5IHBpcGUgaXMgdXNlZCB0byBmb3JtYXQgb3VyIG1vbmV5IG9iamVjdC5cbiAgICAgKi9cbiAgICBjdXJyZW5jeVBpcGU6IEN1cnJlbmN5UGlwZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGN1cnJlbmNpZXMuXG4gICAgICAgIHRoaXMuaW5pdEN1cnJlbmNpZXMoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbmN5UGlwZSA9IG5ldyBDdXJyZW5jeVBpcGUoZW52LmxvY2FsZSk7XG5cbiAgICAgICAgZW52Lm9uTG9jYWxlQ2hhbmdlLnN1YnNjcmliZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lQaXBlID0gbmV3IEN1cnJlbmN5UGlwZShsb2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbmV5LmFtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLm1vbmV5KTtcblxuICAgICAgICB0aGlzLmluaXRDdXJyZW5jaWVzKCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jdXJyZW5jeVNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLl9jdXJyZW5jaWVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVhZHkgdGhlIG1vbmV5IGZpZWxkIGlmIGl0IGV4aXN0cy4gYW5kIG92ZXJyaWRlIHRoZSBleGlzdGluZyB2YWx1ZXMuXG4gICAgICAgIGlmICh0aGlzLm1vbmV5KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5tb25leS5jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9uZXkgPSBuZXcgTW9uZXkobnVsbCwgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBpbml0Q3VycmVuY2llcygpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbmNpZXMgfHwgdGhpcy5fY3VycmVuY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSBbJ1VTRCcsICdDTlknLCAnQVVEJywgJ0VVUicsICdHQlAnXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSB0aGUgcmVhbCB2YWx1ZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBpbiB0aGUgY3VycmVuY3kgd2lkZ2V0LiBUaGVuIGhlIGNhbiBtb2RpZnkgdGhlXG4gICAgICogdmFsdWUgd2l0aG91dCBzZWVpbmcgdGhlIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBvbkZvY3VzKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpICYmIGlzUHJlc2VudCh0aGlzLm1vbmV5LmFtb3VudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5tb25leS5hbW91bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZSB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyBhd2F5LlxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqL1xuICAgIG9uQmx1cihlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5tb25leSA9IHRoaXMubW9uZXkuY2xvbmUoe2Ftb3VudDogTnVtYmVyKGVsLnZhbHVlKX0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb25leSk7XG4gICAgfVxuXG4gICAgb25TZWxlY3Rpb24oY3VycmVuY3k6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSBjdXJyZW5jeTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2lsbCBjaGVjayB0byBzZWUgaWYgY3VycmVuY3kgaXMgYSB2YWxpZCBudW1iZXIgYmVmb3JlIGZvcm1hdHRpbmcuXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuICAgIHByaXZhdGUgZm9ybWF0Q3VycmVuY3kodmFsOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICghdmFsIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlID0gJ1VTRCc7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbmN5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9uZXkgPSB0aGlzLm1vbmV5LmNsb25lKHtjdXJyZW5jeTogdGhpcy5jdXJyZW5jeVNlbGVjdGlvbn0pO1xuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBwcmVjaXNpb24gaXMgMi4gRm9yIGV4YW1wbGUsIDEwLjIzIFVTRC5cbiAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgbW9uZXkgdmFsdWUgZm9yIGRpc3BsYXkuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wcmVjaXNpb24pKSB7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVBpcGUudHJhbnNmb3JtKHZhbCwgY29kZSwgJ3N5bWJvbCcsIGRpZ2l0cyk7XG4gICAgfVxuXG4gICAgZ2V0TW9uZXlDdXJyZW5jeSgpOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGlzcGxheVZhbHVlKSAmJiB0aGlzLmRpc3BsYXlWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgY3VycmVuY2llcygpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbmNpZXM7XG4gICAgfVxuXG4gICAgc2V0IGN1cnJlbmNpZXModmFsdWU6IGFueVtdKVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgTW9uZXkpICYmICFlcXVhbHModmFsdWUsIHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vbmV5ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkuY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMubW9uZXkuY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vbmV5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBNb25leSBvYmplY3QgaXMgcmVwcmVzZW50ZWQgYXMgYSB2YWx1ZSwgbG9jYWxlLCBhbmQgY3VycmVuY3lDb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25leSBpbXBsZW1lbnRzIFZhbHVlXG57XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCwgcHVibGljIHJlYWRvbmx5IGN1cnJlbmN5OiBzdHJpbmcgPSAnVVNEJyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKVxuICAgIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLFxuICAgICAgICAgICAgY3VycmVuY3k6IFN0cmluZyxcbiAgICAgICAgICAgIGxvY2FsZTogU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3NOYW1lKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuICdNb25leSc7XG4gICAgfVxuXG4gICAgJHByb3RvKCk6IE1vbmV5XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IE1vbmV5KDEsICcyMycsICczMycpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50ICsgJywgbG9jYWxlOiAnICsgdGhpcy5sb2NhbGUgKyAnLCBjb2RlOiAgJyArIHRoaXMuY3VycmVuY3k7XG4gICAgfVxuXG5cbiAgICBjbG9uZShkYXRhOiB7IGFtb3VudD86IG51bWJlciwgY3VycmVuY3k/OiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyB9ID0ge30pOiBNb25leVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25leShcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmFtb3VudCkgPyBkYXRhLmFtb3VudCA6IHRoaXMuYW1vdW50LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuY3VycmVuY3kpID8gZGF0YS5jdXJyZW5jeSA6IHRoaXMuY3VycmVuY3ksXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICApO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlLCBDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Ryb3Bkb3duTW9kdWxlLCBJbnB1dFRleHRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0N1cnJlbmN5Q29tcG9uZW50fSBmcm9tICcuL2N1cnJlbmN5LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtDdXJyZW5jeVBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ3VycmVuY3lNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc0RhdGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBMaWdodHdlaWdodCBhbmQgY29uZmlndXJhYmxlIERhdGUgYW5kIFRpbWUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwcmltZW5nLiBUaGlzXG4gKiBjb21wb25lbnQgY29tYmluZXMgYm90aCBkYXRlIHBpY2tlciBhcyB3ZWxsIGFzIHRpbWUgcGlja2VyXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXlUaW1lcicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiAgW25hbWVdPVwiJ2R1ZURhdGUnXCI+XG4gKiAgICA8L2F3LWRhdGUtdGltZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15VGltbWVyQ29tcG9uZXRcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKlxuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCB5b3Ugd2lsbCBzZWUgZGF0ZSBmaWVsZCBhbmQgdGltZSBmaWVsZCBpcyBoaWRkZW4gdG8gc2hvdyBib3RoIHlvdSBqdXN0IGRvIGZvbGxvd2luZzpcbiAqXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteVRpbWVyJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgIFtuYW1lXT1cIidiYmRkJ1wiPlxuICogICAgPC9hdy1kYXRlLXRpbWU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVRpbW1lckNvbXBvbmV0XG4gKiAgICB7XG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKiAgICAgICAgc2hvd1RpbWUgPSB0cnVlO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cblxuXG5leHBvcnQgY29uc3QgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVBbmRUaW1lQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kYXRlLXRpbWUnLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidy1kYXRldGltZSBcIiBbY2xhc3MuaGFzLXRpbWVdPVwic2hvd1RpbWVcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuXG4gICAgICAgIDxwLWNhbGVuZGFyIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgICAgICAgICAgICAgW2RlZmF1bHREYXRlXT1cImRlZmF1bHREYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dJY29uXT1cInNob3dJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdD1cInt7c2hvd1RpbWUgPyBmb3JtYXROYW1lV2l0aFRpbWUgOiBmb3JtYXRQYXR0ZXJufX1cIlxuICAgICAgICAgICAgICAgICAgICBbeWVhck5hdmlnYXRvcl09XCJzaG93TmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFttb250aE5hdmlnYXRvcl09XCJzaG93TmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFt5ZWFyUmFuZ2VdPVwieWVhclJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e3Nob3dUaW1lID8gZm9ybWF0TmFtZVdpdGhUaW1lLnRvVXBwZXJDYXNlKCkgOiBmb3JtYXRQYXR0ZXJuLnRvVXBwZXJDYXNlKCl9fVwiXG4gICAgICAgICAgICAgICAgICAgIChvblNlbGVjdCk9XCJvbkRhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aW1lT25seV09XCIhc2hvd0RhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHlJbnB1dF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvY2FsZV09XCJpMThuXCI+XG4gICAgICAgIDwvcC1jYWxlbmRhcj5cblxuICAgICAgICA8cC1jYWxlbmRhciAqbmdJZj1cInNob3dUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj1cImljb24taGlzdG9yeVwiXG4gICAgICAgICAgICAgICAgICAgIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgICAgICAgICAgICAgW2hvdXJGb3JtYXRdPVwiaG91ckZvcm1hdFwiXG4gICAgICAgICAgICAgICAgICAgIFtkZWZhdWx0RGF0ZV09XCJkZWZhdWx0RGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93SWNvbl09XCJzaG93SWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFt0aW1lT25seV09XCJzaG93VGltZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93VGltZV09XCJzaG93VGltZVwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJ0aW1lUGxhY2VIb2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICAob25TZWxlY3QpPVwib25EYXRlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbbG9jYWxlXT1cImkxOG5cIj5cbiAgICAgICAgPC9wLWNhbGVuZGFyPlxuXG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyB2YWx1ZT1cInt7dmFsdWUgfCBkYXRlOiBmb3JtYXRQYXR0ZXJuTkd9fVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudy1kYXRldGltZSAudWktY2FsZW5kYXIgYnV0dG9ue2JvcmRlcjowO3dpZHRoOjB9L2RlZXAvIC53LWRhdGV0aW1lIC51aS1jYWxlbmRhci51aS1jYWxlbmRhci13LWJ0biAudWktaW5wdXR0ZXh0e3dpZHRoOjEwMCV9L2RlZXAvIC51aS1jYWxlbmRhciAudWktY2FsZW5kYXItYnV0dG9uIC51aS1idXR0b24taWNvbi1sZWZ0e2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojMTk5ZGUwO2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjRlbX0vZGVlcC8gLnVpLWNhbGVuZGFyIC51aS1jYWxlbmRhci1idXR0b24gLnVpLWJ1dHRvbi1pY29uLWxlZnQucGktY2FsZW5kYXI6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMGUwJ30vZGVlcC8gLnVpLWNhbGVuZGFyIC51aS1jYWxlbmRhci1idXR0b24gLnVpLWJ1dHRvbi1pY29uLWxlZnQuaWNvbi1oaXN0b3J5OmJlZm9yZXtjb250ZW50OidcXFxcZTAyZCd9L2RlZXAvIC51aS1kYXRlcGlja2Vye3dpZHRoOjI0LjI4ZW07bGluZS1oZWlnaHQ6MjVweDtwYWRkaW5nOjA7Ym9yZGVyLWNvbG9yOiM5Nzk3OTc7Ym94LXNoYWRvdzpub25lfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1oZWFkZXJ7cGFkZGluZzouOTJlbSAwO2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojMDAwO2ZvbnQtc2l6ZToxZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLW5leHQsL2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLXByZXZ7dG9wOjFlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItcHJldntsZWZ0Oi4yZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLW5leHR7cmlnaHQ6LjJlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGFibGV7Zm9udC1zaXplOjFlbTttYXJnaW46MCAwIDEuNWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0aHtmb250LXdlaWdodDo0MDA7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjO2NvbG9yOiMzNjM2MzY7cGFkZGluZzouNzg2ZW0gMS4wN2VtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0ZHtwYWRkaW5nOi4xZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIHRkIGF7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6Mi43ZW07aGVpZ2h0OjIuN2VtO2xpbmUtaGVpZ2h0OjIuN2VtO3BhZGRpbmc6MDtib3JkZXItcmFkaXVzOjUwJX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGQgYS51aS1zdGF0ZS1kZWZhdWx0e2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudH0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGQgYS51aS1zdGF0ZS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMTk5ZGUwO2NvbG9yOiNmZmZ9L2RlZXAvIC51aS1kYXRlcGlja2VyIC5waXtmb250LXNpemU6MWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciAucGkucGktY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OidcXFxcZTFlZSd9L2RlZXAvIC51aS1kYXRlcGlja2VyIC5waS5waS1jaGV2cm9uLXJpZ2h0OmJlZm9yZXtjb250ZW50OidcXFxcZTFlZCd9L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkOm5vdCgudWktc3RhdGUtZGlzYWJsZWQpIGE6aG92ZXJ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtY29sb3I6cmdiYSgyNSwxNTcsMjI0LC43KTtvcGFjaXR5Oi43NTtjb2xvcjojMzYzNjM2fS9kZWVwLyAudWktZGF0ZXBpY2tlci10aW1lb25seXt3aWR0aDoxMDAlfS9kZWVwLyAudWktdGltZXBpY2tlcntmb250LXNpemU6MS4xNGVtO2NvbG9yOiM3Njc2NzY7Zm9udC13ZWlnaHQ6NDAwfS9kZWVwLyAudWktdGltZXBpY2tlciAucGl7Zm9udC1zaXplOjFlbX0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnBpLnBpLWNoZXZyb24tdXA6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWYwJ30vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnBpLnBpLWNoZXZyb24tZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudWktdGltZXBpY2tlcj5kaXZ7bWFyZ2luLWxlZnQ6MH0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnVpLXNlcGFyYXRvcnt3aWR0aDouMWVtO21pbi13aWR0aDouMWVtfS9kZWVwLyAudWktdGltZXBpY2tlciAudWktc2VwYXJhdG9yIC5waXtmb250LXNpemU6MH0vZGVlcC8gLnVpLWRhdGVwaWNrZXItdHJpZ2dlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS9kZWVwLyAudWktZGF0ZXBpY2tlci10cmlnZ2VyLnVpLWJ1dHRvbjplbmFibGVkOmhvdmVyLC9kZWVwLyAudWktZGF0ZXBpY2tlci10cmlnZ2VyLnVpLWJ1dHRvbjpmb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS9kZWVwLyAuaGFzLXRpbWV7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDpub3dyYXB9L2RlZXAvIC5oYXMtdGltZSBwLWNhbGVuZGFyOmZpcnN0LWNoaWxke3dpZHRoOjU1JTttYXJnaW4tcmlnaHQ6MTRweH0vZGVlcC8gLmhhcy10aW1lIHAtY2FsZW5kYXI6bGFzdC1jaGlsZHt3aWR0aDo0NSV9L2RlZXAvIC5oYXMtdGltZSBwLWNhbGVuZGFyOmxhc3QtY2hpbGQgLnVpLWRhdGVwaWNrZXJ7cGFkZGluZzowfS9kZWVwLyAuaGFzLXRpbWUgLnVpLWJ1dHRvbi1pY29uLWxlZnR7bGluZS1oZWlnaHQ6MThweH1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlQW5kVGltZUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIERhdGVBbmRUaW1lQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTEyOiBzdHJpbmcgPSAnaGg6bW0gYSc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTI0OiBzdHJpbmcgPSAnSEgubW0gYSc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUgdXNlZCB0byBzZXQgdGhlIGRhdGUgYW5kIHRpbWUgcGlja2VyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGF0ZSBmb3JtYXQgcGF0dGVybiB1c2VkIGlmIG5vbmUgaXMgcGFzc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm46IHN0cmluZyA9ICdtbS9kZC95eSc7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgd29ya2Fyb3VuZCBhcyBmb3JtYXR0ZXJzIGluIHRoZSBwcmltZU5HIGFuZCBhbmd1bGFyIGFyZSBkaWZmZXJlbnQgc28gdW50aWwgaXRzXG4gICAgICogZml4ZWQgd2UgbmVlZCB0byBrZWVwIHRoaXMgZXh0cmEgcGF0dGVybi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm5ORzogc3RyaW5nID0gJ01NL2RkL3l5JztcblxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYW5kIGhpZGVzIG5hdmlnYXRpb24gYmFyIHdpdGggeWVhciBhbmQgbW9udGhzIHNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFllYXIgcmFuZ2UgZGlzcGxheWVkIGZvciB0aGUgZHJvcCBkb3duLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgeWVhclJhbmdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhbmQgaGlkZXMgbmF2aWdhdGlvbiBiYXIgd2l0aCB5ZWFyIGFuZCBtb250aHMgc2VsZWN0aW9uc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0ljb246IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRpbWVwaWNrZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUaW1lOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBEYXRlUGlja2VyLiBFdmVuIHdlIGNhbiBoaWRlIGl0LiBpdCBzaG91bGQgYmUgZm9yIG1vc3Qgb2YgdGhlIGNhc2UgYWx3YXlzXG4gICAgICogdHJ1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0RhdGU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkYXRlIHBpY2tlciB3aGF0IGZvcm1hdCBpdCBzaG91bGQgdXNlIHdoZW4gcHJlc2VudGluZyB0aW1lLiBXaGVuIGhvdXJGb3JtYXQgaXMgMTIsXG4gICAgICogaXQgc2hvd3MgdGhlIEFNLCBQTVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBob3VyRm9ybWF0OiBzdHJpbmcgPSAnMjQnO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgZXZlbnQgd2hlbiBzcGVjaWZpYyBkYXRlIGlzIGNsaWNrZWQgaW5zaWRlIERhdGVQaWNrZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRhdGUgdG8gaGlnaGxpZ2h0IG9uIGZpcnN0IG9wZW5pbmcgaWYgdGhlIGZpZWxkIGlzIGJsYW5rLlxuICAgICAqXG4gICAgICovXG4gICAgZGVmYXVsdERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBEYXRldGltZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgRGF0ZUFuZFRpbWUgZm9ybWF0TmFtZSBpcyBub3QgcHJvcGFnYXRlZFxuICAgICAqIHRvIERhdGUgZmllbGQuXG4gICAgICovXG4gICAgZm9ybWF0TmFtZVdpdGhUaW1lOiBzdHJpbmc7XG5cblxuICAgIGkxOG46IGFueTtcbiAgICB0aW1lUGxhY2VIb2xkZXI6IHN0cmluZyA9ICdoaDpzcyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIGRhdGVUaW1lIHBhdHRlcm4gd2hpY2ggaXMgZGVmaW5lZCBpbiByZXNvdXJjZSBmaWxlc1xuICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ICE9PSAnMTInICYmIHRoaXMuaG91ckZvcm1hdCAhPT0gJzI0Jykge1xuICAgICAgICAgICAgdGhpcy5ob3VyRm9ybWF0ID0gJzI0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZVBsYWNlSG9sZGVyID0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSgodmFsOiBEYXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgdGhpcy5lbnYub25Mb2NhbGVDaGFuZ2Uuc3Vic2NyaWJlKChsb2NhbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gcmVmYWN0b3IgdGhpcyBhcyB0aGlzIHJlYWxseSBnZXQgY29tcGxpY2F0ZWQgdHJ5aW5nIHRvIGNvdmVyIHVzZWNhc2Ugd2l0aCB0aW1lXG4gICAgICogYW5kIGRhdGUgYW5kIGV2ZXJ5IGZvcm1hdCB3ZSBoYXZlLiBXZSBzaG91bGQgcHJvYmFibHkgaGF2ZSBzZXBhcmF0ZSBwYXR0ZXJucyBmb3JcbiAgICAgKiBkYXRlcyBvbmx5IGFuZCBkYXRlICsgdGltZVxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFRyYW5zbGF0aW9ucygpIHtcblxuICAgICAgICB0aGlzLmZvcm1hdE5hbWVXaXRoVGltZSA9IHRoaXMuZm9ybWF0UGF0dGVybjtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBhdHRlcm5ORyA9IHRoaXMuZm9ybWF0UGF0dGVybiArPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWUpIHtcbiAgICAgICAgICAgIGxldCB0aW1lU3RhcnRzID0gdGhpcy5mb3JtYXRQYXR0ZXJuLmluZGV4T2YoJ2gnKTtcbiAgICAgICAgICAgIGlmICh0aW1lU3RhcnRzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0TmFtZVdpdGhUaW1lID0gdGhpcy5mb3JtYXRQYXR0ZXJuLnN1YnN0cmluZygwLCB0aW1lU3RhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGF0dGVybk5HICs9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgICAgICBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMTJ9YCA6IGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUyNH1gO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLmkxOG4gPSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JyxcbiAgICAgICAgICAgICAgICAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgICAgICAgICBkYXlOYW1lc01pbjogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLFxuICAgICAgICAgICAgICAgICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsXG4gICAgICAgICAgICAgICAgJ05vdicsICdEZWMnXVxuICAgICAgICB9O1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGRhdGVzIGNoYW5nZXMuIEhlcmUgd2UgdXBkYXRlICB0aGlzLnZhbHVlIC0gPiBkYXRlIGFuZCBhbHNvIHVwZGF0ZSB2YWx1ZSBpbnNpZGVcbiAgICAgKiBmb3JtQ29udHJvbGxlclxuICAgICAqXG4gICAgICovXG4gICAgb25EYXRlQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcblxuICAgICAgICBpZiAoaXNCbGFuayhldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHNvbWUgZXJyb3IgP1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlzRGF0ZShldmVudCkgPyBldmVudCA6IG5ldyBEYXRlKGV2ZW50KTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMudmFsdWUsIHtvbmx5U2VsZjogZmFsc2UsIGVtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iLCJpbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDYWxlbmRhck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RGF0ZUFuZFRpbWVDb21wb25lbnR9IGZyb20gJy4vZGF0ZS1hbmQtdGltZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RhdGVBbmRUaW1lTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGlhbG9nIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGlhbG9nQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2ctaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0hlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBkaWFsb2cgaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBEaWFsb2dDb21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRpYWxvZy1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7RGlhbG9nSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWFsb2cgQ29tcG9uZW50IHRoYXQgcHJvdmlkZXMgdGhlIGxvb2sgYW5kIGZlZWwgZm9yIGEgbW9kYWwgZGlhbG9nLiBUaGlzIGNvbXBvbmVudCBoYXMgdGhyZWVcbiAqIHNlY3Rpb25zOiBoZWFkZXIsIGJvZHksIGFuZCBmb290ZXIuIEl0IGNhbiBiZSB1c2VkIGJ5IGl0c2VsZiBvciBleHRlbmRlZC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgcG9wdXAuXG4gKiAgIDEuICBhIHJlZ3VsYXIgZGlhbG9nIGJveCB0aGF0IGhhcyBoZWFkZXIsIGJvZHkgYW5kIGZvb3Rlci4gSXQncyB0aGUgbW9zdCBjdXN0b21pemFibGUuXG4gKiAgIDIuICBhIGNvbmZpcm1hdGlvbiBib3ggaXMgc2ltaWxhciB0byBhIGRpYWxvZyBib3ggYnV0IGhhcyBhY2NlcHQgYW5kIHJlamVjdCBhY3Rpb24gYnV0dG9ucy5cbiAqICAgMy4gIGEgb3ZlcmxheSwgd2hpY2ggaXMgYSB2ZXJ5IGJhc2ljIHBvcHVwIHdpdGggd2hhdCB5b3UgcHV0IGluc2lkZS5cbiAqICAgICAgIEl0IGRvZXNuJ3QgaGF2ZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIGFueSBwb3B1cCBjb21wb25lbnQuXG4gKiAgIDEuICBFaXRoZXIgZGlyZWN0bHkgYnkgdXNpbmcgY29tcG9uZW50LCBhdy1kaWFsb2csIGF3LWNvbmZpcm1hdGlvbiBvciBhdy1vdmVybGF5XG4gKiAgIDIuICBvciB0aGUgTW9kYWxTZXJ2aWNlICBzZXJ2aWNlLm9wZW4oPERpYWxvZ0NvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBEaWFsb2cgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGlzIHVzYWdlIGlzIGEgcXVpY2sgd2F5IHRvIHNob3cgYVxuICogbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5vcGVuPERpYWxvZ0NvbXBvbmVudD4oIERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nIFsodmlzaWJsZSldPVwiZGlzcGxheVwiIFttb2RhbF09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbk9wZW4pPVwib3BlbkFjdGlvbigpXCIgKG9uQ2xvc2UpPVwiY2xvc2VBY3Rpb24oKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZy1oZWFkZXI+RGlhbG9nIEhlYWRlcjwvYXctZGlhbG9nLWhlYWRlcj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaWFsb2cgQm9keTogQ3JlYXRpbmcgYSBkaWFsb2cgdXNpbmcgdGhlIGRpYWxvZyBjb21wb25lbnRcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2ctZm9vdGVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIFtzdHlsZV09XCIncHJpbWFyeSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNsb3NlKClcIj5PSzwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiAoY2xpY2spPVwib3BlbigpXCI+T3BlbiBEaWFsb2c8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpYWxvZ0FjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbkFjdGlvbigpICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nQWN0aW9uID0gXCJvcGVuXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2cnLFxuICAgIHRlbXBsYXRlOiBgPHAtZGlhbG9nIFtoZWFkZXJdPVwidGl0bGVcIiBbKHZpc2libGUpXT1cInZpc2libGVcIlxuICAgICAgICAgIFttb2RhbF09XCJtb2RhbFwiIFtjbG9zYWJsZV09XCJjbG9zYWJsZVwiIFt3aWR0aF09XCJ3aWR0aFwiIFtoZWlnaHRdPVwiaGVpZ2h0XCJcbiAgICAgICAgICBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW2FwcGVuZFRvXT1cImFwcGVuZFRvXCIgKG9uU2hvdyk9XCJvcGVuKClcIiAob25IaWRlKT1cImNsb3NlKClcIj5cblxuICAgIDxwLWhlYWRlciAqbmdJZj1cImhhc0hlYWRlcigpXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWRpYWxvZy1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9wLWhlYWRlcj5cblxuICAgIHt7Ym9keX19XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG4gICAgPHAtZm9vdGVyICpuZ0lmPVwiaGFzRm9vdGVyKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1mb290ZXItc2VwYXJhdG9yXCI+PC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWRpYWxvZy1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9wLWZvb3Rlcj5cbjwvcC1kaWFsb2c+XG5gLFxuICAgIHN0eWxlczogW2A6Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLXRpdGxlYmFye2JhY2tncm91bmQtY29sb3I6I2YyZjJmMjtwYWRkaW5nOjE1cHggMjBweH06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLXRpdGxlYmFyIC51aS1kaWFsb2ctdGl0bGViYXItaWNvbjpob3Zlcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9OjpuZy1kZWVwIC51aS13aWRnZXQtaGVhZGVye2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6MTZweH06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLWNvbnRlbnR7cGFkZGluZzoxNXB4IDIwcHg7bGluZS1oZWlnaHQ6MS4zZW19OjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLXdpZGdldC1jb250ZW50e2JvcmRlcjpub25lfTo6bmctZGVlcCAudWktZGlhbG9nLnVpLXdpZGdldC1jb250ZW50e2JvcmRlcjpub25lO2JveC1zaGFkb3c6MCAycHggMTBweCAwIHJnYmEoMCwwLDAsLjMpfTo6bmctZGVlcCAudWktZGlhbG9nIC5kaWFsb2ctZm9vdGVyLXNlcGFyYXRvcntib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3O2hlaWdodDoxNHB4fTo6bmctZGVlcCAudWktZGlhbG9nIC51aS1kaWFsb2ctZm9vdGVye3BhZGRpbmc6MCAyMHB4IDE1cHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nQ29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXJcbntcbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIERpYWxvZy4gIGlmIHRpdGxlIGFuZCAnVGl0bGVUZW1wbGF0ZScgYXJlIGJvdGggc2V0LCB0aXRsZVRlbXBsYXRlIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5IHNlY3Rpb24gZm9yIERpYWxvZy4gQ2FsbGVyIHNob3VsZCB1c2UgZWl0aGVyIHRoZSBib2R5IHN0cmluZywgb3IgY29udGVudCBwcm9qZWN0aW9uXG4gICAgICogdG8gYWRkIHZhbHVlcyB0byB0aGUgZGlhbG9nLiBJZiBib3RoIGFyZSB1c2VkLCB0aGV5IHdpbGwgYm90aCBzaG93IHVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIHN1cHBvcnQgdHdvIHdheSBkYXRhIGJpbmRpbmcgb24gdmlzaWJsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBkaWFsb2cgYmxvY2tzIHRoZSByZXN0IG9mIHRoZSBwYWdlIG9yIG5vdCB3aGVuIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1vZGFsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUncyBhbiB4IGF0IHRoZSB0b3AgcmlnaHQgdGhhdCBtYWtlcyB0aGUgZGlhbG9nIGNsb3NhYmxlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0hlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBEaWFsb2dIZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0Zvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBEaWFsb2dGb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gMzAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoaXMgZGlhbG9nLlxuICAgICAqL1xuICAgIG9wZW4oKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuXG4gICAgICAgIC8vIHZpc2libGUgaXMgYSAyLXdheSBiaW5kaW5nIHZhcmlhYmxlLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgZGlhbG9nXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgZGlhbG9nIGhhdmUgaGVhZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzSGVhZGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBkaWFsb2cgaGF2ZSBmb290ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNGb290ZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZvb3Rlcik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtEaWFsb2dDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0hlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0Zvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEaWFsb2dNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIFNraXBTZWxmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEVudmlyb25tZW50LFxuICAgIGVxdWFscyxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNBcnJheSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQcmVzZW50LFxuICAgIExpc3RXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDaG9vc2VyU2VsZWN0aW9uU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zdGF0ZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtDaG9vc2VyRGF0YVNvdXJjZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLWRhdGEtc291cmNlJztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuXG5cbi8qKlxuICogQ29udmVuaWVudCB3cmFwcGVyIGNsYXNzIGFyb3VuZCBjb250cm9scyBzdWNoIGFzIHJhZGlvYnV0dG9ucywgZHJvcGRvd24sIGNoZWNrYm94ZXMsXG4gKiBDaG9vc2VyLiBUaGUgdHlwZSBvZiB0aGUgY2hvb3NlciBtYXkgYmUgZGV0ZXJtaW5lZCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluXG4gKiB0aGUgZGF0YSBzb3VyY2UgbGlzdCwgb3IgY2FuIGJlIHNwZWNpZmllZCBleHBsaWNpdGx5IHZpYSB0aGUgXCJ0eXBlXCIgYmluZGluZy5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1nZW5lcmljLWNob29zZXInLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwidHlwZVwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0NoZWNrYm94J1wiPlxuICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbnNdPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtsYWJlbEZvcm1hdHRlcl09XCJkaXNwbGF5VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICA8L2F3LWNoZWNrYm94LWxpc3Q+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ1JhZGlvJ1wiPlxuICAgICAgICA8YXctcmFkaW9idXR0b24tbGlzdCBbbGlzdF09XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsRm9ybWF0dGVyXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0Ryb3Bkb3duJ1wiPlxuICAgICAgICA8YXctZHJvcGRvd24gW2xpc3RdPVwibGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICBbbm9TZWxlY3Rpb25TdHJpbmddPVwibm9TZWxlY3Rpb25TdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjaXRlbVRlbXBsYXRlIGxldC1pdGVtPlxuXG4gICAgICAgICAgICAgICAgPCEtLSB0b2RvOiBhbGxvdyB0byBwYXNzIGEgUElQRSB0byBkbyBzb21lIGFkZGl0aW9uYWwgZm9ybWF0dGluZyAtLT5cbiAgICAgICAgICAgICAgICB7eyBkaXNwbGF5VmFsdWUoaXRlbS52YWx1ZSkgfX1cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvYXctZHJvcGRvd24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0Nob29zZXInXCI+XG4gICAgICAgIDxhdy1jaG9vc2VyICNjaG9vc2VyXG4gICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW211bHRpc2VsZWN0XT1cIm11bHRpc2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFTb3VyY2VdPVwiZGF0YVNvdXJjZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZVRyYW5zZm9ybWVyXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuXG4gICAgICAgIDwvYXctY2hvb3Nlcj5cblxuICAgIDwvbmctdGVtcGxhdGU+XG5cbjwvbmctY29udGFpbmVyPlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gR2VuZXJpY0Nob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE9yZGVyZWQgbGlzdCBvZiBpdGVtcyBhc3NpZ25hYmxlIHRvIHRoZSBrZXkgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRoaXMgY29udHJvbCBpcyBiZWluZyBhc3NpZ25lZCB0by5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IGZpZWxkIHBhdGggdGhpcyBjb250cm9sIGlzIGJlaW5nIGFzc2lnbmVkIHRvLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAga2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIGluIHBsYWNlIG9mIExJU1QgYmluZGluZyB0byByZXRyaWV2ZSBhIGxpc3QgYmFzZWQgb24gdGhlIENob2ljZVNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiByZXRyaWV2aW5nIGNob2ljZVNvdXJjZSBieSBkZXN0aW5hdGlvbiBjbGFzcyBhbmQgdGhpcyBhcmUgZXh0cmEgcGFyYW1zIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBuYXJyb3cgdGhlIG1hdGNoaW5nIG9yIHRvIHBhc3MgcGFyYW1ldGVycyBpbnRvIENob2ljZVNvdXJjZSBwcm92aWRlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hvaWNlUHJvdmlkZXJQYXJhbXM6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqICBJcyB0aGlzIGEgTGlzdCBwcm9wZXJ0eSwgb3IgYSB0by1vbmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBzdHlsZSBvZiBjaG9vc2VyIHRvIHVzZSAoUmFkaW8sIENoZWNrYm94LCBEcm9wZG93biwgQ2hvb3NlcilcbiAgICAgKiAgRGVmYXVsdHMgYmFzZWQgb24gY2FyZGluYWxpdHkgb2YgdGhlIGxpc3QgYW5kIHdoZXRoZXIgaXQncyBtdWx0aVNlbGVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgY3VzdG9tIGtleS4gaW4gb3JkZXIgdG8gbWFrZSB0aGlzIHdvcmsgd2UgbmVlZCB0byBpbnRyb2R1Y2UgY3VzdG9tIDx0ZW1wbGF0ZXM+IGZvclxuICAgICAqIGFsbCB0aGlzIGNob29zZXIgdHlwZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlLZXk6IHN0cmluZztcblxuICAgIC8vIC8qKlxuICAgIC8vICAqICBTaG91bGQgd2UgYXR0ZW1wdCBhIG1hdGNoIGFzIHRoZXkgdHlwZSAoYWdhaW5zdCB0aGUgZnVsbCBsaXN0KVxuICAgIC8vICAqL1xuICAgIC8vIEBJbnB1dCgpXG4gICAgLy8gYWxsb3dGdWxsTWF0Y2hPbklucHV0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlbmRlcmVkIGFzIGZpcnN0IHZhbHVlIGluIHRoZSBkcm9wZG93biB3aGljaCBsZXQgdGhlIHVzZXIgdG8gbWFrZSAnbm8gc2VsZWN0aW9uJ1xuICAgICAqIGZyb20gYXZhaWxhYmxlIGxpc3Qgb2YgdmFsdWVzLiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSBhbmQgdXNlIG1ha2UgdGhpcyBzZWxlY3Rpb24gd2VcbiAgICAgKiBzYXZlIGEgTlVMTCB2YWx1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9TZWxlY3Rpb25TdHJpbmc6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBDaG9vc2VyIHdvcmtzIGRpcmVjdGx5IHdpdGggb2JqZWN0IGFuZCBpdHMgcmVmZXJlbmNlcyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhpc1xuICAgICAqIGtleXBhdGggdG8gYmUgYWJsZSB0byBzZXQvZ2V0IHZhbHVlIGZyb20gdGFyZ2V0IG9yIHBhcmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBrZXlQYXRoOiBGaWVsZFBhdGg7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHB1YmxpYyBkYXRhU291cmNlOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm9iamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gKDxhbnk+dGhpcy5fdmlld0NvbnRhaW5lci5pbmplY3Rvcikudmlldy5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5UGF0aCA9IG5ldyBGaWVsZFBhdGgodGhpcy5rZXkpO1xuICAgICAgICBsZXQgZGVmYXVsdERhdGFQcm92aWRlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICBkZWZhdWx0RGF0YVByb3ZpZGVyID0gdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlcnMuZmluZCh0aGlzLmxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFQcm92aWRlciA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXJzLmZpbmQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcm9qZWN0ZWRTaXplID0gZGVmYXVsdERhdGFQcm92aWRlci5leHBlY3RlZENvdW50KHRoaXMuY2hvaWNlUHJvdmlkZXJQYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXRUeXBlKHByb2plY3RlZFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdDaG9vc2VyJykge1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiBkZWZhdWx0RGF0YVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cEtleTogdGhpcy5kaXNwbGF5S2V5LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBuZXcgQ2hvb3NlclN0YXRlKG5ldyBHQ0Nob29zZXJTdGF0ZSh0aGlzKSwgdGhpcy5tdWx0aXNlbGVjdCksXG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBkbyB3ZSBuZWVkIHRvIHJlYWQgdGhpcyB2YWx1ZSBpbiBhc3luYz9cbiAgICAgICAgICAgIHRoaXMubGlzdCA9IGRlZmF1bHREYXRhUHJvdmlkZXIuZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubm9TZWxlY3Rpb25TdHJpbmcgPSB0aGlzLmkxOG4uaW5zdGFudCgnV2lkZ2V0cy5nY2hvb3Nlci5ub1NlbFN0cmluZycpO1xuICAgICAgICAgICAgdGhpcy5ub1NlbGVjdGlvblN0cmluZyA9ICdTZWxlY3QgYSBJdGVtJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBASW5wdXQgdHlwZSBpcyBub3QgcGFzc2VkIHdlIHRyeSB0byBndWVzcyBhbmQgc2VsZWN0IHRoZSBiZXN0IHR5cGUgZm9yIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0VHlwZShwcm9qZWN0ZWRTaXplOiBudW1iZXIpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IChwcm9qZWN0ZWRTaXplIDw9IDAgfHwgcHJvamVjdGVkU2l6ZSA+IDgpID8gJ0Nob29zZXInIDogJ0NoZWNrYm94JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKHByb2plY3RlZFNpemUgPD0gMCB8fCBwcm9qZWN0ZWRTaXplID4gMjApID8gJ0Nob29zZXInXG4gICAgICAgICAgICAgICAgICAgIDogKHByb2plY3RlZFNpemUgPCA2KSA/ICdSYWRpbycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Ryb3Bkb3duJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBjZXJ0YWluIHByb3BlcnRpZXMgd2hpY2ggYXJlIHJlcXVpcmVkIGJ5IHRoaXMgY29tcG9uZW50LiBBcyBhbHJlYWR5IG1lbnRpb25lZFxuICAgICAqIGFib3ZlIEdlbmVyaWNDaG9vc2VyIHdvcmtzIHdpdGggcmVmZXJlbmNlcyBhbmQgdGhlZm9yZSB0d28ga2V5IHByb3BlcnRpZXMgYXJlIG9iamVjdCBhbmQga2V5XG4gICAgICogc28gd2UgY2FuIGFjY2VzcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVJlcXVpcmVkKClcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGEgb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBhIGtleSBiaW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5saXN0KSAmJiBpc0JsYW5rKHRoaXMuZGVzdGluYXRpb25DbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBoYXZpbmcgZWl0aGVyIGxpc3Qgb2YgdmFsdWVzIG9yIGRlc3RpbmF0aW9uQ2xhc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlKSAmJlxuICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gJ1JhZGlvJyAmJiB0aGlzLnR5cGUgIT09ICdDaGVja2JveCcgJiYgdGhpcy50eXBlICE9PSAnRHJvcGRvd24nICYmXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICE9PSAnQ2hvb3NlcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIEdlbmVyaWNDaG9vc2VyICAtIGludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kaXNwbGF5S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5S2V5ID0gJ3RvU3RyaW5nJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGRpc3BsYXlpbmcgdmFsdWUgYm90aCBmcm9tIHByaW1pdGl2ZSB0eXBlIGFzIHdlbGwgY29tcGxleCBvYmplY3QuIElmIHlvdSB3YW50IHRvXG4gICAgICogY29udHJvbCBob3cgaXRlbSBpcyBkaXNwbGF5ZWQgeW91IGNhbiBwcm92aWRlIGRpc3BsYXkga2V5LCB3aGljaCBpcyBjYW4gYmUgYSAgbWV0aG9kIG9yXG4gICAgICogcHJvcGVydHkgb2YgdGhlIG9iamVjdCB5b3UgYXJlIGRpc3BsYXlpbmcuXG4gICAgICpcbiAgICAgKiBUb2RvOiB0aGluayBhYm91dCBmb3JtYXR0ZXJzIGFzIHdlbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGlzcGxheUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSwgdGhpcy5kaXNwbGF5S2V5KTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgUmV0cmlldmUgYSBjdXJyZW50IHZhbHVlIGZyb20gdGhlIHBhcmVudC90YXJnZXQgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5UGF0aC5nZXRGaWVsZFZhbHVlKHRoaXMub2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgc2V0IHZhbHVlIGJhY2sgdG8gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHNlbGVjdGlvbih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5rZXlQYXRoLnNldEZpZWxkVmFsdWUodGhpcy5vYmplY3QsIHZhbHVlKTtcbiAgICB9XG5cblxuICAgIG9uU2VsZWN0aW9uKHZhbHVlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KCk7XG5cbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJpY0Nob29zZXIgaW1wbGVtZW50YXRpb24gb2YgdGhlIENob29zZXJTZWxlY3Rpb25TdGF0ZSB3aGljaCBpcyB1c2VkIHdoZW4gVHlwZSA9IENob29zZXIuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgR0NDaG9vc2VyU3RhdGUgZXh0ZW5kcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ0Nob29zZXI6IEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRoaXMuaXNTZWxlY3RlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gaW1wbGVtZW50IHNtYXJ0ZXIgYW5kIG1vcmUgZ2VuZXJpYyB3YXkgaG93IHdlIHVzZSBpdCBpbiBqYXZhXG4gICAgICAgICAgICAvLyBSZWxhdGlvbnNoaXBGaWVsZC5hZGRUbyhfb2JqZWN0LCBfa2V5UGF0aCwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgbGV0IG11bHRpUmVsOiBBcnJheTxhbnk+ID0gdGhpcy5nQ2hvb3Nlci5rZXlQYXRoLmdldEZpZWxkVmFsdWUodGhpcy5nQ2hvb3Nlci5vYmplY3QpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsobXVsdGlSZWwpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlSZWwgPSBbXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobXVsdGlSZWwpICYmICFpc0FycmF5KG11bHRpUmVsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSSBjYW4gbm90IHN0b3JlIG11bHRpc2VsZWN0IHZhbHVlIGludG8gbm9uLWFycmF5IG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlbC5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb24gPSBtdWx0aVJlbDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KG11bHRpUmVsLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgbGV0IG9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICAgICAgcmV0dXJuIChpc0JsYW5rKG9iamVjdHMpIHx8IExpc3RXcmFwcGVyLmlzRW1wdHkob2JqZWN0cykpID8gbnVsbCA6IExpc3RXcmFwcGVyLmxhc3QoXG4gICAgICAgICAgICAgICAgb2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQmxhbmsoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQXJyYXkoc2VsZWN0aW9uKSkgPyBzZWxlY3Rpb24gOiBbc2VsZWN0aW9uXTtcbiAgICB9XG5cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgodGhpcy5zZWxlY3RlZE9iamVjdHMoKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyVmFsdWUgPSB0aGlzLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBlcXVhbHMoY3VyVmFsdWUsIHNlbGVjdGlvbik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBmb3IgUmFkaW9CdXR0b24gY29tcG9uZW50IHByb3ZpZGluZyBjb252ZW5pZW50IHdheSB0byB0byByZW5kZXIgUmFkaW9CdXR0b24gR3JvdXBzXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYFxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnZ2VuZGVyLXNlbGVjdG9yJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiTGlzdFZhbHVlc1wiIFtsYXlvdXRdPVwibGF5b3V0XCJcbiAqICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGVkVmFsdWVcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICogICAgICBgXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBHZW5kZXJTZWxlY3RvckNvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICByYkxpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydtYWxlJyAsICdmZW1hbGUnICwgJ290aGVyJ107XG4gKiAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBzdHJpbmcgPSAnb3RoZXInO1xuICogICAgICAgICAgbGF5b3V0OiBzdHJpbmcgPSAnc3RhY2tlZCc7XG4gKlxuICpcbiAqICAgICAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgICAgICB9XG4gKlxuICogICAgICB9XG4gKlxuICogYGBgXG4gKi9cblxuXG5leHBvcnQgY29uc3QgUkJfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJhZGlvYnV0dG9uLWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBsaXN0OyAgbGV0IGkgPSBpbmRleFwiIGNsYXNzPVwidWktZ1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTJcIj5cbiAgICAgICAgPGF3LXJhZGlvYnV0dG9uXG4gICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJpXCJcbiAgICAgICAgICAgIFtsYWJlbF09XCJsYWJlbFZhbHVlKGl0ZW0pXCI+XG4gICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIExJc3Qgb2YgdmFsdWVzIHVzZWQgdG8gcmVuZGVyIHRoZSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIHdoaWNoIHJhZGlvIGJ1dHRvbnMgaXMgc2VsZWN0ZWQgd2hlbiByZW5kZXJlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIHNwZWNpYWwgZXhwcmVzc2lvbiB0byBmb3JtYXQgbGFiZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGFuIGV2ZW50IHdoZW4gcmFkaW8gYnV0dG9uIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgbW9kZWwgdG8gbGlzdGVuIGZvciByYWRpbyB2YWx1ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgaXMgZXh0cmFjdGVkIGludG8gYSBtZXRob2Qgc28gaW4gdGhlIGZ1dHVyZSB3ZSBjYW4gcGxheSBob3cgd2Ugd2FudCB0byBkaXNwbGF5IHRoZVxuICAgICAqIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgdGhlIGxhYmVsIHdpbGwgbG9vayBsaWtlLlxuICAgICAqXG4gICAgICovXG4gICAgbGFiZWxWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiB0aGlzIHZlcnNpb24gb2YgY2hlY2tib3hlcyB3ZSBzdGlsbCBleHBlY3Qgb25seSBwcmltaXRpdmUgdHlwZXMuIEtlZXAgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICogaW4gZXh0cmEgbWV0aG9kIHNvIHdlIGNhbiB3b3JrIHdpdGggaXQgZXZlbiBub3cgd2UganVzdCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFja1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB2YWx1ZShpdGVtOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPbiBOR01vZGVsIGNoYW5nZSByZXRyaWV2ZSBhY3R1YWwgcmVjb3JkIGJhc2VkIG9uIHRoZSBJTkRFWCBhbmQgcHJvcGFnYXRlIGl0IHRvIGJvdGhcbiAgICAgKiBuZ01vZGVsIGFzIHdlbGwgYXMgRm9ybUdyb3VwLlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBjb21wbGV4IG9iamVjdCBzdG9yZSBvbmx5IElOREVYIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VjZUl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubGlzdC5maW5kSW5kZXgoKGVsZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNvdWNlSXRlbSA9PT0gZWxlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBpbmRleCA9PT0gLTEgPyAwIDogaW5kZXg7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG5ld01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKG5ld01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgSFRNTCByYWRpbyBidXR0b24gb24gdG9wIG9mIFByaW1lTkcgd2l0aCBhcmliYSBzdHlsaW5nXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiAxLiBCYXNpYyB1c2FnZSB1c2luZyBuZ01vZGVsIHByZS1zZWxlY3RlZCBmaXJzdCByYWRpb1xuICpcbiAqICBgYGB0c1xuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgIGBcbiAqICAgICAgfSkqXG4gKiAgICAgIGNsYXNzIEJhc2ljV2l0aE5nTW9kZWxDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqXG4gKiAgYGBgXG4gKlxuICpcbiAqIDIuIEJhc2ljIHVzYWdlIHdpdGggZm9ybUdyb3VwXG4gKlxuICpcbiAqIGBgYHRzXG4gKiAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgIDxkaXYgW2Zvcm1Hcm91cF09XCJlbnYuY3VycmVudEZvcm1cIj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICpcbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgYFxuICogICAgICAgfSlcbiAqICAgICAgIGNsYXNzIEJhc2ljV2l0aEZvcm1Hcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxuICogICAgICAge1xuICogICAgICAgICAgIG1vZGVsOiBzdHJpbmcgPSAnYmx1ZSc7XG4gKlxuICogICAgICAgICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgIG5nT25Jbml0KCk6IHZvaWRcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtLnJlZ2lzdGVyQ29udHJvbCgnY29sb3IyJywgbmV3IEZvcm1Db250cm9sKHRoaXMubW9kZWwpKTtcbiAqICAgICAgICAgICB9XG4gKlxuICpcbiAqICAgICAgICAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgdGhpcy5tb2RlbFNldCA9IGV2ZW50O1xuICogICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKiAgYGBgYFxuICpcbiAqXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmFkaW9idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPHNwYW4gY2xhc3M9XCJ3LXJhZGlvYnV0dG9uXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGUgXCI+XG4gICAgICAgIDxwLXJhZGlvQnV0dG9uIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwib25Nb2RlbENoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCI+XG4gICAgICAgIDwvcC1yYWRpb0J1dHRvbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9zcGFuPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC53LXJhZGlvYnV0dG9uIC51aS1yYWRpb2J1dHRvbi1ib3h7d2lkdGg6MjNweDtoZWlnaHQ6MjNweDtsaW5lLWhlaWdodDoyM3B4fS9kZWVwLyAudy1yYWRpb2J1dHRvbiAudWktcmFkaW9idXR0b24taWNvbntmb250LXNpemU6MS41ZW07bGluZS1oZWlnaHQ6MWVtfWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYWRpb1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgYSByYWRpb1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBjbGljayBldmVudCB3aXRoIGN1cnJyZW50IHNlbGVjdGVkIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIHRvIGNvbXVuaWNhdGUgd2l0aCBwcmltZU5nIFJhZGlvXG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IgKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0ICgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByYWRpbyBpcyBjbGlja2VkLiBOb3QgdXNpbmcgUHJpbWVORyBjbGljayBldmVudCBhcyBpdCBpcyBmaXJlZCBiZWZvcmVcbiAgICAgKiB0aGUgbW9kZWwgaXMgY2hhbmdlZC4gVGhlcmVmb3JlIG5lZWQgdG8gbGlzdGVuIG9uIChuZ01vZGVsQ2hhbmdlKVxuICAgICAqXG4gICAgICovXG4gICAgb25Nb2RlbENoYW5nZSAobmV3VmFsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UmFkaW9CdXR0b25Db21wb25lbnR9IGZyb20gJy4vcmFkaW8tYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmFkaW9CdXR0b25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTGlzdENvbXBvbmVudH0gZnJvbSAnLi9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7R2VuZXJpY0Nob29zZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hMaXN0TW9kdWxlfSBmcm9tICcuLi9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Nob29zZXJNb2R1bGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtFbnRpdHksIGlzQmxhbmssIGlzRW50aXR5LCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge091dGxpbmVGb3JDb21wb25lbnQsIE91dGxpbmVOb2RlfSBmcm9tICcuL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cbi8qKlxuICogT3V0bGluZVN0YXRlIGlzIHRoZSBrZXkgZ2x1aW5nIHBhcnQgZm9yIHRoZSBPdXRsaW5lRm9yIGFuZCBPdXRsaW5lQ29udHJvbGxlciBjb21wb25lbnRzLiBJdFxuICogaG9sZHMgYWxsIGltcG9ydGFudCBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgb3V0bGluZSB0cmVlIGFuZCBtYW5hZ2VzIGV4cGFuc2lvbiBzdGF0ZXMgaW4gZm9ybVxuICogb2Ygc28gY2FsbGVkIGV4cGFuc2lvblBhdGggYW5kIGV4cGFuc2lvblN0YXRlc1xuICpcbiAqIFdlIG5lZWQgdG8gaGF2ZSBhIHdheSBob3cgdG8gd29yayB3aXRoIGdlbmVyaWMgZGF0YSBzdHJ1Y3R1cmUgaW4gb3JkZXIgbm90IHRvIGhvbGQgVUkgc3BlY2lmaWNcbiAqIGluZm9ybWF0aW9uIG9uIHRoZSBkb21haW4gb2JqZWN0IG1vZGVsIGp1c3QgbGlrZSB3ZSBoYWQgaXQgYmVmb3JlLCB3aGVyZSB3ZSBoYWQgYW4gaW50ZXJmYWNlXG4gKiBjYWxsZWQgT3V0bGluZU5vZGUsIHdpdGggZmllbGRzIChleHBhbmRlZCwgc2VsZWN0ZWQsIGV0Yy4uIClcbiAqXG4gKlxuICogYGV4cGFuc2lvblBhdGhgOiBIb2xkcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgYW5kIGV4cGFuZGVkIG5vZGVzLiBUaGlzIGlzIGZpbGxlZCBieVxuICogT3V0bGluZUNvbnRyb2xsZXIuXG4gKlxuICpcbiAqIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggRW50aXR5IG9yIGFueXRoaW5nIHRoYXQgaGFzIGlkZW50aXR5IHRoZW4gd2UgaGF2ZSBlYXNpZXIgc2l0dWF0aW9uIGFzIHdlXG4gKiBjYW4gYXNrIGZvciBJRCBhbmQgaXQgaXMgbW9yZSBlZmZpY2llbnQgZm9yIHNlcmlhbGl6YXRpb25cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE91dGxpbmVTdGF0ZVxue1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZXhwYW5kZWQgbm9kZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgX2V4cGFuc2lvblBhdGg6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBgYWxsb3dTZWxlY3Rpb25gIGlzIGVuYWJsZWQgb24gT3V0bGluZUNvbnRyb2wgaXQgc2F2ZWQgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gdG8gYmVcbiAgICAgKiBhYmxlIGxhdGVyIG9uIGFwcGx5IHNvbWUgc3R5bGluZyBhbmQgYnJvYWRjYXN0IHRoaXMgc2VsZWN0aW9uIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzZWxlY3RlZEl0ZW06IGFueTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWFwcyBvYmplY3QgcmVmZXJlbmNlIHRvIGJvb2xlYW4gdmFsdWVzLCB3aGVyZSBUUlVFIG1lYW5zIEVYUEFOREVELCBGQUxTRSBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBvdXRsaW5lIGlzIHJlbmRlcmVkIGZvciBmaXJzdCB0aW1lIG9yIHJlLXJlbmRlcmVkIGFuZCB3ZSBzZXQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlXG4gICAgICogZXhwYW5zaW9uU3RhdGVzLiBUaGlzIHdheSB3ZSBjYW4gcHJldHR5IGVhc2lseSBleGVjdXRlIENvbGxhcHNlQWxsLCBFeHBhbmRBbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWRBbGw6IGJvb2xlYW4gPSBmYWxzZTsgLy8gY29sbGFwc2VkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhvbGRzIGN1cnJlbnQgbGV2ZWwgZHVyaW5nIHRyZWUgbm9kZSByZW5kZXJpbmcgc28gd2UgY2FuIGFwcGx5IGNvcnJlY3QgaW5kZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRMZXZlbDogbnVtYmVyID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGR1cmluZyBhIHRvZ2dsZSBhY3Rpb24gdG8gcmVjb3JkIGN1cnJlbnQgc2VsZWN0aW9uIHBhdGguXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50UGF0aDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIEdsb2JhbGx5IHNoYXJlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIGNvbGxhcHNlQWxsIGFuZCBleHBhbmRBbGwgd2UgYXJlIHVzaW5nIHNpbXBsZSBtZWNoYW5pc20gd2hlcmUgd2UgY2xlYW4gdXAgYWxsXG4gICAgICogc2VsZWN0aW9uIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGV4cGFuZCBzdGF0ZSwgdGhpcyB3aGV5IGlzRXhwYW5kIG1ldGhvZCByZXR1cm5zIHRoZSBzYW1lXG4gICAgICogc3RhdGUgZm9yIGFsbCBpdGVtc1xuICAgICAqL1xuICAgIGNvbGxhcHNlQWxsICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvcikgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG5cbiAgICAgICAgICAgIC8vIGZvciB0aGlzIGNhc2Ugd2UgY29sbGFwc2UgYWxsIGJ1dCByb290IG5vZGVzXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmxpc3QuZm9yRWFjaCgoaXRlbTogT3V0bGluZU5vZGUpID0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKGl0ZW0uY2hpbGRyZW4gfHwgW10sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOb2Rlcyh0aGlzLm91dGxpbmVGb3IubGlzdCB8fCBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cGFuZEFsbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpICYmXG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2Rlcyh0aGlzLm91dGxpbmVGb3IubGlzdCwgdHJ1ZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkQWxsID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGdldCBleHBhbnNpb25QYXRoICgpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvblBhdGggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uUGF0aDtcbiAgICB9XG5cblxuICAgIHNldCBleHBhbnNpb25QYXRoICh2YWx1ZTogYW55W10pXG4gICAge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoLmZvckVhY2goKGl0ZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB0b2dnbGVFeHBhbnNpb24gKGN1cnJlbnRQYXRoOiBhbnlbXSwgY2hpbGRyZW4/OiBhbnlbXSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgbGV0IGl0ZW1DaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSAhdGhpcy5pc0V4cGFuZGVkKGl0ZW0pO1xuICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKGl0ZW0sIG5ld1N0YXRlKTtcblxuICAgICAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVMYXN0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXMoaXRlbUNoaWxkcmVuLCBuZXdTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEV4cGFuc2lvblBhdGgoY3VycmVudFBhdGgpO1xuICAgIH1cblxuICAgIHVwZGF0ZU5vZGVzIChub2RlczogYW55W10sIG5ld1N0YXRlOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5vdXRsaW5lRm9yLmNoaWxkcmVuRm9ySXRlbShjaGlsZCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW1zKSAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlcyhpdGVtcywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShjaGlsZCwgbmV3U3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRFeHBhbnNpb25TdGF0ZSAoaXRlbTogYW55LCBpc0V4cGFuZGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gRXZlbiBmb3IgdHJlZSBtb2RlIGZvcm1hdCBzYXZlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gdXNlIGl0IGxhdGVyIG9uIGluIGNhc2Ugb2JqZWN0XG4gICAgICAgIC8vIHJlZmVyZW5jZXMgZ2V0cyBtZWVzZWQgdXBcbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvciAmJlxuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgICg8T3V0bGluZU5vZGU+aXRlbSkuaXNFeHBhbmRlZCA9IGlzRXhwYW5kZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgICAgICBpZiAoaXNFeHBhbmRlZCA9PT0gdGhpcy5pc0V4cGFuZGVkQWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIChpc0V4cGFuZGVkKSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBpbXByb3ZlIHN0YXRlIHBlcnNpc3RpbmcgbGV0cyBjaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIE9iamVjdCB0aGF0IGhhcyBJZGVudGl0eVxuICAgICAqIHNvIHdlIGNhbiBleHRyYWN0IGFuIElEIG90aGVyd2lzZSB1c2Ugb2JqZWN0IHRvIGNvbXBhcmUgYnkgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXRlbVRvS2V5IChpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBpc0VudGl0eShpdGVtKSA/ICg8RW50aXR5Pml0ZW0pLmlkZW50aXR5KCkgOiBpdGVtO1xuICAgIH1cblxuXG4gICAgc2V0RXhwYW5zaW9uUGF0aCAoaXRlbXM6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25QYXRoID0gaXRlbXM7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgobm9kZTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKG5vZGUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkIChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvcikgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxPdXRsaW5lTm9kZT5pdGVtKS5pc0V4cGFuZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cGFuc2lvblN0YXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRXhwYW5kZWRBbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbnNpb25TdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthbmltYXRlLCBBbmltYXRpb25CdWlsZGVyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXJ9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBJZGVudGl0eSwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4vb3V0bGluZS1zdGF0ZSc7XG5cblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSByZXByZXNlbnQgY29uY3JldGUgdHJlZSBzdHJ1Y3R1cmUgZm9yIHRoZSBvdXRsaW5lIHRyZWUgbW9kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE91dGxpbmVOb2RlIGV4dGVuZHMgSWRlbnRpdHlcbntcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgcGFyZW50OiBPdXRsaW5lTm9kZTtcblxuICAgIC8qKlxuICAgICAqIE5vZGUncyBjaGlsZHJlbi4gRXZlbiBpdHMgYSBmaWVsZCBpdCBjYW4gYmUgaW1wbGVtZW50ZWQgbGF6aWx5IHVzaW5nIGdldHRlciB3aGVyZSBhIHRhcmdldFxuICAgICAqIG9iamVjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhpcyBhcyBhIHB1YmxpYyBmaWVsZCBidXQgYSBnZXR0ZXIgd2l0aCBjb250cm9sIG92ZXIgdGhlXG4gICAgICogcmV0cmlldmVkIGxpc3RcbiAgICAgKi9cbiAgICBjaGlsZHJlbjogT3V0bGluZU5vZGVbXTtcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBzdGF0ZXMgZm9yIG91dGxpbmUgTm9kZVxuICAgICAqXG4gICAgICogaXNFeHBhbmRlZDogYm9vbGVhbjs9IG1vdmluZyBvdXQgYXMgdGhpcyBpcyBtYW5hZ2VkIGJ5IGV4cGFuc2lvbnN0YXRlLlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQ6IGJvb2xlYW47XG4gICAgaXNTZWxlY3RlZDogYm9vbGVhbjtcbiAgICBpc01hdGNoPzogYm9vbGVhbjtcbiAgICByZWFkb25seT86IGJvb2xlYW47XG4gICAgdHlwZT86IHN0cmluZztcbiAgICBkcmFnZ2FibGU/OiBib29sZWFuO1xuICAgIGRyb3BwYWJsZT86IGJvb2xlYW47XG4gICAgdmlzaWJsZT86IGJvb2xlYW47XG5cbn1cblxuXG4vKipcbiAqXG4gKiBDaGVja3MgdHlwZSBmb3IgT3V0bGluZU5vZGVcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc091dGxpbmVOb2RlKG5vZGU6IGFueSk6IG5vZGUgaXMgT3V0bGluZU5vZGVcbntcbiAgICByZXR1cm4gaXNQcmVzZW50KG5vZGUpICYmIGlzUHJlc2VudCgoPE91dGxpbmVOb2RlPm5vZGUpKVxuICAgICAgICAmJiBpc1ByZXNlbnQoKDxPdXRsaW5lTm9kZT5ub2RlKS5wYXJlbnQpXG4gICAgICAgICYmIGlzUHJlc2VudCgoPE91dGxpbmVOb2RlPm5vZGUpLmNoaWxkcmVuKTtcbn1cblxuXG4vKipcbiAqIEN1cnJlbnRseSBvdXRsaW5lIHN1cHBvcnRzIG9ubHkgdHdvIG1vZGVzIGZyZWUsIHdoZXJlIGFwcGxpY2F0aW9uIGlzIHJlc3BvbnNpYmxlIHRvIHJldHJpZXZlXG4gKiBjaGlsZHJlbiBmb3IgZWFjaCBub2RlIGFuZCB0cmVlIHdpdGggYWJvdmUgT3V0bGluZU5vZGUgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCB0eXBlIE1vZGVsRm9ybWF0ID0gJ2ZyZWUnIHwgJ3RyZWUnO1xuXG5cbi8qKlxuICpcbiAqIE91dGxpbmVGb3JDb21wb25lbnQgaXMgbGlrZSBuZ0ZvciwgYnV0IGZvciBoaWVyYXJjaGljYWwgKG91dGxpbmUvdHJlZSkgc3RydWN0dXJlcyAtLSBpLmUuIGluXG4gKiB0aG9zZSBjYXNlcyB3aGVyZSBhbiBpdGVtIG1heSBoYXZlIGNoaWxkcmVuLlxuICpcbiAqXG4gKiBJdCB1c2VzIG91dGxpbmUgYDxhdy1vdXRsaW5lLWNvbnRyb2w+YCB0byBwcm92aWRlIGV4cGFuZGluZyBmdW5jdGlvbmFsaXR5LCBpbmRlbnRhdGlvblxuICogYW5kIG90aGVyIHRoaW5ncy5cbiAqXG4gKlxuICogVGhpcyBjb21wb25lbnQgaGFzIG1pbmltYWwgc3R5bGluZyB0byBtYWtlIHN1cmUgaXQgY2FuIGJlIGNoYW5nZWQgZWFzaWx5LlxuICpcbiAqICMjIyBFeGFtcGxlIHJlbmRlcmluZyB0cmVlIHNlY3Rpb24sIHdoZXJlIGJhc2VkIG9uIHRoZSB0eXBlIHdlIGZvcm1hdCB0aGUgb3V0IHBsdXNcbiAqIGZvciB0aGUgbWFpbiByb290IHNlY3Rpb24gd2UgYWx3YXlzIHJlbmRlciBsaXR0bGUgcG9wdXAgbWVudS5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1vdXRsaW5lLWZvciBbbGlzdF09XCJsaXN0XCIgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCI+XG4gKlxuICogICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICpcbiAqICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXktc2VjdGlvblwiPlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3V0bGluZVwiPlxuICogICAgICAgICAgICAgICAgICAgPGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJpdGVtLnR5cGVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ3RleHQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXMtcGFyYWdyYWZcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nU3dpdGNoRGVmYXVsdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbHRlcnNcIiAqbmdJZj1cIml0ZW0udHlwZSA9PT0gJ3NlY3Rpb24nXCIgPlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZpbHRlciBJdGVtcydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8YXctbGlzdCBbbGlzdF09XCJmaWx0ZXJJdGVtc1wiIFtib3JkZXJsZXNzXT1cInRydWVcIj48L2F3LWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICA8L2Rpdj5cbiAqICAgICA8L25nLXRlbXBsYXRlPmBcbiAqICAgPC9hdy1vdXRsaW5lLWZvcj5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogV2UgY2FuIHVzZSBpdCBhbHNvIGluIGVtYmVkZGVkIG1vZGUgd2hlcmUgd2UgdXNlIHRoZSBgYXdPdXRsaW5lRm9yYCBkaXJlY3RpdmVcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYGBcbiAqICA8dGFibGUgIGNsYXNzPVwidHJlZS10YWJsZVwiID5cbiAqICAgICAgPHRoZWFkPlxuICogICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cbiAqICAgICAgICAgICAgICA8dGg+VHlwZTwvdGg+XG4gKiAgICAgICAgICA8L3RyPlxuICogICAgICA8L3RoZWFkPlxuICogICAgICA8dGJvZHkgI29vbzIgYXdPdXRsaW5lRm9yIFtsaXN0XT1cImxpc3RcIlxuICogICAgICAgICAgICAgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCJcbiAqICAgICAgICAgICAgIGNsYXNzPVwib3V0bGluZS10YWJsZVwiXG4gKiAgICAgID5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIml0ZW0tbmFtZSBvdXRsaW5lLWFuaW1hdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgPGRpdj48YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD48L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiaXRlbS10eXBlIG91dGxpbmUtYW5pbWF0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pnt7aXRlbS50eXBlfX08L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICA8L3RyPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC90Ym9keT5cbiAqICA8L3RhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqIEkgd2FzIHRoaW5raW5nIG1heWJlIGZvciBmaXJzdCB0aW1lIHdlIGRvbid0IG5lZWQgdGhlIHNhbWUgYW5pbWF0aW9uIGxpa2UgZXhwYW5kaW5nIGFuZFxuICogY29sbGFwc2luZy4gTWF5YmUgd2UgbmVlZCBmYWRlLWluLiBJbiBzdWNoIGNhc2UgSSB3b3VsZCBwcm9iYWJseSBhcHBseSBAc2VjdGlvbiBhbmltIG9ubHlcbiAqIG9uIGl0ZW1zIHdoZXJlIGxldmVsID4gMCAoaW4gdGhlIHRlbXBsYXRlIEkga2VlcCBsZXZlbHMpIGFuZCBpZiBsZXZlbCA9PSAwIHRoZW4gSSB3b3VsZFxuICogZXhlY3V0ZSB0aGUgc2FtZSByZW5kZXJpbmcganVzdCB3aXRob3V0IFtAc2VjdGlvbl1cbiAqXG4gKlxuICogVG9kbzogVGhpbmsgYWJvdXQgaG93IHRvIGRvIGFuaW1hdGlvbiBmb3IgdGhlIHRhYmxlIGNhc2UuIE11c3QgYWxzbyB3cml0ZSB1bml0ZXN0IC0gZHVlIHRvXG4gKiBBcmliYUxpdmUgYWdncmVzc2l2ZSBzY2hlZHVsZSB3ZSBhcmUgc2tpcHBpbmcgdGhlbSBmb3Igbm93XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtZm9yLCBbYXdPdXRsaW5lRm9yXScsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgU3RhcnRzIHdpdGggdGhlIGxpc3QsIHdoZXJlIG5lc3RpbmdMZXZlbCBpcyAtMS5cbiAgICBjYWxsIHRlbXBsYXRlIG91dGxpbmVJdGVtcyB0byBpdGVyYXRlIGFuZCByZW5kZXIgZWFjaCBpdGVtXG4tLT5cbjxuZy1jb250YWluZXIgW25nSWZdPVwibGlzdFwiICpuZ1RlbXBsYXRlT3V0bGV0PVwib3V0bGluZUl0ZW1zO1xuICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogbGlzdCwgbmVzdGluZ0xldmVsOiAwLCBwYXJlbnRJdGVtOiBudWxsLCBleHBhbmRlZDogdHJ1ZX1cIj5cbjwvbmctY29udGFpbmVyPlxuXG48IS0tXG4gICAgTWFpbiBFbnRyeSBwb2ludCBmb3IgdGhlIHJlY3Vyc2lvbi4gdGhpcyBpcyBjYWxsZWQgYnkgdGhlIGJsb2NrIGFib3ZlIGFzIHdlbGwgYXMgYnl0IHRoZSBpbm5lclxuICAgIHBpZWNlIHRoYXQgY2FsbHMgdGhpcyB0ZW1wbGF0ZSByZWN1cnNpdmVseSBhZ2FpbiB3aGVuIGFuIGl0ZW0gaGFzIGNoaWxkcmVuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjb3V0bGluZUl0ZW1zIGxldC1jaGlsZHJlbiBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCJcbiAgICAgICAgICAgICBsZXQtcGFyZW50PVwicGFyZW50SXRlbVwiIGxldC1leHBhbmRlZD1cImV4cGFuZGVkXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiY2hpbGRyZW5cIiBsZXQtcm93SW5kZXg9XCJpbmRleFwiPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJvdXRsaW5lSXRlbTtcbiAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGl0ZW0sIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLCBwYXJlbnRJdGVtOiBwYXJlbnQsXG4gICAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsIHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8IS0tXG5cbiAgICAgICAgICAgIFJlY3Vyc2lvbiBwaWVjZTpcblxuICAgICAgICAgICAgRm9yIG5vbiBlbWJlZGRlZCBjYXNlIHdoZW4gZXZlbiBpZiBpdHMgbm90IGV4cGFuZGVkIHdlIG5lZWQgdG8gaXRlcmF0ZSBjaGlsZHJlblxuICAgICAgICAgICAgYXMgd2Ugd2FudCB0byBhcHBseSBhbmltYXRpb24gdGhhdCBzaG91bGQgZ28gd2l0aCBuZ0lmIHdoaWNoIGluc2lkZSB0aGUgb3V0aW5lSXRlbVxuICAgICAgICAgICAgdGVtcGxhdGVcblxuICAgICAgICAgICAgRG9udCByZWN1cnNlLyByZW5kZXIgaXRlbXMgdGhhdCBhcmUgbm90IHZpc2libGUuXG4gICAgICAgIC0tPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJoYXNDaGlsZHJlbihpdGVtKSAmJiAoaXNFeHBhbmRlZChpdGVtLCBuZXN0aW5nTGV2ZWwpIHx8ICFlbWJlZGRlZCkgJiYgaXNWaXNpYmxlKGl0ZW0pXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwib3V0bGluZUl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogY2hpbGRyZW5Gb3JJdGVtKGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCsxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZDogaXNFeHBhbmRlZChpdGVtLCBuZXN0aW5nTGV2ZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJdGVtOml0ZW0gfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPCEtLVxuICAgIFJlbmRlcnMgYWN0dWFsIG91dGxpbmUgbm9kZSBhbmQgYXBwbGllcyBhbmltYXRpb24gd2hpbGUgZXhwYW5kaW5nIGFuZCBjb2xsYXBzaW5nXG5cbiAgICBbQHNlY3Rpb25dPVwiZXhwYW5kZWQgfHwgaXNFeHBhbmRlZChpdGVtKSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXCJcbi0tPlxuPG5nLXRlbXBsYXRlICNvdXRsaW5lSXRlbSBsZXQtaXRlbSBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LXBhcmVudD1cInBhcmVudEl0ZW1cIlxuICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCJcbiAgICAgICAgICAgICBsZXQtZXhwYW5kZWQ9XCJleHBhbmRlZFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInctb3V0bGluZS1pdGVtXCJcbiAgICAgICAgICpuZ0lmPVwiIWVtYmVkZGVkICYmIGV4cGFuZGVkXCJcbiAgICAgICAgIFtzdHlsZS5wYWRkaW5nLWxlZnQucHhdPVwiaW5kZW50YXRpb24obmVzdGluZ0xldmVsKVwiXG4gICAgICAgICBpbml0TmVzdGluZyBbc2V0TGV2ZWxdPVwibmVzdGluZ0xldmVsXCIgW3NldFBhcmVudEl0ZW1dPVwicGFyZW50XCJcbiAgICAgICAgIFtzZXRDdXJycmVudEl0ZW1dPVwiaXRlbVwiXG4gICAgICAgICBbQHNlY3Rpb25dXG4gICAgICAgICAoQHNlY3Rpb24uZG9uZSk9XCJvbkFuaW1hdGlvbkRvbmUoJGV2ZW50KVwiPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb250cm9sVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnsgJGltcGxpY2l0OiBpdGVtLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgcm93SW5kZXg6cm93SW5kZXggfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS1cbiAgICAgICAgV2hlbiBvdXRsaW5lIGNvbnRyb2wgaXMgdXNlZCBhcyBlbWJlZGRlZCBtZWFuaW5nIGl0cyBpbnNpZGUgZS4uZyBkYXRhdGFibGUgd2VcbiAgICAgICAgY2Fubm90IGhhdmUgYW55IHRhZ3MgYXJvdW5kIGl0LlxuXG4gICAgICAgIFRvZG86IFJlZmFjdG9yIHRoaXMgaW4gdGhlIHdheSBzbyB3ZSBjYW4gZG8gYW5pbWF0aW9uIHdoZW4gdGFibGUgbGluZXMgYXJlXG4gICAgICAgIGV4cGFuZGVkLiBTaW5jZSBpdHMgZW1iZWRkZWQgd2UgY2FuIG5vdCBoYXZlIGFueSB3cmFwcGluZyBlbGVtZW50IGFyb3VuZCwgdGhlIHRlbXBsYXRlXG4gICAgICAgIGlzIGZ1bGx5IHJlc3BvbnNpYmxlXG4gICAgLS0+XG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVtYmVkZGVkICYmIGV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgaW5pdE5lc3RpbmcgW3NldExldmVsXT1cIm5lc3RpbmdMZXZlbFwiIFtzZXRQYXJlbnRJdGVtXT1cInBhcmVudFwiXG4gICAgICAgICAgICAgICAgIFtzZXRDdXJycmVudEl0ZW1dPVwiaXRlbVwiXG4gICAgPlxuICAgICAgICA8bmctY29udGFpbmVyICNyZW5kZXJlZEl0ZW0gKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb250cm9sVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnsgJGltcGxpY2l0OiBpdGVtLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgcm93SW5kZXg6cm93SW5kZXggIH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuPC9uZy10ZW1wbGF0ZT5cblxuXG5gLFxuICAgIHN0eWxlczogW2AuaXMtb3V0bGluZS1hbmltYXRpb24+ZGl2LDo6bmctZGVlcCAudy1vdXRsaW5lLWl0ZW17b3ZlcmZsb3c6aGlkZGVufWBdLFxuXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdzZWN0aW9uJywgW1xuICAgICAgICAgICAgc3RhdGUoJyonLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgJ292ZXJmbG93LXknOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJyonLFxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzogJzEnXG5cbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMCcsXG4gICAgICAgICAgICAgICAgJ29wYWNpdHknOiAnMCcsXG4gICAgICAgICAgICAgICAgJ292ZXJmbG93LXknOiAnaGlkZGVuJ1xuXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBhbmltYXRlKCcyMDBtcyBlYXNlLW91dCcpKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIGFuaW1hdGUoJzIwMG1zIGVhc2UtaW4nKSlcbiAgICAgICAgXSksXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBPdXRsaW5lRm9yQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBpdGVtcyB0aGF0IG5lZWRzIHRvIGJlIHJlbmRlcmVkLiBJdCBkb2VzIG5vdCBoYXZlIHRvIGluIGhpZXJhcmNoaWNhbCBvcmRlciBvciB3ZVxuICAgICAqIGxlYXZlIGl0IHVwIHRvIHRoZSBhcHBsaWNhdGlvbiB0byBkZWNpZGUgYWJvdXQgdGhlIHN0cnVjdHVyZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q/OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIGNvbXBvbmVudCBub3QgdG8gcmVuZGVyIGV4cGFuc2lvbiBjb250cm9sLCBpbiBzdWNoIGNhc2Ugd2UgZXhwYW5kQWxsIGFzIGFcbiAgICAgKiBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dFeHBhbnNpb25Db250cm9sOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBtZXRob2QgcHJvdmlkZWQgYnkgYXBwbGljYXRpb24gdG8gcmV0cmlldmUgbGlzdCBvZiBjaGlsZHJlbiBmb3IgY3VycmVudCBpdGVtLiBJZlxuICAgICAqIGNoaWxkcmVuIGlzIHVuZGVmaW5lZCB0aGVuLCBkZWZhdWx0ICdjaGlsZHJlbicgZmllbGQgaXMgdXNlZCA8Y3VycmVudEl0ZW0+LmNoaWxkcmVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjaGlsZHJlbjogKHZhbHVlOiBhbnkpID0+IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPcHRpb24gdG8gY29uZGl0aW9uYWxseSByZW5kZXIgb25seSBpdGVtcyB0aGF0IGFyZSBzYXRpc2Z5aW5nIGZpbHRlciBjb25kaXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZmlsdGVyT3V0OiAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYWxsIHRyZWUgbm9kZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZEFsbDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiAgTWFuYWdlcyB0aGUgc3RhdGUgZm9yIHRoZSBPdXRsaW5lIGNvbXBvbmVudC4gTGF0ZXIgb24gd2UgY2FuIHByb3ZpZGUgZWFzaWVyIHdlIGhvdyB0b1xuICAgICAqICBpbml0aWFsaXplIGFuZCBzZXQgc2VsZWN0aW9uUGF0aHMgYW5kIHNlbGVjdGlvblN0YXRlcyBmcm9tIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGF0ZTogT3V0bGluZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXQgaW5kZW50YXRpb24gc2l6ZSB0byBiZSB1c2VkIGZvciBlYWNoIGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluZGVudGF0aW9uUGVyTGV2ZWw6IG51bWJlciA9IDI1O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHRlbXBsYXRlIGlzIG91dHNpZGUgb2YgdGhlIG91dGxpbmVGb3JcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4dGVybmFsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBjdXJyZW50IG9iamVjdCB1c2luZyB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dDogYW55O1xuXG5cbiAgICBASW5wdXQoKVxuICAgIHB1c2hSb290U2VjdGlvbk9uTmV3TGluZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJZGVudGlmaWVzIGN1cnJlbnQgbW9kZWwgbW9kZS5cbiAgICAgKlxuICAgICAqIFdlIHJlY29nbml6ZSB0d28gbW9kZXM6XG4gICAgICpcbiAgICAgKiBGcmVlIC0gQXBwbGljYXRpb24gbmVlZHMgdG8gaW1wbGVtZW50IGEgY2hpbGRyZW4gbWV0aG9kIHRvIHJldHJpZXZlIGEgbGlzdCBvZiBjaGlsZHJlbiBmb3JcbiAgICAgKiBlYWNoIG5vZGUgYW5kIGZvcm1hdCBpcyBwcmV0dHkgbXVjaCB1cHQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKiBUcmVlIC0gdGhpcyBpcyBtb3JlIHJlc3RyaWN0aXZlIHdoZXJlIHdlIGhhdmUgY29uY3JldGUgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgKiBpbnRlcmZhY2UgdGhhdCBuZWVkcyB0byBiZSBmb2xsZWRcbiAgICAgKlxuICAgICAqIHRvZG86IGluc3RlYWQgb2YgcGFzc2luZyBmb3JtYXQgYmluZGluZyB0cnkgdG8gbG9vayBpbnRvIHRoZSBsaXN0IHRvIHNlZSB3aGF0IHR5cGUgc29cbiAgICAgKiB3ZSBkb250IG1ha2UgaXQgbWFuZGF0b3J5XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdDogTW9kZWxGb3JtYXQgPSAnZnJlZSc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgd2hlbiBpbiBzZWxlY3Rpb24gbW9kZSB0byBwdXNoIGN1cnJlbnQgc2VsZWN0ZWQgSXRlbSB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSXRlbVNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBieSBPdXRsaW5lQ29udHJvbCB3aGVuIG5vZGUgaXMgZXhwYW5kZWQgb3IgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkV4cGFuZENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBsYXRlIHRvIHVzZSBvbiBhcHBsaWNhdGlvbiBsZXZlbCB0byByZW5kZXIgaW5kaXZpZHVhbCBpdGVtc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ291dGxpbmUnKVxuICAgIGNvbnRyb2xUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgQFZpZXdDaGlsZCgncmVuZGVyZWRJdGVtJylcbiAgICBvdXRsaW5lSXRlbTogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxzXG4gICAgICpcbiAgICAgKiBjdXJyZW50SXRlbSBhbmQgcGFyZW50SXRlbSBhcmUgdXNlZCB0byBjYXB0dXJlIGN1cnJlbnQgcHJvY2Vzc2VkIGl0ZW0gb2YgbmdGb3IuIFRoaXMgaXNcbiAgICAgKiBzZXQgYnkgZGlyZWN0aXZlIGBJbml0TmVzdGluZ0RpcmVjdGl2ZWBcbiAgICAgKlxuICAgICAqIGFuaW1hdGlvbkluUHJvZ3Jlc3M6IHVzZWQgYnkgYW5pbWF0aW9uIGVuZ2luZSB0byBtYWtlIHN1cmUgd2UgZG9udCBkbyBhbnkgYWN0aW9ucyB3aGlsZVxuICAgICAqIGFuaW1hdGlvbiBpcyBpbiB0aGUgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIGVtYmVkZGVkOiBJbmRpY2F0ZXMgdGhhdCB3ZSBhcmUgdXNpbmcgZGlyZWN0aXZlIHNvIGl0IHdpbGwgbm90IGhhdmUgZGVmYXVsdCBjb21wb25lbnRcbiAgICAgKiB3cmFwcGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50SXRlbTogYW55O1xuICAgIHBhcmVudEl0ZW06IGFueTtcbiAgICBhbmltYXRpb25JblByb2dyZXNzOiBib29sZWFuO1xuICAgIGVtYmVkZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIHRoYXQgdGVsbHMgdXMgdGhhdCBjb21wb25lbnQgaXMgZnVsbHkgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIHZpZXdJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgYnVpbGRlcjogQW5pbWF0aW9uQnVpbGRlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBPdXRsaW5lU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm91dGxpbmVGb3IgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kQWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dFeHBhbnNpb25Db250cm9sID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlLmlzRXhwYW5kZWRBbGwgPSB0aGlzLmV4cGFuZEFsbDtcblxuICAgICAgICAvLyBpbiBjYXNlIHdlIHdhbnQgdG8gcmVuZGVyIGNvbnRlbnQgb2YgdHJlZSBvdXRzaWRlIG9mIG91dGxpbmVGb3JcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmV4dGVybmFsVGVtcGxhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xUZW1wbGF0ZSA9IHRoaXMuZXh0ZXJuYWxUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1iZWRkZWQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2F3b3V0bGluZWZvcicpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuICAgIH1cblxuICAgIGlzVHJlZU1vZGVsRm9ybWF0KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA9PT0gJ3RyZWUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgdGVtcGxhdGUgYW5kIE91dGxpbmVDb250cm9sIHRvIGlkZW50aWZ5IHdoaWNoIGl0ZW0gaXMgZXhwYW5kZWQgYW5kIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICovXG4gICAgaXNFeHBhbmRlZChpdGVtOiBhbnksIGN1cnJlbnRMZXZlbDogbnVtYmVyID0gLTEpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoY3VycmVudExldmVsID09PSAwICYmIHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgb3ZlcnJpZGUvcmVzZXQgZm9yIHJvb3Qgbm9kZXNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgICAgICAoPE91dGxpbmVOb2RlPml0ZW0pLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNFeHBhbmRlZChpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNpbmNlIHdlIGhhdmUgY3VycmVudGx5IHR3byB3YXlzIGhvdyB0byBwYXNzIGNoaWxkcmVuIGl0ZW1zIHdlIG5lZWQgaGF2ZSB0aGlzIG1ldGhvZCB0b1xuICAgICAqIHVuaWZ5IHRoZSB3YXkgaG93IHdlIGFjY2VzcyBpdC4gSWYgd2UgcGFzcyBgY2hpbGRyZW5gIGJpbmRpbmcgd2UgdXNlIHRoaXMgaW5zdGVhZCwgb3RoZXJ3aXNlXG4gICAgICogd2UgZXhwZWN0IGN1cnJlbnQgb2JqZWN0IHRvIGhhdmUgYGNoaWxkcmVuYCBmaWVsZFxuICAgICAqXG4gICAgICovXG4gICAgY2hpbGRyZW5Gb3JJdGVtKGl0ZW06IGFueSk6IGFueVtdXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxPdXRsaW5lTm9kZT5pdGVtKS5jaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0NoaWxkcmVuKGl0ZW0pID8gdGhpcy5kb0dldENoaWxkcmVuKGl0ZW0pIDogW107XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgYSBjaGlsZHJlbiBhbmQgbmVlZHMgdG8gYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0NoaWxkcmVuKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9ICg8T3V0bGluZU5vZGU+aXRlbSkuY2hpbGRyZW47XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAwO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNCbGFuayh0aGlzLmNoaWxkcmVuKSAmJiBpc0JsYW5rKGl0ZW0uY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsICdNaXNzaW5nIFtjaGlsZHJlbl0gbWV0aG9kIGJpbmRpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRvR2V0Q2hpbGRyZW4oaXRlbSkubGVuZ3RoID4gMDtcblxuICAgIH1cblxuICAgIGRvR2V0Q2hpbGRyZW4oaXRlbTogYW55KTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW2l0ZW1dKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBVc2VzIHRoZSBgT3V0bGluZVN0YXRlYCB0byB0b2dnbGUgc3RhdGUgb2YgY3VycmVudCBzZWxlY3Rpb25QYXRoLiBUaGUgYHNlbGVjdGlvblBhdGhgIGlzXG4gICAgICogIHB1dCB0b2dldGhlciBpbnNpZGUgYE91dGxpbmVDb250cm9sYCB3aGVyZSB3ZSBpdGVyYXRlIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IGFuZCBhZGRcbiAgICAgKiAgZWFjaCBpdGVtIHRvIHRoZSBgY3VycmVudFBhdGhgIGFycmF5LiBUaGlzIHdheSB3ZSBjb2xsZWN0IGxpc3Qgb2YgaXRlbSByZXByZXNlbnRpbmcgY3VycmVudFxuICAgICAqICBjdXJyZW50IGV4cGFuc2lvblBhdGguXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvbigpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAvLyBiYWNrdXAgcHJvY2VkdXJlIGluIGNhc2Ugb25BbmltYXRpb25Eb25lIGZhaWxzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcykgeyAvLyBjaGFuZ2Ugb25seSBpZiBpdHMgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbWJlZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50SXRlbSA9IExpc3RXcmFwcGVyLmxhc3QodGhpcy5zdGF0ZS5jdXJyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUudG9nZ2xlRXhwYW5zaW9uKHRoaXMuc3RhdGUuY3VycmVudFBhdGgsIHRoaXMuY2hpbGRyZW5Gb3JJdGVtKGN1cnJlbnRJdGVtKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuYW5pbWF0ZUVtYmVkZGVkSXRlbSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGFuaW0uIGNhbGxiYWNrIHRoYXQgc2V0cyBiYWNrIHRoZSBmbGFnIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGFuaW1hdGlvbnNcbiAgICAgKiB3aGVuIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQW5pbWF0aW9uRG9uZShldmVudDogRXZlbnQpXG4gICAge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIGluZGVudGF0aW9uIHVzZWQgdG8gc2hpZnQgdGhlIG5lc3RlZCBzZWN0aW9uIHRvIHRoZSByaWdodCBvciBsYXRlciBvbiB0byB0aGVcbiAgICAgKiBsZWZ0IHdoZW4gUlRMIGlzIHN1cHBvcnRlZFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbmRlbnRhdGlvbihjdXJyZW50TGV2ZWw6IG51bWJlcik6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmIGN1cnJlbnRMZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChjdXJyZW50TGV2ZWwgPT09IDAgJiYgdGhpcy5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpXG4gICAgICAgICAgICA/IDAgOiAodGhpcy5pbmRlbnRhdGlvblBlckxldmVsICogY3VycmVudExldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3QgYWxsIHJvd3MgYXJlIHZpc2libGUgYnkgZGVmYXVsdCwgdGhlcmUgY2FuIGJlIGEgY2FzZSB3aGVyZSB5b3UgZG9udCB3YW50IHRvIHJlbmRlciBpdGVtc1xuICAgICAqIHVzaW5nIG91dGxpbmUuIGUuZy4gRGF0YXRhYmxlIHdpdGggZGV0YWlsIHJvdy5cbiAgICAgKi9cbiAgICBpc1Zpc2libGUoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZpbHRlck91dCkpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5maWx0ZXJPdXQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBTaW5jZSB3ZSBjYW4gbm90IGRpcmVjdGx5IHNldCBgKm5nVGVtcGxhdGVPdXRsZXRgIGNvbnRleHQgdmFyaWFibGVzIHRvIHRoZSB0eXBlc2NyaXB0IGNsYXNzIHdlXG4gKiB1c2UgdGhpcyBkaXJlY3RpdmUgdG8gZG8gdGhlIEpvYlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaW5pdE5lc3RpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBJbml0TmVzdGluZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdFxue1xuXG4gICAgQElucHV0KClcbiAgICBzZXRMZXZlbDogbnVtYmVyO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldEN1cnJyZW50SXRlbTogYW55O1xuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldFBhcmVudEl0ZW06IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBvdXRsaW5lOiBPdXRsaW5lRm9yQ29tcG9uZW50KVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZXRMZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5zdGF0ZS5jdXJyZW50TGV2ZWwgPSB0aGlzLnNldExldmVsO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0Q3VycnJlbnRJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lLmN1cnJlbnRJdGVtID0gdGhpcy5zZXRDdXJycmVudEl0ZW07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmUuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbVsnJCRwYXJlbnRJdGVtJ11cbiAgICAgICAgICAgICAgICAgICAgPSAoPE91dGxpbmVOb2RlPnRoaXMuc2V0Q3VycnJlbnRJdGVtKS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3V0bGluZS5pc1RyZWVNb2RlbEZvcm1hdCgpICYmIGlzUHJlc2VudCh0aGlzLnNldFBhcmVudEl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuY3VycmVudEl0ZW1bJyQkcGFyZW50SXRlbSddID0gdGhpcy5zZXRQYXJlbnRJdGVtO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4uL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZS1zdGF0ZSc7XG5cblxuLyoqXG4gKiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCByZW5kZXJzIHRoZSBpbmRlbnRhdGlvbiwgYXJyb3csIGFuZCB0ZXh0IGZvciBhIG5vZGUgaW4gYW4gb3V0bGluZS5cbiAqIEl0IHNob3VsZCBiZSB1c2VkIGVpdGhlciBpbiB0aGUgYm9keSBvZiBhbiBPdXRsaW5lRm9yIGNvbXBvbmVudCwgb3IgaW5zaWRlIGRhdGF0YWJsZVxuICpcbiAqXG4gKiAjI1VzYWdlIGluc2lkZSBib2R5OlxuICpcbiAqICBIZXJlIHlvdSBjYW4gc2VlIHRoYXQgd2UgbmVlZCB0byB3cmFwIG91dCBjb250ZW50IGluc2lkZSBuZy10ZW1wbGF0ZSB3aGljaCB3aWxsIHB1c2ggdXNcbiAqICBnaXZlIHVzIGN1cnJlbnQgaXRlbSBpdGVtIGFuZCB0aGVuIHdlIGNhbiBwbGFjZSBPdXRsaW5lQ29udHJvbENvbXBvbmVudCB0byBjb250cm9sXG4gKiAgdGhlIHRyZWUuXG4gKlxuICogYGBgXG4gKiAgPGF3LW91dGxpbmUtZm9yMiAjb29vIFtsaXN0XT1cImxpc3RcIiBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIj5cbiAqXG4gKiAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJteS1zZWN0aW9uXCI+XG4gKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm91dGxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgPGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgIDwvYXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgIDwvZGl2PipcbiAqICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L25nLXRlbXBsYXRlPlxuICogIDwvYXctb3V0bGluZS1mb3IyPlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBXZSBjYW5cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtY29udHJvbCcsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgQ29udHJvbCBpcyBqdXN0IHRoZSB0d28gZmxleCBib3ggaXRlbXMgZm9yIGRpc3BsYXlpbmcgZXhwYW5kL2NvbGxhcHNlIGljb24gYW5kIGNvbnRlbnRcblxuICAgIFNpbmNlIHdlIGFuaW1hdGUgb25seSBzdGFuZGFsb25lL25vbi1lbWJlZGRlZCBjYXNlIG5vdyB0aGVuIHdlIG5lZWQgdG8gYWxzbyBhbmltYXRlIHRoZSBpY29uXG4gICAgc28gd2UgdXNlIG9ubHkgaWNvbi1zbGltLWFycm93LXJpZ2h0IGFuZCBkbyB0cmFuZm9ybWF0aW9uIG9uIHRvcCBvZiB0aGlzIHRvIG1ha2UgaXQgcm90YXRlLlxuXG4gICAgSWYgZW1iZWRkZWQgY2FzZSB3ZSB1c2UgYm90aCBpY29ucyBpY29uLXNsaW0tYXJyb3ctcmlnaHQgLyBpY29uLXNsaW0tYXJyb3ctZG93blxuLS0+XG48ZGl2IGNsYXNzPVwidy1vdXRsaW5lLWNvbnRyb2xcIlxuICAgICBbbmdDbGFzc109XCJ7J291dGxpbmUtdS11bnNlbGVjdGFibGUtdGV4dCc6IG91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmICFpdGVtLiQkcGFyZW50SXRlbX1cIj5cbiAgICA8ZGl2IGNsYXNzPVwib3V0bGluZS1pY29uIHNhcC1pY29uXCJcbiAgICAgICAgICpuZ0lmPVwiIW91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lIHx8ICFpc1Jvb3RJdGVtXCJcbiAgICAgICAgIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50KVwiXG4gICAgICAgICBbc3R5bGUubWFyZ2luLWxlZnQucHhdPVwiaW5kZW50YXRpb25cIlxuICAgICAgICAgW25nQ2xhc3NdPVwiY2FsY3VsYXRlU3R5bGVDbGFzcygpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiYWxsb3dTZWxlY3Rpb247IHRoZW4gd2l0aFNlbGVjdGlvbiBlbHNlIHdpdGhvdXRTZWxlY3Rpb25cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48IS0tXG4gV2Ugc3VwcG9ydCB0d28gY2FzZSBmb3IgdGhlIGNvbnRlbnRcblxuIFNlbGVjdGlvbjogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGNvbnRlbnQgaXQgd2lsbCBhZGQgZXh0cmEgY2xhc3Mgc28geW91IGNhbiBzdHlsZSBjdXJyZW50bHlcbiBzZWxlY3RlZCBpdGVtIGFzIHdlbGwgYXMgYnJvYWRjYXN0IGV2ZW50IG91dHNpZGUgc28gZGV2ZWxvcGVyIGNhbiBob29rIGluIHNvbWUgY3VzdG9tIGxvZ2ljXG5cbiBJZiB3ZSBkb250IHN1cHBvcnQgc2VsZWN0aW9uOiBUaGVuIGNsaWNraW5nIG9uIHRoZSBjb250ZW50IGlzIGp1c3QgbGlrZSBjbGlja2luZyBvbiBleHBhbmRhYmxlXG4gaWNvbiwgaXQgdG9nZ2xlcyB0aGUgc3RhdGVcbi0tPlxuXG48bmctdGVtcGxhdGUgI3dpdGhTZWxlY3Rpb24+XG4gICAgIDxzcGFuIGNsYXNzPVwib3V0bGluZS1jb250ZW50IG91dGxpbmUtY29udGVudC1zZWxlY3RlZFwiICpuZ0lmPVwiIWFsbG93RWRpdCAmJiBpc1NlbGVjdGVkKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5nQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cIm91dGxpbmUtY29udGVudFwiICpuZ0lmPVwiIWFsbG93RWRpdCAmJiAhaXNTZWxlY3RlZCgpXCIgKGNsaWNrKT1cInNlbGVjdCgpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJuZ0NvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3NwYW4+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICN3aXRob3V0U2VsZWN0aW9uPlxuICAgIDxzcGFuICpuZ0lmPVwiIWFsbG93RWRpdFwiIGNsYXNzPVwib3V0bGluZS1jb250ZW50XCIgKGNsaWNrKT1cInRvZ2dsZUV4cGFuc2lvbigkZXZlbnQpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJuZ0NvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3NwYW4+XG4gICAgPHNwYW4gKm5nSWY9XCJhbGxvd0VkaXRcIiBjbGFzcz1cIm91dGxpbmUtY29udGVudFwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibmdDb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI25nQ29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLXRlbXBsYXRlPlxuXG5gLFxuICAgIHN0eWxlczogW2Audy1vdXRsaW5lLWNvbnRyb2x7b3ZlcmZsb3c6aGlkZGVuO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwO2N1cnNvcjpwb2ludGVyfS53LW91dGxpbmUtY29udHJvbCAub3V0bGluZS1pY29ue2ZsZXg6MCAwIDE1cHg7Y29sb3I6I2FiYWJhYjtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjExcHg7YWxpZ24tc2VsZjpjZW50ZXI7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSA1MG1zIGVhc2UtaW47dHJhbnNpdGlvbjp0cmFuc2Zvcm0gNTBtcyBlYXNlLWluO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwbXMgZWFzZS1pbiwtd2Via2l0LXRyYW5zZm9ybSA1MG1zIGVhc2UtaW47LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjI1JSA2NSU7dHJhbnNmb3JtLW9yaWdpbjoyNSUgNjUlOy13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkO3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZH0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtaWNvbi5vdXRsaW5lLWljb24tZXhwYW5kZWR7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtY29udGVudHtmbGV4OjEgMSBhdXRvO2ZsZXgtd3JhcDp3cmFwO3BhZGRpbmc6MCA0cHh9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWNvbnRlbnQub3V0bGluZS1jb250ZW50LXNlbGVjdGVke2N1cnNvcjpkZWZhdWx0O2ZvbnQtd2VpZ2h0OjcwMH0ub3V0bGluZS11LXVuc2VsZWN0YWJsZS10ZXh0ey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW8tdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjphdXRvfWBdLFxufSlcbmV4cG9ydCBjbGFzcyBPdXRsaW5lQ29udHJvbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIElmIFRSVUUgaXQgY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIG91dGxpbmUgbm9kZSB0ZXh0IHdoaWNoIGNsaWNrIGlzIHRyaWdnZXJlZFxuICAgICAqICBpdCBzZWxlY3RzIHRoZSBpdGVtIGFuZCBicm9hZGNhc3QgdGhlIGBvbkl0ZW1TZWxlY3RlZGAgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxsb3dTZWxlY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgYWxsb3dFZGl0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIGFjdGlvbiB3aGVuIG91dGxpbmUgaXRlbSBpcyBleHBhbmRlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaXRlbSB1c2VkIGZvciB0aGlzIGBPdXRsaW5lQ29udHJvbGBcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW06IGFueTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgaW5kZW50YXRpb24gdXNlZCB0byBzaGlmdCB0aGUgbmVzdGVkIHNlY3Rpb24gdG8gdGhlIGxlZnQuIFRoaXMgaXMgdXNlZCBmb3JcbiAgICAgKiBlbWJlZGRlZCBtb2RlIGUuZy4gdHJlZSB0YWJsZSB3aGVyZSB3ZSBjYW5ub3QgaW5kZW50IHBhcmVudFxuICAgICAqL1xuICAgIGluZGVudGF0aW9uOiBudW1iZXI7XG5cblxuICAgIGlzUm9vdEl0ZW06IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lU3RhdGUpKVxuICAgICAgICAgICAgICAgIHByaXZhdGUgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGUsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVDb250cm9sQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcml2YXRlIHBhcmVudENvbnRyb2w6IE91dGxpbmVDb250cm9sQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lRm9yQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwdWJsaWMgb3V0bGluZUZvcjogT3V0bGluZUZvckNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMucHJlcGFyZUNvbnRyb2woKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2UgZG9udCBzaG93IGV4cGFuc2lvbiBpY29ucyB3aGVuIHRoZXJlIG5vIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNFeHBhbnNpb25Db250cm9sKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaGFzQ2hpbGRyZW4odGhpcy5pdGVtKSAmJiB0aGlzLm91dGxpbmVGb3Iuc2hvd0V4cGFuc2lvbkNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICBpc1NlbGVjdGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuc2VsZWN0ZWRJdGVtID09PSB0aGlzLml0ZW07XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlU3R5bGVDbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5oYXNFeHBhbnNpb25Db250cm9sKCkgfHxcbiAgICAgICAgICAgICh0aGlzLm91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmIGlzQmxhbmsodGhpcy5pdGVtLiQkcGFyZW50SXRlbSkpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLmlzRXhwYW5kZWQodGhpcy5pdGVtKSA/ICdpY29uLXNsaW0tYXJyb3ctZG93bidcbiAgICAgICAgICAgICAgICA6ICdpY29uLXNsaW0tYXJyb3ctcmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5pc0V4cGFuZGVkKHRoaXMuaXRlbSlcbiAgICAgICAgICAgICAgICA/ICdpY29uLXNsaW0tYXJyb3ctcmlnaHQgb3V0bGluZS1pY29uLWV4cGFuZGVkJyA6ICdpY29uLXNsaW0tYXJyb3ctcmlnaHQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFuZCBleHBhbmRzIGN1cnJlbnQgbm9kZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlRXhwYW5zaW9uKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudFBhdGggPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRoID0gdGhpcy5pdGVtO1xuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudFBhdGgudW5zaGlmdChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICBjdXJyZW50UGF0aCA9IGN1cnJlbnRQYXRoLiQkcGFyZW50SXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0bGluZUZvci50b2dnbGVFeHBhbnNpb24oKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpdGVtOiB0aGlzLml0ZW0sXG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmlzRXhwYW5kZWQodGhpcy5pdGVtKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KHBheWxvYWQpO1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iub25FeHBhbmRDaGFuZ2UuZW1pdChwYXlsb2FkKTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLnNlbGVjdGVkSXRlbSA9IHRoaXMuaXRlbTtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLm9uSXRlbVNlbGVjdGVkLmVtaXQodGhpcy5pdGVtKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXBhcmVDb250cm9sKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub3V0bGluZUZvcikgJiYgaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yID0gdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5vdXRsaW5lRm9yKSwgJ01pc3Npbmcgb3V0bGluZUZvciBjb21wb25lbnQnKTtcbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5lbWJlZGRlZCkge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmIGxldmVsID4gMCkge1xuICAgICAgICAgICAgICAgIGxldmVsIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50YXRpb24gPSAodGhpcy5vdXRsaW5lRm9yLmluZGVudGF0aW9uUGVyTGV2ZWwgKiBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtID0gdGhpcy5vdXRsaW5lRm9yLmN1cnJlbnRJdGVtO1xuICAgICAgICB0aGlzLmlzUm9vdEl0ZW0gPSBpc0JsYW5rKHRoaXMuaXRlbS4kJHBhcmVudEl0ZW0pO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbml0TmVzdGluZ0RpcmVjdGl2ZSwgT3V0bGluZUZvckNvbXBvbmVudH0gZnJvbSAnLi9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtPdXRsaW5lQ29udHJvbENvbXBvbmVudH0gZnJvbSAnLi9vdXRsaW5lLWNvbnRyb2wvb3V0bGluZS1jb250cm9sLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE91dGxpbmVGb3JDb21wb25lbnQsXG4gICAgICAgIE91dGxpbmVDb250cm9sQ29tcG9uZW50LFxuICAgICAgICBJbml0TmVzdGluZ0RpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT3V0bGluZUZvckNvbXBvbmVudCxcbiAgICAgICAgT3V0bGluZUNvbnRyb2xDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXT3V0bGluZUZvck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5cbi8qKlxuICogUmVuZGVycyBodG1sIHRleHQgYXJlYSBjb21wb25lbnRcblxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ215Tm90ZScgLFxuICogICAgICAgICAgdGVtcGxhdGU6ICc8YXctdGV4dC1hcmVhIFt2YWx1ZV09XCJpbnB1dFZhbHVlXCIgW2F1dG9SZXNpemVdPVwiYXV0b1Jlc2l6ZVwiID5cbiAqICAgICAgICAgICAgICA8L2F3LXRleHQtYXJlYT4nXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBNeU5vdGVDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgcmVhbGx5IGxvbmcgdGV4dCc7XG4gKiAgICAgICAgICBhdXRvUmVzaXplOiBmYWxzZTtcbiAqICAgICAgfVxuICpcbiAqIGBgYFxuICogIE5vdGU6IGlmIHlvdSBhcmUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIEZvcm1UYWJsZSBwbGVhc2UgcHJvdmlkZSB5b3VyIG93biBGb3JtR3JvdXBcbiAqL1xuXG5leHBvcnQgY29uc3QgVEVYVEFSRUFfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRBcmVhQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXRleHQtYXJlYScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiZWRpdGFibGVcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuXG5cdDx0ZXh0YXJlYVxuICAgICAgICBwSW5wdXRUZXh0YXJlYVxuICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICBjbGFzcz1cInctdGV4dC1hcmVhXCJcbiAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCJcbiAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwie3tuYW1lfX1cIlxuICAgICAgICBbcm93c109XCJyb3dzXCJcbiAgICAgICAgW2NvbHNdPVwiY29sdW1uc1wiXG4gICAgICAgIFthdXRvUmVzaXplXT1cImF1dG9SZXNpemVcIlxuICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiXG5cbiAgICA+PC90ZXh0YXJlYT5cblxuPC9kaXY+XG5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cInZhbHVlXCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgVEVYVEFSRUFfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBUZXh0QXJlYUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIHVzZWQgdG8gc3RvcmUgYW5kIHJlYWQgdXNlciBpbnB1dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWZpZmllcyB2aXNpYmxlIG51bWJlciBvZiBsaW5lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93czogbnVtYmVyID0gMjtcblxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHZpc2libGUgd2lkdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbHVtbnM6IG51bWJlciA9IDIwO1xuXG5cbiAgICAvKipcbiAgICAgKiB3aGVuIHRoaXMgb3B0aW9uIGlzIFRSVUUgYW5kIHVzZXIgc3RhcnRzIHR5cGluZyBpdCB3aWxsIG1heGltaXplIHRleHRhcmVhJ3Mgd2lkdGggYW5kIGhlaWdodFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXV0b1Jlc2l6ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICAgICkuc3Vic2NyaWJlKHZhbCA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlLCB7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbnB1dFRleHRhcmVhTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtUZXh0QXJlYUNvbXBvbmVudH0gZnJvbSAnLi90ZXh0LWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdUZXh0QXJlYU1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgVGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIFBhZ2UtTm90aWZpY2F0aW9uIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgYSBub3RpZmljYXRpb24gc3lzdGVtIGZvciB0aGUgdXNlciByZWdhcmRpbmdcbiAqIHRoZSBjdXJyZW50IG9iamVjdCBoZSdzIHdvcmtpbmcgb24uIFR5cGljYWwgbm90aWZpY2F0aW9uIGFyZTpcbiAqICAgICAgU3VjY2VzcyAtIHNhdmVkLlxuICogICAgICBXYXJuaW5nIC0gU291cmNpbmcgcmVxdWVzdCByZXF1aXJlcyAzIHN1cHBsaWVycy5cbiAqICAgICAgRXJyb3IgICAtIGNhbm5vdCBjb25uZWN0IHRvIHNlcnZlciwgY2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbi5cbiAqXG4gKlxuICpcbiAqIFVzYWdlIDE6ICBBcyBwYXJ0IG9mIHBhZ2Ugd3JhcHBlci5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ015UGFnZScgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxhdy1vYmplY3QtcGFnZS13cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJNeVBhZ2VcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbb2JqZWN0VHlwZV09XCJNeVR5cGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbm90aWZpY2F0aW9uXT1cInBhZ2VOb3RpZmljYXRpb25cIj5cbiAqICAgICAgICAgICAgIHBhZ2UgY29udGVudFxuICogICAgICAgICAgYFxuICogICAgICAgPC9hdy1vYmplY3QtcGFnZXItd3JhcHBlcj5cbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKlxuICogICAgICAgIHBhZ2VOb3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogVXNhZ2UgMjogZGlyZWN0bHkgaW50byB0aGUgcGFnZS5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGF3LWhlYWRlcj48L2F3LWhlYWRlcj5cbiAqICAgICAgICBQYWdlIEhlYWRlclxuICpcbiAqICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzTm90aWZpY2F0aW9ucygpXCI+XG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1LW5vcGFkZGluZ1wiPlxuICogICAgICAgICAgICA8YXctcGFnZS1ub3RpZmljYXRpb24gW25vdGlmaWNhdGlvbl09XCJub3RpZmljYXRpb25cIj48L2F3LXBhZ2Utbm90aWZpY2F0aW9uPlxuICogICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgIDxhdy1mb290ZXI+PC9hdy1mb290ZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5pbmdcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2Utbm90aWZpY2F0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLW5vdGlmaWNhdGlvblwiPlxuICAgIDxkaXYgW2NsYXNzXT1cIm5vdGlmaWNhdGlvbkNsYXNzKClcIj5cbiAgICAgICAgPGkgW2NsYXNzXT1cIm5vdGlmaWNhdGlvbkljb24oKVwiPjwvaT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj57e25vdGlmaWNhdGlvbi50aXRsZX19PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIm5vdGlmaWNhdGlvbi5oYXNUZW1wbGF0ZSgpOyBlbHNlIGRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vdGlmaWNhdGlvbi5jb250ZW50VG1wbFwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2Rlc2NyaXB0aW9uPnt7bm90aWZpY2F0aW9uLmRlc2NyaXB0aW9ufX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLW5vdGlmaWNhdGlvbnttYXJnaW46MCAwIDVweH0ubm90aWZpY2F0aW9uLWVycm9yLC5ub3RpZmljYXRpb24taW5mbywubm90aWZpY2F0aW9uLXN1Y2Nlc3MsLm5vdGlmaWNhdGlvbi13YXJuaW5ne3BhZGRpbmc6OXB4IDhweH0ubm90aWZpY2F0aW9uLWVycm9yIGksLm5vdGlmaWNhdGlvbi1pbmZvIGksLm5vdGlmaWNhdGlvbi1zdWNjZXNzIGksLm5vdGlmaWNhdGlvbi13YXJuaW5nIGl7Zm9udC1zaXplOjI0cHg7bWFyZ2luOjEwcHh9Lm5vdGlmaWNhdGlvbi1zdWNjZXNzIGl7Y29sb3I6IzU4Yjk1N30ubm90aWZpY2F0aW9uLWluZm8gaXtjb2xvcjojMTk5ZGUwfS5ub3RpZmljYXRpb24td2FybmluZyBpe2NvbG9yOiNmOTB9Lm5vdGlmaWNhdGlvbi1lcnJvciBpe2NvbG9yOiNjMDB9Lm5vdGlmaWNhdGlvbi1zdWNjZXNze2JhY2tncm91bmQtY29sb3I6I2YxZjlmMTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoODgsMTg1LDg3LC41KX0ubm90aWZpY2F0aW9uLWluZm97YmFja2dyb3VuZC1jb2xvcjojZWRmOGZkO2JvcmRlcjoxcHggc29saWQgcmdiYSgyNSwxNTcsMjI0LC41KX0ubm90aWZpY2F0aW9uLXdhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZmOGRkO2JvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMTUzLDAsLjUpfS5ub3RpZmljYXRpb24tZXJyb3J7YmFja2dyb3VuZC1jb2xvcjojZmZlYmViO2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDQsMCwwLC41KX0uaWNvbi1lcnJvcjpiZWZvcmV7Y29udGVudDpcIlxcXFxFQTlEXCJ9Lmljb24td2FybmluZzpiZWZvcmV7Y29udGVudDpcIlxcXFxFQTlDXCJ9LmNvbnRlbnR7dmVydGljYWwtYWxpZ246c3VwZXJ9LnRpdGxle2ZvbnQtd2VpZ2h0OjcwMDttYXJnaW4tcmlnaHQ6MTBweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogQW55IGluZm8sIEVycm9yLCBvciBXYXJuIGZvciB0aGlzIHBhZ2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5vdGlmaWNhdGlvbkNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBub3RpZmljYXRpb24tJHt0aGlzLm5vdGlmaWNhdGlvbi50eXBlfWA7XG4gICAgfVxuXG4gICAgbm90aWZpY2F0aW9uSWNvbigpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgYXJpYmEtaWNvbiBpY29uLSR7dGhpcy5ub3RpZmljYXRpb24udHlwZX1gO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFBhZ2UgTm90aWZpY2F0aW9uIGFyZSBtZXNzYWdlcyBmb3IgdGhpcyBwYWdlIG9ubHkuIEl0IGRpc3BsYXlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIHBhZ2VcbiAqIHJpZ2h0IHVuZGVyIHBhZ2UgdGl0bGUuIFR5cGljYWwgcGFnZSBub3RpZmljYXRpb25zIGFyZSAnc2F2ZSBjb25maXJtYXRpb24nLFxuICogJ2Vycm9yIGR1cmluZyBzdWJtaXQnLCB3YXJuaW5ncyBvZiBmaWVsZCByZXF1aXJlbWVudHMsIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VOb3RpZmljYXRpb25cbntcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdHlwZTogUGFnZU5vdGlmaWNhdGlvblR5cGUsIHB1YmxpYyB0aXRsZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBkZXNjcmlwdGlvbjogc3RyaW5nLCBwdWJsaWMgY29udGVudFRtcGw/OiBUZW1wbGF0ZVJlZjxhbnk+KVxuICAgIHtcbiAgICB9XG5cbiAgICBoYXNUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udGVudFRtcGwpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcsIHRpdGxlOiAnICsgdGhpcy50aXRsZSArICcsIGRlc2NyaXB0aW9uOiAgJyArIHRoaXMuZGVzY3JpcHRpb247XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlTm90aWZpY2F0aW9uVHlwZSA9ICdzdWNjZXNzJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcic7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb25Db21wb25lbnR9IGZyb20gJy4vcGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHBhZ2UgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGFnZUluaXRpYWxpemVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlSW5pdGlhbGl6aWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlRGVzdHJveWVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlRGVzdHJveWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlRXZlbnQgPSBQYWdlSW5pdGlhbGl6ZWQgfCBQYWdlRGVzdHJveWVkO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7UGFnZURlc3Ryb3llZCwgUGFnZUV2ZW50LCBQYWdlSW5pdGlhbGl6ZWR9IGZyb20gJy4vcGFnZS1ldmVudHMnO1xuXG4vKipcbiAqIFBhZ2UgTGlmZUN5Y2xlIFNlcnZpY2UgbW9uaXRvcnMgYWxsIHBhZ2UgaW5pdGlhbGl6YXRpb24gYW5kIGRlc3RydWN0aW9ucy5cbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBoZWxwIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9yIHBhZ2UgbGlmZWN5Y2xlLCBzdWJzY3JpYmVcbiAqIHRvIGxpZmVjeWNsZSBldmVudHMgYW5kIGV4ZWN1dGUgYWN0aW9ucyBzdWNoIGFzIHVzZXIgYW5hbHl0aWNzLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgIDEuICBJbmplY3QgUGFnZUxpZmVDeWNsZVNlcnZpY2UgaW50byB5b3VyIGNvbnN0cnVjdG9yXG4gKlxuICogICAgY29uc3RydWN0b3IocGFnZUxpZmVjeWNsZTpQYWdlTGlmZUN5Y2xlU2VydmljZSkge1xuICogICAgICAgIHBhZ2VMaWZlY3ljbGUucGFnZUV2ZW50cy5zdWJzY3JpYmUoZXZlbnQ6RXZlbnQgPT4ge1xuICogICAgICAgICAgICBpZihldmVudCBpbnN0YW5jZW9mIFBhZ2VJbml0aWFsaXplZCkge1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgICAgIC8vIFBhZ2VEZXN0cm95ZWRcbiAqXG4gKiAgICAgICAgfSk7XG4gKiAgICAgfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUxpZmVDeWNsZVNlcnZpY2VcbntcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgZXZlbnQgcXVldWUgd2hlbiBhbGwgcGFnZSBsaWZlY3ljbGUgZXZlbnRzOiBpbml0LCBkZXN0cm95IGFyZSBlbWl0dGVkLlxuICAgICAqIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFnZUV2ZW50czogU3ViamVjdDxQYWdlRXZlbnQ+ID0gbmV3IFN1YmplY3Q8UGFnZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFnZSBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gcGFnZVRpdGxlXG4gICAgICovXG4gICAgcHVibGljIG9uUGFnZUluaXQocGFnZVRpdGxlOiBzdHJpbmcpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VFdmVudHMubmV4dChuZXcgUGFnZUluaXRpYWxpemVkKHBhZ2VUaXRsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAqIEBwYXJhbSB0aXRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhZ2VEZXN0cm95KHBhZ2VUaXRsZTogc3RyaW5nKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlRXZlbnRzLm5leHQobmV3IFBhZ2VEZXN0cm95ZWQocGFnZVRpdGxlKSk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgcGFnZSB0eXBlcyBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gUGFnZVR5cGUge1xuICAgIEluaXQsICAgICAgICAgLy8gSW5pdCBQYWdlIHR5cGVcbiAgICBMb2dpbiwgICAgICAgIC8vIExvZ2luIFBhZ2VcbiAgICBPYmplY3QsICAgICAgIC8vIE9iamVjdCBkZXRhaWwgcGFnZVxuICAgIExpc3QsICAgICAgICAgLy8gTGlzdCBQYWdlXG4gICAgTWFzdGVyRGV0YWlsLCAvLyBNYXN0ZXJEZXRhaWxcbiAgICBEYXNoYm9hcmQsICAgIC8vIERhc2hib2FyZCBwYWdlXG4gICAgTW9kYWwgICAgICAgICAvLyBNb2RhbCBwYWdlLCBpdCBjYW4gYmUgY29uZmlndXJlZCB0byBiZSBhIHBvcHVwLCBvciBzdGFuZGFsb25lIHBhZ2UuXG59XG5cbi8qKiBQbGFjZWhvbGRlciBub3cuIFRoZSBFcnJvciBNYW5hZ2VyIGhhbmRsZXMgYWxsIHRoZSBlcnJvcnMgb24gdGhlIHBhZ2UuXG4gKiAgSXQgaXMgaW5pdGlhbGl6ZWQgZm9yIGV2ZXJ5IHBhZ2UuIFBhZ2UgZXJyb3JzLCB3YXJuaW5nLCBpbmZvIGdvZXMgdGhyb3VnaFxuICogIHRoZSBlcnJvciBNYW5hZ2VyIGFuZCB0aGUgcmVzdWx0IG1lc3NhZ2UgaXMgZGlzcGxheWVkIG9uIHRoZSBwYWdlIG5vdGlmaWNhdGlvbiBhcmVhLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyXG57XG5cbn1cblxuLyoqXG4gKiAgUGFnZSB3cmFwcGVyIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgcGFnZXMuIFRoZSBpZGVhIGlzIHRoYXQgdGhlcmUgYXJlIGRpZmZlcmVudCBwYWdlIHR5cGVzXG4gKiAgaW4gYW4gQXBwbGljYXRpb24uIEEgTGlzdCBQYWdlIHJlbmRlcnMgYSBsaXN0IG9mIG9iamVjdHMsIGV4OiBjdXN0b21lcnMsIHJlcXVlc3RzLCBQTy4gIEFuZFxuICogIGEgb2JqZWN0IHBhZ2Ugd2lsbCByZW5kZXIgb25lIG9iamVjdCBpbiBkZXRhaWwuXG4gKlxuICogIFRoZXkgc2hhcmUgY29tbW9uIGF0dHJpYnV0ZXMgc3VjaCBhcyBwYWdlIHR5cGUgYW5kIHBhZ2UgaWQuXG4gKlxuICogIEFyaWJhIFBhZ2UgaGF2ZSBhIGxpZmUgY3ljbGUuIFdoZW4gcGFnZSBzdGFydHMgdXAsIGl0J3MgaW5pdGlhbGl6ZWQuIEFuZCB3aGVuIHRoZSBwYWdlIGlzXG4gKiAgZGVzdHJveWVkLCBpdCdsbCBiZSBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhZ2VXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFdoYXQgdHlwZSBvZiBwYWdlIHRoaXMgaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGFnZVR5cGU6IFBhZ2VUeXBlID0gUGFnZVR5cGUuSW5pdDtcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgSWQuIFVzZWQgd2hlbiBwYWdlcyBhcmUgc3RvcmVkIGluIG1hcC5cbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxpbmcgYWxsIHRoZSBlcnJvciBvbiBhIHBhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGVycm9yTWFuYWdlcjogRXJyb3JNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdGhhdCB0aGlzIHBhZ2Ugd3JhcHBlciBoYXMgYmVlbiB3cmFwcGVkIGJ5IGFub3RoZXIgcGFnZSB3cmFwcGVyLlxuICAgICAqIEluIHRoaXMgY2FzZSwgd2Ugd291bGRuJ3QgZGlzcGxheSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgb3RoZXIgcGFnZSB3cmFwcGVyIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBhbHJlYWR5SW5QYWdlV3JhcHBlcjogYm9vbGVhbjtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHBhZ2VUeXBlOiBQYWdlVHlwZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYWdlTGlmZWN5Y2xlU2VydmljZTogUGFnZUxpZmVDeWNsZVNlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICB0aGlzLnBhZ2VUeXBlID0gcGFnZVR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHN1YmNsYXNzIG5lZWRzIHRvIGdlbmVyYXRlZCBhIHBhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBJdCBmb2xsb3dzIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICAgKiAgICB0eXBlX3RpdGxlX2lkXG4gICAgICpcbiAgICAgKiAgICBSRlFfU291cmNpbmdSZXF1ZXN0XzEyM1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdlbmVyYXRlUGFnZUlkKCk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5pcXVlIElkIGZvciB0aGlzIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SWQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlkID0gdGhpcy5nZW5lcmF0ZVBhZ2VJZCgpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50LCBSb3V0aW5nU2VydmljZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1NpZGVuYXZDb21wb25lbnR9IGZyb20gJy4uL3NpZGVuYXYvc2lkZW5hdi5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogSGVhZGVyIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvciBmb3IgYW4gQXJpYmEgcGFnZS5cbiAqIEhlYWRlciBpbmNsdWRlcyBhIG1lbnUsIHVzZXIgcHJvZmlsZSwgYW5kIGFsZXJ0cy5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgIDxhdy1wYWdlLWhlYWRlciBbc2hvd0JhY2tBY3Rpb25dPVwidHJ1ZVwiIHVzZXJOYW1lPVwiQ2hhZCBOb2xsXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21lbnVJdGVtc109XCJtZW51SXRlbXNcIiBbbm90aWZpY2F0aW9uc109XCJ1c2VyTm90aWZpY2F0aW9uc1wiPlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItY2VudGVyXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2YmFyLWJyYW5kXCIgdGFiaW5kZXg9XCIwXCIgaHJlZj1cIi9cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJuYXZiYXItbG9nb1wiIHNyYz1cIi4vaW1hZ2VzL1NBUF9BcmliYV9EQi5wbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD1cIkdvIHRvIGhvbWVwYWdlXCIgZGF0YS1waW4tbm9waW49XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgIDwvYXctcGFnZS1oZWFkZXI+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqICAgICAgbWVudUl0ZW1zOiBQYWdlTWVudUl0ZW1bXSA9IFtuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWhvbWUnLCAnSG9tZScsICcvcGxheS8nKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tZXhwZW5zZS1yZXBvcnQnLCAnUmVwb3J0cycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tc2FsZXMtb3JkZXInLCAnUHVyY2hhc2UgT3JkZXInLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tYWNjb3VudCcsICdBY2NvdW50cycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKV07XG4gKlxuICogICAgIHVzZXJOb3RpZmljYXRpb25zOiBVc2VyTm90aWZpY2F0aW9uW10gPSBbXG4gKiAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1leHBlbnNlLXJlcG9ydCcsICdFeHBlbnNlIHJlcG9ydCBFWFA0NTMgaGFzIGJlZW4gYXBwcm92ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJyksXG4gKiAgICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLXNhbGVzLW9yZGVyJywgJ1NhbGVzIE9yZGVyIFNPMTIzNCBoYXMgYmVlbiBjcmVhdGVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpLFxuICogICAgICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLWFjY291bnQnLCAnU3VwcGxpZXIgYWNjb3VudCBTQTEyMzQgaGFzIGJlZW4gdXBkYXRlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpXG4gKiAgICAgICAgXTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6IGA8bmF2IGNsYXNzPVwibmF2YmFyIHBhZ2UtaGVhZGVyXCIgcm9sZT1cIm5hdmlnYXRpb25cIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLTQgbmF2YmFyLWxlZnRcIj5cblxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc01lbnVJdGVtcygpXCI+XG4gICAgICAgICAgICA8YSAoY2xpY2spPVwic2hvd0hpZGVNZW51KClcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIGljb24tcGFnaW5nXCI+PC9pPlxuICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgICA8IS0tIFNpZGUgbWVudSAtLT5cbiAgICAgICAgICAgIDxhdy1zaWRlbmF2ICNzaWRlbWVudSBbaXRlbXNdPVwibWVudUl0ZW1zXCI+PC9hdy1zaWRlbmF2PlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8IS0tIEVuZCBIYW1idXJnZXIgbWVudS4gLS0+XG5cbiAgICAgICAgICAgIDwhLS0gIGJhY2sgYWN0aW9uIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWNrLWFjdGlvblwiPlxuICAgICAgICAgICAgPGEgKGNsaWNrKT1cImJhY2tBY3Rpb24oKVwiPlxuICAgICAgICAgICAgICAgIDxpICpuZ0lmPVwic2hvd0JhY2tBY3Rpb25cIiBjbGFzcz1cInNhcC1pY29uIGljb24tYXJyb3ctbGVmdFwiIHJvbGU9XCJidXR0b25cIj48L2k+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC00IG5hdmJhci1jZW50ZXJcIj5cblxuICAgICAgICAgICAgPCEtLSBjZW50cmFsIHNlY3Rpb24uICBBcHBsaWNhdGlvbiBjYW4gYWRkIEFyaWJhLWxvZ28sIHNlYXJjaCBib3gsIGV0YyAtLT5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLWhlYWRlci1jZW50ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLTQgbmF2YmFyLXJpZ2h0XCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwidXNlck5hbWVcIj5cbiAgICAgICAgICAgIDxpbWcgaWQ9XCJ1c2VyUHJvZmlsZVBpY3R1cmVcIiBjbGFzcz1cInByb2ZpbGUtbG9nb1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgIFt0aXRsZV09XCJ1c2VyTmFtZVwiIHNyYz1cInt7YXNzZXRGb2xkZXJ9fS9pbWFnZXMvZGVmYXVsdF9pbWFnZV9zbWFsbC5wbmdcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicHJvZmlsZS11c2VyXCIgdGl0bGU9XCJ7e3VzZXJOYW1lfX1cIj57e3VzZXJOYW1lfX08L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhaGlkZU5vdGlmaWNhdGlvblwiIGNsYXNzPVwibm90aWZpY2F0aW9uLWNvbnRhaW5lclwiPlxuXG4gICAgICAgICAgICA8aSAjbm90aWZpY2F0aW9uSWNvbiBjbGFzcz1cImFyaWJhLWljb24gaWNvbi1ub3RpZmljYXRpb25cIlxuICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU5vdGlmaWNhdGlvblBhbmVsKClcIj48L2k+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cImhhc05vdGlmaWNhdGlvbnMoKVwiIGNsYXNzPVwibm90aWZpY2F0aW9uLWJhZGdlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3tub3RpZmljYXRpb25zLmxlbmd0aH19PC9zcGFuPlxuXG4gICAgICAgICAgICAgICAgPCEtLSBPcmlnaW5hbGx5IEkgd2FzIHVzaW5nIHAtb3ZlcmxheS1wYW5lbCwgaG93ZXZlciwgaXQgZG9lc24ndCBwb3NpdGlvbiBjb3JyZWN0bHkgdW5kZXIgdGhlIG5vdGlmaWNhdGlvbiBpY29uLlxuICAgICAgICAgICAgICAgICAgICAgVGhlIHBvc2l0aW9uaW5nIGxvZ2ljIGluIHByaW1lIG5nIG5lZWRzIHNvbWUgbW9yZSBpbnZlc3RpZ2F0aW9uLiBTbyBmb3Igbm93LCB1c2UgYSBkaXYgaW5zdGVhZC0tPlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cInNob3dOb3RpZmljYXRpb25QYW5lbFwiIGNsYXNzPVwibm90aWZpY2F0aW9uLXBhbmVsXCI+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgTm90aWZpY2F0aW9uc1xuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibm90aWZpY2F0aW9uLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBub3RpIG9mIG5vdGlmaWNhdGlvbnNcIiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJub3RpLmxpbmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1pdGVtLWljb25cIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCInc2FwLWljb24gJyArIG5vdGkuaWNvblwiPjwvaT48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tub3RpLmxhYmVsfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG5cblxuICAgIDwvZGl2PlxuPC9uYXY+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS1oZWFkZXIgaXtmb250LXNpemU6MzJweH0ucGFnZS1oZWFkZXIgLmljb24tcGFnaW5ne2ZvbnQtc2l6ZTozMHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDoycHh9LmJhY2stYWN0aW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjE1cHh9LmJhY2stYWN0aW9uIGl7cG9zaXRpb246cmVsYXRpdmU7dG9wOjNweH0ubmF2YmFye2JhY2tncm91bmQ6IzAwMDtjb2xvcjojZmZmfS5uYXZiYXItbGVmdHtwYWRkaW5nLWxlZnQ6MTVweDtoZWlnaHQ6NTBweH0ubmF2YmFyLWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcjtoZWlnaHQ6NTBweH0ubmF2YmFyLXJpZ2h0e3RleHQtYWxpZ246cmlnaHQ7aGVpZ2h0OjUwcHh9LnByb2ZpbGUtbG9nb3t3aWR0aDozMHB4O2hlaWdodDozMHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDoycHh9LnByb2ZpbGUtdXNlcnt2ZXJ0aWNhbC1hbGlnbjpzdXBlcjttYXJnaW4tcmlnaHQ6MzBweH0uaWNvbi1ub3RpZmljYXRpb246YmVmb3Jle2NvbnRlbnQ6XCJcXFxcZUExNFwifS5uYXZiYXIgI3NpZGViYXItbWVudS1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDouNWVtfS5ub3RpZmljYXRpb24tY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1yaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5ub3RpZmljYXRpb24tYmFkZ2V7ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzoycHggNXB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjcwMDtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2MwMDtib3JkZXItcmFkaXVzOjEwcHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDoxNnB4fS5ub3RpZmljYXRpb24tcGFuZWx7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTI3cHg7dG9wOjQ1cHg7d2lkdGg6MzUwcHg7Y29sb3I6Izc2NzY3Njtib3gtc2hhZG93OjAgMnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xMyk7YmFja2dyb3VuZC1jb2xvcjojZmZmO292ZXJmbG93OmhpZGRlbjt0cmFuc2l0aW9uOmFsbCAuM3MgZWFzZS1pbi1vdXR9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWhlYWRlcntiYWNrZ3JvdW5kLWNvbG9yOiNmM2YzZjM7Zm9udC1zaXplOjE2cHg7aGVpZ2h0OjUwcHg7bGluZS1oZWlnaHQ6NTBweDt0ZXh0LWFsaWduOmNlbnRlcn0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24tY29udGVudHtwYWRkaW5nOjA7bWFyZ2luOjB9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWl0ZW17aGVpZ2h0OjUwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkNztwYWRkaW5nOjE1cHggMTBweDt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpc30ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbSBhe2NvbG9yOiM3Njc2NzY7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6MzVweH0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y4ZmF9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWl0ZW0taWNvbnttYXJnaW4tcmlnaHQ6MTVweDtjb2xvcjojNzY3Njc2O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi10b3A6MTBweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9YF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgbWVudSBlbnRyaWVzLiBUaGUgcGFnZSBtZW51IGljb24gd2lsbCBvbmx5IGRpc3BsYXkgd2hlbiB0aGlzIGxpc3QgaXMgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWVudUl0ZW1zOiBQYWdlTWVudUl0ZW1bXTtcblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgdXNlciBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vdGlmaWNhdGlvbnM6IFVzZXJOb3RpZmljYXRpb25bXTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGUgdXNlciBub3RpZmljYXRpb24gaWNvbiBiZSBoaWRkZW4uIERlZmF1bHQgaXQgdG8gc2hvdyB0aGUgaWNvbiBldmVuXG4gICAgICogaWYgdGhlcmUncyBubyBub3RpZmljYXRpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlTm90aWZpY2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgYmFjayBsaW5rIHRoYXQgbmF2aWdhdGVzIHVzZXIgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JhY2tBY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbG9nZ2VkIGluIHVzZXIgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZXJOYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2lkZW1lbnVcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzaWRlbWVudScpXG4gICAgc2lkZW5hdjogU2lkZW5hdkNvbXBvbmVudDtcblxuICAgIHNob3dOb3RpZmljYXRpb25QYW5lbDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByb3V0aW5nOiBSb3V0aW5nU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBiYWNrQWN0aW9uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucm91dGluZy5nb0JhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBpIGhhdmUgYW55IG1lbnUgaXRlbXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNNZW51SXRlbXMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1lbnVJdGVtcyAmJiB0aGlzLm1lbnVJdGVtcy5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHNpZGUgbmF2aWdhdGlvbiBtZW51LlxuICAgICAqL1xuICAgIHNob3dIaWRlTWVudSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNpZGVuYXYudG9nZ2xlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG8gSSBoYXZlIGFueSBub3RpZmljYXRpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzTm90aWZpY2F0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubm90aWZpY2F0aW9ucykgJiYgdGhpcy5ub3RpZmljYXRpb25zLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xpbmcgd2hlYXRoZXIgbm90aWZpY2F0aW9uIHBhbmVsIGlzIGRpc3BsYXllZCBvciBub3QuXG4gICAgICovXG4gICAgdG9nZ2xlTm90aWZpY2F0aW9uUGFuZWwoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uUGFuZWwgPSAhdGhpcy5zaG93Tm90aWZpY2F0aW9uUGFuZWw7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhZ2VNZW51SXRlbSByZXByZXNlbnRzIGFuIGl0ZW0gaW4gdGhlIHBhZ2UgbWVudSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlTWVudUl0ZW1cbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWNvbiAgICAtIEljb24gb2YgdGhpcyBtZW51IGl0ZW0uXG4gICAgICogQHBhcmFtIGxhYmVsICAgLSBsYWJlbCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHBhcmFtIGxpbmsgICAgLSBsaW5rIHRvIHRoZSBkZXN0aW5hdGlvbiB3aGVuIHVzZXIgY2xpY2tzIG9uIGl0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpY29uOiBzdHJpbmcsIHB1YmxpYyBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBsaW5rOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlTWVudUl0ZW06IChsYWJlbCwgJHt0aGlzLmxhYmVsfSlgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBub3RpZmljYXRpb24gZm9yIHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyLlxuICogRXg6ICBQUjIwNDkgaGFzIGJlZW4gYXBwcm92ZWQuXG4gKiAgICAgIE9yZGVyIFBPNTE4IHJlY2VpdmVkLlxuICovXG5leHBvcnQgY2xhc3MgVXNlck5vdGlmaWNhdGlvblxue1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGljb24gICAtIGFsZXJ0IG5vdGlmaWNhdGlvbiBpY29uXG4gICAgICogQHBhcmFtIGxhYmVsICAtIGFsZXJ0IG5vdGlmaWNhdGlvbiBsYWJlbFxuICAgICAqIEBwYXJhbSBsaW5rICAgLSBsaW5rXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIGljb246IHN0cmluZywgcHVibGljIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIGxpbms6IHN0cmluZylcbiAgICB7XG5cbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZVVzZXJOb3RpZmljYXRpb246IChsYWJlbCwgJHt0aGlzLmxhYmVsfSlgO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBGb290ZXIgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yLlxuICogVGhpcyBmb290ZXIgY29tcG9uZW50IHNlbGYgY29udGFpbmVkLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICAgIDxhdy1wYWdlLWZvb3Rlcj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtZm9vdGVyLWxvZ29cIj5cbiAqICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaW1hZ2VzL2FyaWJhX2xvZ29fd2hpdGVfYmtnZC5wbmdcIj5cbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWZvb3Rlci11c2VyLWluZm9cIj5cbiAqICAgICAgICAgICAgICAgICAgIENoYWQgTm9sbCAoY25vbGwpIGxhc3QgdmlzaXQge3tsYXN0X3Zpc2l0ZWQgfCBkYXRlOidNTS9kZC95eXl5IGg6bW1hJyB9fVxuICAqICAgICAgICAgICAgICAgICAgIHwgQnV5ZXIgT3JnYW5pemF0aW9uXG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBhZ2UtZm9vdGVyLWNvcHlyaWdodFwiICNjb3B5cmlnaHQ+XG4gKiAgICAgICAgICAgICAgICAgICA8cD7DgsKpIDIwMjDDosKAwpMyMDI4IFRoZSBGdXR1cmUsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZDwvcD5cbiAqICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgIDwvYXctcGFnZS1mb290ZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1mb290ZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2UtZm9vdGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtOFwiPlxuXG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1mb290ZXItbG9nb1wiPjwvbmctY29udGVudD5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXItaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLWZvb3Rlci11c2VyLWluZm9cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPHVsIGNsYXNzPVwiZm9vdGVyLWxpbmtzXCI+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YSBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmFfdG91LmNmbVwiPlRlcm1zIG9mXG4gICAgICAgICAgICAgICAgICAgIFVzZTwvYT48L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhX3NlY3VyaXR5X3BvbGljeS5jZm1cIj5TZWN1cml0eVxuICAgICAgICAgICAgICAgICAgICBEaXNjbG9zdXJlPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YVxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmFfcHJpdmFjeV9zdGF0ZW1lbnQuY2ZtXCI+UHJpdmFjeVxuICAgICAgICAgICAgICAgICAgICBTdGF0ZW1lbnQ8L2E+PC9saT5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYS1wcml2YWN5LXN0YXRlbWVudFwiPkNvb2tpZSBTdGF0ZW1lbnQ8L2E+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYS1wcml2YWN5LXN0YXRlbWVudFwiPlBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgIFN0YXRlbWVudDwvYT48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInUtYm90dG9tLWFsaWduXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidS1ocmlnaHQgY29weXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtZm9vdGVyLWNvcHlyaWdodFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIERlZmF1bHQgQ29weXJpZ2h0IC0tPlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cInNob3dEZWZhdWx0Q29weXJpZ2h0XCIgY2xhc3M9XCJ1LWhyaWdodCBjb3B5cmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8cD7DgsKpIDE5OTbDosKAwpMyMDE3IEFyaWJhLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQ8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtZm9vdGVye2JhY2tncm91bmQ6I2ZmZjtwYWRkaW5nOjE1cHggMCAwO2ZvbnQtc2l6ZToxMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICNkN2Q3ZDd9LnBhZ2UtZm9vdGVyIC51c2VyLWluZm97Y29sb3I6I2NjY30ucGFnZS1mb290ZXIgLnVpLWd7bWFyZ2luOjAgYXV0b30ucGFnZS1mb290ZXIgLmNvcHlyaWdodHtjb2xvcjojY2NjfS5mb290ZXItbGlua3N7bGlzdC1zdHlsZTpub25lO21hcmdpbjowIC0xNXB4O3BhZGRpbmc6MDtmb250LXNpemU6MTBweH0uZm9vdGVyLWxpbmtzIGxpe2Zsb2F0OmxlZnR9LmZvb3Rlci1saW5rczphZnRlciwuZm9vdGVyLWxpbmtzOmJlZm9yZXtjb250ZW50OlwiIFwiO2Rpc3BsYXk6dGFibGV9LmZvb3Rlci1saW5rczphZnRlcntjbGVhcjpib3RofS5mb290ZXItbGlua3M+bGksLmZvb3Rlci1saW5rcz5saT5he3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2t9LmZvb3Rlci1saW5rcz5saT5he3BhZGRpbmc6MTBweCAxNXB4O2NvbG9yOiMxOTlkZTB9YF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUZvb3RlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBjb3B5cmlnaHQgY29udGVudFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2NvcHlyaWdodCcpIGNvcHlyaWdodDogYW55O1xuXG4gICAgLyoqXG4gICAgICogc2hvdyBkZWZhdWx0IGNvcHlyaWdodC4gSWYgY29weXJpZ2h0IGlzIHBhc3NlZCBpbiwgdGhlbiBzaG93IHRoZSBwYXNzZWQgaW4gb25lLlxuICAgICAqL1xuICAgIHNob3dEZWZhdWx0Q29weXJpZ2h0OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLnNob3dEZWZhdWx0Q29weXJpZ2h0ID0gIWlzUHJlc2VudCh0aGlzLmNvcHlyaWdodCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuLi8uLi8uLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7UGFnZVR5cGUsIFBhZ2VXcmFwcGVyfSBmcm9tICcuLi9wYWdlLXdyYXBwZXInO1xuaW1wb3J0IHtQYWdlTm90aWZpY2F0aW9ufSBmcm9tICcuLi8uLi9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlTGlmZUN5Y2xlU2VydmljZX0gZnJvbSAnLi4vcGFnZS1saWZlY3ljbGUuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VIZWFkZXJDb21wb25lbnR9IGZyb20gJy4uL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VGb290ZXJDb21wb25lbnR9IGZyb20gJy4uL3BhZ2UtZm9vdGVyL3BhZ2UtZm9vdGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIE9iamVjdCBQYWdlIFdyYXBwZXIgQ29tcG9uZW50IHJlbmRlcnMgYW55IG9iamVjdCBpbnN0YW5jZSBpbiBkZXRhaWwuIEl0IGhhcyBhIHVuaWZvcm0gbGF5b3V0LFxuICogSGVhZGVyLCBQYWdlIHRpdGxlLCBQYWdlIG5vdGlmaWNhdGlvbiwgYWN0aW9ucywgY29udGVudCwgYW5kIEZvb3Rlci5cbiAqXG4gKlxuICogIFVzYWdlOlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnUkZYUGFnZScgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxhdy1vYmplY3QtcGFnZS13cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJyZnhFbnRpdHkuaGVhZGVySW5mby50aXRsZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtvYmplY3RUeXBlXT1cInJmeEVudGl0eS5oZWFkZXJJbmZvLmV2ZW50VHlwZVN0cmluZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtub3RpZmljYXRpb25dPVwicGFnZU5vdGlmaWNhdGlvblwiPlxuICpcbiAqXG4gKiAgICAgICAgICAgPGF3LXBhZ2UtYWN0aW9ucz5cbiAqICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInc3VibWl0J1wiIFtuYW1lXT1cIidlZGl0J1wiIFt2YWx1ZV09XCJlZGl0XCIgW3N0eWxlXT1cIidwcmltYXJ5J1wiPlxuICogICAgICAgICAgICAgICAgICAgRWRpdFxuICogICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ2J1dHRvbidcIiBbbmFtZV09XCInY2FuY2VsJ1wiIFt2YWx1ZV09XCJjYW5jZWxcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIj5cbiAqICAgICAgICAgICAgICAgICAgQ2FuY2VsXG4gKiAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgIDwvYXctcGFnZS1hY3Rpb25zPlxuICpcbiAqICAgICAgICAgICA8YXctcGFnZS1jb250ZW50PlxuICogICAgICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJTb3VyY2luZyByZXF1ZXN0IGluZm9cIiAob25TdGF0ZUNoYW5nZWQpPVwib25TdGF0ZUNoYW5nZSgkZXZlbnQpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgPG0tY29udGV4dCBbb2JqZWN0XT1cInJmeEVudGl0eS5oZWFkZXJJbmZvXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wZXJhdGlvbl09XCJ0aGlzLmVkaXRhYmlsaXR5U3RhdGUuaGVhZGVySW5mb09wXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0PVwiSW5zcGVjdFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpR3JvdXA9XCJIZWFkZXJHZW5lcmFsXCJcbiAqICAgICAgICAgICAgICAgICAgID5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8bS1pbmNsdWRlLWNvbXBvbmVudD48L20taW5jbHVkZS1jb21wb25lbnQ+XG4gKiAgICAgICAgICAgICAgICAgICA8L20tY29udGV4dD5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWNvbnRlbnQ+XG4gKiAgICAgICA8L2F3LW9iamVjdC1wYWdlLXdyYXBwZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIFJGWFBhZ2VcbiAqICAgIHtcbiAqICAgICAgIC8vIFRvIGtlZXAgdHJhY2sgd2hhdCBzZWN0aW9uIGlzIGVkaXRhYmxlIGFuZCB3aGljaCByZWFkIG9ubHlcbiAqICAgICAgIGVkaXRhYmlsaXR5U3RhdGU6IEVkaXRhYmlsaXR5U3RhdGU7XG4gKlxuICogICAgICAgLy8gQ3VycmVudCBSRlggZXZlbnRcbiAqICAgICAgIHJmeEVudGl0eTogUmZ4RXZlbnRFbnRpdHk7XG4gKlxuICogICAgICAgLy8gTm90aWZpY2F0aW9uc1xuICogICAgICAgbm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vYmplY3QtcGFnZS13cmFwcGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLXdyYXBwZXJcIj5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhpZGVIZWFkZXJcIj5cbiAgICAgICAgPGF3LWluY2x1ZGUtY29tcG9uZW50IFtuYW1lXT0naGVhZGVyLm5hbWUnPjwvYXctaW5jbHVkZS1jb21wb25lbnQ+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJhcmMtb2JqZWN0LWRldGFpbFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG5cbiAgICAgICAgICAgIDwhLS0gcGFnZSBoZWFkZXIgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiBwYWdlLXRpdGxlXCI+XG5cbiAgICAgICAgICAgICAgICA8IS0tIHBhZ2UgdGl0bGUgLS0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctOCB1aS1tZC04IHBhZ2UtdGl0bGUtdGV4dFwiPnt7dGl0bGV9fTwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctNCB1aS1tZC00IHBhZ2Utc3RhdHVzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwib2JqZWN0LXN0YXR1cy1sYWJlbFwiPnt7b2JqZWN0U3RhdHVzTGFiZWx9fSAmbmJzcDs8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwib2JqZWN0LXN0YXR1c1wiPnt7b2JqZWN0U3RhdHVzfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBwYWdlIGFjdGlvbnMgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiBwYWdlLWFjdGlvbnNcIiAqbmdJZj1cImhhc1RvcFBhZ2VBY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYWN0aW9uc1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNUb3BQYWdlQWN0aW9uc1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBvYmplY3Qgc3RhdGVzICBkaXNwbGF5cyBvbmx5IGlmIHN0YXRlIGV4aXN0cy4gLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiBwYWdlLXN0YXRlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMyBwYWdlLXN0YXRlLWxlZnRcIiBbY2xhc3MuY29udGVudF09XCJoYXNPYmplY3RTdGF0ZXMoKVwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1zdGF0ZS1sZWZ0XCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTYgcGFnZS1zdGF0ZS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImhhc09iamVjdFN0YXRlcygpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcHBlciBbc3RlcHNdPVwib2JqZWN0U3RhdGVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50U3RlcF09XCJvYmplY3RTdGF0ZUluZGV4XCI+PC9hdy1zdGVwcGVyPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0zIHBhZ2Utc3RhdGUtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2Utc3RhdGUtcmlnaHRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuXG4gICAgICAgICAgICA8IS0tIFBhZ2UgTm90aWZpY2F0aW9uIC0tPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImhhc05vdGlmaWNhdGlvbnMoKVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHUtbm9wYWRkaW5nXCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGF3LXBhZ2Utbm90aWZpY2F0aW9uICpuZ0Zvcj1cImxldCBub3RpZmljYXRpb24gb2Ygbm90aWZpY2F0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbm90aWZpY2F0aW9uXT1cIm5vdGlmaWNhdGlvblwiPjwvYXctcGFnZS1ub3RpZmljYXRpb24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8IS0tIGFkZGl0aW9uYWwgY29udGVudCAtLT5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LXBhZ2UtY29udGVudFwiPjwvbmctY29udGVudD5cblxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBwYWdlIGFjdGlvbnMgLS0+XG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTIgcGFnZS1hY3Rpb25zLWJvdHRvbVwiICpuZ0lmPVwiaGFzQm90dG9tUGFnZUFjdGlvbnNcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYWN0aW9uc1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQm90dG9tUGFnZUFjdGlvbnNcIj48L25nLXRlbXBsYXRlPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1wdXNoXCI+PC9kaXY+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoaWRlRm9vdGVyXCI+XG4gICAgPGF3LWluY2x1ZGUtY29tcG9uZW50IFtuYW1lXT0nZm9vdGVyLm5hbWUnPjwvYXctaW5jbHVkZS1jb21wb25lbnQ+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2Utd3JhcHBlcntiYWNrZ3JvdW5kLWNvbG9yOiNmMmYyZjI7bWluLWhlaWdodDoxMDAlO21hcmdpbi1ib3R0b206LTEwMHB4fS5hcmMtb2JqZWN0LWRldGFpbHtwYWRkaW5nOjIwcHh9LnBhZ2UtdGl0bGUtdGV4dHtmb250LXNpemU6MjJweDtjb2xvcjojMDAwO3BhZGRpbmc6MTRweCAwfS5wYWdlLXRpdGxle3BhZGRpbmc6NXB4IDA7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2Q3ZDdkN30ucGFnZS1hY3Rpb25ze3BhZGRpbmc6MTVweCAwIDVweH0ucGFnZS1hY3Rpb25zLWJvdHRvbXtwYWRkaW5nOjAgMjBweH0ucGFnZS1zdGF0ZSwucGFnZS1zdGF0ZS1jZW50ZXIsLnBhZ2Utc3RhdGUtbGVmdCwucGFnZS1zdGF0ZS1yaWdodHtwYWRkaW5nOjB9LmNvbnRlbnQ6OmFmdGVye2NvbnRlbnQ6J1xcXFwwMGEwJztmb250LXNpemU6MH0ucGFnZS10aXRsZSAvZGVlcC8gLnVpLWJ1dHRvbnttaW4td2lkdGg6MTAwcHh9LnBhZ2Utc3RhdHVze3RleHQtYWxpZ246cmlnaHQ7cGFkZGluZzoxOHB4IDB9LnBhZ2Utc3RhdHVzIC5vYmplY3Qtc3RhdHVzLWxhYmVse2NvbG9yOiM3Njc2NzZ9LnBhZ2Utc3RhdHVzIC5vYmplY3Qtc3RhdHVze2ZvbnQtd2VpZ2h0OjcwMDtjb2xvcjojMDM4NzE5fS5wYWdlLXB1c2h7aGVpZ2h0OjEwMHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50IGV4dGVuZHMgUGFnZVdyYXBwZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3lcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHBhZ2VcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0IGJlaW5nIHJlbmRlcmVkIC0gRXZlbnQsIFdvcmtzcGFjZSwgY29udHJhY3QsIGV0Yy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIGxhYmVsIGZvciB0aGUgb2JqZWN0IHN0YXR1cy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXR1c0xhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCdzIHN0YXR1cy4gRm9yIGV4YW1wbGUsIGRyYWZ0LCBwZW5kaW5nIHNlbGVjdGlvbixcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXR1czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwuIFNvbWUgb2JqZWN0IGhhcyBzdGF0ZXMuIEZvciBleGFtcGxlOiBSRnhPYmplY3QgaGFzIFJlc29sdmUsIFJldmlldywgR2V0IFF1b3RlLlxuICAgICAqIE9iamVjdCBzdGF0ZXMgd2lsbCBhcHBlYXIgb24gdGhlIHBhZ2Ugd2hlbiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdGVzOiBzdHJpbmdbXTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBTdGVwcGVyIGlzIHVzZWQgdGhpcyBpZGVudGlmaWVzIGN1cnJlbnQgc2V0IHN0YXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RhdGU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGlzIGEgY29tcG9uZW50IHR5cGUgdG8gYmUgcmVuZGVyZWQgYXMgYSBwYWdlIEhlYWRlci5cbiAgICAgKlxuICAgICAqIFRoZSAnZGVmYXVsdCcgdmFsdWUgaXMgdGhlIGNvbXBvbmVudC93aWRnZXQvSGVhZGVyQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWFkZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0cnVlIGlmIHBhZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBoZWFkZXIuIE5lZWQgdG8gc2V0IHRvIHRydWUgZXZlbiBubyBoZWFkZXJcbiAgICAgKiBvYmplY3QgaXMgcGFzc2VkIGluLiBPdGhlcndpc2UsIGEgZGVmYXVsdCBIZWFkZXIgY29tcG9uZW50IHdpbGwgYmUgYWRkZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGb290ZXIgQ29tcG9uZW50IGlzIHRoZSBwYWdlIGZvb3Rlci5cbiAgICAgKiBjYW4gYmUgb3ZlcnJpZGVuIGJ1dCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBjb21wb2VuZW50L3dpZGdldC9Gb290ZXJDb21wb25lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb290ZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0cnVlIGlmIHBhZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBmb290ZXIuIE5lZWQgdG8gc2V0IHRvIHRydWUgZXZlbiBubyBmb290ZXJcbiAgICAgKiBvYmplY3QgaXMgcGFzc2VkIGluLiBPdGhlcndpc2UsIGEgZGVmYXVsdCBGb290ZXIgY29tcG9uZW50IHdpbGwgYmUgYWRkZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlRm9vdGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb25pbmcgb2YgdGhlIHBhZ2UgYWN0aW9ucyAocGFnZSBidXR0b25zKVxuICAgICAqICAgJ3RvcCcgOiAgICBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLCBiZWxvdyB0aGUgdGl0bGUsIHRvIHRoZSByaWdodC5cbiAgICAgKiAgICdib3R0b20nIDogcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSwgYWJvdmUgdGhlIGZvb3Rlci5cbiAgICAgKiAgICdib3RoJyAgIDogcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgYm90aCB0b3AgYW5kIGJvdHRvbS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGFnZUFjdGlvblBvc2l0aW9uOiBzdHJpbmcgPSAndG9wJztcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmbGFnIGlzIGRyaXZlbiBieSBwYWdlQWN0aW9uUG9zaXRpb24uIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIHRvcC5cbiAgICAgKiBWYWx1ZSBpcyB0cnVlIGZvciBib3RoICd0b3AnIGFuZCAnYm90aCcgb2YgcGFnZUFjdGlvblBvc2l0aW9uLlxuICAgICAqL1xuICAgIGhhc1RvcFBhZ2VBY3Rpb25zOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmxhZyBpcyBkcml2ZW4gYnkgcGFnZUFjdGlvbiBwb3NpdGlvbi5cbiAgICAgKiBWYWx1ZSBpcyB0cnVlIGZvciBib3RoICdib3R0b20nIGFuZCAnYm90aCcgb2YgcGFnZUFjdGlvblBvc2l0aW9uLlxuICAgICAqL1xuICAgIGhhc0JvdHRvbVBhZ2VBY3Rpb25zOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgcCB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdwYWdlQWN0aW9ucycpXG4gICAgYWN0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQW55IFN1Y2Nlc3MsIEluZm8sIEVycm9yLCBvciBXYXJuIGZvciB0aGlzIHBhZ2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb25zOiBQYWdlTm90aWZpY2F0aW9uW107XG5cblxuICAgIG9iamVjdFN0YXRlSW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5LCBwYWdlTGlmZWN5Y2xlU2VydmljZTogUGFnZUxpZmVDeWNsZVNlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIFBhZ2VUeXBlLk9iamVjdCwgY29tcG9uZW50UmVnaXN0cnksIHBhZ2VMaWZlY3ljbGVTZXJ2aWNlKTtcblxuICAgICAgICAvLyBTZXR0aW5nIERlZmF1bHQgaGVhZGVyIGNvbXBvbmVudFxuICAgICAgICB0aGlzLmhlYWRlciA9IFBhZ2VIZWFkZXJDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZm9vdGVyID0gUGFnZUZvb3RlckNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJZCBmb3IgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVBhZ2VJZCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdFR5cGUgKyAnXycgKyB0aGlzLnRpdGxlICsgKHRoaXMuaWQpID8gKCdfJyArIHRoaXMuaWQpIDogJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyBteSBwYWdlIGhhdmUgcGFnZSBub3RpZmljYXRpb24/XG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNOb3RpZmljYXRpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5ub3RpZmljYXRpb25zICYmIHRoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICBoYXNPYmplY3RTdGF0ZXMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm9iamVjdFN0YXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBteSBsb2NhbCBjb21wb25lbnRzXG4gICAgICovXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBOZXcgQ29tcG9uZW50IHR5cGVzIHRoYXQgYXJlIHVzZWQgaW4gYy1pbmNsdWRlLWNvbXBvbmVudFxuICAgICAgICBpZiAodGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJUeXBlKHRoaXMuaGVhZGVyLm5hbWUsIHRoaXMuaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyBDb21wb25lbnQgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiBjLWluY2x1ZGUtY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRSZWdpc3RyeS5yZWdpc3RlclR5cGUodGhpcy5mb290ZXIubmFtZSwgdGhpcy5mb290ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIG5vdGlmeSBzdWJzY3JpYmVycyBvZiB0aGUgcGFnZSBsaWZlY3ljbGUgc2VydmljZSAgKi9cbiAgICAgICAgdGhpcy5wYWdlTGlmZWN5Y2xlU2VydmljZS5vblBhZ2VJbml0KHRoaXMudGl0bGUpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIHBhZ2UgYWN0aW9uIHBvc2l0aW9uLlxuICAgICAgICBpZiAodGhpcy5wYWdlQWN0aW9uUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1RvcFBhZ2VBY3Rpb25zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhhc0JvdHRvbVBhZ2VBY3Rpb25zID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZUFjdGlvblBvc2l0aW9uID09PSAnYm90aCcpIHtcblxuICAgICAgICAgICAgdGhpcy5oYXNUb3BQYWdlQWN0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhhc0JvdHRvbVBhZ2VBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vYmplY3RTdGF0ZXMpICYmIHRoaXMub2JqZWN0U3RhdGVzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICYmIGlzUHJlc2VudCh0aGlzLmN1cnJlbnRTdGF0ZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5vYmplY3RTdGF0ZUluZGV4ID0gdGhpcy5vYmplY3RTdGF0ZXMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddKSAmJlxuICAgICAgICAgICAgY2hhbmdlc1snY3VycmVudFN0YXRlJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWydjdXJyZW50U3RhdGUnXS5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb250IG5lZWQgdG8gY2hlY2sgaWYgb2JqZWN0U3RhdGVzIGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5vYmplY3RTdGF0ZUluZGV4ID0gdGhpcy5vYmplY3RTdGF0ZXMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMucGFnZUxpZmVjeWNsZVNlcnZpY2Uub25QYWdlRGVzdHJveSh0aGlzLnRpdGxlKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBQYWdlIGFjdGlvbnMgaXMgYSB3cmFwcGVyIGZvciBhbGwgcGFnZSBhY3Rpb25zLCBidXR0b25zLCBsaW5rcywgbWVudXMgdGhhdCBpbnRlcmFjdHMgaXQgd2l0aCB0aGVcbiAqIHBhZ2UuIFRoZSB3cmFwcGVyIHVzZSB0aGUgYWJpbGl0eSB0byBwb3NpdGlvbiBpdCBhcyBuZWVkZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLWFjdGlvbnNcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWFjdGlvbnN7dGV4dC1hbGlnbjpyaWdodDtwYWRkaW5nLXRvcDowO3BhZGRpbmctcmlnaHQ6MH1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlQWN0aW9uc0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFnZSBjb250ZW50IGlzIGEgd3JhcHBlciBmb3IgcGFnZSBjb250ZW50LlxuICogQ3VycmVudGx5LCBpdCdzIHByZXR0eSBiYXJlLCBidXQgYXMgd2UgYWRkIG1vcmUgaW50ZXJhY3Rpb25zIG9uIHRoZSBwYWdlLCBsaWtlIGEgc2lkZSBiYXIsXG4gKiB0aGUgcGFnZSBjb250ZW50IGFyZWEgd2lsbCBsaWtlbHkgZ2V0IGFmZmVjdGVkLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtY29udGVudCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICBzdHlsZXM6IFsnOmhvc3Qge3dpZHRoOiAxMDAlOyBwYWRkaW5nOiAwIC41ZW07fSddXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VDb250ZW50Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuXG5jb25zdCBTVEVQUEVSX0NPTVBMRVRFRF9TVEVQX0NPTE9SID0gJyM1OGI5NTcnO1xuY29uc3QgU1RFUFBFUl9DVVJSRU5UX1NURVBfQ09MT1IgPSAnIzAwNzZDQic7XG5jb25zdCBTVEVQUEVSX1JFTUFJTklOR19TVEVQX0NPTE9SID0gJyNEN0Q3RDcnO1xuXG4vKipcbiAqIFN0ZXBwZXIgY29tcG9uZW50IGRpc3BsYXlzIGEgbGlzdCBvZiBzdGVwcyBmb3IgdXNlciB0byBmb2xsb3cuIEl0IGNhbiBiZSB1c2VkIGFzIGEgY2hlY2tsaXN0XG4gKiB0byBpbmRpY2F0ZSBjb21wbGV0ZWQsIGN1cnJlbnQgYW5kIHJlbWFpbmluZyBpdGVtcy4gSXQgY291bGQgYmUgYWxzbyBiZSB1c2VkIHRvIGluZGljYXRlXG4gKiB0aGUgc3RhdGUgb2YgYW4gZG9jdW1lbnQsIGNyZWF0ZWQsIHN1Ym1pdHRlZCwgYXBwcm92ZWQsIGV0Yy4uLlxuICpcbiAqXG4gKiBVc2FnZTpcbiAqICAgMS4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS4gcHJvdmlkZSBhIGxpc3Qgb2Ygc3RlcHMgYW5kIHRoZSBjdXJyZW50IHN0ZXAuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgIDxhdy1zdGVwcGVyIFtzdGVwc109XCJzdGVwc1wiIFtjdXJyZW50U3RlcF09XCJjdXJyZW50U3RlcFwiPjwvYXctc3RlcHBlcj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBzdGVwczogc3RyaW5nW10gPSBbJ01vbml0b3InLCAnQWRkIFN1cHBsaWVyJywgJ0dldCBRdW90ZSddO1xuICogICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqICAgICAgIH1cbiAqXG4gKiAgIDIuICBPdmVycmlkZSB0aGUgZGVmYXVsdCBjb2xvcnMuXG4gKlxuICogICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cInN0ZXBzXCIgW3N0ZXBDb2xvckN1cnJlbnRdPVwiJyNmZjk5MDAnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdGVwQ29sb3JSZW1haW5pbmddPVwiJyNDQzAwMDAnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdGVwQ29sb3JDb21wbGV0ZWRdPVwiJyM5N2E4MjInXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50U3RlcF09XCJjdXJyZW50U3RlcFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1zdGVwcGVyPlxuICogICAgICAgICAgICAgICAgICBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3RlcHBlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic3RlcHBlci1jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwic3RlcHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXAtc3BhY2luZ1wiPjwvZGl2PlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpPWluZGV4OyBsZXQgbGFzdD1sYXN0O1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXBcIj5cbiAgICAgICAgICAgICAgICA8YXctc3RlcCBbdGl0bGVdPVwic3RlcFwiIFtjb2xvcl09XCJnZXRTdGVwQ29sb3IoaSlcIj48L2F3LXN0ZXA+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIhbGFzdFwiIGNsYXNzPVwic3RlcC1jb25uZWN0b3JcIiBbc3R5bGUud2lkdGhdPVwiY29ubmVjdG9yV2lkdGhcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29ubmVjdG9yXCIgW3N0eWxlLmJvcmRlckJvdHRvbUNvbG9yXT1cImdldENvbm5lY3RvckNvbG9yKGkpXCI+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXAtc3BhY2luZ1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInN0ZXAtbGFiZWxzXCI+PC9kaXY+XG48L2Rpdj5cblxuXG5gLFxuICAgIHN0eWxlczogW2Auc3RlcHBlci1jb250YWluZXJ7ZGlzcGxheTp0YWJsZTt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uc3RlcHN7ZGlzcGxheTp0YWJsZS1yb3d9LnN0ZXAtc3BhY2luZ3tkaXNwbGF5OnRhYmxlLWNlbGw7d2lkdGg6MTAlfS5zdGVwe2Rpc3BsYXk6dGFibGUtY2VsbDt3aWR0aDozMnB4fS5zdGVwLWNvbm5lY3RvcntkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlfS5jb25uZWN0b3J7aGVpZ2h0OjFweDtib3JkZXItYm90dG9tOjNweCBzb2xpZCAjNThiOTU3fS5zdGVwLWxhYmVsc3tkaXNwbGF5OnRhYmxlLXJvdztoZWlnaHQ6NTBweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBTdGVwcGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkXG4gICAgICogQXJyYXkgb2Ygc3RlcHMuIE9yZGVyIG9mIHRoZSBzdGVwcyBzaG91bGQgYmUgaW4gYXJyYXkgb3JkZXIuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwczogc3RyaW5nW107XG5cblxuICAgIC8qKlxuICAgICAqIHNwZWNpZnkgdGhlIGNvbG9ycyBhc3NvY2lhdGVkIHdpdGggc3RlcHMgYWJvdmUuIFRoZSBudW1iZXIgb2YgY29sb3JzXG4gICAgICogYW5kIG51bWJlciBvZiBzdGVwcyBtdXN0IG1hdGNoLlxuICAgICAqIE9wdGlvbmFsOiwgaWYgZW1wdHksIGRlZmF1bHQgY29sb3JzIG9yIGNvbG9ycyBmcm9tIHN0ZXBDb2xvciBpbnB1dHMgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29sb3JzOiBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIHZhcmlhYmxlIHRvIGluZGljYXRlIHdoZXRoZXIgdG8gdXNlIHRoZSBjb2xvcnMgYXJyYXkgb3Igbm90LlxuICAgICAqL1xuICAgIGJVc2VDb2xvckFycmF5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiBjb21wbGV0ZWQgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvckNvbXBsZXRlZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgSW5wdXQgZm9yIGNhbGxlciB0byBvdmVycmlkZSB0aGUgY29sb3Igb2YgY3VycmVudCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yQ3VycmVudDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgSW5wdXQgZm9yIGNhbGxlciB0byBvdmVycmlkZSB0aGUgY29sb3Igb2YgcmVtYWluaW5nIHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JSZW1haW5pbmc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0ZXAgdGhhdCdzIG9uLiBJZiBub3QgcHJvdmlkZWQgZGVmYXVsdCB0byB0aGUgZmlyc3Qgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1cnJlbnRTdGVwOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlZCB0aGUgd2lkdGggb2YgY29ubmVjdG9ycyBiZXR3ZWVuIHN0ZXBzLiBUaGUgY2FsY3VsYXRpb25zIGlzIHNvXG4gICAgICogdGhhdCB0aGUgc3RlcHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5LlxuICAgICAqL1xuICAgIGNvbm5lY3RvcldpZHRoOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgICAgIC8vIEluaXRpYWwgY29sb3IgZm9yIHRoZSBkaWZmZXJlbnQgc3RhZ2VzIG9mIHN0ZXBzLlxuICAgICAgICB0aGlzLnN0ZXBDb2xvckNvbXBsZXRlZCA9IFNURVBQRVJfQ09NUExFVEVEX1NURVBfQ09MT1I7XG4gICAgICAgIHRoaXMuc3RlcENvbG9yQ3VycmVudCA9IFNURVBQRVJfQ1VSUkVOVF9TVEVQX0NPTE9SO1xuICAgICAgICB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZyA9IFNURVBQRVJfUkVNQUlOSU5HX1NURVBfQ09MT1I7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb25uZWN0b3Igd2lkdGggYmFzZWQgb24gaG93IG1hbnkgc3RlcHNcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0ZXBzKSAmJiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgLy8gKDEwMCUgLSAyMCUgKHNpZGUgbWFyZ2lucykpIC8gKE51bU9mU3RlcHMgLTEpXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcldpZHRoID0gTWF0aC5jZWlsKDgwIC8gKHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkpICsgJyUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGUgY29sb3IgYXJyYXkgaWYgaXQncyBkZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbG9ycykpIHtcblxuICAgICAgICAgICAgdGhpcy5iVXNlQ29sb3JBcnJheSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9ycy5sZW5ndGggIT09IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2l6ZSBvZiB0aGUgc3RlcHMgYW5kIGNvbG9ycyBkb24ndCBtYXRjaDpcbiAgICAgICAgICAgICAgICAgIChzdGVwcy5sZW5ndGggPSAke3RoaXMuc3RlcHMubGVuZ3RofSksIChjb2xvcnMubGVuZ3RoID0gJHt0aGlzLmNvbG9ycy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXR0aW5nIHRoZSBjb2xvciBvZiB0aGUgc3RlcCBmb3IgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIGdldFN0ZXBDb2xvcihpbmRleDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgLy8gQ29sb3IgQXJyYXkgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgICAgaWYgKHRoaXMuYlVzZUNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1tpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmN1cnJlbnRTdGVwKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvckNvbXBsZXRlZDtcblxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdGVwKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvckN1cnJlbnQ7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3RvciBjb2xvcnMgYXJlIGRyaXZlbiBieSB0aGUgc3RlcCBjb2xvcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRDb25uZWN0b3JDb2xvcihpbmRleDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgLy8gQ29sb3IgQXJyYXkgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgICAgaWYgKHRoaXMuYlVzZUNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1tpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmN1cnJlbnRTdGVwKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvckNvbXBsZXRlZDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JSZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0ZXAuXG4gICAgICovXG4gICAgbmV4dFN0ZXAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXZpb3VzIHN0ZXAuXG4gICAgICovXG4gICAgcHJldlN0ZXAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcC0tO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkluaXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFua30gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogUmVuZGVycyBodG1sIHN0ZXAgY29tcG9uZW50XG4gKlxuICogICogVXNhZ2U6XG4gKiAgICAgICBTdHJhaWdodCBmb3J3YXJkIHRvIHVzZS4gQnV0IG1vc3RseSBpdCB3b3VsZCBiZSB1c2VkIGFzIHBhcnQgb2YgdGhlIHN0ZXBwZXIgY29tcG9uZW50LlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdGVwIFt0aXRsZV09XCJzdGVwXCIgW2NvbG9yXT1cImNvbG9yXCI+PC9hdy1zdGVwPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gKi9cblxuICAgIC8vIERlZmF1bHQgY29sb3IgZm9yIHRoaXMgc3RlcC5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSAnIzU4Yjk1Nyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3RlcCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic3RlcC1jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwib3V0ZXItY2lyY2xlXCIgW3N0eWxlLmJvcmRlckNvbG9yXT1cImNvbG9yXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci1jaXJjbGVcIiBbc3R5bGUuYm9yZGVyQ29sb3JdPVwiY29sb3JcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImNvbG9yXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic3RlcC10aXRsZVwiPnt7dGl0bGV9fTwvZGl2PlxuPC9kaXY+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC5zdGVwLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMnB4fS5vdXRlci1jaXJjbGV7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjNweCBzb2xpZCAjNThiOTU3O3Bvc2l0aW9uOnJlbGF0aXZlfS5pbm5lci1jaXJjbGV7d2lkdGg6OHB4O2hlaWdodDo4cHg7Ym9yZGVyLXJhZGl1czo1MCU7Ym9yZGVyOjJweCBzb2xpZCAjNThiOTU3O2JhY2tncm91bmQtY29sb3I6IzU4Yjk1NzttYXJnaW46MCBhdXRvO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpfS5zdGVwLXRpdGxle3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjE1MHB4O3RvcDo0MHB4O2xlZnQ6LTYwcHg7dGV4dC1hbGlnbjpjZW50ZXJ9YF1cbn0pXG5leHBvcnQgY2xhc3MgU3RlcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciBvZiBzdGVwIGljb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2xvcjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogdGl0bGUgYXBwZWFycyB1bmRlciB0aGUgc3RlcCBncmFwaGljcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBERUZBVUxUX0NPTE9SO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTdGVwcGVyQ29tcG9uZW50fSBmcm9tICcuL3N0ZXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7U3RlcENvbXBvbmVudH0gZnJvbSAnLi9zdGVwL3N0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN0ZXBDb21wb25lbnQsXG4gICAgICAgIFN0ZXBwZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1N0ZXBwZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7UGFnZU1lbnVJdGVtfSBmcm9tICcuLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiAgVGhpcyBpcyBhIHRlbXBvcmFyeSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHBhZ2UgaGVhZGVyIGNvbXBvbmVudC5cbiAqICBXaGVuIHRoZSByZWFsIGltcGxlbWVudGF0aW9uIG9mIHNpZGUgbWVudSBpcyBkb25lLCBQYWdlSGVhZGVyQ29tcG9uZW50IHdpbGxcbiAqICBiZSBzd2FwZWQgdG8gdXNlIGl0LlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zaWRlbmF2JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgW25nQ2xhc3NdPVwiZ2V0U2lkZW5hdkNsYXNzKClcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2lkZW5hdi1jb250ZW50XCI+XG4gICAgICAgIDxhICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCIgW3JvdXRlckxpbmtdPVwiaXRlbS5saW5rXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNpZGVuYXYtaWNvblwiPjxpIFtuZ0NsYXNzXT1cIidzYXAtaWNvbiAnICsgaXRlbS5pY29uXCI+PC9pPjwvc3Bhbj5cbiAgICAgICAgICAgIHt7aXRlbS5sYWJlbH19XG4gICAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnNpZGVuYXZ7aGVpZ2h0OjEwMCU7d2lkdGg6MDtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjE7dG9wOjUwcHg7bGVmdDowO2JhY2tncm91bmQtY29sb3I6IzM2MzYzNjtvdmVyZmxvdy14OmhpZGRlbjtwYWRkaW5nLXRvcDoyMHB4O3RyYW5zaXRpb246LjVzfS5zaWRlbmF2LWFjdGl2ZXt3aWR0aDoyNTBweH0uc2lkZW5hdiBhe3BhZGRpbmc6OHB4IDhweCA4cHggMzJweDt0ZXh0LWRlY29yYXRpb246bm9uZTtmb250LXNpemU6MTZweDtjb2xvcjojZmZmO2Rpc3BsYXk6YmxvY2s7dHJhbnNpdGlvbjouM3N9LnNpZGVuYXYgYTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LnNpZGVuYXYtaWNvbntmb250LXNpemU6MzBweDtjb2xvcjojY2NjO21hcmdpbi1yaWdodDoxMHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVuYXZDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBtZW51IGl0ZW1zXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpdGVtczogUGFnZU1lbnVJdGVtW107XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgYmFjayBsaW5rIHRoYXQgbmF2aWdhdGVzIHVzZXIgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvdzogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgZ2V0U2lkZW5hdkNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgLy8gT25seSBzaG93IGlmIEkgaGF2ZSBpdGVtc1xuICAgICAgICByZXR1cm4gKHRoaXMuc2hvdyAmJiB0aGlzLml0ZW1zKSA/ICdzaWRlbmF2IHNpZGVuYXYtYWN0aXZlJyA6ICdzaWRlbmF2JztcbiAgICB9XG5cbiAgICBvcGVuKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvdyA9ICF0aGlzLnNob3c7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQYWdlTGlmZUN5Y2xlU2VydmljZX0gZnJvbSAnLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7T2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnR9IGZyb20gJy4vb2JqZWN0LXBhZ2Utd3JhcHBlci9vYmplY3QtcGFnZS13cmFwcGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VBY3Rpb25zQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtYWN0aW9ucy9wYWdlLWFjdGlvbnMuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUNvbnRlbnRDb21wb25lbnR9IGZyb20gJy4vcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtZm9vdGVyL3BhZ2UtZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VIZWFkZXJDb21wb25lbnR9IGZyb20gJy4vcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdGVwcGVyTW9kdWxlfSBmcm9tICcuLi9zdGVwcGVyL3N0ZXBwZXIubW9kdWxlJztcbmltcG9ydCB7U2lkZW5hdkNvbXBvbmVudH0gZnJvbSAnLi9zaWRlbmF2L3NpZGVuYXYuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlfSBmcm9tICcuLi9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtSb3V0ZXJNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFNpZGVuYXZDb21wb25lbnRcblxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJvdXRlck1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBTaWRlbmF2Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtQYWdlTGlmZUN5Y2xlU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQVdQYWdlV3JhcHBlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIFJpY2hUZXh0QXJlYSBjb21wb25lbnQgcmVwcmVzZW50cyBhIHRleHQgZWRpdG9yIHdoaWNoIGFsbG93cyB1c2VycyB0byBmb3JtYXQgdGV4dCBpbnB1dC5cbiAqIFRoZSBlZGl0b3IncyB0b29sYmFyIGlzIHByZS1jb25maWd1cmVkIHRvIGNvbnRhaW4gZnVuY3Rpb25hbGl0aWVzIHRoYXQgYXJlIGluIG91ciBkZXNpZ24uXG4gKiBAc2VlIHtAbGluayBlZGl0b3IvZWRpdG9yLmNvbXBvbmVudC5odG1sfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmZ4LWV2ZW50JyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICA8IS0tIEJhc2ljIFVzYWdlLiAtLT5cbiAqICAgICAgICA8YXctcmljaHRleHRhcmVhIFtuYW1lXT1cIidkZXNjcmlwdGlvbidcIiBbdmFsdWVdPVwiZGVzY3JpcHRpb25cIiBwbGFjZUhvbGRlcj1cInB1dFxuICogICAgICAgIGRlc2NyaXB0aW9uXCI+XG4gKiAgICAgICAgPC9hdy1yaWNodGV4dGFyZWE+XG4gKlxuICogICAgICAgIDwhLS0gRWRpdG9yIHdpdGggRnVsbCBmdW5jdGlvbmFsaXR5IC0tPlxuICogICAgICA8YXctcmljaHRleHRhcmVhIFtuYW1lXT1cIidjb21tZW50J1wiIFt0eXBlXT1cImVkaXRvclR5cGVcIiBbdmFsdWVdPVwidmFsdWVcIlxuICogICAgICBwbGFjZUhvbGRlcj1cImhvbGQgdGhpc1wiPlxuICogICAgICA8L2F3LXJpY2h0ZXh0YXJlYT5cbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICBlZGl0b3JUeXBlOkVkaXRvclR5cGUgPSBFZGl0b3JUeXBlLkZ1bGw7XG4gKiAgICAgICAgdmFsdWU6U3RyaW5nO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgdGV4dCBlZGl0b3IuIFRoZXkgYXJlIHByZWNvbmZpZ3VyZWQgd2l0aFxuICogZnVuY3Rpb25hbGl0eSBiYXNlZCBvbiB0eXBlLiBVc2UgY3VzdG9tIHRvIGFkZCB5b3VyIG93biB0b29sYmFyIG1lbnUuXG4gKi9cbmV4cG9ydCBlbnVtIEVkaXRvclR5cGUge1xuICAgIERlZmF1bHQsICAgIC8vIERlZmF1bHQgRWRpdG9yIHN1cHBvcnRzIE1pbmltYWwgc2V0IG9mIGZ1bmN0aW9uYWxpdHlcbiAgICAvLyBbIGJvbGQgfCBpdGFsaWMgfCB1bmRlcmxpbmUgfCBvcmRlcmVkIHwgYnVsbGV0IHwgYWxpZ25tZW50XVxuICAgIEZ1bGwsICAgICAgIC8vIFRoZSBmdWxsIGxpc3Qgb2YgZnVuY3Rpb25hbGl0eSxcbiAgICBUZXh0Rm9ybWF0LCAvLyBGdW5jdGlvbmFsaXRpZXMgdGhhdCBhZmZlY3RzIHRleHQgZm9ybWF0dGluZy5cbiAgICBDdXN0b20gICAgIC8vIEN1c3RvbSB0b29sYmFyLlxufVxuXG5cbmV4cG9ydCBjb25zdCBFRElUT1JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJpY2hUZXh0QXJlYUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yaWNodGV4dGFyZWEnLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlXCI+XG5cbiAgICA8IS0tIEJhc2ljIGVkaXRvciwgYWxzbyB0aGUgZGVmYXVsdCwgd2hpY2ggdGhlIG1vc3QgdXNlZCBmZWF0dXJlcyBlbmFibGVkLiAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwidHlwZSA9PT0gRWRpdG9yVHlwZS5EZWZhdWx0XCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWJvbGRcIiBhcmlhLWxhYmVsPVwiQm9sZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWl0YWxpY1wiIGFyaWEtbGFiZWw9XCJJdGFsaWNcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC11bmRlcmxpbmVcIiBhcmlhLWxhYmVsPVwiVW5kZXJsaW5lXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJvcmRlcmVkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwiYnVsbGV0XCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwibGVmdFwiIHNlbGVjdGVkPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJjZW50ZXJcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwicmlnaHRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwianVzdGlmeVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L3AtaGVhZGVyPlxuICAgICAgICA8L3AtZWRpdG9yPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBFZGl0b3Igd2l0aCBhbGwgdGhlIGZlYXR1cmVzIGVuYWJsZWQgLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuRnVsbFwiPlxuICAgICAgICA8cC1lZGl0b3IgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbc3R5bGVdPVwieydoZWlnaHQnOicxODBweCd9XCJcbiAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiPjwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEVkaXRvciB3aXRoIGFsbCBUZXh0IGZvcm1hdHRpbmcgIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJ0eXBlID09PSBFZGl0b3JUeXBlLlRleHRGb3JtYXRcIj5cbiAgICAgICAgPHAtZWRpdG9yIFsobmdNb2RlbCldPVwidmFsdWVcIiBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW3N0eWxlXT1cInsnaGVpZ2h0JzonMTgwcHgnfVwiXG4gICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIj5cbiAgICAgICAgICAgIDxwLWhlYWRlcj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0LWdyb3VwXCI+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJGb250XCIgY2xhc3M9XCJxbC1mb250XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNhbnMtc2VyaWZcIiBzZWxlY3RlZD1cIlwiPlNhbnMgU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic2VyaWZcIj5TZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtb25vc3BhY2VcIj5Nb25vc3BhY2U8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJTaXplXCIgY2xhc3M9XCJxbC1zaXplXCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwcHhcIj5TbWFsbDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxM3B4XCIgc2VsZWN0ZWQ9XCJcIj5Ob3JtYWw8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMThweFwiPkxhcmdlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjMycHhcIj5IdWdlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtYm9sZFwiIGFyaWEtbGFiZWw9XCJCb2xkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1pdGFsaWNcIiBhcmlhLWxhYmVsPVwiSXRhbGljXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC11bmRlcmxpbmVcIiBhcmlhLWxhYmVsPVwiVW5kZXJsaW5lXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0LWdyb3VwXCI+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJUZXh0IENvbG9yXCIgY2xhc3M9XCJxbC1jb2xvclwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMCwgMClcIiBsYWJlbD1cInJnYigwLCAwLCAwKVwiIHNlbGVjdGVkPVwiXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzAsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMjMwLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAxNTMsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAxNTMsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMClcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDEzOCwgMClcIiBsYWJlbD1cInJnYigwLCAxMzgsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMDIsIDIwNClcIiBsYWJlbD1cInJnYigwLCAxMDIsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE1MywgNTEsIDI1NSlcIiBsYWJlbD1cInJnYigxNTMsIDUxLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjU1KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTAsIDIwNCwgMjA0KVwiIGxhYmVsPVwicmdiKDI1MCwgMjA0LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDIzNSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjM1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIzMiwgMjA0KVwiIGxhYmVsPVwicmdiKDIwNCwgMjMyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIyNCwgMjQ1KVwiIGxhYmVsPVwicmdiKDIwNCwgMjI0LCAyNDUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzUsIDIxNCwgMjU1KVwiIGxhYmVsPVwicmdiKDIzNSwgMjE0LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxODcsIDE4NywgMTg3KVwiIGxhYmVsPVwicmdiKDE4NywgMTg3LCAxODcpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNDAsIDEwMiwgMTAyKVwiIGxhYmVsPVwicmdiKDI0MCwgMTAyLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE5NCwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMTk0LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE4NSwgMTAyKVwiIGxhYmVsPVwicmdiKDEwMiwgMTg1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE2MywgMjI0KVwiIGxhYmVsPVwicmdiKDEwMiwgMTYzLCAyMjQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxOTQsIDEzMywgMjU1KVwiIGxhYmVsPVwicmdiKDE5NCwgMTMzLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMzYsIDEzNiwgMTM2KVwiIGxhYmVsPVwicmdiKDEzNiwgMTM2LCAxMzYpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNjEsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMTYxLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxMDcsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxMDcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDE3OCwgMClcIiBsYWJlbD1cInJnYigxNzgsIDE3OCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDk3LCAwKVwiIGxhYmVsPVwicmdiKDAsIDk3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNzEsIDE3OClcIiBsYWJlbD1cInJnYigwLCA3MSwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiIGxhYmVsPVwicmdiKDEwNywgMzYsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDY4LCA2OCwgNjgpXCIgbGFiZWw9XCJyZ2IoNjgsIDY4LCA2OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDkyLCAwLCAwKVwiIGxhYmVsPVwicmdiKDkyLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCA2MSwgMClcIiBsYWJlbD1cInJnYigxMDIsIDYxLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxMDIsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCAxMDIsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA1NSwgMClcIiBsYWJlbD1cInJnYigwLCA1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDQxLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMCwgNDEsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDYxLCAyMCwgMTAyKVwiIGxhYmVsPVwicmdiKDYxLCAyMCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXQtc2VwYXJhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgICA8c2VsZWN0IHRpdGxlPVwiQmFja2dyb3VuZCBDb2xvclwiIGNsYXNzPVwicWwtYmFja2dyb3VuZFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMCwgMClcIiBsYWJlbD1cInJnYigwLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjMwLCAwLCAwKVwiIGxhYmVsPVwicmdiKDIzMCwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMTUzLCAwKVwiIGxhYmVsPVwicmdiKDI1NSwgMTUzLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMzgsIDApXCIgbGFiZWw9XCJyZ2IoMCwgMTM4LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMTAyLCAyMDQpXCIgbGFiZWw9XCJyZ2IoMCwgMTAyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNTMsIDUxLCAyNTUpXCIgbGFiZWw9XCJyZ2IoMTUzLCA1MSwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMjU1KVwiIHNlbGVjdGVkPVwiXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTAsIDIwNCwgMjA0KVwiIGxhYmVsPVwicmdiKDI1MCwgMjA0LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDIzNSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjM1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIzMiwgMjA0KVwiIGxhYmVsPVwicmdiKDIwNCwgMjMyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIyNCwgMjQ1KVwiIGxhYmVsPVwicmdiKDIwNCwgMjI0LCAyNDUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzUsIDIxNCwgMjU1KVwiIGxhYmVsPVwicmdiKDIzNSwgMjE0LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxODcsIDE4NywgMTg3KVwiIGxhYmVsPVwicmdiKDE4NywgMTg3LCAxODcpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNDAsIDEwMiwgMTAyKVwiIGxhYmVsPVwicmdiKDI0MCwgMTAyLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE5NCwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMTk0LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE4NSwgMTAyKVwiIGxhYmVsPVwicmdiKDEwMiwgMTg1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE2MywgMjI0KVwiIGxhYmVsPVwicmdiKDEwMiwgMTYzLCAyMjQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxOTQsIDEzMywgMjU1KVwiIGxhYmVsPVwicmdiKDE5NCwgMTMzLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMzYsIDEzNiwgMTM2KVwiIGxhYmVsPVwicmdiKDEzNiwgMTM2LCAxMzYpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNjEsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMTYxLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxMDcsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxMDcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDE3OCwgMClcIiBsYWJlbD1cInJnYigxNzgsIDE3OCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDk3LCAwKVwiIGxhYmVsPVwicmdiKDAsIDk3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNzEsIDE3OClcIiBsYWJlbD1cInJnYigwLCA3MSwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiIGxhYmVsPVwicmdiKDEwNywgMzYsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDY4LCA2OCwgNjgpXCIgbGFiZWw9XCJyZ2IoNjgsIDY4LCA2OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDkyLCAwLCAwKVwiIGxhYmVsPVwicmdiKDkyLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCA2MSwgMClcIiBsYWJlbD1cInJnYigxMDIsIDYxLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxMDIsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCAxMDIsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA1NSwgMClcIiBsYWJlbD1cInJnYigwLCA1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDQxLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMCwgNDEsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDYxLCAyMCwgMTAyKVwiIGxhYmVsPVwicmdiKDYxLCAyMCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwib3JkZXJlZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJidWxsZXRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImxlZnRcIiBzZWxlY3RlZD48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImNlbnRlclwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwicmlnaHRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImp1c3RpZnlcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG4gICAgICAgIDwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEN1c3RvbSBoZWFkZXIgVGV4dCBFZGl0b3IgLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuQ3VzdG9tXCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY3VzdG9tLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG4gICAgICAgIDwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cInZhbHVlXCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjU7Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3fS9kZWVwLyBwLWVkaXRvcjphY3RpdmUgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhci5xbC10b29sYmFyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmZvY3VzIC9kZWVwLyAudWktZWRpdG9yLXRvb2xiYXIucWwtdG9vbGJhci5xbC1zbm93LC9kZWVwLyBwLWVkaXRvcjpob3ZlciAvZGVlcC8gLnVpLWVkaXRvci10b29sYmFyLnFsLXRvb2xiYXIucWwtc25vd3tib3JkZXItY29sb3I6IzE5OWRlMH0vZGVlcC8gcC1lZGl0b3I6YWN0aXZlIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmZvY3VzIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmhvdmVyIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3d7Ym9yZGVyLWNvbG9yOiMxOTlkZTB9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEVESVRPUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJpY2hUZXh0QXJlYUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIFJpY2hUZXh0QXJlYUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgZWRpdG9yLiAgU2VlIEVkaXRvclR5cGUgZm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogRWRpdG9yVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzYXZlIGFuZCByZWFkIHdoZW4gcmVuZGVyaW5nIGFuZCB1cGRhdGluZyB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIGVkaXRvclR5cGUgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiB0aGlzIGNvbXBvbmVudHMgdGVtcGxhdGUuXG4gICAgICovXG4gICAgRWRpdG9yVHlwZTogYW55ID0gRWRpdG9yVHlwZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBFZGl0b3JUeXBlLkRlZmF1bHQ7XG4gICAgICAgIHRoaXMuc3R5bGVDbGFzcyA9ICdkZWZhdWx0LWVkaXRvcic7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0VkaXRvck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtSaWNoVGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4uL3JpY2gtdGV4dC1hcmVhL3JpY2gtdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmljaFRleHRBcmVhTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FjY29yZGlvblRhYn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBBbGxvdyBkZXZlbG9wZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCBhY3Rpb25zLiBNdXN0IGhhdmUgdGhpcyBkZWNsYXJlZCBiZWZvcmUgY2xhc3Mgd2hlbiB3ZVxuICogd2FudCB0byBoYXZlIHRoaXMgZGVjbGFyYXRpb24gaW5zaWRlIHRoZSBzYW1lIGZpbGUuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2VjdGlvbi1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD4gYCxcbn0pXG5leHBvcnQgY2xhc3MgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbntcblxufVxuXG5cbi8qKlxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBhIHNlY3Rpb24gb2YgdGhlIHBhZ2UuIEl0J3MgYW4gb3V0bGluZSBib3ggdGhhdFxuICogaGFzIHRoZSBhYmlsaXR5IHRvIGV4cGFuZCBhbmQgaGlkZSBpdHMgY29udGVudC5cbiAqXG4gKiBgYGB0c1xuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZngtZGV0YWlscycgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJTb3VyY2luZyByZXF1ZXN0IGluZm9cIiAob25FZGl0KT1cIm9uU3RhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICogICAgICAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgPG0tY29udGV4dCBbb2JqZWN0XT1cInJmeEVudGl0eS5oZWFkZXJJbmZvXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dD1cIkluc3BlY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHVpR3JvdXA9XCJIZWFkZXJHZW5lcmFsXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8bS1pbmNsdWRlLWNvbXBvbmVudD48L20taW5jbHVkZS1jb21wb25lbnQ+XG4gKiAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKlxuICogICAgICAgICAgIDxhdy1zZWN0aW9uICNzdXBwbGllclNlY3Rpb24gdGl0bGU9XCJTZWxlY3RlZCBzdXBwbGllcnNcIiAob25PcGVuKT1cIm9uT3BlbigpXCJcbiAgICogICAgICAgICAgICAgICAgW29wZW5lZF09XCJmYWxzZVwiPlxuICogICAgICAgICAgICAgICA8c3VwcGxpZXItcHJvZmlsZS1jYXJkPjwvc3VwcGxpZXItcHJvZmlsZS1jYXJkPlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiAgICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJSRlEgRGV0YWlsc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb249XCJSZXZpZXcgYW5kIHVwZGF0ZSBpbmZvcm1hdGlvbiBmb3Igc3VwcGxpZXJzIHRvIHJlc3BvbmQuXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZUNsb3NlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgIDxhdy1zdWJzZWN0aW9uIHRpdGxlPVwiRXZlbnQgdGltZWxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXRhYmxlIFt1c2VGaXZlWm9uZV09XCJmYWxzZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1N0YXJ0IERhdGUnXCIgW25hbWVdPVwiJ3N0YXJ0RGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaGlnaGxpZ2h0Um93XT1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0TmFtZT1cImRhdGVUaW1lXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJzdGFydERhdGVcIiBbdmFsdWVdPVwicmZ4RW50aXR5LmNyZWF0ZWRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Nob3dUaW1lXT1cInRydWVcIj48L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXRhYmxlPlxuICogICAgICAgICAgICAgICA8L2F3LXN1YnNlY3Rpb24+XG4gKiAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IGFsc28gc3VwcG9ydHMgZWRpdGFiaWxpdHkgbW9kZXMgYW5kIGlmIGVuYWJsZWQgaXQgd2lsbCByZW5kZXIgYWN0aW9uIGJ1dHRvbnNcbiAqIGluIHRoZSBmb290ZXIuIERldmVsb3BlciBjYW4gYWxzbyBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIGFuZCBwcm92aWRlIGN1c3RvbSBhY3Rpb25zLlxuICpcbiAqXG4gKiBlLmc6XG4gKlxuICogYGBgXG4gKiAgICAgIDxhdy1zZWN0aW9uIFt0aXRsZV09XCJ0aXRsZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25DYW5jZWxBY3Rpb24pPVwic29tZUhhbmRsZXIxKCRldmVudClcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvblNhdmVBY3Rpb24pPVwic29tZUhhbmRsZXIyKCRldmVudClcIiA+XG4gKiAgICAgICAgICAgICAgc2VjdGlvbiBjb250ZW50XG4gKlxuICpcbiAqICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqIGBgYFxuICpcbiAqIG9yIGN1c3RvbSBhY3Rpb24gYnV0dG9uczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICAgICAgIDxhdy1zZWN0aW9uLWFjdGlvbnM+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uID5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvblRlc3QxXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdXR0b25UZXN0MlxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgPC9hdy1zZWN0aW9uLWFjdGlvbnM+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFRoZXJlIGFyZSB0d28gZWRpdCBtb2Rlc1xuICogICMgRGVmYXVsdFxuICogICAgICBSZW5kZXJzIGFjdGlvbiBidXR0b25zIGluIHRoZSBmb290ZXJzIGFuZCBlbWl0IGFjdGlvbnMgdG8gdGhlIGFwcGxpY2F0aW9uXG4gKlxuICogICMgRXh0ZXJuYWxcbiAqICAgICBObyBhY3Rpb24gYnV0dG9ucyBhcmUgc2hvd24gaW4gdGhlIGZvb3RlciBhbmQgYmVoYXZpb3IgaXMgaGFuZGxlZCBieSBhcHBsaWNhdGlvbi4gT25seSBldmVudFxuICogICAgIGlzIGVtaXRlZC5cbiAqXG4gKlxuICogIGUuZzpcbiAqXG4gKiAgYGBgdHNcbiAqXG4gKiAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiVXNlciBJbmZvcm1hdGlvblwiIChvbkVkaXQpPVwib25BZGRTb21ldGhpbmcoJGV2ZW50KVwiXG4gKiAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCIgW2VkaXRNb2RlXT1cIidleHRlcm5hbCdcIiA+XG4gKiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICBDb250ZW50XG4gKiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LXNlY3Rpb24+XG4gKlxuICogIGBgYFxuICpcbiAqIE5vdGU6IFdoZW4gdXNpbmcgZWRpdGluZyBtb2RlIHlvdSBoYXZlIHRvIGNhbGwgYXQgdGhlIGVuZCBvZiB0aGUgZWRpdGluZyBjeWNsZSBtZXRob2RcbiAqIGBjb21wbGV0ZUVkaXRpbmcoKWAgdG8gY29tbWl0IGVkaXRpbmcgd2hpY2ggY2hhbmdlcyBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgU2VjdGlvbi5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zZWN0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHNlY3Rpb24tY29udGFpbmVyXCJcbiAgICAgW2NsYXNzLmVkaXRpbmddPVwiZWRpdGFibGUgJiYgZWRpdFN0YXRlICYmIGVkaXRNb2RlID09PSAnZGVmYXVsdCdcIj5cblxuICAgIDxwLWFjY29yZGlvbiAob25PcGVuKT1cIm9uU2VjdGlvbk9wZW4oJGV2ZW50KVwiIChvbkNsb3NlKT1cIm9uU2VjdGlvbkNsb3NlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICBbc3R5bGVDbGFzc109XCJhQ2xhc3MoKVwiPlxuICAgICAgICA8cC1hY2NvcmRpb25UYWIgI2FjY29yZGlvblRhYiBbc2VsZWN0ZWRdPVwib3BlbmVkXCIgW2Rpc2FibGVkXT1cImRpc2FibGVDbG9zZVwiPlxuICAgICAgICAgICAgPHAtaGVhZGVyPlxuICAgICAgICAgICAgICAgIDwhLS0gdGl0bGUgYW5kIGRlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWhlYWRlci1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdGl0bGVcIj57e3RpdGxlfX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhhc0Rlc2NyaXB0aW9uKClcIiBjbGFzcz1cInNlY3Rpb24tZGVzY3JpcHRpb25cIj57e2Rlc2NyaXB0aW9ufX08L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8IS0tIGFjdGlvbnM6IEhpZGUgd2hlbiBpbiBlZGl0aW5nIGFuZCBlZGl0TW9kZSBpcyBkZWZhdWx0IC0tPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiKGVkaXRhYmxlICYmICFlZGl0U3RhdGUgJiYgZWRpdE1vZGUgPT09ICdkZWZhdWx0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlZGl0YWJsZSAmJiBlZGl0TW9kZSA9PT0gJ2V4dGVybmFsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2VjdGlvbi1hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YXctaHlwZXJsaW5rIChhY3Rpb24pPVwib25FZGl0QWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIHNlY3Rpb24tZWRpdC1hY3Rpb25cIiBbbmdDbGFzc109XCJhY3Rpb25JY29uXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1oeXBlcmxpbms+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9wLWhlYWRlcj5cblxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L3AtYWNjb3JkaW9uVGFiPlxuICAgIDwvcC1hY2NvcmRpb24+XG4gICAgPCEtLVxuICAgICAgICBuZWVkIHRvIHB1dCBpdCBvdXRzaWRlIG9mIHAtYWNjb3JkaW9uIG90aGVyd2lzZSBidXR0b24gd2lsbCBpbmhlcml0IGRpZmZlcmVudFxuICAgICAgICBjb2xvciBzY2hlbWVcbiAgICAtLT5cbiAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1mb290ZXItY29udGFpbmVyXCIgKm5nSWY9XCJlZGl0YWJsZSAmJiBlZGl0U3RhdGUgJiZcbiAgICAgICAgICAgIGVkaXRNb2RlID09PSAnZGVmYXVsdCdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvb3Rlci1hY3Rpb25zXCI+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQ3VzdG9tQWN0aW9ucygpXCI+XG4gICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIiBzaXplPVwic21hbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNhbmNlbEFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgQ2FuY2VsXG4gICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBzaXplPVwic21hbGxcIiAoYWN0aW9uKT1cIm9uU2F2ZUFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgU2F2ZVxuICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctc2VjdGlvbi1hY3Rpb25zXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnNlY3Rpb24taGVhZGVyLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0uc2VjdGlvbi1jb250YWluZXJ7bWFyZ2luOjEwcHggMDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7cGFkZGluZzouMmVtIC41ZW07Ym9yZGVyOjJweCBkYXNoZWQgdHJhbnNwYXJlbnR9LnNlY3Rpb24tY29udGFpbmVyLmVkaXRpbmd7Ym9yZGVyLWNvbG9yOiMxOTlkZTB9LnNlY3Rpb24tY29udGFpbmVyIDo6bmctZGVlcCAudWktYWNjb3JkaW9uLWhlYWRlcj5he2Rpc3BsYXk6ZmxleH0uc2VjdGlvbi1jb250YWluZXIgOjpuZy1kZWVwIC51aS1hY2NvcmRpb24taGVhZGVyPmEgLnVpLWFjY29yZGlvbi10b2dnbGUtaWNvbntmbGV4OjAgMCAzMHB4O3BhZGRpbmctdG9wOjJweH0uc2VjdGlvbi1jb250YWluZXIgOjpuZy1kZWVwIC51aS1hY2NvcmRpb24taGVhZGVyPmEgcC1oZWFkZXJ7ZmxleDoxIDB9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1kaXNhYmxlZHtvcGFjaXR5OjF9LnNlY3Rpb24tdGl0bGV7Zm9udC1zaXplOjEuMWVtfS5zZWN0aW9uLWRlc2NyaXB0aW9ue2ZvbnQtc2l6ZTouOWVtO3BhZGRpbmc6LjZlbSAwIC4yZW19LnNlY3Rpb24tZm9vdGVyLWNvbnRhaW5lcnttYXJnaW46MWVtIDJlbSAwO3BhZGRpbmc6LjhlbSAwIDEuNWVtIC44ZW07Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkN30uc2VjdGlvbi1mb290ZXItY29udGFpbmVyIC5mb290ZXItYWN0aW9uc3tkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOnJpZ2h0O3dpZHRoOjEwMCV9LnNlY3Rpb24tYWN0aW9uc3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO3otaW5kZXg6MX0uc2VjdGlvbi1hY3Rpb25zIC9kZWVwLyBhLmxpbmssLnNlY3Rpb24tYWN0aW9ucyAvZGVlcC8gYS5saW5rOmhvdmVye3BhZGRpbmc6MDt0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VjdGlvbi1lZGl0LWFjdGlvbntmb250LXNpemU6MS41ZW07cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzouMWVtIDAgLjFlbSAuNWVtO2N1cnNvcjpwb2ludGVyfS5zZWN0aW9uLWVkaXQtYWN0aW9uLmljb24tZWRpdHtmb250LXNpemU6MS40ZW19LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlcntjb2xvcjojMzYzNjM2O2JvcmRlcjpub25lO2JhY2tncm91bmQ6I2ZmZiFpbXBvcnRhbnQ7cGFkZGluZzowIDFlbX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24tY29udGVudHtib3JkZXI6bm9uZTtwYWRkaW5nOjFlbSAyZW19LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gYVtyb2xlPXRhYl17cGFkZGluZzouNzVlbSAwO3RleHQtZGVjb3JhdGlvbjpub25lfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtYWN0aXZlIC9kZWVwLyBhW3JvbGU9dGFiXXtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZDdkN2Q3O2NvbG9yOiMzNjM2MzZ9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAuc2VjdGlvbi1uby1oZWFkZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVye2hlaWdodDoxcHh9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAuc2VjdGlvbi1uby1oZWFkZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWFjdGl2ZSAvZGVlcC8gYVtyb2xlPXRhYl17Ym9yZGVyLWJvdHRvbTpub25lfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnNlY3Rpb24tbm8taGVhZGVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAuc2VjdGlvbi1lZGl0LWFjdGlvbntjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnR9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtZG93biw6aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIC5waS5waS1jYXJldC1yaWdodHtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Zm9udC1zaXplOjEuMWVtO3RvcDouOGVtO2xlZnQ6LjFlbTtjb2xvcjojNzY3Njc2O21hcmdpbi10b3A6MH06aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtZGlzYWJsZWQgL2RlZXAvIC5mYSw6aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtZGlzYWJsZWQgL2RlZXAvIC5waXtkaXNwbGF5Om5vbmV9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XCJcXFxcZTFlZFwifTpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gLnBpLnBpLWNhcmV0LWRvd246YmVmb3Jle2NvbnRlbnQ6XCJcXFxcZTFlZlwifWBdXG59KVxuZXhwb3J0IGNsYXNzIFNlY3Rpb25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBzZWN0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgc2VjdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgdGhpcyBzZWN0aW9uIGJlIG9wZW5lZCBhdCB0aGUgc3RhcnQuIERlZmF1bHQgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb3BlbmVkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBzZWN0aW9uIGNhbiBiZSBjbG9zZWQgb3Igbm90LlxuICAgICAqKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVDbG9zZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNlY3Rpb24gaXMgaW4gRWRpdFN0YXRlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgd2Ugc2hvdyBcIkNhbmNlbCAvIFNhdmVcIiBidXR0b24gZGV2ZWxvcGVyIG5lZWRzIHVzZSB0aGlzIGJpbmRpbmdcbiAgICAgKiB0byBjb250cm9sIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRTdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IEVkaXRpbmcgbW9kZS4gVGVsbHMgdGhlIGNvbXBvbmVudHMgaWYgaXRzIGl0cyBkZWZhdWx0IGJlaGF2aW9yIG9yIGRyaXZlbiBieVxuICAgICAqIGFwcGxpY2F0aW9uIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICoge0BzZWUgRWRpdE1vZGV9XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRNb2RlOiBFZGl0TW9kZSA9ICdkZWZhdWx0JztcblxuXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVyIGNhbiBwcm92aWRlIGN1c3RvbSBFZGl0IGFjdGlvbiBpY29uIHRoYXQgd2lsbCBhcHBlYXIgaW4gdGhlIHJpZ2h0IHRvcCBjb3JuZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFjdGlvbkljb246IHN0cmluZyA9ICdpY29uLWVkaXQnO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWN0aW9uIGlzIGZ1bGx5IG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWN0aW9uIGlzIGZ1bGx5IGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEVkaXQgc3RhdGUgdG8gYnJvYWRjYXN0IHN0YXRlIG9mIGN1cnJlbnQgc2VjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uRWRpdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgZGVmYXVsdCBidXR0b25zIGFyZSByZW5kZXJlZCBvbiBjbGljayBicm9hZGNhc3QgQ2FuY2VsIGFjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCBkZWZhdWx0IGJ1dHRvbnMgYXJlIHJlbmRlcmVkIG9uIGNsaWNrIGJyb2FkY2FzdCBTYXZlIGFjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2F2ZUFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIEBPdXRwdXQoKVxuICAgIG9uRWRpdGluZ0NvbXBsZXRlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIHZhcmlhYmxlIG9uIHdoZXRoZXIgdGhpcyBzZWN0aW9uIGlzIGV4cGFuZGVkIG9yIG5vdC5cbiAgICAgKiBEaWZmZXJzIGZyb20gJ29wZW5lZCcuIG9wZW5lZCBpcyBhbiBpbnB1dCBwYXJhbWV0ZXIgYW5kIGl0IGRvZXNuJ3QgdHJhY2tcbiAgICAgKiBjdXJyZW50IHNlY3Rpb24gZXhwYW5kZWQgc3RhdGUuXG4gICAgICovXG4gICAgZXhwYW5kZWQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBhY2NvcmRpb25UYWJcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdhY2NvcmRpb25UYWInKVxuICAgIHByaXZhdGUgYWNjb3JkaW9uVGFiOiBBY2NvcmRpb25UYWI7XG5cblxuICAgIC8qKlxuICAgICAqIFNhdmUgcmVmZXJlbmNlIHRvIGRldmVsb3BlcidzIGRlZmluZWQgYWN0aW9ucyBzbyBpZiB3ZSBjYW4gaGlkZSBkZWZhdWx0IG9uZXNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50KVxuICAgIGN1c3RvbUFjdGlvbnM6IFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIElmIEkgaGF2ZSBub3QgaGVhZGVyLCB0aGVuIEkgY2FuJ3QgY2xvc2UgdGhlIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5pc0hlYWRlckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBJIGNhbid0IGNsb3NlIHRoZSBzZWN0aW9uLCB0aGVuIGl0IHNob3VsZCBkZWZhdWx0IG9wZW4uXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBleHBhbmRlZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRoaXMub3BlbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvbid0IGRpc3BsYXkgaGVhZGVyIGFyZWEgaWYgSSBkb24ndCBoYXZlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNIZWFkZXJEaXNwbGF5ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQodGhpcy50aXRsZSkgfHwgaXNQcmVzZW50KHRoaXMuZGVzY3JpcHRpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDc3MgQ2xhc3MgdGhhdCBjb250cm9sIHRoZSBsb29rIGFuZCBmZWVsIGZvciBzZWN0aW9uIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhQ2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaXNIZWFkZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWN0aW9uLW5vLWhlYWRlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UgaW50cm9kdWNlZCBidXR0b25zIGFuZCBlZGl0U3RhdGUgdGhlIGRlY2lzaW9uIG9uIHdoZW4gdG8gZXhpdCBlZGl0aW5nIG1vZGVcbiAgICAgKiBzaG91bGQgYmUgb24gdGhlIGRldmVsb3BlciB1c2luZyB0aGlzIGNvbXBvbmVudCB0aGVyZWZvcmUgb25seSBzdGFydEVkaXRpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRWRpdEFjdGlvbigkZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgLy8gd2hlbiBpbiBlZGl0aW5nIG1ha2Ugc3VyZSB3ZSBkb250IHN3aXRjaCBzdGF0ZSBhcyB0aGVyZSBjYW4gYmUgc29tZSBGb3JtIGVycm9yc1xuICAgICAgICAvLyB3aGljaCBuZWVkcyB0byBiZSBoYW5kbGVkIGJ5IGRldmVsb3BlciBhbmQgb25seSB0aGVuIGNoYW5nZSB0aGUgZWRpdFN0YXRlXG4gICAgICAgIGlmICghdGhpcy5lZGl0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFN0YXRlID0gIXRoaXMuZWRpdFN0YXRlO1xuICAgICAgICAgICAgbGV0IHN0YXRlOiBzdHJpbmcgPSAodGhpcy5lZGl0U3RhdGUpID8gJ2luRWRpdCcgOiAnbm90SW5FZGl0JztcblxuICAgICAgICAgICAgdGhpcy5vbkVkaXQuZW1pdChzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIG9yaWdpbmFsIGV2ZW50IGZyb20gYnViYmxpbmcgdXAuIEJlY2F1c2UgdGhlIGVkaXQgaWNvbiBpcyBpbnNpZGVcbiAgICAgICAgLy8gdGhlIGhlYWRlci4gSWYgdGhlIGNsaWNrIGV2ZW4gaXMgYnViYmxlZCB1cCwgdGhpcyBldmVudCB3aWxsIGNhdXNlIHRoZSBzZWN0aW9uIHRvXG4gICAgICAgIC8vIGV4cGFuZCBvciBjb2xsYXBzZS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCgkZXZlbnQuZXZlbnQpKSB7XG4gICAgICAgICAgICAkZXZlbnQuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkZXZlbnQuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc0Rlc2NyaXB0aW9uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5kZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGlzIHNlY3Rpb24sIGlmIGl0J3MgYWxyZWFkeSBvcGVuLCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgb3BlbihldmVudD86IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvblRhYi50b2dnbGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhpcyBzZWN0aW9uLCBpZiBpdCdzIGFscmVhZHkgY2xvc2UsIHdpbGwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBjbG9zZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uVGFiLnRvZ2dsZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYWNjb3JkaW9uIGlzIG9wZW5lZFxuICAgICAqXG4gICAgICovXG4gICAgb25TZWN0aW9uT3BlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoJ29wZW4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYWNjb3JkaW9uIGlzIGNsb3NlZFxuICAgICAqXG4gICAgICovXG4gICAgb25TZWN0aW9uQ2xvc2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHVzIGlmIHdlIG5lZWQgdG8gcmVuZGVyIGFwcGxpY2F0aW9uIGRlZmluZWQgY3VzdG9tIGFjdGlvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0N1c3RvbUFjdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmN1c3RvbUFjdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGVkaXRpbmcgc3RhdGUgYmFjayB0byBub24tZWRpdGFibGVcbiAgICAgKi9cbiAgICBjb21wbGV0ZUVkaXRpbmcoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5lZGl0U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkVkaXRpbmdDb21wbGV0ZS5lbWl0KHRoaXMuZWRpdFN0YXRlKTtcbiAgICB9XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3Vic2VjdGlvbicsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwic3Vic2VjdGlvbi10aXRsZVwiPnt7dGl0bGV9fTwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICAgYCxcbiAgICBzdHlsZXM6IFsnLnN1YnNlY3Rpb24tdGl0bGUge2NvbG9yOiAjMzYzNjM2OyB9J11cbn0pXG5leHBvcnQgY2xhc3MgU3ViU2VjdGlvbkNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgc3ViIHNlY3Rpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG59XG5cblxuLyoqXG4gKiBEZWZpbmVzIGVkaXRpbmcgbW9kZXMgZm9yIHRoZSBTZWN0aW9ucy4gRGVmYXVsdCBtZWFucyB3ZSBzaG93IGNhbmNlbCAvIHNhdmUgYnV0dG9ucyBhbmQgaGlkZVxuICogZWRpdCBpY29ucyB3aGVuIGluIGVkaXRpbmcuIGV4dGVybmFsIGlzIGRyaXZlbiBieSBhcHBsaWNhdGlvblxuICovXG5leHBvcnQgdHlwZSBFZGl0TW9kZSA9ICdkZWZhdWx0JyB8ICdleHRlcm5hbCc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QXJpYmFDb3JlTW9kdWxlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtBY2NvcmRpb25Nb2R1bGUsIFNoYXJlZE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7U2VjdGlvbkFjdGlvbnNDb21wb25lbnQsIFNlY3Rpb25Db21wb25lbnQsIFN1YlNlY3Rpb25Db21wb25lbnR9IGZyb20gJy4vc2VjdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi4vaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQWNjb3JkaW9uTW9kdWxlLFxuICAgICAgICBBcmliYUNvcmVNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgU2hhcmVkTW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTZWN0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBJbnB1dCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FXRGF0YVRhYmxlfSBmcm9tICcuLi9hdy1kYXRhdGFibGUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jvb2xlYW5XcmFwcGVyLCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuZXhwb3J0IHR5cGUgRFRIQWxpZ25tZW50ID0gJ2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnO1xuXG5cbi8qKlxuICogRFRDb2x1bW4gcmVwcmVzZW50IHNpbmdsZSBjb2x1bW4gaW5jbHVkaW5nIGhlYWRlciBhbmQgaXRzIGJvZHkuIEVhY2ggY29sdW1uIGhhcyBpdHMgb3duXG4gKiByZW5kZXJlclRlbXBsYXRlIHdoaWNoIGEgZW50cnkgdG8gdGhpcyBjb21wb25lbnQuXG4gKlxuICogS2VlcGluZyB0aGlzIHNlcGFyYXRlIGZyb20gdGhlIGRhdGF0YWJsZSB3aGVyZSBEVCBpcyBub3QgcmVhbGx5IGF3YXJlIHdoYXQgaXQgaXMgcmVuZGVyaW5nLFxuICogaXQgYWxsb3dzIHVzIG1vcmUgZmxleGliaWxpdHkgaW4gdGVybXMgb2YgZGlmZmVyZW50IHR5cGUgb2YgY29sdW1uIGluaGVyaXRpbmcgZnJvbSB0aGlzXG4gKiBvbmUuLiBTdWNoIGFzOlxuICogIERUUm93RGV0YWlsICBjb2x1bW5cbiAqICBEVFNpbmdsZVNlbGVjdGlvbiBjb2x1bW5cbiAqICBEVE11bHRpU2VsZWN0aW9uIGNvbHVtblxuICpcbiAqIFRoaXMgd2F5IHdlIGRvbid0IGRvIElGL1RIRU4vRUxTRSBpbnNpZGUgdGhlIGRhdGF0YWJsZSBhbmQgdHJ5aW5nIHRvIGNyZWF0ZSBkaWZmZXJlbnQgY2FzZXMuXG4gKlxuICogIFRoZW4gbGF0ZXIgb24gdGhpcyB3aWxsIGxldCB1cyBjcmVhdGUgYWRkaXRpb25hbCBsb2dpYyBmb3IgdGhlIHBpdm90YWwgbGF5b3V0LiBCZWNhdXNlIERUXG4gKiAgZG9lcyBrbm93IGFueXRoaW5nIGFib3V0IHRoZSB0eXBlIG9mIHRoZSBjb2x1bW4gc28gd2hhdGV2ZXIgaXMgYWRkZWQgdG8gdGhlIERULmNvbHVtbnMgaXRcbiAqICB3aWxsIGJlIHJlbmRlcmVkLlxuICpcbiAqXG4gKiAgQ29sdW1ucyBjYW4gYmUgYWxzbyBmcm96ZW4gbWVhbmluZyBpZiB0aGUgY29udGVudCBvdmVyZmxvd3MgdGhleSBkb250IHNjcm9sbC4gVG8gbWFrZSB0aGVcbiAqICBjb2x1bW4gZnJvemVuIHdlIG5lZWQgdG8gdXNlIFtmcm96ZW5dIGJpbmRpbmcgYW5kIHNlIGl0IHRvIFRSVUUgcGx1cyBpdCByZXF1aXJlcyBhIFt3aWR0aF1cbiAqICBiaW5kaW5nIHRvIGJlIHNldCAoaW4gcHgpLlxuICogIFdlIG5lZWQgdGhpcyB0byBiZSBhYmxlIHRvIHByb3Blcmx5IHBvc2l0aW9uIHRoZSBzZWNvbmQgdGFibGUgd2hpY2ggaXMgY2hhbmdlZCB0byBhYnNvbHV0ZVxuICogIHBvc2l0aW9uaW5nLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWNvbHVtbjInLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFRvIG1ha2UgaXQgbW9yZSByZWFkYWJsZSBFYWNoIENvbHVtbiB0eXBlIGhhcyBpdHMgb3duIHJlbmRlcmluZyB0ZW1wbGF0ZSBpbnN0ZWFkIG9mIHB1dHRpbmdcbiAgICBhbGwgdGhpcyBpbnRvIGRhdGF0YWJsZSBhcyB0aGlzIGlzIG1vcmUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNvbHVtbi4gQW5kIHRoZSBtYWluIGdvYWxcbiAgICB3YXMgdHJ5IHRvIGJlIG1vZHVsYXIgYXMgcG9zc2libGUuIFdoZW4gVGhlcmUgd2lsbCBiZSBkaWZmZXJlbnQgdHlwZXMgb2YgY29sdW1uc1xuXG4gICAgLSBSZWd1bGFyIERUQ29sdW1uIChjdXJyZW50IGltcGxlbWVudGF0aW9uKSxcbiAgICAtIFNlbGVjdGlvbkNvbHVtbiAoU2luZ2xlL011bHRpIHNlbGVjdCkgLSB0b2RvLFxuICAgIC0gRGV0YWlsUm93IGNvbHVtbiwgdGhlbiBwaXZvdGFsIGNvbGx1bW4gdG8gcmVuZGVyIHJvdy9jb2x1bW4vZGV0YWlsIGF0dHJpYnV0ZXMgLSB0b2RvLlxuXG4gICAgV2hlbiBpbXBsZW1lbnRpbmcgbmV3IGNvbHVtbiB0eXBlIHlvdSBqdXN0IGluaGVyaXQgdGhpcyBEVENvbHVtbkNvbXBvbmVudCBhbmQgcHJvdmlkZSB5b3VyXG4gICAgb3duIHJlbmRlcmluZyB0ZW1wbGF0ZSBhbmQgRFQgdGFrZSBjYXJlIG9mIHRoZSByZXN0LlxuXG4gICAgdG9kbzogV2UgaGF2ZSBTaW5nbGVTZWxlY3QsIE11bHRpc2VsZWN0IHJlbmRlcmluZyB0ZW1wbGF0ZSB0aGF0IGlzIEFkZGVkIHByb2dyYW1hdGljYWxseVxuICAgIHRvZG86IFdlIGhhdmUgcGl2b3RhbCByZW5kZXJpbmcgdGVtcGxhdGVcblxuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIlxuICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xIZWFkZXJcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXNTdWJIZWFkZXIsIGNvbHVtbkluZGV4OmNvbHVtbkluZGV4LCBkYXRhOiBkYXRhVG9SZW5kZXIsXG4gICAgICAgICAgICAgICAgIHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xCb2R5XCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGNvbHVtbiwgZGF0YTpkYXRhVG9SZW5kZXIscm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPCEtLVxuICAgIFRlbXBsYXRlcyBmb3IgaGVhZGVyIGNvbHVtbnMuIEhlcmUgd2UgYXJlIHJlbmRlcmluZyB0d28gdHlwZXMuIEhlYWRlciBhbmQgU3ViaGVhZGVyIHRoYXQgd2VcbiAgICB1c3VhbGx5IHVzZSBoZXJlIGFzIHNvbWUga2luZCBvZiBzdW1tYXJ5IGNvbHVtbnMuIE5vdCByZWFsbHkgaGF2aW5nIHN1bW1hcnkgYXQgdGhlIGJvdHRvbSBsaWtlIG90aGVyXG4gICAgRFQuXG5cbiAgICBUSCBjb2x1bW4gYW5kIHRoZWlyIHRleHQgYXJlIHVzdWFsbHkgdW5zZWxlY3RhYmxlIGFuZCBtb3N0IG9mIHRoZXNlIHdlcmUgaW5oZXJpdGVkIGZyb21cbiAgICBvcmlnaW5hbCBQcmltZU5nIERUIGV2ZW4gbm90IG1hbnkgdGhpbmdzIGdvdCBsZWZ0IGFmdGVyIHdlIHJlZmFjdG9yIHRoaXMgYnV0IHRoZSBpZGVhIGlzIHRoZVxuICAgIHNhbWUuXG5cbiAgICBFYWNoIGNlbGwgaGFzIGl0cyBkdC1jZWxsLWRlZiBjbGFzcyB0aGF0IHNldHMgZGVmYXVsdCBzdHlsaW5nIGxpa2UgZm9udCwgYmFja2dyb3VuZCwgYWxpZ25tZW50XG4gICAgcGFkZGluZywgZXRjcy4uXG5cblxuLS0+XG48bmctdGVtcGxhdGUgI2NvbEhlYWRlciBsZXQtaXNTdWJIZWFkZXIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIiBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPHRoICNoZWFkZXJDZWxsMSBbY2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc3x8c3R5bGVDbGFzc1wiICpuZ0lmPVwiIWlzU3ViSGVhZGVyXCJcbiAgICAgICAgKGNsaWNrKT1cImhhbmRsZUhlYWRlckNsaWNrKCRldmVudCwgaGVhZGVyQ2VsbDEpXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQnIDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiBkdC5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCcgfHwgKCFkdC5pc091dGxpbmUoKSB8fCAhZHQucGl2b3RhbExheW91dCksXG4gICAgICAgICAgICAgICAgICAgICdkdC11LXNvcnRhYmxlJzogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1hY3RpdmUnOiBpc1NvcnRlZCgpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWlzVmlzaWJsZX1cIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwic29ydGFibGUgPyAxIDogbnVsbFwiXG4gICAgICAgIFtkdE1heFdpZHRoXT1cIm1heFdpZHRoUHhcIlxuICAgID5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZHQuaGVhZGVyRmlsdGVyVGVtcGxhdGUgJiYgY29sdW1uSW5kZXggPT09IDAgXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHQuaGVhZGVyRmlsdGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8IS0tXG4gICAgICAgICAgICB3aGVuIGNlbGwgYXJlIHNlbGVjdGFibGUgd2UgbmVlZCB0d28gdmVyc2lvbiB3aGVyZSBvbmUgd3JhcCB0aGUgY2VsbCBjb250ZW50IGluIGRpdlxuICAgICAgICAtLT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzSGVhZGVyU2VsZWN0YWJsZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VsZWN0YWJsZUhlYWRlckNlbGw7IGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXN9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNIZWFkZXJTZWxlY3RhYmxlKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub25TZWxlY3RhYmxlSGVhZGVyQ2VsbDsgY29udGV4dDogeyRpbXBsaWNpdDogdGhpc31cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdGg+XG5cbiAgICA8dGggI2hlYWRlckNlbGwyIFtjbGFzc109XCJoZWFkZXJTdHlsZUNsYXNzfHxzdHlsZUNsYXNzXCIgKm5nSWY9XCJpc1N1YkhlYWRlclwiXG4gICAgICAgIFthdHRyLndpZHRoXT1cIndpZHRoXCJcbiAgICAgICAgW2F0dHIuYWxpZ25dPVwiYWxpZ25cIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtY2VsbC1kZWYgZHQtc3ViLWhlYWRlciBkdC11LXVuc2VsZWN0YWJsZS10ZXh0Jzp0cnVlfVwiXG4gICAgICAgIFtkdE1heFdpZHRoXT1cIm1heFdpZHRoUHhcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC10aXRsZVwiICpuZ0lmPVwiZHQuc2hvd1N1YkhlYWRlciAmJiBzdWJIZWFkZXJUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInN1YkhlYWRlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCByb3dEYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvdGg+XG48L25nLXRlbXBsYXRlPlxuXG5cbjwhLS1cbiAgICBUZW1wbGF0ZSBmb3IgdGhlIGJvZHkgPSB0aGUgVEQuIEZvciB0aGUgYm9keSBhbmQgd2UgbWlnaHQgd2FudCB0byBkbyB0aGUgc2FtZSBmb3IgaGVhZGVyIHdlXG4gICAgYWxsb3cgdG8gaGF2ZSBjYWxjdWxhdGVkIGJvZHkgY2xhc3MgdGhhdCBjb21lcyBmcm9tIHRoZSBhcHBsaWNhdGlvbi4gU28gYmFzZWQgb24gdGhlIGRhdGEgdHlwZXNcbiAgICB5b3UgbWlnaHQgd2FudCB0byBhcHBseSBkaWZmZXJlbnQgY2xhc3MgaW4gb3JkZXIgdG8gYXBwbHkgY3VzdG9tIHN0eWxpbmcuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjY29sQm9keSBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPHRkICNjZWxsIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKGRhdGEpXCJcbiAgICAgICAgKGNsaWNrKT1cImR0Lm9uQ2VsbFNlbGVjdGlvbkNoYW5nZShjZWxsLCB0aGlzLCBkYXRhKVwiXG4gICAgICAgIFthdHRyLndpZHRoXT1cIndpZHRoXCJcbiAgICAgICAgW2F0dHIuYWxpZ25dPVwiYWxpZ25cIlxuICAgICAgICBbbmdDbGFzc109XCJ7ICdkdC1pcy1kZWZhdWx0JzogdHJ1ZSxcbiAgICAgICAgJ2R0LWNlbGwtZGVmJzogIWlzQ2VsbFNlbGVjdGFibGUoZGF0YSksXG4gICAgICAgICdkdC1pcy1oaWRkZW4nOiAhaXNWaXNpYmxlfVwiXG4gICAgICAgIFtkdE1heFdpZHRoXT1cIm1heFdpZHRoUHhcIlxuICAgICAgICA+XG5cbiAgICAgICAgPCEtLVxuICAgICAgICAgICAgU2luY2Ugd2UgbmVlZCB0byBzdXBwb3J0IGNlbGwgc2VsZWN0aW9uIHdoZW4gd2UgbmVlZCB0byBkcmF3IGJvcmRlciBhcm91bmQgaXRcbiAgICAgICAgICAgIFdlIGFyZSB3cmFwcGluZyBzdWNoIHNlbGxzIHdpdGggZGl2IHdoaWNoIGdpdmVzIHVzIGJldHRlciBmbGV4aWJpbGl0eVxuICAgICAgICAtLT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzQ2VsbFNlbGVjdGFibGUoZGF0YSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzZWxlY3RhYmxlQm9keUNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXggfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNDZWxsU2VsZWN0YWJsZShkYXRhKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vblNlbGVjdGFibGVCb2R5Q2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPC90ZD5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS1cbiAgICBUb2RvOiBjcmVhdGUgYmV0dGVyIHNvbHV0aW9uIGluc3RlYWQgb2YgdXNpbmcgZGlmZmVyZW50IHRlbXBsYXRlIGNyZWF0ZSBkaXJlY3RpdmUgdGhhdCB3cmFwc1xuICAgIGl0IHdpdGggdGhlIGRpdiBjb25kaXRpb25hbGx5XG4tLT5cbjxuZy10ZW1wbGF0ZSAjc2VsZWN0YWJsZUhlYWRlckNlbGwgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJkdC1jZWxsLWRlZi1zZWxlY3RhYmxlXCJcbiAgICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtY2VsbC1zZWxlY3RlZCc6IGR0LmlzSGVhZGVyU2VsZWN0ZWQodGhpcyl9XCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJDZWxsQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjbm9uU2VsZWN0YWJsZUhlYWRlckNlbGwgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyQ2VsbENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjaGVhZGVyQ2VsbENvbnRlbnQgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC10aXRsZVwiICpuZ0lmPVwic2hvd0NvbHVtbkxhYmVsICYmICFoZWFkZXJUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIHt7bGFiZWx9fVxuICAgIDwvc3Bhbj5cblxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLXRpdGxlXCIgKm5nSWY9XCJzaG93Q29sdW1uTGFiZWwgJiYgaGVhZGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4IH1cIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtc29ydGFibGUtaWNvbiBzYXAtaWNvbiBpY29uLXNvcnRcIiAqbmdJZj1cInNvcnRhYmxlXCJcbiAgICAgICAgICBbbmdDbGFzc109XCJ7J2ljb24tc29ydC1kZXNjZW5kaW5nJzogKGdldFNvcnRPcmRlcigpID09IC0xKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdpY29uLXNvcnQtYXNjZW5kaW5nJzogKGdldFNvcnRPcmRlcigpID09IDEpfVwiPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNzZWxlY3RhYmxlQm9keUNlbGwgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtY2VsbC1kZWYtc2VsZWN0YWJsZVwiXG4gICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWNlbGwtc2VsZWN0ZWQnOiBkdC5pc0JvZHlDZWxsU2VsZWN0ZWQodGhpcywgZGF0YSl9XCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5Q2VsbENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI25vblNlbGVjdGFibGVCb2R5Q2VsbCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5Q2VsbENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjYm9keUNlbGxDb250ZW50IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPCEtLVxuICAgICAgICAgICB3aGVuIG5vIHRlbXBsYXRlIGlzIHVzZWQgdXNlIG91ciBGaWVsZFBhdGggdG8gYWNjZXNzIHRoZSBvYmplY3QgdmFsdWUgYmFzZWQgb24gdGhlXG4gICAgICAgICAgIGtleSBiaW5kaW5nXG4gICAgICAgIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLWNlbGwtZGF0YVwiICpuZ0lmPVwiIWJvZHlUZW1wbGF0ZVwiPlxuICAgICAgICAgICAge3tkdC5nZXRWYWx1ZShkYXRhLCBrZXkpfX1cbiAgICAgICAgPC9zcGFuPlxuXG5cbiAgICA8IS0tXG4gICAgICAgIEluIGNhc2UgYXBwbGljYXRpb24gd2FudHMgdG8gcHJvdmlkZSB0aGVpciBvd24gY2VsbCBjb21wb25lbnQgdGhleSB1c2VcbiAgICAgICAgI2JvZHkgbmctdGVtcGxhdGUgdG8gZG8gc28uXG4gICAgLS0+XG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtY2VsbC1kYXRhXCIgKm5nSWY9XCJib2R5VGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5VGVtcGxhdGU7XG4gICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCByb3dEYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AuZHQtc29ydGFibGUtY29se2N1cnNvcjpwb2ludGVyfS5kdC1jb2wtc29ydGFibGUtaWNvbntkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDouMTI1ZW19dGguZHQtY2VsbC1kZWZ7Zm9udC13ZWlnaHQ6NDAwO2NvbG9yOiM0YTRhNGF9dGguZHQtaXMtZGVmYXVsdHtiYWNrZ3JvdW5kLWNvbG9yOiNmMmYyZjI7d2hpdGUtc3BhY2U6bm93cmFwfXRoLmR0LWlzLWRlZmF1bHQuZHQtY2VsbC1kZWY6bm90KC5kdC1zdWItaGVhZGVyKXtib3JkZXItYm90dG9tLWNvbG9yOiNmMmYyZjJ9dGguZHQtc3ViLWhlYWRlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9dGggLmR0LWNlbGwtc2VsZWN0ZWR7Ym9yZGVyLWNvbG9yOiM1OGI5NTd9dGQgLmR0LWNlbGwtc2VsZWN0ZWR7Ym9yZGVyLWxlZnQtY29sb3I6IzRmOWZjZn0uZHQtcm9vdC1zZWN0aW9uIC5kdC1zZWxlY3Rpb24tY29sdW1uLC5kdC1zZWxlY3Rpb24tY29sdW1ue3dpZHRoOjQ2cHg7cGFkZGluZzowIDEycHh9LmR0LXBpdm90LWxheW91dCB0ZC5kdC1zZWxlY3Rpb24tY29sdW1uLHRoLmR0LXNlbGVjdGlvbi1jb2x1bW57Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fXRoZWFkIHRyOmZpcnN0LWNoaWxkIHRoe2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnR9dGJvZHkgdHI6bGFzdC1jaGlsZDpub3QoLmR0LWRyYWctcm93LWJvdHRvbSkgdGR7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudH10ZDpmaXJzdC1jaGlsZCx0aDpmaXJzdC1jaGlsZHtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudH10ZDpsYXN0LWNoaWxkLHRoOmxhc3QtY2hpbGR7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fXRib2R5IC5kdC1kcmFnLXJvdy10b3A+dGR7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMGRlZywjZmZmIDAsI2ZmZiA5NyUsIzAyNzFkMiAxMDAlKX10Ym9keSAuZHQtZHJhZy1yb3ctYm90dG9tPnRke2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDE4MGRlZywjZmZmIDAsI2ZmZiA5NyUsIzAyNzFkMiAxMDAlKX10Ym9keSAuZHQtZHJhZy1yb3ctYm90aD50ZHtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgwZGVnLCMwMjcxZDIgMCwjZmZmIDMlLCNmZmYgOTclLCMwMjcxZDIgMTAwJSl9dGJvZHkgLmR0LXJvdy1kcmFnZ2luZz50ZHtiYWNrZ3JvdW5kLWNvbG9yOiNlY2VjZWM7Y29sb3I6I2I5YjliOX10Ym9keSAuZHQtcm93LWRyYWdnaW5nIC51aS1zdGF0ZS1hY3RpdmV7b3BhY2l0eTouNTtjdXJzb3I6bm90LWFsbG93ZWR9YF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERUQ29sdW1uMkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGhlYWRlciBsYWJlbC5cbiAgICAgKlxuICAgICAqIE9yIHlvdSBjYW4gdXNlIGhlYWRlclRlbXBsYXRlIHRvIGRlZmluZSB5b3VyIG93biB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZmllbGQgbmFtZSB0byByZWFkIGZyb20gdGhlIGdpdmVuIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAga2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENlbGwgYWxpZ25tZW50LiBJdCBpbnNlcnRzIHJlZ3VsYXIgYWxpZ24gYXR0cmlidXRlIHRvIHRoZSB0YWJsZSBjZWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsaWduOiBEVEhBbGlnbm1lbnQgPSAnbGVmdCc7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkeW5hbWljIGNsYXNzIGJhc2VkIG9uIGRhdGEgYW5kIHRoZW4gaXRzIGFkZGVkIHRvIHRoZSB0YWJsZSBjZWxsIFREXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSWYgZmFsc2UgYXBwbGllcyBkdC1pcy1oaWRkZW4gc3R5bGUgdGhhdCBoaWRlcyB0aGUgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjb2x1bW4gYXMgc29ydGFibGUgd2hpY2ggbWVhbnMgc29ydGluZyBpY29uIGlzIGFkZGVkIHRvIHRoZSBoZWFkZXIgd2l0aCBzcGVjaWFsXG4gICAgICogc29ydGluZyBoYW5kbGluZ1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc29ydGFibGU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNvcnRpbmcgZGlyZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRPcmRlcmluZzogc3RyaW5nID0gJ2Rlc2NlbmRpbmcnO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHRlbXBsYXRlIGlmIHdoZXRoZXIgdG8gcmVuZGVyIGEgbGFiZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0NvbHVtbkxhYmVsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0aWMgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgVEggaW50byB0aGUgaGVhZGVyLiBJdCBkb2VzIG5vdCByZWx5IG9uIGRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGVhZGVyU3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0aWMgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGQgaW50byB0aGUgYm9keS4gSXQgZG9lcyBub3QgcmVseSBvbiBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHlTdHlsZUNsYXNzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgdG9nZXRoZXIgd2l0aCBjZWxsIHNlbGVjdGlvbk1vZGUgdG8gdGVsbCB3aGljaCBjb2x1bW4gaXMgc2VsZWN0YWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBIRUFERVIgdGVtcGxhdGUgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbEhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBTdWJIZWFkZXIgdGVtcGxhdGUgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbFN1YkhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBib2R5IHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbEJvZHk6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgY29sdW1uIGlzIGRhdGEgY29sdW1uICAtIGlmIGl0IGlzIHJlbmRlcmluZyBkYXRhIG9yIGp1c3QgYSBsYWJlbCBvciBzb21lXG4gICAgICogY29udHJvbFxuICAgICAqXG4gICAgICogVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiBjYWxjdWxhdGluZyBhIGNvbHVtbiBzcGFuIGFuZCB3ZSBuZWVkIHRvIGtub3cgd2hpY2ggY29sdW1ucyBhcmUgb3JcbiAgICAgKiB3aWxsIGJlIGp1c3QgZm9yIHNlbGVjdGlvbiBjb250cm9scyBhbmQgd2hpY2ggaG9sZHMgZGF0YVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNEYXRhQ29sdW1uOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgY29sdW1uIHRoYXQgd2lsbCBub3Qgc2Nyb2xsIGhvcml6b250YWxseSB3aXRoIG90aGVyIGNvbHVtbnMuIENvbHVtbiBpc1xuICAgICAqIGZyb3plbi5cbiAgICAgKlxuICAgICAqIEZvciBzdWNoIGNvbHVtbnMgdGhhdCBhcmUgbWFya2VkIGFzIGZyb3plbiBiaW5kaW5nIFt3aWR0aF0gaXMgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTWF4IFdpZHRoIGZvciB0aGUgVEQuIEV2ZW4gVEQgZG9lcyBub3Qgc3VwcG9ydCB3ZSBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgd2lkdGhcbiAgICAgKiBmb3IgZWFjaCBjZWxsIGFuZCB0aGVuIGRlY2lkZSBpZiB3ZSBuZWVkIHRvIGVubGFyZ2UgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEBFeHBlcmltYW50YWwgYmluZGluZyB0aGF0IGlzIGN1cnJlbnRseSB3b3JraW5nIGlmIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIGlzIGlubGluZVxuICAgICAqIGVsZW1lbnQgd2hlcmUgd2UgY2FuIGNvbnRyb2wgd2hpdGVzcGFjZSB3cmFwcGluZyBpbiBvcmRlciB0byBmaW5kIG91dCB0aGUgcmVhbCB3aWR0aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWF4V2lkdGg6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWluV2lkdGggb24gdGhlIGNlbGwuIEFnYWluIGp1c3QgbGlrZSBtYXhXaWR0aCBjc3MgcHJvcGVybHkgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgICAqIHRoZSB0YWJsZSBzbyB0aGVyZSBpcyBhIHdvcmthcm91bmQgd2hlcmUgd2UgY3JlYXRlIGFkZGl0aW9uYWwgcm93IHRoYXQgc2V0cyBwYWRkaW5nIHJpZ2h0XG4gICAgICogYW5kIHRoaXMgd2lsbCBwcmV2ZW50IHRoZSBjb2x1bW4gdG8gY29sbGFwc2UgdW5kZXIgc3BlY2lmaWVkIHdpZHRoXG4gICAgICpcbiAgICAgKiB0b2RvOiBzdGlsbCBUQkRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbldpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNYWluIHJlbmRlcmluZyB0ZW1wbGF0ZSB1c2VkIGJ5IGRhdGF0YWJsZSB0byByZW5kZXIgZWFjaCBjb2x1bW4uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncmVuZGVyaW5nVGVtcGxhdGUnKVxuICAgIHJlbmRlcmVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gaGVhZGVyIHRlbXBsYXRlLiBJdCB3aWxsIG92ZXJyaWRlIHByb3ZpZGVkIGxhYmVsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyJylcbiAgICBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBzdWJIZWFkZXIgdGVtcGxhdGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnc3ViSGVhZGVyJylcbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBib2R5IHRlbXBsYXRlIHRoYXQgd2lsbCBvdmVycmlkZSByZWFkIHZhbHVlIGZyb20gdGhlIFtrZXldIGJpbmRpbmdcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdib2R5JylcbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLi4uXG4gICAgICovXG4gICAgc29ydE9yZGVyOiBudW1iZXI7XG4gICAgbWF4V2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICBtaW5XaWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIHdpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgd2lkZXN0Q2VsbDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBEYXRhdGFibGUgSW1wbGVtZW50YXRpb25zXG4gICAgICovXG4gICAgZHQ6IEFXRGF0YVRhYmxlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMua2V5KSAmJiBpc0JsYW5rKHRoaXMubGFiZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYmluZGluZzogJyArXG4gICAgICAgICAgICAgICAgJ1trZXldIG9yIFtsYWJlbF0gYmluZGluZ3MgbXVzdCBiZSB1c2VkIGF0IG1pbmltdW0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGJlIGFibGUgdG8gcG9zaXRpb24gc2Vjb25kIERUIHdlIHJlcXVpcmUgW3dpZHRoXSB0byBiZSBzZXQgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy5mcm96ZW4gJiYgaXNCbGFuayh0aGlzLndpZHRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGJpbmRpbmcgW3dpZHRoXTogJyArXG4gICAgICAgICAgICAgICAgJ3doZW4gW2Zyb3plbl09dHJ1ZSB0aGVuIFt3aWR0aF0gYmluZGluZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIG5lZWQgdG8gZGVmZmVyIHRoaXMgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBvdGhlcndpc2UgSSBnZXRcbiAgICAgICAgLy8gdmFsdWUgd2FzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQgZXJyb3JcbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAvLyB7XG5cbiAgICAgICAgLy8gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNlbGwgc2VsZWN0aW9uTW9kZSBpcyBlbmFibGVkIHRoaXMgbWV0aG9kIGlzIHRyaWdnZXJlZCB3aGVuIHdlIGNsaWNrIG9uIGhlYWRlci5cbiAgICAgKiBJdCBkZWxlZ2F0ZXMgdGhlIGNhbGwgdG8gdGhlIERUIHdoZXJlIGl0IHRvZ2dsZXMgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVIZWFkZXJDbGljayhldmVudDogYW55LCBlbGVtZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pc0hlYWRlclNlbGVjdGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kdC5vbkhlYWRlclNlbGVjdGlvbkNoYW5nZShlbGVtZW50LCB0aGlzKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRvZG86IEltcGxlbWVudCBvdXIgb3duIHNvcnRpbmcgbWVjaGFuaXNtIG9uY2Ugd2UgZXh0cmFjdCB0aGUgc29ydGluZyBsb2dpYyB0byBpdHMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0KGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtdS1zb3J0YWJsZScpIHx8XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LWNvbC10aXRsZScpIHx8XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LWNvbC1zb3J0YWJsZS1pY29uJykpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LnNvcnRDb2x1bW4pICYmIHRoaXMuZHQuc29ydENvbHVtbi5rZXkgPT09IHRoaXMua2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXIgPSB0aGlzLnNvcnRPcmRlciAqIC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyaW5nID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JOdW1iZXIodGhpcy5zb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuc29ydENvbHVtbiA9IHRoaXM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5zb3J0S2V5ID0gdGhpcy5rZXk7XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuc29ydE9yZGVyID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5zb3J0T3JkZXJpbmcpO1xuXG4gICAgICAgICAgICB0aGlzLmR0LnNvcnRTaW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR0LnVwZGF0ZURhdGFUb1JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgc3R5bGUgY2xhc3MgYmFzZWQgb24gZGF0YVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBkeW5hbWljQm9keUNsYXNzKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBkeW5DbGFzcyA9IGlzUHJlc2VudCh0aGlzLmJvZHlDbGFzc0ZuKVxuICAgICAgICAgICAgPyB0aGlzLmJvZHlDbGFzc0ZuLmFwcGx5KHRoaXMuZHQuY29udGV4dCwgW3RoaXMsIGl0ZW1dKSA6ICcnO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ib2R5U3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIGR5bkNsYXNzICs9ICcgJyArIHRoaXMuYm9keVN0eWxlQ2xhc3M7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5zdHlsZUNsYXNzKSkge1xuICAgICAgICAgICAgZHluQ2xhc3MgKz0gJyAnICsgdGhpcy5zdHlsZUNsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR5bkNsYXNzO1xuICAgIH1cblxuXG4gICAgaXNSb3dTZWxlY3RhYmxlKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5pc1Jvd1NlbGVjdGFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kdC5pc1Jvd1NlbGVjdGFibGUoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNDZWxsU2VsZWN0YWJsZShpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5zZWxlY3Rpb25Nb2RlID09PSAnY2VsbCcgJiYgdGhpcy5pc1Jvd1NlbGVjdGFibGUoaXRlbSkgJiYgdGhpcy5zZWxlY3RhYmxlO1xuXG4gICAgfVxuXG5cbiAgICBpc0hlYWRlclNlbGVjdGFibGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuc2VsZWN0aW9uTW9kZSA9PT0gJ2NlbGwnICYmIHRoaXMuc2VsZWN0YWJsZTtcblxuICAgIH1cblxuXG4gICAgZ2V0U29ydE9yZGVyKClcbiAgICB7XG4gICAgICAgIGxldCBvcmRlciA9IDA7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LnNvcnRDb2x1bW4pICYmIHRoaXMua2V5ID09PSB0aGlzLmR0LnNvcnRDb2x1bW4ua2V5KSB7XG4gICAgICAgICAgICBvcmRlciA9IHRoaXMuZHQuc29ydENvbHVtbi5zb3J0T3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cblxuICAgIGlzU29ydGVkKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmtleSA9PT0gdGhpcy5kdC5zb3J0Q29sdW1uLmtleTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplKHRhYmxlOiBBV0RhdGFUYWJsZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQgPSB0YWJsZTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuaW5pdGlhbFNvcnRLZXkpICYmIHRoaXMuZHQuaW5pdGlhbFNvcnRLZXkgPT09IHRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5kdC5pbml0aWFsU29ydE9yZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZHQuc29ydENvbHVtbiA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmJvZHlUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmJvZHlUZW1wbGF0ZSA9IHRoaXMuZHQuYm9keVRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5oZWFkZXJUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmR0LmhlYWRlclRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdWJIZWFkZXJUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxTdWJIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3ViSGVhZGVyVGVtcGxhdGUgPSB0aGlzLmR0LnN1YkhlYWRlclRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5ib2R5Q2xhc3NGbikpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keUNsYXNzRm4gPSB0aGlzLmR0LmJvZHlDbGFzc0ZuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXhXaWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy5tYXhXaWR0aCk7XG4gICAgICAgIHRoaXMubWluV2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMubWluV2lkdGgpO1xuICAgICAgICB0aGlzLndpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLndpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgdmlldyBpbml0IGN5Y2xlIGZyb20gdGhlIGR0Lm5nQWZ0ZXJWaWV3Q2hlY2tlZC5cbiAgICAgKlxuICAgICAqIEluIGNhc2Ugd2UgdXNlIE1heFdpZHRoIGRpcmVjdGl2ZSB3ZSBzZXQgbmV3IHdpZHRoIG9uY2UgZm9yIGFsbCBjb2x1bXNuXG4gICAgICovXG4gICAgcG9zdEluaXRpYWxpemUobXlJbmRleDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgY29sSW5kZXggPSBteUluZGV4ICsgMTtcbiAgICAgICAgbGV0IHRhYmxlO1xuXG4gICAgICAgIGlmICh0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgdGFibGUgPSAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWxcbiAgICAgICAgICAgICAgICAubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtYm9keS1mcm96ZW4gdGFibGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhYmxlID0gKDxEYXRhdGFibGUyQ29tcG9uZW50PnRoaXMuZHQpLmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGFibGUnKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHRoaXMud2lkZXN0Q2VsbCA+IDApIHtcbiAgICAgICAgICAgIGxldCBhbGwgPSB0YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0ciB0aDpudGgtY2hpbGQoJyArIGNvbEluZGV4ICsgJyksICcgK1xuICAgICAgICAgICAgICAgICd0ciB0ZDpudGgtY2hpbGQoJyArIGNvbEluZGV4ICsgJyknKS5mb3JFYWNoKChub2RlOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkZXN0Q2VsbCArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogWW91IGVpdGhlciB1c2UgdGhpcyBiaW5kaW5nIGRpcmVjdGx5IGFuZCBzYXkgaXRzIGRhdGFjb2x1bW4gb3Igd2hlbiB0aGVyZSBpcyBhIFtrZXldXG4gICAgICogYmlkaW5nIHdlIGtub3cgaXQgcmVmZXJzIHRvIHNvbWUgZmllbGQuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1ZhbHVlQ29sdW1uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAoaXNQcmVzZW50KHRoaXMuaXNEYXRhQ29sdW1uKSAmJiBCb29sZWFuV3JhcHBlci5pc1RydWUodGhpcy5pc0RhdGFDb2x1bW4pKSB8fFxuICAgICAgICAgICAgaXNQcmVzZW50KHRoaXMua2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGFyZSBpbiBvdXRsaW5lIG1vZGUgIHdlIG5lZWQgdG8gYWxzbyBpbmRlbmQgZWFjaCBzZWxlY3Rpb24gY29udHJvbCBhY2NvcmRpbmdseS5cbiAgICAgKlxuICAgICAqIGluZGVudCAtIDEgPiBvbmx5IG9mZnNldCB3aXRoXG4gICAgICogaW5kZW50XG4gICAgICovXG4gICAgaW5kZW50Rm9yQ29udHJvbChjZWxsOiBhbnksIGxldmVsOiBudW1iZXIpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmR0LmlzT3V0bGluZSgpICYmIGxldmVsID4gMCAmJiBjZWxsLm9mZnNldFdpZHRoID4gMFxuICAgICAgICAgICAgJiYgaXNQcmVzZW50KGNlbGwubmV4dEVsZW1lbnRTaWJsaW5nKSlcbiAgICAgICAge1xuXG4gICAgICAgICAgICBsZXQgb3V0bGluZU5vZGVQYWRkaW5nID1cbiAgICAgICAgICAgICAgICBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGNlbGwubmV4dEVsZW1lbnRTaWJsaW5nKS5wYWRkaW5nTGVmdCkgfHwgMDtcblxuICAgICAgICAgICAgLy8gMXN0IGxldmVsIGlzIHB1c2hlZCBhcyByb290XG4gICAgICAgICAgICBpZiAodGhpcy5kdC5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxldmVsID09PSAxKSA/IG51bGwgOiAodGhpcy5kdC5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIC0gb3V0bGluZU5vZGVQYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZHQuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKSArIG91dGxpbmVOb2RlUGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIHdpZHRoVG9QeCh3aWR0aDogc3RyaW5nKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgcHg7XG4gICAgICAgIGlmIChpc1ByZXNlbnQod2lkdGgpKSB7XG4gICAgICAgICAgICBpZiAod2lkdGguaW5kZXhPZignJScpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vblBjID0gcGFyc2VGbG9hdCh3aWR0aCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgcHggPSBub25QYyAqICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBweCA9IHBhcnNlRmxvYXQod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB4O1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGF0YXRhYmxlIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGF0YVRhYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1oZWFkZXIyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERUSGVhZGVyQ29tcG9uZW50Mlxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXRGF0YVRhYmxlfSBmcm9tICcuLi8uLi9hdy1kYXRhdGFibGUnO1xuXG5cbi8qKlxuICpcbiAqIEN1c3RvbSBjb2x1bW4gaW1wbGVtZW50YXRpb24gdG8gcmVuZGVyIGRldGFpbCByb3cgc3BhbmluZyBpdHMgY29sdW1uIGFjcm9zcyB3aG9sZSB0YWJsZSB3aWR0aC5cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWRldGFpbC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFJlbmRlcnMgYXBwbGljYXRpb24gZGVmaW5lZCBkZXRhaWwgY29sdW1uLiBUaGlzIHRlbXBsYXRlIGp1c3QgcmVuZGVycyBhIGRldGFpbCByb3cgYW5kXG4gICAgbm90IGV4cGFuc2lvbiBjb250cm9sLiBUaGlzIGlzIGltcGxlbWVudGVkIGJ5IGRpZmZlcmVudCBEdENvbHVtbiBpbXBsZW1lbnRhdGlvbiBhbmQgaXRzIGFkZGVkXG4gICAgKHdpbGwgYmUpIGFkZGVkIHByb2dyYW1tYXRpY2FsbHkgZHVyaW5nIGNvbHVtbiBpbml0aWFsaXphdGlvblxuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtcm93RGF0YT1cImRhdGFcIj5cblxuICAgIDx0ciAjZGV0YWlsUm93RWxlbWVudCBjbGFzcz1cImR0LWJvZHktcm93IGR0LWRldGFpbC1yb3dcIj5cblxuICAgICAgICA8dGQgKm5nSWY9XCJkdC5oYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKVwiIHdpZHRoPVwiMXB4XCI+PC90ZD5cbiAgICAgICAgPHRkICpuZ0lmPVwidmlzaWJsZUxlYWRpbmdDb2xzKCkgPiAwXCIgY29sc3Bhbj1cInZpc2libGVMZWFkaW5nQ29scygpXCIgd2lkdGg9XCIxcHhcIj5cbiAgICAgICAgICAgICZuYnNwOyZuYnNwO1xuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJkdC5zdGFydE9mRmlyc3REYXRhQ29sdW1uXCIgW2NsYXNzXT1cImR5bmFtaWNCb2R5Q2xhc3Mocm93RGF0YSlcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCBkdC1jZWxsLWRlZic6IHRydWV9XCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlUZW1wbGF0ZTsgY29udGV4dDp7JGltcGxpY2l0OiB0aGlzLCByb3dEYXRhOnJvd0RhdGF9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90ZD5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERURGV0YWlsUm93Q29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1cnJlbnQgdmlzaWJpbGl0eSBmb3IgY3VycmVudCBkYXRhIHJvdyB1c2luZyBtZXRob2QgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzVmlzaWJsZUZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiB0ZWxscyBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhIGxpbmUgYmV0d2VlbiBpdGVtIHJvdyBhbmQgaXRzIGRldGFpbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93TGluZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBqdXN0IHRvIGdldCBhcm91bmQgdGhlIGNoZWNrIGluIHBhcmVudCBjbGFzc1xuICAgICAgICB0aGlzLmtleSA9ICcnO1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgbmVlZCB0byBrZWVwIHNvbWUgbGVhZGluZyBURHNcbiAgICAgKlxuICAgICAqL1xuICAgIHZpc2libGVMZWFkaW5nQ29scygpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0Lm51bWJlck9mQ29sc0JlZm9yZURhdGEgLSAodGhpcy5kdC5oYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKSA/IDEgOiAwKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgd2UgY2FuIHNob3cgZGV0YWlsIHJvdy9jb2x1bW4gdXNpbmcgZWl0aGVyIFtpc1Zpc2libGVdIG9yIFtpc1Zpc2libGVGbl0gYmluZGluZ3MuXG4gICAgICogSGVyZSBjYW4gaG9vayBvbiBhcHBsaWNhdGlvbiBsZXZlbCBjdXN0b20gbWV0aG9kIHRvIGRlY2lkZSBpZiBjdXJyZW50IGl0ZW0gaGFzIGRldGFpbCByb3dcbiAgICAgKiBvciBub3RcbiAgICAgKlxuICAgICAqIE9yIHdlIGNhbiB1c2UgaXNWaXNpYmxlPXRydWUgdG8gdGVsbCBhbGwgcm93IGhhdmUgZGV0YWlsIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd0RldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgaXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pc1Zpc2libGVGbikpIHtcbiAgICAgICAgICAgIGlzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlRm4uYXBwbHkodGhpcy5kdC5jb250ZXh0LCBbdGhpcywgaXRlbV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplKHRhYmxlOiBBV0RhdGFUYWJsZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUodGFibGUpO1xuXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gIXRoaXMuZHQuaXNPdXRsaW5lKCkgfHwgIXRoaXMuZHQucGl2b3RhbExheW91dDtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtZGV0YWlsLWNvbHVtbi1leHBhbmQnLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgU3BlY2lhbCBjb2x1bW4gdGhhdCByZW5kZXJzIGV4cGFuZC9jb2xsYXBzZSBjb250cm9sIGZvciBkZXRhaWwgcm93IHdoZW4gZGV0YWlsIHJvdyBpcyBlbmFibGVkLlxuXG4gICBKdXN0IGxpa2UgZm9yIHRoZSBvdGhlciBjb2x1bW4gaXQgcmVuZGVycyBoZWFkZXIgc2VjdGlvbiBhcyB3ZWxsIGFzIGJvZHkgc2VjdGlvbiB3aXRoXG4gICBleHBhbmQgY29udHJvbCB0byB0b2dnbGUgdGhlIGV4cGFuc2lvblxuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIiBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0hlYWRlciAmJiAhaXNTdWJIZWFkZXJcIj5cbiAgICAgICAgPHRoICNoZWFkZXJDZWxsMSBbY2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc3x8c3R5bGVDbGFzc1wiXG4gICAgICAgICAgICBjbGFzcz1cImR0LXJvdy1jZWxsLWV4cGFuZG9cIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQgZHQtY2VsbC1kZWYnIDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2R0LWRldC1yb3ctZXhwYW5kZWQnOiBkdC5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGRhdGFUb1JlbmRlcil9XCI+XG4gICAgICAgIDwvdGg+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc0hlYWRlciAmJiAhaXNTdWJIZWFkZXJcIj5cbiAgICAgICAgPHRkICNjZWxsXG4gICAgICAgICAgICBjbGFzcz1cImR0LXJvdy1jZWxsLWV4cGFuZG9cIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1jZWxsLWRlZic6ICFpc0NlbGxTZWxlY3RhYmxlKGRhdGFUb1JlbmRlciksXG4gICAgICAgICAgICAgICAgICAgICdkdC1kZXQtcm93LWV4cGFuZGVkJzogZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChkYXRhVG9SZW5kZXIpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtZGV0LXJvdy13aXRoLWxuJyA6IGR0LnJvd0RldGFpbENvbHVtbi5zaG93Um93TGluZX1cIj5cblxuICAgICAgICAgICAgPHNwYW4gKGNsaWNrKT1cInRvZ2dsZUV4cGFuc2lvbigkZXZlbnQsIGRhdGFUb1JlbmRlcilcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkdC1kZXQtcm93LWV4cGFuZCBzYXAtaWNvblwiXG4gICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjYWxjdWxhdGVTdHlsZUNsYXNzKGRhdGFUb1JlbmRlcilcIj5cblxuICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDwvdGQ+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG5cbjwvbmctdGVtcGxhdGU+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC5kdC1yb3ctY2VsbC1leHBhbmRve3dpZHRoOjE0cHg7dGV4dC1hbGlnbjpyaWdodDtwYWRkaW5nOjE3cHggNXB4IDE3cHggMTdweDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LXJvdy1jZWxsLWV4cGFuZG8gLmR0LWRldC1yb3ctZXhwYW5ke2N1cnNvcjpwb2ludGVyO2xpbmUtaGVpZ2h0OjIxcHh9dGQuZHQtZGV0LXJvdy1leHBhbmRlZDpub3QoLmR0LWRldC1yb3ctd2l0aC1sbiksdGQuZHQtZGV0LXJvdy1leHBhbmRlZDpub3QoLmR0LWRldC1yb3ctd2l0aC1sbil+dGR7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudH1gXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyB3ZSBkb250IHdhbnQgdG8gc2hvdyB0aGUgcm93L2NvbHVtbiB1bmxlc3MgYXBwbGljYXRpb24gc2F5cyBzb1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBqdXN0IHRvIGdldCBhcm91bmQgdGhlIGNoZWNrIGluIHBhcmVudCBjbGFzc1xuICAgICAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUudG9nZ2xlKGl0ZW0pO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVTdHlsZUNsYXNzKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChpdGVtKSA/XG4gICAgICAgICAgICAnaWNvbi1zbGltLWFycm93LWRvd24nIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cblxuXG5pbXBvcnQge1RlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U2VsZWN0aW9uTW9kZX0gZnJvbSAnLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7RGV0YWlsUm93RXhwYW5zaW9uU3RhdGUsIERUMkRhdGFTb3VyY2V9IGZyb20gJy4vZGF0YXRhYmxlMi1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZSc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcblxuXG5leHBvcnQgY29uc3QgRHJhZ0V2ZW50czogc3RyaW5nW10gPSBbJ21vdXNlZG93bicsICdkcmFnc3RhcnQnLCAnZHJhZ292ZXInLCAnZHJhZ2VudGVyJywgJ2RyYWdsZWF2ZScsXG4gICAgJ2Ryb3AnLCAnZHJhZ2VuZCddO1xuXG5leHBvcnQgZW51bSBEcmFnRGlyZWN0aW9uXG57XG4gICAgTm9uZSA9ICdub25lJyxcbiAgICBVcCA9ICdkdC1kcmFnLXJvdy10b3AnLFxuICAgIERvd24gPSAnZHQtZHJhZy1yb3ctYm90dG9tJyxcbiAgICBNaWRkbGUgPSAnZHQtZHJhZy1yb3ctYm90aCdcbn1cblxuXG5leHBvcnQgZW51bSBEcm9wUG9zaXRpb25cbntcbiAgICBCZWZvcmUgPSAnYmVmb3JlJyxcbiAgICBBZnRlciA9ICdhZnRlcicsXG4gICAgSW50byA9ICdpbnRvJ1xufVxuXG5cbi8qKlxuICogQWJzdHJhY3QgdHlwZSB0aGF0IGlzIHNoYXJhYmxlIGFtb25nIGRlcGVuZGFudCBEVCBvYmplY3Qgc3VjaCBhcyBDb2x1bW5zLCBEYXRhU291cmNlcyxcbiAqIERpcmVjdGl2ZXMgdG8gYmUgYWJsZSB0byBjb21tdW5pY2F0ZSBiYWNrIHRvIHRoZSBkYXRhdGFibGUgbWFpbmx5IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBV0RhdGFUYWJsZVxue1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBwYXNzIHlvdXIgb3duIGRhdGFzb3VyY2UgdG8gb3ZlcnJpZGUgZGVmYXVsdCBvbmUuIEFsc28gd2hlbiBkYXRhU291cmNlIGlzXG4gICAgICogdXNlZCB0aGUgZGVzdGluYXRpb25DbGFzcyBvciBsaXN0IGFyZSBpZ25vcmVkXG4gICAgICovXG4gICAgZGF0YVNvdXJjZTogRFQyRGF0YVNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgb3V0bGluZSBzdGF0ZXMgZm9yIERhdGF0YWJsZXMgdXNpbmcgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2UgaGF2ZSBkZXRhaWwgcm93IHJlbWVtYmVyIGl0cyBleHBhbnNpb24gc3RhdGVcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTogRGV0YWlsUm93RXhwYW5zaW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGNvbHVtbiBpcyB1c2VkIGFzIGZpcnN0IGZvciBzb3J0aW5nXG4gICAgICovXG4gICAgaW5pdGlhbFNvcnRLZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEFsbG93IHRvIGNoYW5nZSBzb3J0aW5nIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGluaXRpYWxTb3J0T3JkZXI6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgRFQgaWYgd2Ugc3VwcG9ydCBjZWxsIHNlbGVjdGlvbiBvciByb3cgYmFzZWQgc2VsZWN0aW9uIHdoaWNoIGlzIHJlZ3VsYXIgRFQuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBzaW5nbGUgb3IgbXVsdGlzZWxlY3Rpb24gc2hvdyBjb250cm9sc1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHdhbnQgdG8gcmVuZGVyIG9uZSBzZWxlY3Rpb24gY29udHJvbCBpbiB0aGUgaGVhZGVyIHRvIHNlbGVjdCBhbGwgdGhlXG4gICAgICogcm93cy4gQXBwbGljYWJsZSBmb3IgbXVsdGlzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTZWxlY3RBbGw6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSBpZiByb3cgb3IgY2VsbCBpcyBzZWxlY3RhYmxlIGJhc2VkIG9uIGRhdGFcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGFibGU6IChpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIEVhY2ggRFRDb2x1bW4gaGF2ZSBoYXZlIGl0cyBvd24gdGVtcGxhdGUgdG8gcHJvdmlkZSBjb250ZW50IGZvciBoZWFkZXIsIHN1YmhlYWRlciBhbmRcbiAgICAgKiBib2R5IGJ1dCBpZiB0aG9zZSB0ZW1wbGF0ZSBhcmUgaWRlbnRpY2FsIHRoZXJlIHdvdWxkIGJlIHRvbyBtdWNoIGR1cGxpY2F0ZSBjb2RlIHRvIHJlcGxpY2F0ZVxuICAgICAqIGZvciBlYWNoIGNvbHVtbiB0aGUgc2FtZS4gVGhlcmVmb3JlIHdlIGhhdmUgdGhlc2UgZ2xvYmFsIHRlbXBsYXRlcyB0aGF0IHlvdSBjYW4gZGVjbGFyZVxuICAgICAqIG9uIERUIGxldmVsIChub3QgdW5kZXIgY29sdW1ucykgYW5kIGNvbnRlbnQgb2YgdGhlc2UgdGVtcGxhdGUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIGNvbHVtblxuICAgICAqXG4gICAgICogWW91IGNhbiBtaXggdGhlbSBhcyB3ZWxsLiBZb3UgY2FuIGhhdmUgZ2xvYmFsIHRlbXBsYXRlcyBhcyB3ZWxsIGFzIHRlbXBsYXRlIG9uIHRoZSBDb2x1bW5cbiAgICAgKiBsZXZlbCB3aGljaCB3b3VsZCBvdmVycmlkZSB0aGUgZ2xvYmFsIG9uZVxuICAgICAqXG4gICAgICovXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIHN1YkhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVuZGVyIGEgc3ViSGVhZGVyIHRlbXBsYXRlIGlmIHByZXNlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGdsb2JhbCBzdHlsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBib3VuZCB0byB0YWJsZSBhbmQgcmVhZCBieSBlYWNoIGNvbHVtbi5cbiAgICAgKiBUaGUgc2FtZSB5b3UgY2FuIHNlZSBvbiB0aGUgRFRDb2x1bW5cbiAgICAgKi9cbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBpbXBvcnRhbnQgd2hlbiB3ZSBleGVjdXRlIGFueSBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCBpbiBhcyBpbnB1dC4gV2UgbmVlZCB0b1xuICAgICAqIGdpdmUgb3B0aW9uIHRvIGJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgY29udGV4dCAodGhpcykgb2YgdGhlIGNvZGUgdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb250ZXh0OiBhbnk7XG5cbiAgICAvLyBPdXRsaW5lIG5lZWRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgb3V0bGluZUZvciBzZWN0aW9uIG9uIHRoZSBuZXcgbGluZSBhbmQgMm5kIGxldmVsIGNoaWxkIG1ha2UgaXQgcm9vdCBmb3IgdGhpc1xuICAgICAqIHNlY3Rpb25cbiAgICAgKi9cbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGNoYW5nZSBkZWZhdWx0IGluZGVudGF0aW9uIGZvciB0aGUgb3V0bGluZSBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBhY3RpdmUgYXBwbGllcyBzcGVjaWFsIHN0eWxlcyB0byB0aGUgRFQuIExhdGVyIG9uIG9uY2UgcGl2b3QgaXMgaW1wbGVtZW50ZWQgdGhpcyB3aWxsXG4gICAgICogYWxzbyBhZGQgYWRkaXRpb25hbCBiZWhhdmlvciB0byB0aGUgRFRcbiAgICAgKlxuICAgICAqL1xuICAgIHBpdm90YWxMYXlvdXQ6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gc29ydGluZyBpcyBlbmFibGVkIHRoaXMgaXMgY3VycmVudCBhY3RpdmUgY29sdW1uIGJlaW5nIHNvcnRlZC5cbiAgICAgKlxuICAgICAqICAtIHdlIGRvbnQgc3VwcG9ydCBtdWx0aXBsZSBjb2x1bW4gc29ydGluZ1xuICAgICAqL1xuICAgIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBhdy1kdC1kZXRhaWwtY29sdW1uIGlmIHByZXNlbnQgZGV0YWlsIHJvdyBpcyByZW5kZXJlZCBmb3Igc3BlY2lmaWVkXG4gICAgICogaXRlbXNcbiAgICAgKi9cbiAgICByb3dEZXRhaWxDb2x1bW46IERURGV0YWlsUm93Q29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3BhbmluZyBjYWxjdWxhdGlvbiBvciBmb3IgdGhlIGRldGFpbCByb3cgdG8gaWRlbnRpZnkgY29ycmVjdCBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqIHRvIHNwYW4sIHdoZW4gdGhleSBhcmUgc29tZSBub24tZGF0YSBjb2x1bW4gKGV4cGFuc2lvbiBjb250cm9sLCBzaW5nbGUvbXVsdGkgc2VsZWN0aW9uKVxuICAgICAqL1xuICAgIG51bWJlck9mQ29sc0JlZm9yZURhdGE6IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogIHdoYXQgaXMgdGhlIGluZGV4IG9mIGZpcnN0IGRhdGEgY29sdW1uc1xuICAgICAqL1xuICAgIHN0YXJ0T2ZGaXJzdERhdGFDb2x1bW46IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gaW4gY2VsbCBzZWxlY3Rpb24gbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBjb2x1bW4gd2hlIGhlYWRlciBpcyBzZWxlY3RlZC4gQ3VycmVudCB3ZSBhc3N1bWUgdGhlIG9ubHkgb25lIGhlYWRlciBjYW4gYmVcbiAgICAgKiBzZWxlY3RlZCBhdCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQpOiB2b2lkO1xuXG5cbiAgICBvbkhhbmRsZVJvd0NsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSGFuZGxlcyByb3cgc2VsZWN0aW9uIGxvZ2ljIHdoZXJlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluc2lkZSB0aGUgc2VsZWN0ZWQgaXRlbXMsIHRoZW5cbiAgICAgKiBpdHMgcmVtb3ZlZCBvdGhlcndpc2UgaXRzIGFkZGVkLlxuICAgICAqXG4gICAgICogVG9kbzogU3luYyAmIHJlZmFjdG9yIHRoaXMgd2l0aCBkdC5vbkNlbGxTZWxlY3Rpb25DaGFuZ2UgLSBwcmV0dHkgc2ltaWxhciBjb2RlXG4gICAgICpcbiAgICAgKiBXZSB3YW50IHRvIGhhdmUgcm93VG9nZ2xlIGFzIHdlbGwgYXMgd2Ugd2lsbCBoYXZlIHJvd1NlbGVjdCBvciBzb21ldGhpZ24gc2ltaWxhciB0b1xuICAgICAqIGlkZW50aWZ5IHdlIGFyZSBkZWFsaW5nIHdpdGggbXVsdGlzZWxlY3QgYW5kIHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBvblJvd1RvZ2dsZShldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgcm93IHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93U2VsZWN0KGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBvdXRsaW5lICh0cmVlKSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3aGVuIHdlIHNlbGVjdCBzb21lIHJvb3QgaXRlbSBpdFxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIHNlbGVjdCBhbGwgaXRzIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEp1c3QgbGlrZSBmb3Igb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbiB0aGUgc2FtZSBiZWhhdmlvciBuZWVkcyB0byBiZSBhcHBsaWVkIGZvclxuICAgICAqIHRvd2FyZHMgdXAuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsbGVkIGJ5IEQmRCByb3cgZGlyZWN0aXZlIHRvIHVwZGF0ZSB0aGlzIFREIHRoYXQgcm93IHJlb3JkZXJpbmcgbmVlZHMgdG8gaGFwcGVuLiBXZVxuICAgICAqIHJlY2VpdmUgYW4gSU5ERVggb2Ygcm93IHdlIGFyZSBkcmFnZ2luZyBhbmQgbmV3IGRyb3AgcG9zaXRpb24sIHBsdXMgaW5mb3JtYXRpb24gaWYgaXRcbiAgICAgKiBuZWVkcyB0byBiZSBkcm9wcGVkIGJlZm9yZSBuZXcgcm93IHBvc2l0aW9uIG9yIGFmdGVyLlxuICAgICAqXG4gICAgICovXG4gICAgb25EbkRSb3dEcm9wKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBkZXRhaWwgcm93IGlzIGNvbWJpbmVkIHdpdGggb3V0bGluZSBjb250cm9sIHdlIG5lZWQgbWFrZSBzdXJlIHRoYXQgd2UgbWFpbnRhaW4gdGhlXG4gICAgICogY29ycmVjdCBzdGF0ZSBmb3IgaXRlbXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqIEluIHRoaXMgc3BlY2lmaWMgY2FzZSB0aGUgZGV0YWlsIHJvdyBkb2VzIG5vdCBoYXZlIGl0cyBvd24gZXhwYW5kZXIgYnV0IHV0aWxpemluZyB0aGVcbiAgICAgKiBvdXRsaW5lQ29udHJvbFxuICAgICAqL1xuICAgIG9uT3V0bGluZUV4cGFuZENoYW5nZShldmVudDogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBmb3Igc2luZ2xlIGNvbHVtbiBzb3J0aW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRTaW5nbGUoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGF0YSBjaGFuZ2VzLCBlaXRoZXIgdGhleSBhcmUgbGF6aWx5IGZldGNoZWQgb3IgQElucHV0IExJU1QgaXMgdXBkYXRlZCB3ZSBuZWVkXG4gICAgICogcmVzb3J0IG91dCBkYXRhIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGUgYW5kIHVwZGF0ZSBpbnRlcm5hbCBsaXN0IGRhdGFUb1JlbmRlciBzbyBuZXdcbiAgICAgKiBkYXRhIGNhbiByZS1yZW5kZXJlZCArIHRyaWdnZXJzIGV2ZW50IHZhbHVlQ2hhbmdlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbmdlKCk6IHZvaWQ7XG5cbiAgICB1cGRhdGVEYXRhVG9SZW5kZXIoZGF0YXNvdXJjZT86IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvciB1bnNlbGVjdCBhbGwgcm93cy4gVXNlZCBieSBoZWFkZXIgY2hlY2tib3hcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUFsbENvbHVtbnMoZXZlbnQ6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBNb3JlIGxpa2UgdXRpbGl0eSBtZXRob2RzIHRvIHRyYW5zbGF0ZSBzdHJpbmc8LS0+bnVtYmVyIHZhbHVlIGZvciBzb3J0aW5nXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgdXNlZCBvbmx5IGJ5IERUQ29sdW1uLiBXZSBtaWdodCB3YW50IHRvIG1vdmUgdGhpcyBpdHMgb3duIGNvbXBvbmVudCBmb3JcbiAgICAgKiBoZWFkZXJTb3J0IGFuZCBvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgc29ydE9yZGVyaW5nRm9yU3RyaW5nKGRpcmVjdGlvbjogc3RyaW5nKTogbnVtYmVyO1xuXG4gICAgc29ydE9yZGVyaW5nRm9yTnVtYmVyKGRpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nO1xuXG4gICAgdmlzaWJsZUNvbHVtbnMoKTogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cbiAgICBoYXNGcm96ZW5Db2x1bW5zKCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBmdW5jdGlvbmFsaXR5IGZvciB0aGUgc2luZ2xlL211bHRpc2VsZWN0IGZ1bmN0aW9uYWxpdHkgd2hlcmUgd2UgbmVlZCB0byB0cmFjayBpZlxuICAgICAqIHdlIHN1cHBvcnQgc2VsZWN0aW9uIHBsdXMgaG93IG1hbnkgY29sdW1uIGl0IG9jY3VwaWVzIGFuZCBpZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xzIGFyZVxuICAgICAqIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAqL1xuICAgIGhhc0ludmlzaWJsZVNlbGVjdGlvbkNvbHVtbigpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBsYWNlaG9sZGVyIHRvIGlkZW50aWZ5IGlmIHRoZXkgYXJlIG5vbi12YWx1ZSBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogVG8gY29tcGFyZSB0aGUgZGF0YSBpZiB3ZSB1c2UgZGVlcCBvYmplY3QgZXF1YWxpdHkgYW5kIHRoaXMgaXMgdXNlZCB3aXRoaW4gdGhpcyBjbGFzcyBhc1xuICAgICAqIHdlbGwgYXMgZnJvbSB0aGUgRFRDb2x1bW4gdG8gY29uZGl0aW9uYWxseSBhZGQgY2xhc3Mgd2hpY2ggc2VsZWN0IHRoZSBjZWxsXG4gICAgICpcbiAgICAgKiBXZSBtaWdodCB3YW50IHRvIGNoYW5nZSB0byBjaGVjayBvbmx5IGEga2V5IG9mIHRoZSBvYmplY3Qgc29tZSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBpc0hlYWRlclNlbGVjdGVkKGl0ZW06IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpYyBjZWxsIGlzIHNlbGVjdGVkLiBXZSBuZWVkIHR3byBwb2ludHMgdG8gaWRlbnRpZnkgaWYgY2VsbCBpcyBzZWxlY3RlZFxuICAgICAqIHRoZSBhY3R1YWwgSXRlbSB0aGF0IGNvdWxkIHJlcHJlc2VudCB3aG9sZSByb3cgYW5kIENvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgaXNCb2R5Q2VsbFNlbGVjdGVkKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogIENoZWNrIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGFtb25nIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkKGl0ZW06IGFueSk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gW2NoaWxkcmVuXSBiaW5kaW5nIGlzIHByZXNlbnQgdGhlbiBpdCBtZWFucyB3ZSBuZWVkIHRvIHJlbmRlciBpdCBhcyBhIHRyZWVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzT3V0bGluZSgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRoZSBjaGVja2JveCB0byBlaXRoZXIgc2VsZWN0ZWQgYW5kIG5vdCBzZWxlY3RlZCBkZXBlbmRlZCBvbiBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpOiBib29sZWFuO1xuXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5EaXNhYmxlZCgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZXMgYXJlIGZpZWxkIHBhdGggdXRpbGl0eSBjbGFzcyB0byByZXRyaWV2ZSBkYXRhIGZyb20gb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShkYXRhOiBhbnksIGZpZWxkOiBzdHJpbmcpOiBhbnk7XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgRW50aXR5LFxuICAgIGlzQmxhbmssXG4gICAgaXNFbnRpdHksXG4gICAgaXNQcmVzZW50LFxuICAgIGlzU3RyaW5nLFxuICAgIExpc3RXcmFwcGVyLFxuICAgIE1hcFdyYXBwZXJcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEYXRhU291cmNlLCBEU0luaXRQYXJhbXN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdEYXRhVGFibGUsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi9hdy1kYXRhdGFibGUnO1xuXG5cbi8qKlxuICogQ29uY3JldGUgRGF0YVNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgRGF0YXRhYmxlIHdoaWNoIGRlZmluZXMgc3RhdGUgYW5kIGNvbHVtbiBkZWZpbml0aW9uIHRoYXRcbiAqIGNhbiBwcm9ncmFtbWF0aWNhbGx5IG1vZGlmeSByZW5kZXJlZCBjb2x1bW5zIChpZiBwcm92aWRlZCkgYW5kIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuZFxuICogYW5kIGRlbGV0aW5nIHJlY29yZHM7XG4gKlxuICogQWxsIG9wZXJhdGlvbnMgZGVhbGluZyB3aXRoIGRhdGEgdXNlIE9ic2VydmFibGU8VD4gYW5kIGluc3RhbnQoKSBtZXRob2QgdG8gcmV0cmlldmUgY3VycmVudFxuICogc3RhdGUgaXMgbm90IGltcGxlbWVudGVkLlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBEVDJEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZVxue1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMaW1pdCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIGRhdGFQcm92aWRlcnMgYW5kIGZpbmRlcnNcbiAgICAgKi9cbiAgICBkYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuICAgIGRhdGFGaW5kZXI6IERhdGFGaW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZGF0YXRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IERhdGF0YWJsZTJTdGF0ZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGRlYnVnVGltZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgb2JqZWN0IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbnRpdHk6IEVudGl0eURlZjI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHB1YmxpYyBmaW5kZXJzPzogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgICAgICBzdXBlcihkYXRhUHJvdmlkZXJzLCBmaW5kZXJzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgpO1xuXG4gICAgICAgIHRoaXMuZGVidWdUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG5cbiAgICBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoYXJncykgfHwgYXJncy5sZW5ndGggIT09IDEgJiYgIWlzRFRJbml0UGFyYW1zKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIGluaXRpYWxpemUgRFMgd2l0aCAoRFNDaG9vc2VySW5pdFBhcmFtcyknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdDogRFREU0luaXRQYXJhbXMgPSBhcmdzWzBdO1xuXG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBvciBmaW5kIGJlc3QgbWF0Y2ggZm9yIGRhdGFQcm92aWRlclxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IGlzUHJlc2VudChpbml0LmRhdGFQcm92aWRlcikgPyBpbml0LmRhdGFQcm92aWRlclxuICAgICAgICAgICAgOiB0aGlzLmRhdGFQcm92aWRlcnMuZmluZChpbml0Lm9iaik7XG5cbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIG9yIGZpbmQgYmVzdCBtYXRjaCBmb3IgZGF0YUZpbmRlclxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhRmluZGVyKSA/IGluaXQuZGF0YUZpbmRlclxuICAgICAgICAgICAgOiB0aGlzLmZpbmRlcnMuZmluZCh0aGlzLmRhdGFQcm92aWRlciwgaW5pdC5xdWVyeVR5cGUpO1xuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kYXRhUHJvdmlkZXIpICYmIGlzUHJlc2VudCh0aGlzLmRhdGFGaW5kZXIpLFxuICAgICAgICAgICAgJ0RhdGFTb3VyY2UgaW5jb3JyZWN0bHkgaW5pdGlhbGl6ZWQuIChEYXRhUHJvdmlkZXIsIERhdGFGaW5kZXIpIG1pc3NpbmcuICcpO1xuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICAgICAgaWYgKGlzQmxhbmsoaW5pdC5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gaW5pdC5zdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXN5bmMgZmV0Y2ggZGF0YSByZXF1ZXN0IGFuZCByZXN1bHQgaXMgZ2l2ZW4gYmFjayB1c2luZyBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoKHdpdGhQYXJhbXM/OiBEYXRhdGFibGUyU3RhdGUpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh3aXRoUGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gbmV3IE1hcCgpLnNldCgnb2Zmc2V0Jywgd2l0aFBhcmFtcy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgLnNldCgnbGltaXQnLCB3aXRoUGFyYW1zLmxpbWl0KVxuICAgICAgICAgICAgICAgIC5zZXQoJ29yZGVyYnknLCB3aXRoUGFyYW1zLnNvcnRLZXkpXG4gICAgICAgICAgICAgICAgLnNldCgnc2VsZWN0b3InLCB3aXRoUGFyYW1zLnNvcnRPcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5mZXRjaChwYXJhbXMpLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHdpdGhQYXJhbXMub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmNyRGF0YSA9IFsuLi50aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpLCAuLi5yZXN1bHRdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoaW5jckRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVzZXMgdGhpcyBtZXRob2QgdG8gb3BlbiB1cCBjb250aW51b3VzIHN0cmVhbSB0byBsaXN0ZW4gZm9yIGFueSBjaGFuZ2VzIHdoaWNoXG4gICAgICogbmVlZCB0byBiZSByZWZsZWN0ZWQgb24gdGhlIFVJLlxuICAgICAqXG4gICAgICogRG9udCBmb3JnZXQgdG8gdW5zdWJzY3JpYmUgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSWYgQ1JVRCBpcyBlbmFibGVkIHdlIGRlbGVnYXRlIGNhbGxzIHRvIERhdGFQcm92aWRlciB0aGF0IGlzIHJlc3BvbnNpYmxlIHRvIHRlbGwgdGhlXG4gICAgICogZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzIHRoYXQgYXJlIG5ldyBkYXRhLiBJZiBub3QgZW5hYmxlZCB3ZSBoYXZlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aGljaCB3b3JrcyB3aXRoIGxvY2FsIGFycmF5XG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqZWN0OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kYXRhUHJvdmlkZXIuY2FuQ1JVRCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5pbnNlcnQob2JqZWN0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YS5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMuZGF0YVByb3ZpZGVyLm9mZlNjcmVlbkRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGVhc2Ugc2VlIHtAbGluayBpbnNlcnR9IG1ldGhvZFxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlKG9iamVjdDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3ZpZGVyLmNhbkNSVUQoKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIucmVtb3ZlKG9iamVjdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YSwgb2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQodGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byBEYXRhRmluZGVyIHdoaWNoIGNhbiBhY2NlcHQgZWl0aGVyIHBsYWluIHN0cmluZyBvciBNYXAuXG4gICAgICpcbiAgICAgKiBUbyBiZSBhYmxlIHRvIHByb3ZpZGUgY29ycmVjdCBpbnB1dCB3ZSBuZWVkIHRvIGFzayBEYXRhRmluZGVyIGlmIGl0IHN1cHBvcnRzIEZ1bGxUZXh0IGxpa2VcbiAgICAgKiB0eXBlIHF1ZXJ5IG9yIFByZWRpY2F0ZS4gSW4gY2FzZSBvZiBQcmVkaWNhdGUgd2UgYnVpbGQgdGhlIE1hcCB3aXRoIGRpZmZlcmVudCBrZXkvdmFsdWVcbiAgICAgKiBwYWlyc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBmaW5kKHBhdHRlcm4/OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXR0ZXJuKSB8fCBwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZWQgZW1wdHkgc3RyaW5nIHJldHVybiBvcmdpbmFsIGxpc3RcbiAgICAgICAgICAgIHRoaXMuZmV0Y2godGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoUGFyYW06IGFueSA9IHBhdHRlcm47XG4gICAgICAgIGlmICh0aGlzLmRhdGFGaW5kZXIuYWNjZXB0cyh0aGlzLmRhdGFQcm92aWRlciwgUXVlcnlUeXBlLlByZWRpY2F0ZSkpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtID0gbmV3IE1hcCgpLnNldCgncXVlcnknLCBwYXR0ZXJuKS5zZXQoJ2xpbWl0JywgRFQyRGF0YVNvdXJjZS5NYXhMaW1pdCk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnb3JkZXJieScsIHRoaXMuc3RhdGUuc29ydEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnc2VsZWN0b3InLCB0aGlzLnN0YXRlLnNvcnRPcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQoaXNTdHJpbmcocGF0dGVybiksICdDYW5ub3QgcGFzcyBub24tc3RyaW5nIHZhbHVlIHRvIEZ1bGxUZXh0IEZpbmRlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLm1hdGNoPGFueT4oc2VhcmNoUGFyYW0pLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGF0YSBzb3VyY2UgZGVsZWdhdGVzIHRoZSByZXNwb25zaWJpbGl0eSB0byB0aGUgZ2l2ZW4gZGF0YSBwcm92aWRlciB3aGljaCBuZWVkcyB0byBpbXBsZW1lbnRcbiAgICAgKiBzcGVjaWZpYyBzb3J0aW5nIG1lY2hhbmlzbVxuICAgICAqXG4gICAgICogVG9kbzogRXh0ZW5kIHRvIHNvcnQgYnkgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqXG4gICAgICovXG4gICAgc29ydChrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkpIHx8IHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gc29ydE9yZGVyO1xuICAgICAgICB0aGlzLmZldGNoKHRoaXMuc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUGVyc2lzdCBkYiBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlU3RhdGUob2Zmc2V0OiBudW1iZXIsIHNvcnRGaWVsZDogc3RyaW5nLCBzT3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gc09yZGVyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXNodWZmbGVzIGN1cnJlbnQgYXJyYXkgYmFzZWQgb24gbmV3IHJvdyBEJkQgcmVzdWx0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGlmIHdlIG1vdmUgaXRlbSBmcm9tIGJvdHRvbSBvciBmcm9tIHRoZSB0b3AgYW5kIHRoZW4gYWNjb3JkaW5nbHlcbiAgICAgKiBoaWdobGlnaHRpbmcgYSBzcGFjZSBiZXR3ZWVuIHJvd3MuIFdlIG5lZWQgdG8gcmVmbGVjdCB0aGlzIGluIGhlcmUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMTpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBpdCBkb3duIHNvIHRoYXQgeW91IGNhbiBzZWUgYSBkcm9wcGluZyBsaW5lXG4gICAgICogYmV0d2VlbiByb3cgd2l0aCBpbmRleCAyIC0gM1xuICAgICAqXG4gICAgICogMi4gSW4gdGhpcyBjYXNlIHNwbGljZSgpIHN0YXJ0cyBmcm9tIHBvc2l0aW9uIDIgYW5kIGluc2VydCBhbGwgZWxlbWVudHMgYWZ0ZXIgMlxuICAgICAqICAgICAgc3BsaWNlKHN0YXJ0OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiBUW107XG4gICAgICpcbiAgICAgKiAzLiBubyBuZWVkIHRvIHVwZGF0ZSBuZXdQb3NcbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMjpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBhbGwgdGhlIHdheSBkb3duIG9mIHRoZSBEVCBhbmQgbm93IG1vdmUgdGhlXG4gICAgICogcm93IHRvd2FyZCBUT1AgYW5kIHNwYWNlIGJldHdlZW4gcm93cyB3aXRoIGluZGV4IDIgLSAzIGlzIGhpZ2hsaWdodGVkIGFnYWluLlxuICAgICAqXG4gICAgICogMi4gSGVyZSBpcyB0aGUgZGlmZmVyZW5jZSwgYmVmb3JlIHdlIGhpZ2hsaWdodGVkIHJvdyAjMiB3aXRoIGxpbmUgYXQgdGhlIGJvdHRvbSwgbm93XG4gICAgICogaXQgc2VlbXMgdGhlIHNhbWUgYnV0IGl0cyBoaWdobGlnaHRlZCByb3cgIzMgd2l0aCBsaW5lIGF0IHRoZSBUT1AuXG4gICAgICpcbiAgICAgKiAqIFRoaXMgaXMgdGhlIHJlYXNvbiB3aGV5IHdlIG5lZWQgdG8gZG8gbmV3UG9zIC09IDEgb3IgbmV3UG9zICs9IDE7IGRlcGVuZGluZyBvdXIgZGlyZWN0aW9uXG4gICAgICogd2hlcmUgd2hlcmUgdGhlIGxpbmUgYmV0d2VlbiByb3dzIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IGNvbXBsaWNhdGVkIGNhbGN1bGF0aW9uIHRyeWluZyB0byBmaW5kIG91dCBpZiB3ZSBhcmUgb24gb25lIGhhbGYgb2YgdGhlIHJvd1xuICAgICAqIG9yIHNlY29uZCBoYWxmIGFuZCBiYXNlZCBvbiB0aGlzIHRyeSB0byBhcHBseSBjZXJ0YWluIHN0eWxlLiBUaGlzIHdvdWxkIG5vdCBnaXZlIHNvIG11Y2hcbiAgICAgKiBzcGFjZSBpZiB3ZSB3YW50IGRyb3Agcm93IGludG8gdGhlIHJvdy4gQW5kIHRoZSBjYWxjdWxhdGlvbiB3aXRoIGNvb3JkaW5hdGVzIHdvdWRsIGJlIHRvb1xuICAgICAqIGNvbXBsaWNhdGVkLlxuICAgICAqXG4gICAgICogV2Ugc2ltcGx5IHJlbWVtYmVyIHRoZSBkaXJlY3Rpb24gd2UgYXJlIG1vdmluZyBhbmQgYmFzZWQgb24gdGhpcyB3ZSBhcHBseSBzdHlsZSB0b1xuICAgICAqIHRvIGNyZWF0ZSBhIGxpbmUgYXQgdGhlIFRPUCBpZiB3ZSBhcmUgZ29pbmcgdXB3YXJkcyBvciBib3R0b20gb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW9yZGVyUm93cyhvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgYXJyYXkgPSB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkuc2xpY2UoKTtcblxuICAgICAgICAvLyB0YWtlIHNvbWV0aGluZyBmcm9tIHRvcCBhbmQgZHJhZyZkcm9wIHVuZGVyXG4gICAgICAgIGlmIChuZXdQb3MgPiBvcmlnUG9zICYmIGRyb3BQb3MgPT09IERyb3BQb3NpdGlvbi5CZWZvcmUgJiYgbmV3UG9zIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXdQb3MgLT0gMTtcblxuICAgICAgICAgICAgLy8gdGFrZSBzb21ldGhpbmcgZnJvbSBib3R0b20gYW5kIGRyYWcmZHJvcCBhYm92ZVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IG9yaWdQb3MgJiYgZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyICYmIG5ld1BvcyA+PSAwKSB7XG4gICAgICAgICAgICBuZXdQb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5LnNwbGljZShuZXdQb3MsIDAsIC4uLmFycmF5LnNwbGljZShvcmlnUG9zLCAxKVswXSk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoYXJyYXkpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEVudGl0eSBkZWZpbml0aW9uIHRvIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBwcm9ncmFtbWF0aWNhbGx5IGNvbHVtbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlEZWYyXG57XG4gICAgcHJvcGVydHlLZXlzOiBzdHJpbmdbXTtcblxuICAgIGRlZmF1bHRGb3JtYXR0ZXI6IChrZXk6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgZGlzcGxheVN0cmluZ0ZvcktleTogKGtleTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgICBkZWZhdWx0QWxpZ25tZW50Rm9yS2V5OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbn1cblxuLyoqXG4gKiBLZWVwcyBjdXJyZW50IGRhdGF0YWJsZSBzdGF0ZSB0aGUgc3RhdGUgd2hpY2ggZHJpdmVycyB0aGUgd2F5IHdoaWxlIGZldGNoaW5nIHRoZSBkYXRhIGFzIHdlbGxcbiAqIGVuY2Fwc3VsYXRlIHNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgbmVlZHMgdG8gYmUgcGVyc2lzdGV0IGluIG9yZGVyIHRvIHJlY292ZXIgYSBzdGF0ZSBhZnRlciBlLmcuXG4gKiBicm93c2VyIHJlZnJlc2hcbiAqXG4gKlxuICogdG9kbzogQ3JlYXRlIG1ldGhvZHMgdG8gY29udmVydCB0aGlzIHN0YXRlIGZyb20gYW5kIHRvIEpTT04gZm9yIGVhc2llciBzZXJpYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhdGFibGUyU3RhdGVcbntcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFzY2VuZGluZyA9IDE7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEZXNjZW5kaW5nID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIGZvciBwYWdpbmcgYW5kIGZldGNoaW5nXG4gICAgICovXG4gICAgb2Zmc2V0OiBudW1iZXIgPSAwO1xuICAgIGxpbWl0OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyBkZWZhdWx0IHZhbHVlIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgTiBudW1iZXIgb2Ygcm93cyBpbiBub24tZnVsbHNjcmVlblxuICAgICAqIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlMaW1pdDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc29ydGluZyBmaWVsZFxuICAgICAqL1xuICAgIHNvcnRLZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNvcnRpbmcgb3JkZXIgb2YgdGhlIHNvcnQgZmllbGQuIERhdGFUYWJsZSBzdXBwb3J0IHNvcnRpbmcgZm9yIG11bHRpcGxlIGNvbHVtbiBidXQgd2VcbiAgICAgKiBkb250IHBlcnNpc3QgaXQgbm93LiBNYXliZSBpbiB0aGUgZnV0dXJlXG4gICAgICovXG4gICAgc29ydE9yZGVyOiBudW1iZXIgPSBEYXRhdGFibGUyU3RhdGUuQXNjZW5kaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIHVzaW5nIGdsb2JhbCBmaWx0ZXIgZm9yIGN1cnJlbnQgZGF0YXRhYmxlIHRoZW4gc2F2ZSBpdCBoZXJlXG4gICAgICovXG4gICAgY3VycmVudFNlYXJjaFF1ZXJ5OiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaWYgYW55IHByZXNlbGVjdGVkIGZpbHRlclxuICAgICAqL1xuICAgIGN1cnJlbnRGaWx0ZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudCBjdXJyZW50IHNlbGVjdGlvbiBkZXBlbmRpbmcgb24gc2VsZWN0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBDdXJyZW50IHNlbGVjdGlvbiB1c2VkIGJvdGggZm9yIHJvdyBzZWxlY3Rpb24gYW5kIGNlbGwgc2VsZWN0aW9uLiBSb3cgc2VsZWN0aW9uIGlzIHVzZWQgd2hlblxuICAgICAqIFNpbmdsZVNlbGVjdCBhbmQgTXVsdGlTZWxlY3Qgb25jZSB3ZSBpbXBsZW1lbnQgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGlvbjogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGhlYWRlciBzZWxlY3Rpb24gaXMgZW5hYmxlZCBpdCBjYXB0dXJlcyBjdXJyZW50bHkgc2VsZWN0ZWQgY29sdW1uXG4gICAgICovXG4gICAgaGVhZGVyU2VsZWN0aW9uOiBEVENvbHVtbjJDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEhvbGRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG91dGxpbmUgdHJlZSBpZiB1c2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBvdXRsaW5lU3RhdGU/OiBNYXA8YW55LCBib29sZWFuPjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEhvbGRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRldGFpbCByb3dzIGlmIHVzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlPzogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZVN0YXRlID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKG9mZnNldDogbnVtYmVyID0gMCwgbGltaXQ6IG51bWJlciA9IDE1LCBkaXNwbGF5TGltaXQ6IG51bWJlciA9IDUsXG4gICAgICAgICAgICAgICAgICBzb3J0RmllbGQ6IHN0cmluZyA9ICcnLCBzT3JkZXI6IG51bWJlciA9IDAsIHNlYXJjaFF1ZXJ5Pzogc3RyaW5nLCBmaWx0ZXI/OiBhbnksXG4gICAgICAgICAgICAgICAgICBvdXRsaW5lU3RhdGU6IE1hcDxhbnksIGJvb2xlYW4+ID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCksXG4gICAgICAgICAgICAgICAgICBkZXRhaWxSb3dTdGF0ZTogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSk6IERhdGF0YWJsZTJTdGF0ZVxuICAgIHtcbiAgICAgICAgbGV0IHMgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIHMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHMuZGlzcGxheUxpbWl0ID0gZGlzcGxheUxpbWl0O1xuICAgICAgICBzLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHMuc29ydE9yZGVyID0gc09yZGVyO1xuICAgICAgICBzLmN1cnJlbnRTZWFyY2hRdWVyeSA9IHNlYXJjaFF1ZXJ5O1xuICAgICAgICBzLmN1cnJlbnRGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHMub3V0bGluZVN0YXRlID0gb3V0bGluZVN0YXRlO1xuICAgICAgICBzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gZGV0YWlsUm93U3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21KU09OKGRhdGE6IHN0cmluZyk6IERhdGF0YWJsZTJTdGF0ZVxuICAgIHtcbiAgICAgICAgbGV0IHN0YXRlOiBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgbGV0IGRzID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICBkcy5vZmZzZXQgPSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGRzLmxpbWl0ID0gc3RhdGUubGltaXQ7XG4gICAgICAgIGRzLmRpc3BsYXlMaW1pdCA9IHN0YXRlLmRpc3BsYXlMaW1pdDtcbiAgICAgICAgZHMuc29ydEtleSA9IHN0YXRlLnNvcnRLZXk7XG4gICAgICAgIGRzLnNvcnRPcmRlciA9IHN0YXRlLnNvcnRPcmRlcjtcbiAgICAgICAgZHMuY3VycmVudFNlYXJjaFF1ZXJ5ID0gc3RhdGUuY3VycmVudFNlYXJjaFF1ZXJ5O1xuICAgICAgICBkcy5vdXRsaW5lU3RhdGUgPSBNYXBXcmFwcGVyLmNyZWF0ZUZyb21BbnlNYXA8Ym9vbGVhbj4oc3RhdGUub3V0bGluZVN0YXRlKTtcbiAgICAgICAgZHMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBNYXBXcmFwcGVyLmNyZWF0ZUZyb21BbnlNYXA8Ym9vbGVhbj4oc3RhdGUuZGV0YWlsUm93RXhwYW5kU3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBkcztcbiAgICB9XG5cblxuICAgIHN0YXRpYyB0b0pTT04oZGF0YTogRGF0YXRhYmxlMlN0YXRlKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgdG9Db252ZXJ0OiBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiBkYXRhLm9mZnNldCxcbiAgICAgICAgICAgIGxpbWl0OiBkYXRhLmxpbWl0LFxuICAgICAgICAgICAgZGlzcGxheUxpbWl0OiBkYXRhLmRpc3BsYXlMaW1pdCxcbiAgICAgICAgICAgIHNvcnRLZXk6IGRhdGEuc29ydEtleSxcbiAgICAgICAgICAgIHNvcnRPcmRlcjogZGF0YS5zb3J0T3JkZXIsXG4gICAgICAgICAgICBjdXJyZW50U2VhcmNoUXVlcnk6IGRhdGEuY3VycmVudFNlYXJjaFF1ZXJ5LFxuICAgICAgICAgICAgb3V0bGluZVN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEub3V0bGluZVN0YXRlKSxcbiAgICAgICAgICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEuZGV0YWlsUm93RXhwYW5kU3RhdGUpXG5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRvQ29udmVydCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUaGlzIG5lZWRzIHRvIGdvIHRvIERURGF0YVNvdXJjZSB0byBrZWVwIGFuZCBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBkZXRhaWwgcm93LiBUaGUgaWRlYSBpc1xuICogc2ltcGxlIHdlIGhhdmUgYSBtYXAgaG9sZGluZyBpdGVtIHJlZmVyZW5jZSBhcyBhIGtleSBhbmQgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZVxuICogZGV0YWlsIHJvdyBpcyB2aXNpYmxlXG4gKlxuICogVG9kbzogbW92ZSB0aGlzIG91dCB0byBEU1xuICovXG5leHBvcnQgY2xhc3MgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGVcbntcblxuICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZHQ6IEFXRGF0YVRhYmxlKVxuICAgIHtcbiAgICB9XG5cbiAgICBnZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZXhwYW5zaW9uU3RhdGVzKTtcbiAgICB9XG5cbiAgICBzZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCh2YWx1ZTogYm9vbGVhbilcbiAgICB7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlKGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSB0aGlzLmV4cGFuc2lvblN0YXRlcztcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb2xsYXBzZSBwYXJlbnQgb2YgcGFyZW50IHdoaWxlIGRldGFpbCByb3cgaXMgZXhwYW5kZWRcbiAgICAgICAgaWYgKHRoaXMuZHQuaXNPdXRsaW5lKCkgJiYgIXRoaXMuZHQub3V0bGluZVN0YXRlLmlzRXhwYW5kZWQoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNPdXRsaW5lRXhwYW5kZWQgPSB0aGlzLmR0LmlzT3V0bGluZSgpID8gdGhpcy5kdC5vdXRsaW5lU3RhdGUuaXNFeHBhbmRlZChrZXkpIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChrZXkpICYmIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXRlbVRvS2V5KGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzRW50aXR5KGl0ZW0pID8gKDxFbnRpdHk+aXRlbSkuaWRlbnRpdHkoKSA6IGl0ZW07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXJcbntcbiAgICBvZmZzZXQ6IG51bWJlcjtcbiAgICBsaW1pdDogbnVtYmVyO1xuICAgIGRpc3BsYXlMaW1pdDogbnVtYmVyO1xuICAgIHNvcnRLZXk6IHN0cmluZztcbiAgICBzb3J0T3JkZXI6IG51bWJlcjtcbiAgICBjdXJyZW50U2VhcmNoUXVlcnk6IHN0cmluZztcbiAgICBjdXJyZW50RmlsdGVyPzogYW55O1xuICAgIG91dGxpbmVTdGF0ZTogYW55O1xuICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBhbnk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRFRJbml0UGFyYW1zKGluaXQ6IERURFNJbml0UGFyYW1zKTogaW5pdCBpcyBEVERTSW5pdFBhcmFtc1xue1xuICAgIHJldHVybiBpc1ByZXNlbnQoaW5pdC5vYmopIHx8IGlzUHJlc2VudChpbml0LnF1ZXJ5VHlwZSkgfHwgaXNQcmVzZW50KGluaXQuZW50aXR5KTtcbn1cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEVERTSW5pdFBhcmFtcyBleHRlbmRzIERTSW5pdFBhcmFtc1xue1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGRlZmluaXRpb24gZm9yIHRoZSBkYXRhXG4gICAgICovXG4gICAgZW50aXR5PzogRW50aXR5RGVmMjtcblxuICAgIHN0YXRlPzogRGF0YXRhYmxlMlN0YXRlO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5qZWN0LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uLy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIENvbHVtbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIE11bHRpc2VsZWN0aW9uIHdoZXJlIHdlIHNob3cgY2hlY2tib3ggY29udHJvbFxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtbXVsdGktc2VsZWN0LWNvbHVtbicsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgTWFuYWdlcyBtdWx0aSBzZWxlY3Rpb24gYW5kIHJlbmRlcnMgY2hlY2tib3hlcyBib3RoIGZvciBoZWFkZXIgaW4gY2FzZSBbc2hvd1NlbGVjdEFsbF0gaXNcbiAgICBlbmFibGVkIGFzIHdlbGwgYXMgZWFjaCBjaGVja2JveCBwZXIgcm93XG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIlxuICAgICAgICAgICAgIGxldC1sZXZlbD1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgICAgICAgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEhlYWRlclwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpc1N1YkhlYWRlciwgY29sdW1uSW5kZXg6Y29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgIGxldmVsOmxldmVsfVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xCb2R5XCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGNvbHVtbiwgbGV2ZWw6bGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ZGF0YVRvUmVuZGVyLHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sSGVhZGVyIGxldC1pc1N1YkhlYWRlciBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiPlxuICAgIDx0aCBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtdS11bnNlbGVjdGFibGUtdGV4dCBkdC1zZWxlY3Rpb24tY29sdW1uJyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LXN1Yi1oZWFkZXInOiBpc1N1YkhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiIGFsaWduPVwiY2VudGVyXCI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImR0LnNob3dTZWxlY3RBbGxcIj5cbiAgICAgICAgICAgIDxhdy1jaGVja2JveCBbdHlwZV09XCInYWN0aW9uJ1wiIChhY3Rpb24pPVwiZHQudG9nZ2xlQWxsQ29sdW1ucygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiZHQuaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZHQuaXNUb2dnbGVBbGxDb2x1bW5EaXNhYmxlZCgpXCI+XG4gICAgICAgICAgICA8L2F3LWNoZWNrYm94PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZHQuc2hvd1NlbGVjdEFsbFwiPiZuYnNwO1xuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdGg+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNjb2xCb2R5IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCIgLCBsZXQtbGV2ZWw9XCJsZXZlbFwiPlxuXG4gICAgPHRkICNjZWxsIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKGRhdGEpXCJcbiAgICAgICAgW3N0eWxlLnBhZGRpbmctbGVmdC5weF09XCJpbmRlbnRGb3JDb250cm9sKGNlbGwsIGxldmVsKVwiXG4gICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCBkdC1zZWxlY3Rpb24tY29sdW1uJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiPlxuXG4gICAgICAgIDxhdy1jaGVja2JveCBbdHlwZV09XCInYWN0aW9uJ1wiIFt2YWx1ZV09XCJkdC5pc1Jvd1NlbGVjdGVkKGRhdGEpXCI+XG4gICAgICAgIDwvYXctY2hlY2tib3g+XG5cbiAgICA8L3RkPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBTaW5nbGVTZWxlY3Qgd2hlcmUgd2Ugc2hvdyBjaGVja2JveCBjb250cm9sXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbicsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgTWFuYWdlcyBtdWx0aSBzZWxlY3Rpb24gYW5kIHJlbmRlcnMgY2hlY2tib3hlcyBib3RoIGZvciBoZWFkZXIgaW4gY2FzZSBbc2hvd1NlbGVjdEFsbF0gaXNcbiAgICBlbmFibGVkIGFzIHdlbGwgYXMgZWFjaCBjaGVja2JveCBwZXIgcm93XG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIlxuICAgICAgICAgICAgIGxldC1sZXZlbD1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgICAgICAgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEhlYWRlclwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpc1N1YkhlYWRlciwgY29sdW1uSW5kZXg6Y29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgIGxldmVsOmxldmVsfVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xCb2R5XCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGNvbHVtbiwgbGV2ZWw6bGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ZGF0YVRvUmVuZGVyLHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sSGVhZGVyIGxldC1pc1N1YkhlYWRlciBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiPlxuICAgIDx0aCBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtdS11bnNlbGVjdGFibGUtdGV4dCBkdC1zZWxlY3Rpb24tY29sdW1uJyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LXN1Yi1oZWFkZXInOiBpc1N1YkhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiIGFsaWduPVwiY2VudGVyXCI+XG4gICAgICAgICZuYnNwO1xuICAgIDwvdGg+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNjb2xCb2R5IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCIgLCBsZXQtbGV2ZWw9XCJsZXZlbFwiPlxuXG4gICAgPHRkICNjZWxsIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKGRhdGEpXCJcbiAgICAgICAgW3N0eWxlLnBhZGRpbmctbGVmdC5weF09XCJpbmRlbnRGb3JDb250cm9sKGNlbGwsIGxldmVsKVwiXG4gICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCBkdC1zZWxlY3Rpb24tY29sdW1uJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiPlxuXG4gICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInRFRSYWRpbydcIiBbdmFsdWVdPVwiZGF0YVwiIFsobmdNb2RlbCldPVwiZHQuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3Rpb25cIj5cbiAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAgICA8L3RkPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqICBAb3JpZ2luYWwtbGljZW5zZVxuICogIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IFByaW1lVGVrXG4gKlxuICogIENyZWRpdDogRGVyaXZlZCBhbmQgZXh0ZW5kZWQgZnJvbSBQcmltZS1uZyBkYXRhYmxlIHdoZXJlIHdlIG5lZWRlZCBtb3JlIG1vZHVsYXIgc29sdXRpb24uXG4gKiAgV2UgcmV1c2VkIHRoZSBjb3JlIHN0cnVjdHVyZSBhbmQgbGF5b3V0IGJ1dCBoYWQgdG8gcmVmYWN0b3IgYm90aCBjb2RlIGFuZCB0ZW1wbGF0ZSB0byBtYXRjaCBvdXJcbiAqICBuZWVkcy4gTW9yZSBpbiB0aGUgZGVzY3JpcHRpb25cbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbmplY3QsXG4gICAgSW5qZWN0b3IsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JqZWN0VXRpbHN9IGZyb20gJ3ByaW1lbmcvY29tcG9uZW50cy91dGlscy9vYmplY3R1dGlscyc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2lzT3V0bGluZU5vZGUsIE91dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZS9pbmRleCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgQm9vbGVhbldyYXBwZXIsXG4gICAgRW52aXJvbm1lbnQsXG4gICAgZXF1YWxzLFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0JsYW5rLFxuICAgIGlzUHJlc2VudCxcbiAgICBMaXN0V3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QVdEYXRhVGFibGUsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi9hdy1kYXRhdGFibGUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YXRhYmxlMlN0YXRlLCBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSwgRFQyRGF0YVNvdXJjZX0gZnJvbSAnLi9kYXRhdGFibGUyLWRhdGEtc291cmNlJztcbmltcG9ydCB7XG4gICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGVsRm9ybWF0fSBmcm9tICcuLi9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdtdWx0aScgfCAnc2luZ2xlJyB8ICdjZWxsJyB8ICdub25lJztcblxuLyoqXG4gKiBEVCBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIHRoZSBkYXRhIGdyaWQgdGhhdCBzaG93cyB0YWJ1bGFyIGRhdGEuIEV2ZW4gdGhlIGJhc2ljXG4gKiBzdHJ1Y3R1cmUgaXMgYmFzZWQgb24gUHJpbWVORyBkYXRhdGFibGUgaXRzIGNvbXBsZXRlbHkgcmVmYWN0b3JlZCBpbnRvIHNtYWxsZXIgcGllY2VzIHRoYXRcbiAqIGFsbG93cyBtb3JlIGV4dGVuc2liaWxpdHkgYW5kIHRyeWluZyB0byBzdGF5IGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGV4aXN0aW5nIEFXTCBpbXBsZW1lbnRhdGlvblxuICpcbiAqIFRoZXJlIGFyZSAzIG1haW4gcGllY2VzOlxuICpcbiAqICBUYWJsZSBXcmFwcGVyIC0gZm9jdXNlcyBvbiB0aGUgb3V0ZXIgc3RydWN0dXJlLiBDb250YWluZXIgd2l0aCBiYXNpYyBkYXRhYmxlIGxheW91dCBwbHVzXG4gKiAgY29udGFpbnMgYW55IGFkZGl0aW9uYWwgcGFuZWxzIHRoYXQgZGF0YXRhYmxlIG5lZWRzIHN1Y2ggYXMgb3VyIG5ldyBjb25jZXB0IGhvdyBlZGl0aW5nIHdpbGxcbiAqICB3b3JrIC0gc2xpZGluZyBwYW5lbCBmcm9tIHRoZSBib3R0b21cbiAqXG4gKiAgRGF0YXRhYmxlIENvbHVtbiAtIEluc3RlYWQgb2YgcmVuZGVyaW5nIGV2ZXJ5dGhpbmcgaW5zaWRlIERUIEkgc3BsaXQgdGhlIHBhcnQgdGhhdCByZW5kZXJzXG4gKiAgY29sdW1uIGludG8gc2VwYXJhdGUgY29tcG9uZW50LiBUaGlzIHdheSBjb21wb25lbnQgY29sdW1uIGhhcyBpdHMgb3duIHJlbmRlcmVyIHRlbXBsYXRlIHdoaWNoXG4gKiAgY2FuIHJlbmRlciBib3RoIGhlYWRlciBhbmQgZGF0YSBjZWxscy5cbiAqICBMYXRlciBvbiBEVENvbHVtbiBpcyB0aGVuIGV4dGVuZGVkIHRvIHN1cHBvcnQgb3RoZXIgYWRkaXRpb25hbCBjb2x1bW4gdHlwZXNcbiAqICBTaW5nbGVTZWxlY3Rpb25Db2x1bW4sIE11bHRpU2VsZWN0aW9uQ29sdW1uLCBib3RoIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbnRyb2xzLlxuICpcbiAqIFRvIHN1cHBvcnQgcGl2b3RhbCBsYXlvdXQgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgZm9yIG90aGVyIGFkZGl0aW9uYWwgY29sdW1ucyB0aGF0IGltcGxlbWVudHMgdGhlaXJcbiAqIG93biByZW5kZXJpbmcgdGVtcGxhdGVzXG4gKlxuICogRGF0YXRhYmxlIC0gVGhlIG1haW4gY29tcG9uZW50IHRoYXQgaXMgb25seSBmb2N1cyBvbiBoZWFkZXIgYW5kIGJvZHkgcmVuZGVyaW5nIGFuZCBiYXNhZWQgb24gdGhlXG4gKiBjb2x1bW4gdHlwZSBpdCB3aWxsIHJlbmRlciB0aGUgY29ycmVjdCB0ZW1wbGF0ZVxuICogY29sdW1uIHR5cGUgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlY3QgdGVtcGxhdGVcbiAqXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRhdGF0YWJsZTInLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFRoaXMgdGVtcGxhdGUgZm9jdXMgb25seSBvbiBoZWFkZXIgYW5kIGJvZHkgcmVuZGVyaW5nLlxuXG4gICAgVGhpcyBkYXRhdGFibGUgYWxzbyBzdXBwb3J0cyBmcm96ZW4gY29sdW1uIGFuZCBmb3IgdGhpcyByZW5kZXJpbmcgaXQgaXMgcHJldHR5IG11Y2ggdHJhbnNwYXJlbnRcbiAgICBhcyBpdCByZWNlaXZlZCBzZXRzIG9mIGNvbHVtbiB0aGF0IGl0IG5lZWRzIHRvIHJlbmRlciBmcm9tIHRoZSBUYWJsZVdyYXBwZXIuXG5cbiAgICBUYWJsZVdyYXBwZXIgaW4gY2FzZSBvZiBmcm96ZW4gY29sdW1ucyBjYWxscyAjaGVhZGVyUm93cyBhbmQgI2JvZHlSb3dzIHRlbXBsYXRlcyB0d2ljZSB0b1xuICAgIHJlbmRlciB0byBzZXBhcmF0ZSB0YWJsZXMgd2hlcmUgb25lIGhhcyBmcm96ZW4gY29sdW1ucyBhbmQgYW5vdGhlciBvbmUgaGFzIHRoZSByZXN0IGFuZCBpdHNcbiAgICBzY3JvbGxhYmxlXG4tLT5cblxuPGF3LWR0LXdyYXBwZXIgI2R0V3JhcHBlcj5cbiAgICA8bmctdGVtcGxhdGUgI2hlYWRpbmdBcmVhPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1kdC1oZWFkZXIyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgI2hlYWRlclJvd3MgbGV0LWNvbHNUb1JlbmRlciBsZXQtZnJvemVuVmlldz1cImZyb3plbkNvbHVtbnNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXI7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyLCBmcm96ZW46ZnJvemVuVmlldyB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgI2JvZHlSb3dzIGxldC1jb2xzVG9SZW5kZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc091dGxpbmUoKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keU91dGxpbmU7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzT3V0bGluZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5UGxhaW47IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L2F3LWR0LXdyYXBwZXI+XG5cblxuPCEtLVxuICAgIEVhY2ggcmVuZGVyaW5nIGNvbHVtbiBoYXMgaXRzIG93biByZW5kZXJUZW1wbGF0ZSB3aGljaCBkZWZpbmUgaG93IHRoaW5ncyBzaG91bGQgYmUgcmVuZGVyLlxuICAgIEJhc2VkIG9uIGRpZmZlcmVudCBjb2x1bW4gdHlwZXMgdGhpcyBjb2RlIHNob3VsZCBiZSB0cmFuc3BhcmVudCBhcyB3ZSBkb250IGNhcmUgb24gdGhpc1xuICAgIGxldmVsIHdoYXQga2luZCBvZiBjb2x1bW4gd2UgYXJlIHJlbmRlcmluZy5cblxuICAgIExhdGVyIG9uIHdoZW4gd2Ugd2lsbCBzdXBwb3J0IHNpbmdsZS9tdWx0aSBzZWxlY3Rpb24sIHRoaXMgd2lsbCBiZSBqdXN0IGFub3RoZXIgY29sdW1uIGV4dGVuZGluZ1xuICAgIERUQ29sdW1uIGFuZCBwcm92aWRpbmcgaXRzIG93biB0ZW1wbGF0ZVxuXG4gICAgV2UgcGFzcyBpbnRvIHRoaXMgdGVtcGxhdGUgaWYgd2UgYXJlIHJlbmRlcmluZyBoZWFkZXIsIHN1YkhlYWRlciwgb3IgZGF0YVxuLS0+XG48bmctdGVtcGxhdGUgI2hlYWRlciBsZXQtY29sc1RvUmVuZGVyIGxldC1mcm96ZW49XCJmcm96ZW5cIj5cbiAgICA8dHI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cImNvbHNUb1JlbmRlclwiIGxldC1sYXN0Q29sPVwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICBsZXQtY29sdW1uSW5kZXg9XCJpbmRleFwiPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiB0cnVlLCBpc1N1YkhlYWRlcjpmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDooZnJvemVuID8gY29sdW1uSW5kZXg6IChjb2x1bW5zLmxlbmd0aCArIGNvbHVtbkluZGV4KSl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuXG4gICAgPHRyICpuZ0lmPVwic2hvd1N1YkhlYWRlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XCJjb2xzVG9SZW5kZXJcIiBsZXQtbGFzdENvbD1cImxhc3RcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IHRydWUsIGlzU3ViSGVhZGVyOnRydWV9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2JvZHlQbGFpbiBsZXQtY29sc1RvUmVuZGVyPlxuXG4gICAgPHRib2R5IFtuZ0NsYXNzXT1cInsnZHQtY29udGVudCBkdC1kYXRhLWNlbGxzICc6IHRydWUsICdkdC1pcy1ob3ZlcmFibGUtcm93Jzogcm93SG92ZXJ9XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXJvd0RhdGEgW25nRm9yT2ZdPVwiZGF0YVRvUmVuZGVyXCIgbGV0LWV2ZW49XCJldmVuXCIgbGV0LW9kZD1cIm9kZFwiXG4gICAgICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCIgW25nRm9yVHJhY2tCeV09XCJyb3dUcmFja0J5XCI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd1RlbXBsYXRlOyBjb250ZXh0OnskaW1wbGljaXQ6IHJvd0RhdGEsIGV2ZW46ZXZlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9kZDpvZGQsIHJvd0luZGV4OnJvd0luZGV4LCBjb2xzVG9SZW5kZXI6Y29sc1RvUmVuZGVyfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2hvd0RldGFpbENvbHVtbihyb3dEYXRhKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0RldGFpbENvbHVtbi5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IGZhbHNlLCBkYXRhOnJvd0RhdGEsIHJvd0luZGV4Oihyb3dJbmRleCl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vRGF0YVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvdGJvZHk+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjYm9keU91dGxpbmUgbGV0LWNvbHNUb1JlbmRlcj5cbiAgICA8dGJvZHkgI291dGxpbmVGb3IgYXdPdXRsaW5lRm9yIFtsaXN0XT1cImRhdGFUb1JlbmRlclwiXG4gICAgICAgICAgIFtmb3JtYXRdPVwib3V0bGluZUZvcm1hdFwiXG4gICAgICAgICAgIFtjb250ZXh0XT1cImNvbnRleHRcIlxuICAgICAgICAgICBbaW5kZW50YXRpb25QZXJMZXZlbF09XCJpbmRlbnRhdGlvblBlckxldmVsXCJcbiAgICAgICAgICAgW3B1c2hSb290U2VjdGlvbk9uTmV3TGluZV09XCJwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmVcIlxuICAgICAgICAgICBbY2hpbGRyZW5dPVwiY2hpbGRyZW5cIiBbZXhwYW5kQWxsXT1cImV4cGFuZEFsbFwiXG4gICAgICAgICAgIFtzdGF0ZV09XCJvdXRsaW5lU3RhdGVcIlxuICAgICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWNvbnRlbnQgZHQtZGF0YS1jZWxscyAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhvdmVyYWJsZS1yb3cnOiByb3dIb3Zlcn1cIlxuICAgICAgICAgICAob25FeHBhbmRDaGFuZ2UpPVwib25PdXRsaW5lRXhwYW5kQ2hhbmdlKCRldmVudClcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtcm93RGF0YSBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd1RlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IHJvd0RhdGEsIG5lc3RpbmdMZXZlbDpuZXN0aW5nTGV2ZWwsIGNvbHNUb1JlbmRlcjpjb2xzVG9SZW5kZXJ9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJzaG93RGV0YWlsQ29sdW1uKHJvd0RhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RGV0YWlsQ29sdW1uLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogZmFsc2UsIGRhdGE6cm93RGF0YSwgcm93SW5kZXg6KHJvd0luZGV4KX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9EYXRhXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS1cbiAgICBEZWZhdWx0IHRlbXBsYXRlIHRoYXQgaXMgZGlzcGxheSB3aGVuIHRoZXJlIGFyZSBubyBkYXRhXG4tLT5cbjxuZy10ZW1wbGF0ZSAjbm9EYXRhPlxuICAgIDx0ciAqbmdJZj1cImlzRW1wdHkoKVwiIGNsYXNzPVwiIGR0LWVtcHR5bWVzc2FnZS1yb3dcIlxuICAgICAgICBbc3R5bGUudmlzaWJpbGl0eV09XCJsb2FkaW5nID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcIj5cblxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJ2aXNpYmxlQ29sdW1ucygpLmxlbmd0aFwiIGNsYXNzPVwiZHQtZW1wdHltZXNzYWdlXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFlbXB0eU1lc3NhZ2VUZW1wbGF0ZVwiPnt7ZW1wdHlNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZW1wdHlNZXNzYWdlVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90ZD5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLVxuICAgIFRlbXBsYXRlIHRoYXQgcmVuZGVycyBhY3R1YWwgcm93LiBSZW5kZXJzIGJvdGggaGVhZGVyIGFuZCBib2R5IGNvbHVtbi4gRWFjaCByZW5kZXJlZFxuICAgIGNvbHVtbiBoYXMgaXRzIG93biB0ZW1wbGF0ZSBjYWxsZWQgcmVuZGVyZXJUZW1wbGF0ZSB0aGF0IGhhcyBhbGwgdGhpbmdzIHRoYXQgbmVlZHMgdG8gYmVcbiAgICByZW5kZXJlZCBhbmQgd2UganVzdCB0ZWxsIHRoZSB0ZW1wbGF0ZSBpZiB3ZSBhcmUgcmVuZGVyaW5nIGhlYWRlciwgc3ViaGVhZGVyIG9yIGJvZHlcbi0tPlxuPG5nLXRlbXBsYXRlICNyb3dUZW1wbGF0ZSBsZXQtcm93RGF0YSBsZXQtZXZlbj1cImV2ZW50XCIgbGV0LW9kZD1cIm9kZFwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCJcbiAgICAgICAgICAgICBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LWNvbHNUb1JlbmRlcj1cImNvbHNUb1JlbmRlclwiPlxuXG5cbiAgICA8dHIgI3Jvd0VsZW1lbnQgZHREcmFnZ2FibGVSb3cgW2RuZFJvd0luZGV4XT1cInJvd0luZGV4XCJcbiAgICAgICAgY2xhc3M9XCJkdC1ib2R5LXJvd1wiXG4gICAgICAgIChjbGljayk9XCJvbkhhbmRsZVJvd0NsaWNrZWQoJGV2ZW50LCByb3dEYXRhKVwiXG4gICAgICAgIFthdHRyLm5lc3RpbmdMZXZlbF09XCJuZXN0aW5nTGV2ZWxcIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWV2ZW4tcm93JzogZXZlbiwgJ2R0LW9kZC1yb3cnOiBvZGQsXG4gICAgICAgICAgICAnZHQtcm93LXNlbGVjdGVkJzogaXNSb3dTZWxlY3RlZChyb3dEYXRhKSxcbiAgICAgICAgICAgICdkdC1yb3ctZHJhZ2dhYmxlJzogZG5kUm93RW5hYmxlZCxcbiAgICAgICAgICAgICdkdC1yb290LXNlY3Rpb24nOiBuZXN0aW5nTGV2ZWwgPT09IDAgfVwiPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cImNvbHNUb1JlbmRlclwiIGxldC1jb2xJbmRleD1cImluZGV4XCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogZmFsc2UsIGRhdGE6cm93RGF0YSwgcm93SW5kZXg6cm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5lc3RpbmdMZXZlbDpuZXN0aW5nTGV2ZWx9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG5gLFxuICAgIHN0eWxlczogW2Audy1kYXRhdGFibGV7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9LnctZGF0YXRhYmxlIHRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTt3aWR0aDoxMDAlO3RhYmxlLWxheW91dDpmaXhlZH0udy1kYXRhdGFibGUgdGJvZHksLnctZGF0YXRhYmxlIHRkLC53LWRhdGF0YWJsZSB0aHtvdXRsaW5lOjB9LmR0LWNlbGwtZGVmLC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7cGFkZGluZzoxN3B4IDE2cHg7Ym94LXNpemluZzpib3JkZXItYm94fS5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2N1cnNvcjpwb2ludGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9dGggLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Ym9yZGVyLXdpZHRoOjRweCAxcHggMXB4O3BhZGRpbmc6MTRweCAxNnB4IDE3cHh9dGQgLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Ym9yZGVyLXdpZHRoOjAgMXB4IDAgNXB4O3BhZGRpbmc6MTdweCAxNnB4IDE3cHggMTNweH0uZHQtZGF0YS1jZWxscyB0ci5kdC1pcy1oaWdobGlnaHQsLmR0LWRhdGEtY2VsbHMgdHIuZHQtaXMtaG92ZXJ7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcn0udy1kYXRhdGFibGUtcnRse2RpcmVjdGlvbjpydGx9LnctZGF0YXRhYmxlLXJ0bC53LWRhdGF0YWJsZS1ydGwudy1kYXRhdGFibGUgdGhlYWQgdGh7dGV4dC1hbGlnbjpyaWdodH0uZHQtcm9vdC1zZWN0aW9uIC5kdC1jZWxsLWRlZiwuZHQtcm9vdC1zZWN0aW9uIC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JhY2tncm91bmQtY29sb3I6I2YzZjZmODtwYWRkaW5nOjEwcHggMTZweDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH0uZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1hY3RpdmUsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtZGVmYXVsdCwuZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1oaWdobGlnaHQsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtaG92ZXIsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtaG92ZXJhYmxlLXJvd3tib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LWlzLWFjdGl2ZSwuZHQtaXMtZGVmYXVsdCwuZHQtaXMtaGlnaGxpZ2h0LC5kdC1pcy1ob3ZlciwuZHQtaXMtaG92ZXJhYmxlLXJvd3tib3JkZXI6MXB4IHNvbGlkICNkN2Q3ZDc7YmFja2dyb3VuZC1jb2xvcjojZmZmO2NvbG9yOiMzNjM2MzZ9LmR0LXJvdy1zZWxlY3RlZCB0ZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjM4LDI1NSwyMzgsLjcxKX0uZHQtaXMtYWN0aXZle2JvcmRlci1jb2xvcjojMDY1ZDljO2NvbG9yOiMxOTlkZTB9LmR0LWlzLWhpZ2hsaWdodHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNjUsMTE3LDUsLjE4KX0uZHQtaXMtaGlkZGVue2Rpc3BsYXk6bm9uZX0uZHQtdS11bnNlbGVjdGFibGUtdGV4dHstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1vLXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZHQtdS1zb3J0YWJsZXtjdXJzb3I6cG9pbnRlcn1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgT2JqZWN0VXRpbHMsXG4gICAgICAgIE91dGxpbmVTdGF0ZSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogRFQyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX0sXG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG5cbn0pXG5leHBvcnQgY2xhc3MgRGF0YXRhYmxlMkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBV0RhdGFUYWJsZSwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiAgTGlzdCBvZiBpdGVtcyB0byBzaG93IGluIHRoZSBkYXRhdGFibGUuXG4gICAgICpcbiAgICAgKiAgdG9kbzogaW1wbGVtZW50IHRoZSBzYW1lIERhdGFzb3VyY2UgYW5kIGxhenkgbG9hZGluZyBqdXN0IGxpa2UgSSBkaWQgaXQgZm9yIGRhdGF0YWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBlbnRpdHkgZm9yIHdoaWNoIERhdGFQcm92aWRlciB3aWxsIGJlIGxvYWRlZC4gWW91IGNhbiBlaXRoZXIgcGFzcyBsaXN0IG9mIGl0ZW1zXG4gICAgICogb3IgdXNlIHRoaXMgZGVzdGluYXRpb25DbGFzcy4gTm90IGJvdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBUYWJsZVdyYXBwZXIgdG8gYWRkIHVzZXIgZGVmaW5lZCBjbGFzIGludG8gdGhlIHRhYmxlIHRhZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YWJsZVN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Jvd1NlbGVjdGFibGU6IChpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqICBIaWRlcyBvciBzaG93cyB0YWJsZSBoZWFkaW5nIHdoZXJlIHdlIGhhdmUgZmlsdGVycyBhbmQgdG9vbHMgbWVudXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUYWJsZUhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwaXZvdGFsTGF5b3V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dDogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbml0aWFsU29ydE9yZGVyOiBzdHJpbmcgPSAnZGVzY2VuZGluZyc7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluaXRpYWxTb3J0S2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gRFQgaXMgbG9hZGVkIGluIHRoZSBwYWdlIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmdWxsIHNjcmVlbiAoZnVsbCBwYWdlIG1vZGUpLCB0aGlzXG4gICAgICogaXMgaHRlIG51bWJlciBvZiBsaW5lcyB0aGF0IERUIHdpbGwgc2hvd1xuICAgICAqXG4gICAgICogdG9kbzogY29tZSB1cCB3aXRoIGJldHRlciBuYW1lXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5Um93U2l6ZTogbnVtYmVyID0gMTA7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHBhZ2luZyBvbiBsYXp5IGxvYWRpbmcgdXNpbmcgaW5maW5pdGUgc2Nyb2xsZXIgdG8gc2V0IGluaXRpYWwgZmV0Y2ggbGltaXQgc2l6ZVxuICAgICAqXG4gICAgICogdG9kbzogY29tZSB1cCB3aXRoIGJldHRlciBuYW1lICEhIVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYWdlU2l6ZTogbnVtYmVyID0gMTU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGF0YVNvdXJjZTogRFQyRGF0YVNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgbWVzc2FnZSB3aGVuIHRoZXJlIGFyZSBubyBkYXRhIC5cbiAgICAgKlxuICAgICAqIHRvZG86IFVzZSBpMThuIHZhbHVlIGFuZCBjcmVhdGUgcmVzb3VyY2UgZmlsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1wdHlNZXNzYWdlOiBzdHJpbmcgPSAnTm8gcmVjb3JkcyBmb3VuZCc7XG5cblxuICAgIC8qKlxuICAgICAqIERldmVsb3BlciBjYW4gcHJvdmlkZSBjdXN0b20gdHJhY2tCeSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBpdGVyYXRlIG92ZXIgdGhlXG4gICAgICogcmVjb3Jkc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93VHJhY2tCeTogKGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSkgPT4gYW55O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIGFkZHMgY3VzdG9tIGhvdmVyaW5nIGNsYXNzIHRvIHRoZSB0Ym9keVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93SG92ZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBzaG93IGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICpcbiAgICAgKiBUb2RvOiByZW5hbWUgdG8gc2hvd0xvYWRpbmdcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxvYWRpbmc6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdGlvbk1vZGUgPSAnbm9uZSc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbiBwcm92aWRlIGN1c3RvbSBpY29uLiBUaGVzZSBpY29ucyBhcmUgbm90IGFuaW1hdGVkIGRpdnMsIHdlIHVzZWQgY3NzXG4gICAgICogdHJhbnNmb3JtYXRpb24gdG8gcm90YXRlIHRoZW0uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxvYWRpbmdJY29uOiBzdHJpbmcgPSAnaWNvbi1zeW5jaHJvbml6ZSc7XG5cblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgaW5kZW50IGNhbiBiZSBhZGRlZCB3aGVuIHJlbmRlcmluZyBkZXRhaWwgcm93XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnREZXRhaWxSb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXIgPSAyNTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIFN1YkhlYWRlciBpcyB1c2VkIHRvIHNob3cgc3VtbWFyeSBjb2x1bW5zLCB3aGljaCBpbiBvdXIgVVggaXMgc2hvd24gYXQgdGhlIHRvcCBqdXN0IHVuZGVyXG4gICAgICogIHRoZSByZWd1bGFyIHRhYmxlIGhlYWRlclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgT3V0bGluZUZvciAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICpcbiAgICAgKiBOb3QgdXNlZCB3aGVuIFtvdXRsaW5lRm9ybWF0XT1cIid0cnVlZSdcIlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogV2UgbWlnaHQgaGF2ZSB0aGlzIGNvbmRpdGlvbmFsIGFzIHRoaXMgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdmFsdWUsIHNvIHRoZSBzYW1lXG4gICAgICogYXMgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dFeHBhbnNpb25Db250cm9sOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQWxsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIE91dGxpbmVGb3IgIC0gZm9ybWF0IC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG91dGxpbmVGb3JtYXQ6IE1vZGVsRm9ybWF0ID0gJ2ZyZWUnO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgb3IgaGlkZSBleHBhbnNpb24gY29udHJvbCBmb3Igcm93IGRldGFpbCBjb2x1bW5zLiBFeHBhbnNpb24gY29udHJvbCBtYWtlcyBzZW5zZSBmb3JcbiAgICAgKiBzaW1wbGUgdGFibGUsIHdoZW4gdXNpbmcgdGhpcyBpbnNpZGUgb3V0bGluZSAodHJlZSB0YWJsZSksIGl0cyBkcml2ZW4gYnkgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93RGV0YWlsRXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U2VsZWN0QWxsOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIGdsb2JhbCBzZWFyY2ggdGVybSBpbnB1dCBmaWVsZCBpbiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93R2xvYmFsU2VhcmNoOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBmcm96ZW4gY29sdW1uIGFyZSB1c2luZyB3ZSBjYW4gc3BlY2lmeSBvbiBnbG9iYWwgbGV2ZWwgdG90YWwgd2lkdGggb2YgdGhlIHRhYmxlIHRoZVxuICAgICAqIG92ZXJmbG93aW5nIGNvbnRlbnQgb3Igd2lkdGggZm9yIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2Nyb2xsV2lkdGg6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyByb3cgcmVvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGV2ZW50IHRoYXQgc29ydGluZyBpcyBlbmFibGVkIGZvciBjb2x1bW4gYW5kIHdlIHRyaWdnZXIgc29ydGluZ1xuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Tb3J0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gc2VsZWN0aW9uIG1vZGUgaXQgdHJpZ2dlcnMgZXZlblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Sb3dDbGljazogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbXVsdGkgb3Igc2luZ2xlIHNlbGVjdGlvbiBtb2RlIGlzIGVuYWJsZWQgaXQgd2lsbCB0cmlnZ2VyIGV2ZW50IHdoZW4gY2hlY2tib3ggb3JcbiAgICAgKiByYWRpbyBidXR0b25zIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbXBsZW1lbnQgU2luZ2xlU2VsZWN0aW9uRFRDb2x1bW4sIE11bHRpU2VsZWN0aW9uRFRDb2x1bW4gd2l0aCB0aGVpciByZW5kZXJlcnNcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2VsbCBib2R5IHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2VsbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNlbGwgaGVhZGVyIHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSGVhZGVyU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgQENvbnRlbnRDaGlsZChEVEhlYWRlckNvbXBvbmVudDIpXG4gICAgaGVhZGVyOiBEVEhlYWRlckNvbXBvbmVudDI7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIHRlbXBsYXRlIHRoYXQgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHNob3cgd2hlbiB0aGVyZSBhcmVcbiAgICAgKiBubyBkYXRhIGluIHRoZSBkYXRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbm9EYXRhVGVtcGwnKVxuICAgIGVtcHR5TWVzc2FnZVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEhlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdFN1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEJvZHknKVxuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyRmlsdGVyJylcbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgdXNlZCBEVENvbHVtbiBpbnNpZGUgZGF0YXRhYmxlIGFuZCB0aGVuIHRoZXkgYXJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZSB0b1xuICAgICAqIGl0ZXJhdGUgb3ZlciBhbmQgdXNlIGl0cyByZW5kZXJlclRlbXBsYXRlLlxuICAgICAqXG4gICAgICogV2hlbiB3ZSB3aWxsIGJlIGRlZmluaW5nIG5ldyBjb2x1bW5zIGl0cyBpbXBvcnRhbnQgdGhhdCBpdCBjYW4gYWxzbyBtYXRjaCBhbGwgdGhlXG4gICAgICogaW5oZXJpdGVkIG9uZXMuIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGRlZmluZSBhIHByb3ZpZGVyIHRob3NlIHRob3NlIGNvbHVtbnMgdG8gcG9pbnRcbiAgICAgKiB0byB0aGUgRFRDb2x1bW5Db21wb25lbnRcbiAgICAgKlxuICAgICAqIGUuZy46XG4gICAgICpcbiAgICAgKiB7cHJvdmlkZTogRFRDb2x1bW5Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERldGFpbFJvd0NvbHVtbil9XG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKERUQ29sdW1uMkNvbXBvbmVudClcbiAgICBjb2xzUXVlcnk6IFF1ZXJ5TGlzdDxEVENvbHVtbjJDb21wb25lbnQ+O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERURGV0YWlsUm93Q29tcG9uZW50KVxuICAgIHJvd0RldGFpbENvbHVtbjogRFREZXRhaWxSb3dDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgd2hlbiBpdGVtcyBpbiB0aGUgbGlzdCBhcmUgdXBkYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgICBjbGFzc0xpc3Q6IHN0cmluZyA9ICd3LWRhdGF0YWJsZSAnO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3IgaW50ZXJuYWwgdXNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRhdGFzZXQgdGhhdCBpcyBiZWluZyByZW5kZXJlZC4gU2V0IGZyb20gdGhlIFtsaXN0XSBiaW5kaW5nIG9yIGJ5IGxhenkgbG9hZCBmcm9tXG4gICAgICogZGF0YXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBkYXRhVG9SZW5kZXI6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2UgY29udmVydCBRdWVyeUxpc3Q8RFRDb2x1bW4yQ29tcG9uZW50PiB0byB0aGlzIGFycmF5IGZvciBlYXNpZXIgbWFuaXB1bGF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbnM6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNlY29uZGFyeSBsaXN0IG9mIGNvbHVtbnMgd2hpY2ggaXMgdXNlZCBpbiBjYXNlIHdlIGhhdmUgaGF2ZSBlbmFibGVkXG4gICAgICogZnJvemVuIGNvbHVtbnMuIENvbHVtbnMgdGhhdCBhcmUgbWFya2VkIGFzIGZyb3plbiBuZWVkcyB0byBiZSBwbGFjZWQgaW50byBzZXBhcmF0ZSBhcnJheVxuICAgICAqIHRvIGJlIHJlbmRlcmVkIHdheSB0aGFuIHJlZ3VsYXIgY29sdW1ucyB3aGljaCBhcmUgc3RvcmVkIGluIHRoZSBjb2x1bW5zIGFycmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBmcm96ZW5Db2x1bW5zOiBEVENvbHVtbjJDb21wb25lbnRbXTtcblxuXG4gICAgLyoqXG4gICAgICogIEluZGljYXRlcyB0aGF0IGNvbHVtbnMgd2VyZSBpbml0aWFsZWQgQWxzbyB1c2VkIHdoZW4gd2UgaGlkZSBhbmQgc2hvdyBjb2x1bW4gdG8gdHJpZ2dlclxuICAgICAqICBjaGFuZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uc0NoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgcHVibGljIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGNvbHNRdWVyeSBhbmQgaXRzIGNoYW5nZXMgc28gd2UgY2FuIGxhdGVyIG9uIHJlbGVhc2UgdGhlIHN1YnNjcmlwdGlvblxuICAgICAqL1xuICAgIGNvbHVtbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5zaW9uU3RhdGU6IERldGFpbFJvd0V4cGFuc2lvblN0YXRlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBudW1iZXJPZkNvbHNCZWZvcmVEYXRhOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBzdGFydE9mRmlyc3REYXRhQ29sdW1uOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWN0aW9uIGZvciBwcm9ncmFtbWF0aWNhbGx5IGluc3RhbnRpYXRlZCBjb2x1bW5zIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBsaXN0IGlmIGFkZGl0aW9uYWxcbiAgICAgKiBzcGFuIG9yIGxvZ2ljIGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGEgbmV3IGNvbHVtbiBpbnRvIGNvbHVtbnMgYXJyYXkgbGlrZSBleHBhbmRvIGNvbHVtbiBmb3IgZGV0YWlsXG4gICAgICogcm93LCBvciBTaW5nbGVTZWxlY3QsIE11bHRpU2VsZWN0IGNvbHVtbiB3aGVuIHNlbGVjdGlvbiBpcyBlbmFibGVkIHdlIG5lZWQgdG8gdXNlXG4gICAgICogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGluc3RhbnRpYXRlIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgcm93RGV0YWlsRXhwYW5kQ29sdW1uOiBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50O1xuICAgIHByaXZhdGUgbXVsdGlTZWxlY3RDb2x1bW46IERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQ7XG4gICAgcHJpdmF0ZSBzaW5nbGVTZWxlY3RDb2x1bW46IERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEluIGNhc2Ugb2Ygb3V0bGluZSB0YWJsZSB3ZSBhcmUgaW5qZWN0IE91dGxpbmVTdGF0ZSB3aGljaCBpcyBwcm92aWRlZCBpbiB0aGUgRFQgY29tcG9uZW50XG4gICAgICogZGVmaW5pdGlvbi4gVGhpcyBpcyB1c2VkIGJ5IG5lc3RlZCBvdXRsaW5lRm9yIGNvbXBvbmVudCBpdCBzZXQgaXRzZWxmIGFzIHJlZmVyZW5jZSBhbmRcbiAgICAgKiBpbml0aWFsaXplIHRoZSBzdGF0ZSBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlciBvbiBpbnNpZGUgT3V0bGluZUNvbnRyb2xcbiAgICAgKlxuICAgICAqXG4gICAgICogRWFjaCBEYXRhdGFibGUgaXMgcHJlLWRlZmF1bHRlZCB3aXRoIGl0cyBvd24gdmVyc2lvbiBvZiBEYXRhU291cmNlIHNvIGFsbCB0aGUgb2JzZXJ2ZXJzXG4gICAgICogaW5zaWRlIGFyZSB1bmlxdWUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHByaXZhdGUgX2RlZmF1bHREUzogRFQyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGUsXG4gICAgICAgICAgICAgICAgcHVibGljIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fZGVmYXVsdERTO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIHN0YXRlIG91dCB0byBhcHBsaWNhdGlvbi4gQ2FuIGJlIHVzZSBhcyB0d28gd2F5IGJpbmRpbmdzXG4gICAgICpcbiAgICAgKiBbKHN0YXRlKV09ZHRTdGF0ZShzKVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RhdGUoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnN0YXRlO1xuICAgIH1cblxuICAgIHNldCBzdGF0ZSh2YWw6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZSA9IHZhbDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGJpbmRpbmdzIFtsaXN0XSBhbmQgW2Rlc3RpbmF0aW9uQ2xhc3NdIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUgPSBuZXcgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGUodGhpcyk7XG5cbiAgICAgICAgLy8gaW5pdCBkZWZhdWx0IGNvbHVtbnNcbiAgICAgICAgdGhpcy5yb3dEZXRhaWxFeHBhbmRDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuXG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdENvbHVtbiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGRhdGEgYXJlIG5vdCBkZWZlcnJlZCBhbmQgd2UgZ2V0IGxpc3QgZGlyZWN0bHkgdGhlbiBpdCBjcmVhdGVzIERTLiBJZlxuICAgICAgICAgKiBuZ09uQ2hhbmdlcyBpcyBjYWxsZWQgZmlyc3Qgd2UgcHJvcGVybHkgaW5pdCBEUyBhbmQgY2xlYW4gdGhpcy5saXN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgfHwgaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW5jZSB3ZSB3b3JrIHdpdGggcmVmZXJlbmNlcyBsZXQncyBwYXNzIGNyZWF0ZWQgbWFwIGluc2lkZSBvdXIgc3RhdGVcbiAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUuZXhwYW5zaW9uU3RhdGVzID0gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkYXRhIGFycml2ZXMgbGF0ZXIgbWF5YmUgZHVlIHRvIFJFU1QgQVBJIGxhdGVuY3ksIGluaXRpYWxpemUgRFMgb25seSB3aGVuIHdlIGhhdmUgYVxuICAgICAqIGRhdGEsIG90aGVyd2lzZSBpZiBkYXRhIGNoYW5nZWQgdGhydSB0aGUgYmluZGluZ3MganVzdCB0cmlnZ2VyIGRhdGFDaGFuZ2UgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoY2hhbmdlc1snbGlzdCddICYmIGlzUHJlc2VudChjaGFuZ2VzWydsaXN0J10uY3VycmVudFZhbHVlKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZClcbiAgICAgICAge1xuXG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dCh0aGlzLmxpc3QpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKVxuICAgIHtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaW5pdCBhIHN0YXRlIHdoZW4gZGV0YWlsIGNvbHVtbiBpcyBwcmVzZW50XG4gICAgICAgIC8vIHRvZG86IG1vdmUgdGhpcyBpbml0aWFsaXphdGlvbiB0byBkYXRhc291cmNlXG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCA9IGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbik7XG5cbiAgICAgICAgdGhpcy5pbml0Q29sdW1ucygpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24gPSB0aGlzLmNvbHNRdWVyeS5jaGFuZ2VzLnN1YnNjcmliZShfID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpXG4gICAge1xuICAgICAgICAvLyBhc3NpZ24gaXQgcHJvZ3JhbWF0aWNhbGx5IGFzIHdlIHdhbnQgdG8gaGF2ZSBhIGNvbnRleHQgZm9yIHRoZSBmaWx0ZXJcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiYgaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmZpbHRlck91dCA9IHRoaXMuc2tpcE91dGxpbmVJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmNoYW5nZURldGVjdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvci5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc0NoYW5nZWQgJiYgdGhpcy5lbC5uYXRpdmVFbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXkgZW50cnkgbWV0aG9kIHRoYXQgaW5pdGlhbGl6ZWQgb3VyIGNvbHVtbnMuIExhdGVyIG9uIHdoZW4gd2Ugd2lsbCBzdXBwb3J0IHNlbGVjdGlvbiBhbmRcbiAgICAgKiBtdWx0aXNlbGVjdGlvbiB3ZSB3aWxsIHByb2dyYW1tYXRpY2FsbHkgaW5zdGFudGlhdGUgU2luZ2xlU2VsZWN0aW9uLCBNdWx0aVNlbGVjdGlvbiBjb2x1bW5cbiAgICAgKiBjb21wb25lbnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCBzbyB0aGV5IGNhbiBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIHNvIHRoZSBpZGVhIGhlcmUgaXM6XG4gICAgICpcbiAgICAgKiBXaGVuIERUIGNvbXBvbmVudCBpbml0aWFsaXplIGFuZCB3ZSBhcmUgaW4gZWRpdGluZyBtb2RlIGFuZCB3ZSBzdXBwb3J0IFNpbmdsZS9NdWx0aSBzZWxlY3Rpb25cbiAgICAgKiB3ZSB3aWxsIHVzZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gY3JlYXRlIGNvbXBvbmVudCBhbmQgYWRkIGl0IGFzIGZpcnN0IGl0ZW0gdG8gdGhlIGxpc3RcbiAgICAgKiBhbmQgdGhlbiBpdCB3aWxsIGJlIHJlbmRlcmVkIGp1c3QgbGlrZSBhbnl0aGlnbiBlbHNlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdENvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERldGFpbENvbHVtbkV4cGFuc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb2x1bW4uaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRoaXMubXVsdGlTZWxlY3RDb2x1bW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0Q29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnNpbmdsZVNlbGVjdENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGV4cGFuc2lvbiBjb2x1bW4gd2hlbiBkZXRhaWwgcm93IGlzIGVuYWJsZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgJiYgIXRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnJvd0RldGFpbEV4cGFuZENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbHNRdWVyeVxuICAgICAgICAgICAgLmZpbHRlcigoY29sMTogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiAhY29sMS5mcm96ZW4pXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdEZyb3plbkNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5pbml0Q29sdW1uSW5mbygpO1xuICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjdXJyZW50IGNvbHVtbiBpcyBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW50ZXJuYWxDb2x1bW4oY29sOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gY29sIGluc3RhbmNlb2YgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IERhdGFzb3VyY2UgYmFzZWQgb24gcGFzc2VkIHZhbHVlcy4gSXQgdHJpZXMgdG8gaW5pdGlhbGl6ZSBEUyBmb3IgZmlyc3QgdGltZVxuICAgICAqIGluc2lkZSB0aGUgbmdJbml0IGJ1dCBpbiBjYXNlIERhdGEgYXJyaXZlcyBsYXRlciBtYXliZSBkdWUgdG8gc29tZSBSRVNUIEFQSSBjYWxscyB0aGlzXG4gICAgICogY2FuIGJlIHRyaWdnZXJlZCBhbHNvIGZyb20gbmdPbkNoYW5nZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RGF0YXNvdXJjZShpbml0aWFsaXplOiBib29sZWFuID0gdHJ1ZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgwLCB0aGlzLnBhZ2VTaXplLCB0aGlzLmRpc3BsYXlSb3dTaXplLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFNvcnRLZXksIHRoaXMuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuaW5pdGlhbFNvcnRPcmRlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW1pdCA9IHRoaXMuc3RhdGUuZGlzcGxheUxpbWl0ID0gdGhpcy5kaXNwbGF5Um93U2l6ZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbml0aWFsU29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSB0aGlzLmluaXRpYWxTb3J0S2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gdGhpcy5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5pbml0aWFsU29ydE9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsaXplKSB7XG5cbiAgICAgICAgICAgIGxldCBxVHlwZSA9ICh0aGlzLmlzT3V0bGluZSgpICYmIHRoaXMub3V0bGluZUZvcm1hdCA9PT0gJ3RyZWUnKSA/XG4gICAgICAgICAgICAgICAgUXVlcnlUeXBlLkZ1bGxUZXh0T3V0bGluZSA6IFF1ZXJ5VHlwZS5GdWxsVGV4dDtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICAgICAgICAgICAgICAgIG9iajogaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgPyB0aGlzLmRlc3RpbmF0aW9uQ2xhc3MgOiB0aGlzLmxpc3QsXG4gICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBxVHlwZSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLnN0YXRlKTtcblxuICAgICAgICAvLyByZXNldCBsaXN0IHRvIG1ha2Ugc3VyZSBpdCBjb21lcyBmcm9tIERhdGFQcm92aWRlciwgd2UgdXNlIGxpc3QgIHRvIGluaXRpYWxpemVcbiAgICAgICAgdGhpcy5saXN0ID0gbnVsbDtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBFTlRSWSBwb2ludCBmb3IgdGhlIERBVEEgQ0hBTkdFUy4gQWxsIGFkZGl0aW9uLCBlZGl0cywgZGVsZXRpb24gZW5kcyB1cFxuICAgICAgICAvLyBoZXJlLiBXZSBkb250IHdvcmsgZGlyZWN0bHkgd2l0aCBMSVNULiBBbnkgY2hhbmdlIGlzIHJlYWN0aXZlIGFuZCBoZXJlIGlzIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5vcGVuKCkuc3Vic2NyaWJlKChkYXRhOiBhbnlbXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRldGFpbFJvdyBjb2x1bW4gaXMgcHJlc2VudCB3ZSBpbml0aWFsaXplIGEgc3RhdGUgaG9sZGluZyBpbmZvcm1hdGlvbiB3aGljaCBpdGVtIGlzXG4gICAgICogZXhwYW5kZWQuXG4gICAgICpcbiAgICAgKiB0b2RvOiBUaGlzIGlzIHRlbXBvcmFyeSBoZXJlIGFuZCBvbmNlIHdlIHN1cG9ydCBsYXp5IGxvYWRpbmcgbW92ZSB0aGlzIHRvIGRhdGFzb3VyY2UuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSBmb3Igb3V0bGluZSB0cmVlIHRhYmxlIHdlIG5lZWQgdG8gY29ubmVjdCBhIHN0YXRlIGZyb20gb3V0bGluZSB3aXRoIGEgc3RhdGUgaW5cbiAgICAgKiBoZXJlIGFzIHdlIGFyZSB1c2luZyBvdXRsaW5lIGNvbnRyb2wgdG8gZXhwYW5kIGFuZCBjb2xsYXBzZSBpdGVtc1xuICAgICAqL1xuICAgIGluaXREZXRhaWxDb2x1bW5FeHBhbnNpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikpIHtcbiAgICAgICAgICAgIHRoaXMucm93RGV0YWlsQ29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkID0gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJlxuICAgICAgICAgICAgQm9vbGVhbldyYXBwZXIuaXNUcnVlKHRoaXMuc2hvd1Jvd0RldGFpbEV4cGFuc2lvbkNvbnRyb2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGV4ZWN1dGVkIGFmdGVyIHdlIGluaXRpYWxpemUgYWxsIHRoZSBjb2x1bW5zIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBjb3JyZWN0XG4gICAgICogbnVtYmVycyB1c2VkIGZvciBpbmRlbnRhdGlvbiB3aGlsZSByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbHVtbnMgYXMgd2VsbCBhcyBkZXRhaWwgcm93IGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBIZXJlIHdlIG5lZWQgdG8gYmUgYXdhcmUgaG93IG1hbnkgY29sdW1ucyB0byBzcGFuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0Q29sdW1uSW5mbygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGEgPSAwO1xuXG4gICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjb2wuaXNWYWx1ZUNvbHVtbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmluZGVudERldGFpbFJvdykge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0T2ZGaXJzdERhdGFDb2x1bW4gPSB0aGlzLmNvbHVtbnMubGVuZ3RoIC0gdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdjZWxsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb29rdXBLZXkgPSB7XG4gICAgICAgICAgICBjb2w6IGNvbHVtbi5rZXkgfHwgY29sdW1uLmxhYmVsLFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5KTtcbiAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkID0gZm91bmRJbmRleCAhPT0gLTE7XG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW2xvb2t1cEtleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNlbGxDaGFuZ2UuZW1pdCh0aGlzLnN0YXRlLnNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhlYWRlclNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGVyU2VsZWN0ZWQoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBjb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uSGVhZGVyU2VsZWN0aW9uLmVtaXQodGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIG9uSGFuZGxlUm93Q2xpY2tlZChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBzcGVjaWFsIGFsdCBrZXkgbW9kaWZpZXIuIFdoZW4gdXNlZCB3aXRoIHJvd3MgaXQgaW5kaWNhdGVzIHRoZXJlIGlzIGEgRCZEIGVuYWJsZWRcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgdGhpcy5vblJvd1RvZ2dsZShldmVudCwgaXRlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLm9uUm93U2VsZWN0KGV2ZW50LCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dUb2dnbGUoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHJvd1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiYgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKTtcbiAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkID0gZm91bmRJbmRleCAhPT0gLTE7XG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb3IgdGhlIG91dGxpbmUgZ28gdXAgYW5kIGRvd24gdGhlIHN5bmMgd2l0aCB0cmVlaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMub0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW2l0ZW1dO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc091dGxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Sb3dTZWxlY3Rpb25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBpc1NlbGVjdGVkOiByb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIGl0ZW06IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dTZWxlY3QoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBpdGVtO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLm9uUm93U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY2hpbGRyZW5Gb3JOb2RlID0gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtjdXJyZW50SXRlbV0pIHx8IFtdO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbkZvck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgaXMgc2VsZWN0ZWQgY3VycmVudGx5IHRoZW4gdG9nZ2xlIHRvIG90aGVyIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNoZWNraW5nIGFsbCBmcm9tIHJvb3QsIGRlc2VsZWN0IGNoaWxkcmVuIGFuZCBhZGQgYWxsXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgLi4uY2hpbGRyZW5Gb3JOb2RlXTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWFjaCBjaGlsZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBmb3VuZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBzYW1lIGZvciBjaGlsZHJlbiBvZiBjaGlsZHJlblxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGNoaWxkLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5Gb3JOb2RlID0gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtwYXJlbnRdKSB8fCBbXTtcblxuICAgICAgICAgICAgbGV0IGFsbFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdGVkID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgY2hpbGQpICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiBhbGxTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50SW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBwYXJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG5EUm93RHJvcChvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdEcm9wcGluZyByb3cgIzogJywgb3JpZ1BvcyArICcgJyArIGRyb3BQb3MgKyAnIHJvdyAjOiAnICsgbmV3UG9zKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yZW9yZGVyUm93cyhvcmlnUG9zLCBuZXdQb3MsIGRyb3BQb3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk91dGxpbmVFeHBhbmRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpdGVtID0gZXZlbnQuaXRlbTtcblxuICAgICAgICAvLyBXZSBkb250IHJlYWxseSBuZWVkIHRvIHN0b3JlIGEgc3RhdGUgZm9ybSBvdXRsaW5lIGxvY2FsbHkgYXMgd2UgYXJlIHVzaW5nIHRoZSBzYW1lIG9iamVjdFxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgLy8gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGUgPSB0aGlzLm91dGxpbmVTdGF0ZS5leHBhbnNpb25TdGF0ZXM7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0U2luZ2xlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5zb3J0Q29sdW1uKSkge1xuXG4gICAgICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuc29ydENvbHVtbi5rZXkpLCAnSW52YWxpZCBjb2x1bW4gdG8gc29ydCcpO1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnQodGhpcy5zb3J0Q29sdW1uLmtleSwgdGhpcy5zb3J0Q29sdW1uLnNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIHRoaXMub25Tb3J0LmVtaXQoe1xuICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLnNvcnRDb2x1bW4ua2V5LFxuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLnNvcnRDb2x1bW4uc29ydE9yZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5nZSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zb3J0S2V5IHx8IHRoaXMuc29ydENvbHVtbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNvcnRDb2x1bW4gJiYgdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Q29sdW1uID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9PiBjb2wua2V5ID09PSB0aGlzLnN0YXRlLnNvcnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMubGlzdCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRGF0YVRvUmVuZGVyKGRhdGFzb3VyY2U/OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IGRhdGFzb3VyY2UgfHwgdGhpcy5saXN0O1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY2hpbGRyZW4pICYmIGlzUHJlc2VudCh0aGlzLmRhdGFUb1JlbmRlcilcbiAgICAgICAgICAgICYmIHRoaXMuZGF0YVRvUmVuZGVyLmxlbmd0aCA+IDAgJiYgaXNPdXRsaW5lTm9kZSh0aGlzLmRhdGFUb1JlbmRlclswXSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvcm1hdCA9ICd0cmVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIHJlc2V0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc29ydENvbHVtbiA9IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgaXNIZWFkZXJTZWxlY3RlZChpdGVtOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2xNYXRjaGVkID0gaXRlbS5rZXkgfHwgaXRlbS5sYWJlbDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2wgPSB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbi5rZXkgfHwgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24ubGFiZWw7XG4gICAgICAgIHJldHVybiBjb2xNYXRjaGVkID09PSBjdXJyZW50Q29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JvZHlDZWxsU2VsZWN0ZWQoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBsb29rdXBLZXkgPSB7XG4gICAgICAgICAgICBjb2w6IGNvbHVtbi5rZXkgfHwgY29sdW1uLmxhYmVsLFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pICE9PSAtMTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBkYXRhIHRvIHJlbmRlciBVc2VkIGluc2lkZSB0ZW1wbGF0ZSB0byB0ZWxsIGlmIHdlIHNob3VsZCB1c2UgdGhlIE5vRGF0YSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNFbXB0eSgpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNCbGFuayh0aGlzLmRhdGFUb1JlbmRlcikgfHwgKHRoaXMuZGF0YVRvUmVuZGVyLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuXG4gICAgaGFzRnJvemVuQ29sdW1ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZnJvemVuQ29sdW1ucykgJiYgdGhpcy5mcm96ZW5Db2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiAhdGhpcy5zaG93U2VsZWN0aW9uQ29sdW1uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdub25lJyAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICdjZWxsJztcbiAgICB9XG5cbiAgICB2aXNpYmxlQ29sdW1ucygpOiBEVENvbHVtbjJDb21wb25lbnRbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucyA/IHRoaXMuY29sdW1ucy5maWx0ZXIoYyA9PiBjLmlzVmlzaWJsZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRPcmRlcmluZ0ZvclN0cmluZyhkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAnZGVzY2VuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBsb2cgYmFkIGtleVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBzb3J0T3JkZXJpbmdGb3JOdW1iZXIoZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogbG9nIGJhZCBrZXlcbiAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlQWxsQ29sdW1ucyhldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtcyA9IHRoaXMuZGF0YVRvUmVuZGVyIHx8IFtdO1xuICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0Lmxlbmd0aCA+PSBjdXJyZW50SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLmN1cnJlbnRJdGVtc107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50SXRlbXMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZE9iamVjdC5sZW5ndGggPj0gY3VycmVudEl0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpc1RvZ2dsZUFsbENvbHVtbkRpc2FibGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcblxuICAgICAgICByZXR1cm4gY3VycmVudEl0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgYnkgdGVtcGxhdGUgdG8gZGVjaWRlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIERldGFpbFJvdyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byBoYXZlXG4gICAgICogRGV0YWlsUm93IENvbnRlbnRDaGlsZCBhbmQgdXNpbmcgRGV0YWlsUm93IGNvbXBvbmVudCBbaXNWaXNpYmxlRm5dIGZ1bmN0aW9uIGJpbmRpbmcgd2VcbiAgICAgKiBjaGVjayBpZiB0aGUgaXRlbSB0aGF0IGlzIGFib3V0IHRvIGJlIHJlbmRlcmVkIGlzIGVsaWdpYmxlIGZvciBkZXRhaWwgcm93XG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93RGV0YWlsQ29sdW1uKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKSAmJiB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNPdXRsaW5lKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jaGlsZHJlbikgfHwgdGhpcy5vdXRsaW5lRm9ybWF0ID09PSAndHJlZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBkZXRhaWwgY29sdW1uIChkZXRhaWwgcm93KSBhbmQgb3V0bGluZSBhbGwgdG9nZXRoZXIgd2UgbmVlZCBoYXZlIGFcbiAgICAgKiBtZWNoYW5pc20gdG8gdGVsbCB0byB0aGUgb3V0bGluZSBcImRvbid0IHJlbmRlciB0aGUgbmV4dCBsZXZlbCBvZiBpdGVtc1wiIGFuZCB1c2UgZGV0YWlsIHJvdy5cbiAgICAgKiBTbyBjZXJ0YWluIGl0ZW0gdHlwZSBuZWVkcyB0byBiZSBza2lwcGVkLlxuICAgICAqXG4gICAgICogVGhlIHdheSB3ZSBza2lwIHRob3NlIGl0ZW0gaXMgd2UgdXNlIGlzVmlzaWJsZUZuIGNvbmRpdGlvbiBvZiB0aGUgZGV0YWlsIHJvdyBhbmQgbG9vayBhaGVhZFxuICAgICAqIGlmIHdlIHNob3VsZCBza2lwIG5leHQgbGV2ZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBza2lwT3V0bGluZUl0ZW0oaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoZGF0YTogYW55LCBmaWVsZDogc3RyaW5nKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YSwgZmllbGQpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGF0IHdlIGFsc28gaW5jbHVkZSBwcm9ncmFtbWF0aWMgY29sdW1uIGlmIHByZXNlbnQuIE1vdmUgdGhlbSB0byB0aGUgY29ycmVjdFxuICAgICAqIGFycmF5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRGcm96ZW5Db2x1bW5zKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY29sc1F1ZXJ5XG4gICAgICAgICAgICAuZmlsdGVyKChjb2wxOiBEVENvbHVtbjJDb21wb25lbnQpID0+IGNvbDEuZnJvemVuKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbC5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucy5wdXNoKGNvbCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmZyb3plbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZmluZCBsYXN0IGluZGV4IG9mIGNvbHVtbiB0aGF0IGlzIGludGVybmFsIC8gcHJvZ3JhbW1hdGljXG5cbiAgICAgICAgICAgIGxldCBsYXN0SW54ID0gdGhpcy5jb2x1bW5zLnNsaWNlKClcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLmZpbmRJbmRleCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IHRoaXMuaXNJbnRlcm5hbENvbHVtbihjb2wpKTtcblxuICAgICAgICAgICAgaWYgKGxhc3RJbnggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMuY29sdW1ucy5sZW5ndGggLSAxIC0gbGFzdElueDtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJuYWxDb2xzID0gdGhpcy5jb2x1bW5zLnNwbGljZSgwLCBpZHggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMgPSBbLi4uaW50ZXJuYWxDb2xzLCAuLi50aGlzLmZyb3plbkNvbHVtbnNdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBoYXNWYWxpZENvbHMgPSB0aGlzLmNvbHVtbnNcbiAgICAgICAgICAgICAgICAuZmluZEluZGV4KChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gaXNCbGFuayhjb2wud2lkdGgpKSA9PT0gLTE7XG5cbiAgICAgICAgICAgIGFzc2VydChoYXNWYWxpZENvbHMgfHwgaXNQcmVzZW50KHRoaXMuc2Nyb2xsV2lkdGgpLFxuICAgICAgICAgICAgICAgICdXaGVuIHVzaW5nIFtmcm96ZW5dIGJpbmRpbmcgeW91IG5lZWQgc3BlY2lmeSBbd2lkdGhdIGZvciBlYWNoICcgK1xuICAgICAgICAgICAgICAgICdjb2x1bW4gb3IgW3Njcm9sbFdpZHRoXSBvbiBkYXRhdGFibGUhJyk7XG5cblxuICAgICAgICAgICAgYXNzZXJ0KGlzQmxhbmsodGhpcy5yb3dEZXRhaWxDb2x1bW4pLFxuICAgICAgICAgICAgICAgICdZb3UgY2Fubm90IGNvbWJpbmUgYXctZHQtZGV0YWlsLWNvbHVtbiB3aXRoIGZyb3plbiBjb2x1bW5zIScpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1cnJlbnQgaW1tdXRhYmxlIGxpc3QgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi4gTmVlZCB0byB3cmFwIGl0IHdpdGhcbiAgICAgKiBzZXRUaW1lb3V0IGFzIHRoZSBjaGFuZ2UgY2FuIGVhc2lseSBjb21lIGFmdGVyIHZpZXcgY2hlY2tlZCBhbmQgdGhpcyB3b3VsZCByZXN1bHQgc29tZSBlcnJvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlTGlzdChuZXdMaXN0OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhblVzZUZvckRldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJlxuICAgICAgICAgICAgKDxEVERldGFpbFJvd0NvbXBvbmVudD50aGlzLnJvd0RldGFpbENvbHVtbikuc2hvd0RldGFpbFJvdyhpdGVtKTtcbiAgICB9XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBQTEFURk9STV9JRCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc3dpdGNoTWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge2lzUGxhdGZvcm1Ccm93c2VyfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBQbGVhc2Ugc2VlIGRhdGF0YWJsZSBmb3IgbW9yZSBkZXRhaWwgZGVzY3JpcHRpb24uIEJ1dCB0aGUgbWFpbiBnb2FsIG9mIHRoaXMgd3JhcHBlciB0byByZW1vdmVcbiAqIGFsbCB0aGUgY29tbW9uIHN1cnJvdW5kaW5nIHBhcnRzIGFyb3VuZCB0aGUgZGF0YXRhYmxlIGFuZCBtYWtlIHN1cmUgRFQgY2FuIGZvY3VzIG9ubHkgYWN0dWFsXG4gKiBoZWFkZXIgYW5kIGJvZHkgc3RydWN0dXJlXG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB3cmFwcGVyIGFsc28gcHJvdmlkZXMgc29tZSBjb2RlIGZvciB0aGUgc2xpZGluZyB1cCBwYW5lbCBjb250YWluaW5nXG4gKiBidXR0b25zIGFuZCBvdGhlciBhY3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGR1cmluZyBlZGl0aW5nXG4gKlxuICpcbiAqIFRvZG86IEV4dHJhY3QgdGhlIGV4cGFuZCBsb2dpYyBvdXQgaW50byBzb21lIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgb3IganVzdCBhIGNsYXNzXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LXdyYXBwZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBbbmdDbGFzc109XCJkdC5zdHlsZUNsYXNzXCIgW2NsYXNzLmR0LWZ1bGwtc2NyZWVuLW1vZGVdPVwiaXNGdWxsU2NyZWVuTW9kZVwiXG4gICAgIFtzdHlsZS53aWR0aF09XCJkdC53aWR0aFwiXG4+XG4gICAgPGRpdiBjbGFzcz1cImR0LWxvYWRpbmctb3ZlcmxheVwiICpuZ0lmPVwiZHQubG9hZGluZ1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkdC1sb2FkaW5nLWNvbnRlbnRcIiAqbmdJZj1cImR0LmxvYWRpbmdcIj5cbiAgICAgICAgPGkgW2NsYXNzXT1cIidzYXAtaWNvbiB1LWR0LXNwaW4taWNvbiAnICsgZHQubG9hZGluZ0ljb25cIj48L2k+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtaGVhZGVyXCIgKm5nSWY9XCJkdC5zaG93VGFibGVIZWFkZXJcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZHQuaGVhZGVyOyB0aGVuIGFwcERlZmluZWRIZWFkZXIgZWxzZSBkZWZhdWx0SGVhZGVyXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRFQgQk9EWSB3aXRoIHRhYmxlIGhlYWRlcnMgYW5kIHZhbHVlcyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtYm9keS13cmFwcGVyLXZpZXdcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cImR0Lmhhc0Zyb3plbkNvbHVtbnMoKTsgdGhlbiBkdEJvZHlXaXRoRnJvemVuQ29sdW1ucyBlbHNlIGR0Qm9keU5vRnJvemVuQ29sdW1uc1wiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLTxkaXYgY2xhc3M9XCJkdC1mb290ZXJcIiAqbmdJZj1cImZvb3RlclwiPi0tPlxuICAgIDwhLS0mbHQ7ISZuZGFzaDsgZm9vdGVyQXJlYSZuZGFzaDsmZ3Q7LS0+XG4gICAgPCEtLTxuZy1jb250ZW50IHNlbGVjdD1cImF3LWR0LWZvb3RlclwiPjwvbmctY29udGVudD4tLT5cbiAgICA8IS0tPC9kaXY+LS0+XG48L2Rpdj5cblxuPCEtLSB0b2RvOiBkb250IGFjdGl2YXRlIHRoaXMgaWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIGxpc3QgLSAtLT5cbjxhdy1pbmZpbml0ZS1zY3JvbGwgI2luZmluaXRlU2Nyb2xsICpuZ0lmPVwiaXNGdWxsU2NyZWVuTW9kZVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXN0YW5jZV09XCInMTAlJ1wiXG4gICAgICAgICAgICAgICAgICAgIFtmZXRjaFNpemVdPVwiZHQuc3RhdGUubGltaXRcIlxuICAgICAgICAgICAgICAgICAgICAob25Mb2FkKT1cIm9uTGF6eUxvYWQoJGV2ZW50KVwiPlxuPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG5cblxuPG5nLXRlbXBsYXRlICNhcHBEZWZpbmVkSGVhZGVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkaW5nO1wiPjwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0SGVhZGVyPlxuICAgIDxkaXYgY2xhc3M9XCJkdC1nbG9iYWwtZmlsdGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1maWx0ZXJcIj48L3NwYW4+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtZ2xvYmFsLWFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImR0LWFjdGlvbi1jb21ib1wiPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzdXBwb3J0RnVsbFNjcmVlblwiIGNsYXNzPVwic2FwLWljb24gaWNvbi1yZXNpemVcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUZ1bGxTY3JlZW4oJGV2ZW50KVwiPjwvc3Bhbj5cblxuICAgICAgICAgICAgPGF3LWlucHV0LWZpZWxkICpuZ0lmPVwiZHQuc2hvd0dsb2JhbFNlYXJjaFwiIHN0eWxlQ2xhc3M9XCJkdC10YWJsZS1zZWFyY2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwiZHQuc3RhdGUuY3VycmVudFNlYXJjaFF1ZXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZUhvbGRlcj1cInNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImljb24tc2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJzZWFyY2hUZXJtcy5uZXh0KCRldmVudClcIj5cbiAgICAgICAgICAgIDwvYXctaW5wdXQtZmllbGQ+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFyaWJhLWljb24gaWNvbi1tb3JlXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS1cbiAgICBFYWNoIHNlY3Rpb24gZnJvemVuL25vbi1mcm96ZW4gaXMgY2FsY3VsYXRlZCBpbnNpZGUgdGFibGUtd3JhcHBlciBpbiB0aGUgbmdBZnRlclZpZXdDaGVja2VkLCB3aGVyZSB3ZSBzZXRcbiAgICBwcm9wZXIgd2lkdGggZm9yIGVhY2ggZnJhbWUgYXMgd2VsbCBhcyBsZWZ0IGNvb3JkaW5hdGVzIGZvciB0aGUgcmlnaHQgb25lXG4tLT5cbjxuZy10ZW1wbGF0ZSAjZHRCb2R5Tm9Gcm96ZW5Db2x1bW5zPlxuICAgIDwhLS1cbiAgICAgICAgRm9yIG5vbi1mcm96ZW4gY2FzZSB3ZSBhbHNvIG5lZWQgdG8gc2V0IFRSVUUgYXMgdGhlIHZpZXcgaXMgYWN0dWFsbHkgZnJvemVuIGFuZCBkb2VzIG5vdFxuICAgICAgICBzY3JvbGwuXG4gICAgICAgIFdlIHVzZSB0aGlzIGZyb3plbkNvbHVtbnMgZmxhZyBpbnNpZGUgRFQgdG8gcHJvcGVybHkgc2V0IGNvbHVtbiBpbmRleCBvbiB0aGUgaGVhZGVyIGxldmVsXG4gICAgICAgIGNvbHVtbkluZGV4Oihmcm96ZW4gPyBjb2x1bW5JbmRleDogKGNvbHVtbnMubGVuZ3RoICsgY29sdW1uSW5kZXgpKVxuXG4gICAgICAgIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIHNldCB0cnVlIGV2ZW4gaW4gdGhpcyBjYXNlIHRvIHJldHVybiByZWFsIGNvbHVtbkluZGV4IHNpbmNlIHdlIGRvbnRcbiAgICAgICAgaGF2ZSB0aGUgc2Vjb25kIHRhYmxlLlxuICAgIC0tPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkdEJvZHk7IGNvbnRleHQ6eyRpbXBsaWNpdDogZHQuY29sdW1ucywgZnJvemVuQ29sdW1uczogdHJ1ZSB9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2R0Qm9keVdpdGhGcm96ZW5Db2x1bW5zPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkdEJvZHk7IGNvbnRleHQ6eyRpbXBsaWNpdDogZHQuZnJvemVuQ29sdW1ucywgZnJvemVuQ29sdW1uczogdHJ1ZSB9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImR0Qm9keTsgY29udGV4dDp7JGltcGxpY2l0OiBkdC5jb2x1bW5zLCBmcm96ZW5Db2x1bW5zOiBmYWxzZSB9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjZHRCb2R5IGxldC1jb2x1bW5zIGxldC1mcm96ZW5Db2x1bW5zPVwiZnJvemVuQ29sdW1uc1wiPlxuXG4gICAgPGRpdiAjZHRDb250YWluZXIgY2xhc3M9XCJkdC1ib2R5LXdyYXBwZXJcIlxuICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cInRoaXMuY2FsY3VsYXRlRnJvemVuV2lkdGgoKVwiXG4gICAgICAgICBbY2xhc3MuZHQtYm9keS11bmZyb3plbl09XCJkdC5oYXNGcm96ZW5Db2x1bW5zKCkgJiYgIWZyb3plbkNvbHVtbnNcIlxuICAgICAgICAgW2NsYXNzLmR0LWJvZHktZnJvemVuXT1cImR0Lmhhc0Zyb3plbkNvbHVtbnMoKSAmJiBmcm96ZW5Db2x1bW5zXCJcbiAgICA+XG5cbiAgICAgICAgPHRhYmxlIFtuZ0NsYXNzXT1cImR0LnRhYmxlU3R5bGVDbGFzc1wiXG4gICAgICAgICAgICAgICBbc3R5bGUud2lkdGhdPVwiZnJvemVuQ29sdW1ucyA/IG51bGwgOiBkdC5zY3JvbGxXaWR0aFwiXG4gICAgICAgICAgICAgICBbY2xhc3MuZHQtcGl2b3QtbGF5b3V0XT1cImR0LnBpdm90YWxMYXlvdXRcIlxuICAgICAgICAgICAgICAgW2NsYXNzLmR0LXBsYWluLWxheW91dF09XCIhZHQucGl2b3RhbExheW91dCAmJiAhZHQuaXNPdXRsaW5lKClcIj5cblxuICAgICAgICAgICAgPCEtLSBSZW5kZXIgVEggaGVhZGVyIHJvd3MtLT5cbiAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cImR0LXRoZWFkXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyUm93czsgY29udGV4dDp7JGltcGxpY2l0OiBjb2x1bW5zLGZyb3plbkNvbHVtbnM6ZnJvemVuQ29sdW1ucyB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvdGhlYWQ+XG5cbiAgICAgICAgICAgIDwhLS1cbiAgICAgICAgICAgICAgICBSZW5kZXIgZGF0YSByb3dzLiBGb3IgZGF0YSByb3dzIHdlIG5lZWQgdG8ga2VlcCB0Ym9keSB0YWcgaW5zaWRlIERUIHRhYmxlXG4gICAgICAgICAgICAgICAgZHVlIHRvIE91dGxpbmVcbiAgICAgICAgICAgICAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5Um93czsgY29udGV4dDp7JGltcGxpY2l0OiBjb2x1bW5zLCAgZnJvemVuQ29sdW1uczpmcm96ZW5Db2x1bW5zIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3RhYmxlPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48ZGl2ICNkdEZ1bGxTY3JlZW5PdmVybGF5IGNsYXNzPVwiZHQtZnVsbC1zY3JlZW4tb3ZlcmxheSB1LWZ1bGwtc2NyZWVuLWVsZW1lbnRcIj48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5kdC1mb290ZXIsLmR0LWhlYWRlcnt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOi41ZW0gLjc1ZW07Ym94LXNpemluZzpib3JkZXItYm94fS5kdC1mb290ZXJ7Ym9yZGVyLXRvcDowfS5kdC10aGVhZCB0cntib3JkZXItd2lkdGg6MH0uZHQtYm9keS13cmFwcGVyLXZpZXd7cG9zaXRpb246cmVsYXRpdmV9LmR0LWJvZHktd3JhcHBlcntvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3fS5kdC1ib2R5LXdyYXBwZXIuZHQtYm9keS11bmZyb3plbntib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtvdmVyZmxvdy14OmF1dG99LmR0LWxvYWRpbmctb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiM5YjliOWI7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvcGFjaXR5Oi4xO3otaW5kZXg6MX0uZHQtbG9hZGluZy1jb250ZW50e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NTAlO3RvcDoyNSU7ei1pbmRleDoyfS5kdC1oZWFkZXJ7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OnJvdyBub3dyYXA7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47Y29sb3I6IzM2MzYzNjtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZjFmMWYxO21hcmdpbi1ib3R0b206MzBweH0uZHQtaGVhZGVyIC5kdC1nbG9iYWwtZmlsdGVye2ZsZXg6MCAwO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7Zm9udC1zaXplOjE4cHh9LmR0LWhlYWRlciAuZHQtZ2xvYmFsLWFjdGlvbnN7ZmxleDowIDA7YWxpZ24taXRlbXM6ZmxleC1lbmR9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJve2Rpc3BsYXk6ZmxleDtmbGV4LWZsb3c6cm93IG5vd3JhcDtjb2xvcjojN2Q3ZDdkfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuYXJpYmEtaWNvbiwuZHQtaGVhZGVyIC5kdC1hY3Rpb24tY29tYm8gLnNhcC1pY29ue21hcmdpbi1sZWZ0OjE1cHg7Zm9udC1zaXplOjIwcHg7YWxpZ24tc2VsZjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5kdC10YWJsZS1zZWFyY2h7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5pY29uLXJlc2l6ZXtjb2xvcjojNGE0YTRhO2ZvbnQtc2l6ZToxNnB4O2xpbmUtaGVpZ2h0OjE4cHg7bWFyZ2luLXJpZ2h0OjE1cHh9LnUtZHQtc3Bpbi1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrOy13ZWJraXQtYW5pbWF0aW9uOjJzIGxpbmVhciBpbmZpbml0ZSBkb1NwaW47YW5pbWF0aW9uOjJzIGxpbmVhciBpbmZpbml0ZSBkb1NwaW59QC13ZWJraXQta2V5ZnJhbWVzIGRvU3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBkb1NwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5kdC1mdWxsLXNjcmVlbi1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2l0aW9uOmFsbCAuNHMgZWFzZS1pbi1vdXR9LmR0LWZ1bGwtc2NyZWVue3dpZHRoOjk4dnc7ei1pbmRleDoxMjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjE1cHg7cG9pbnRlci1ldmVudHM6YWxsO3RyYW5zaXRpb246b3BhY2l0eSAuNXMgZWFzZS1pbi1vdXR9LnUtZnMtZWxlbWVudC1vdXR7ZGlzcGxheTpub25lfWBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcblxufSlcbmV4cG9ydCBjbGFzcyBEVFdyYXBwZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZFxue1xuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdGhhdCBpcyB1c2VkIGJ5IGZ1bGwgc2NyZWVuIGRpdiBvdmVybGF5IHRvIGNyZWF0ZSBleHBhbmRpbmcgZWZmZWN0IHdoaWNoIG5lZWRzIHRvIGhhdmVcbiAgICAgKiBsaXR0bGUgdGVudDtcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JGcm9tOiBzdHJpbmcgPSAnI2YzZjNmMyc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCB0byBzZXQgYWZ0ZXIgd2UgYXJlIGluIHRoZSBmdWxsIHNjcmVlbiBzbyBvdXIgb3ZlcmxheSBkaXYgaGlkZSBldmVyeXRoaW5nXG4gICAgICogb24gdGhlIHBhZ2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JUbzogc3RyaW5nID0gJyNGRkZGRkYnO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRhYmxlIGhlYWRpbmcgYXJlYSBvZmZlcnMgZGV2ZWxvcGVyIHRvIGNvbXBsZXRlbHkgb3ZlcnJpZGUgdGhlIHRvcCBiYXIgd2hlcmUgd2UgaGF2ZSBmaWx0ZXJzXG4gICAgICogYW5kIG90aGVycyBhY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGluZ0FyZWEnKVxuICAgIGhlYWRpbmc6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgaGVhZGVycyBhbmQgd3JhcHMgdGhlbSB3aXRoaW4gdGhlYWQgdGFnXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyUm93cycpXG4gICAgaGVhZGVyUm93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0YWJsZSBib2R5XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keVJvd3MnKVxuICAgIGJvZHlSb3dzOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBoZWFkaW5nIHRlbXBsYXRlLiBXZSBuZWVkIHRvIHJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgb24gcHJpbWVORyBzbyBmYXIgaXQgaXMgdXNpbmdcbiAgICAgKiBwLWZvb3RlclxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2Zvb3RlckFyZWEnKVxuICAgIGZvb3RlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogRGl2IHVzZWQgdG8gbWFrZSB0aGUgZnVsbCBzY3JlZW4gZXhwYW5zaW9uIGVmZmVjdFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2R0RnVsbFNjcmVlbk92ZXJsYXknKVxuICAgIGR0RnVsbFNjcmVlbk92ZXJsYXk6IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBpbmZpdGUgc2Nyb2xsLiBXZSBhcmUgdXNpbmcgdGhpcyB0byB0cmlnZ2VyIGxvYWRpbmcgZmluaXNoIGV2ZW50IHNvIHdlIGNhblxuICAgICAqIGhpZGUgbG9hZGluZyBhbmltYXRpb25cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdpbmZpbml0ZVNjcm9sbCcpXG4gICAgaW5maW5pdGVTY3JvbGw6IEluZmluaXRlU2Nyb2xsQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBkZWJvdW5jZSB0aGUgdHlwaW5nIHdlIG5lZWQgdG8gdXNlIHN1YmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNlYXJjaFRlcm1zID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU3BlY2lmaWVzIGlmIHdlIGFyZSBpbiB2aWV3aW5nL2VkaXRpbmcgbW9kZSB0aGF0IGNhbiBicm93c2Ugd2hvbGUgZGF0YXNldCBsYXppbHlcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRnVsbFNjcmVlbk1vZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIGNhbiBzdXBwb3J0IGZ1bGwgc2NyZWVuIG1vZGUgLSBvbmx5IGF2YWlsYWJsZSBmb3IgdGhlIGJyb3dzZXJcbiAgICAgKlxuICAgICAqL1xuICAgIHN1cHBvcnRGdWxsU2NyZWVuOiBib29sZWFuID0gdHJ1ZTtcbiAgICBxdWVyeVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIGxvYWRpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICAvKipcbiAgICAgKiAgU2F2ZXMgb3JpZ2luYWwgYm91bmRpbmcgcmVjdCBjb29yZGluYXRlcyBiZWZvcmUgd2UgZXhwYW5kIHRoZSBEVCB0byBmdWxsIHNjcmVlblxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkdEJvdW5kaW5nQ2xpZW50UmVjdDogYW55O1xuICAgIC8qKlxuICAgICAqIFJlbWVtYmVycyBvcmlnaW5hbCBzY3JvbGwgcG9zaXRpb24gYmVmb3JlIHdlIHN3aXRjaCB0byBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBvcmlnaW5hbFNjcm9sbFBvc2l0aW9uOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGhpc0VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgICAgICAgICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhdGFibGUyQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwdWJsaWMgZHQ6IERhdGF0YWJsZTJDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uID0gdGhpcy5zZWFyY2hUZXJtcy5waXBlKFxuICAgICAgICAgICAgLy8gd2FpdCAzMDBtcyBhZnRlciBlYWNoIGtleXN0cm9rZSBiZWZvcmUgY29uc2lkZXJpbmcgdGhlIHRlcm1cbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgzMDApLFxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV3IHRlcm0gaWYgc2FtZSBhcyBwcmV2aW91cyB0ZXJtXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHRlcm06IHN0cmluZykgPT4gb2YodGVybSkpXG4gICAgICAgICkuc3Vic2NyaWJlKCh0ZXJtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGVybSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmluZCh0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nU3ViID0gdGhpcy5kdC52YWx1ZUNoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZGF0YTogYW55KSA9PiB0aGlzLmxvYWRpbmdGaW5pc2hlZCgpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGNvbHVtbnMgbWFya2VkIGFzIGZyb3plbiBhbmQgcmV0cmlldmUgYSB3aWR0aCBzbyB3ZSBjYW4gdXBkYXRlXG4gICAgICogcGFyZW50IGRpdlxuICAgICAqXG4gICAgICovXG4gICAgY2FsY3VsYXRlRnJvemVuV2lkdGgoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZHQuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmR0LmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb2wubWF4V2lkdGhQeCA+IDApIHtcbiAgICAgICAgICAgICAgICBmV2lkdGggKz0gY29sLndpZGVzdENlbGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZXaWR0aCArPSBwYXJzZUludChjb2wud2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZldpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBoYXZpbmcgdHdvIHNlcGFyYXRlIHRhYmxlcyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHJvd3Mgb2YgdGhlIHRhYmxlcyBhcmUgYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSB0aGlzIG1ldGhvZCB0YWtlcyBmaXJzdCBjb2x1bW4gZnJvbSBlYWNoIHRhYmxlIHJlYWQgdGhlIGhlaWdodCBvZiB0aGUgcm93cyBhbmQgc2V0XG4gICAgICogdGhlIG1heCBoZWlnaHQgdG8gYm90aCByb3dzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhbGlnblRhYmxlc0hlaWdodHMoZnJvemVuVmlldzogYW55LCB1bkZyb3plblZpZXc6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQoZnJvemVuVmlldykgJiYgaXNQcmVzZW50KGZyb3plblZpZXcpLFxuICAgICAgICAgICAgJ0NhbnQgYWxpZ24gdGFibGUgdmlld3MgYXMgb25lIG9mIHRoZSB2aWV3IGlzIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIGxldCBmcm96ZW5Sb3dzOiBhbnlbXSA9IGZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcbiAgICAgICAgbGV0IHVuRnJvemVuUm93czogYW55W10gPSB1bkZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcblxuICAgICAgICBhc3NlcnQoZnJvemVuUm93cy5sZW5ndGggPT09IHVuRnJvemVuUm93cy5sZW5ndGgsXG4gICAgICAgICAgICAnRnJvemVuIENvbHVtbjogVHdvIHRhYmxlcyBkb2VzIG5vdCBtdWNoIScpO1xuXG4gICAgICAgIEFycmF5LmZyb20oZnJvemVuUm93cykuZm9yRWFjaCgoZnJvemVuOiBhbnksIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBoID0gTWF0aC5tYXgoZnJvemVuLm9mZnNldEhlaWdodCwgdW5Gcm96ZW5Sb3dzW2luZGV4XS5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgZnJvemVuLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICAgICAgdW5Gcm96ZW5Sb3dzW2luZGV4XS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdEZ1bGxTY3JlZW4oKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmICh0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgbGV0IGZyb3plblZpZXcgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuJyk7XG4gICAgICAgICAgICBsZXQgdW5Gcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LXVuZnJvemVuJyk7XG5cbiAgICAgICAgICAgIGxldCBmcm96ZW5XaWR0aCA9IHRoaXMuY2FsY3VsYXRlRnJvemVuV2lkdGgoKTtcblxuICAgICAgICAgICAgZnJvemVuVmlldy5zdHlsZS53aWR0aCA9IGZyb3plbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodW5Gcm96ZW5WaWV3KSkge1xuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgYm9yZGVyIGFuZCBjcmVhdGUgaW5kZW50IGVmZmVjdCBieSBoYXZpbmcgMXB4IHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgdW5Gcm96ZW5WaWV3LnN0eWxlLmxlZnQgPSAoZnJvemVuV2lkdGggKyAyKSArICdweCc7XG4gICAgICAgICAgICAgICAgdW5Gcm96ZW5WaWV3LnN0eWxlLndpZHRoID0gdW5Gcm96ZW5WaWV3LnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLSBmcm96ZW5WaWV3Lm9mZnNldFdpZHRoICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25UYWJsZXNIZWlnaHRzKGZyb3plblZpZXcsIHVuRnJvemVuVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5xdWVyeVN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sb2FkaW5nU3ViKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZVTEwgU0NSRUVOIE1PREUgbWV0aG9kc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGZ1bGxzY3JlZW4gZnVuY3Rpb25hbGl0eSBpcyBlbmFibGVkIHRoaXMgbWV0aG9kIHN3aXRjaGVzIGJldHdlZW4gbm9ybWwgYW5kIGZ1bGwgc2NyZWVuXG4gICAgICogbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsU2NyZWVuTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuRnVsbFNjcmVlbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBwdXNoIHRoaXMgY29tcG9uZW50IHRvIGZ1bGwgc2NyZWVuIG1vZGUgb3IgbWF5YmUgZnVsbCBwYWdlIG1vZGUgd2UgbmVlZCBydW4gZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogIC0gRXhlY3V0ZSBleHBhbmQgdHJhbnNmb3JtYXRpb24sIHdoZXJlIHdlIGhhdmUgYWRkaXRpb25hbCBvdmVybGF5IGRpdiB0aGF0IHdlIHNsb3dseSBleHBhbmRcbiAgICAgKiAgYW5kIHRoaXMgY3JlYXRlcyBpbXByZXNzaW9uIHRoZSBEVCBpcyBleHBhbmRpbmdcbiAgICAgKlxuICAgICAqICAtIGFwcGx5IGZ1bGwtc2NyZWVuIGNsYXNzIG9uIHRvcCBob3N0IGVsZW1lbnQgIC0gaW4gdGhpcyBjYXNlIGl0cyBEYXRhVGFibGUgdG8gc3dpdGNoXG4gICAgICogIHRvIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKiAgLSBtYWtlIHN1cmUgd2UgYXJlIHNjcm9sbGVkIGFsbCB0aGUgd2F5IHVwXG4gICAgICpcbiAgICAgKiAgLSBoaWRlIGFsbCB0aGUgZWxlbWVudHMgb24gdGhlIHBhZ2Ugc28gdGhlaXIgZGltZW5zaW9uIGRvbid0IGludGVyZmVyZSB3aXRoIHRoaXMgdGFibGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW5GdWxsU2NyZWVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmlzRnVsbFNjcmVlbk1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucnVuRXhwYW5kRWZmZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuT25EVCh0cnVlKTtcblxuXG4gICAgICAgIC8vIG1hcmsgbXkgZWxlbWVudCBpbiB0aGUgcGF0aCB0aGF0IG5lZWRzIHRvIHN0YXlcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCd1LWZ1bGwtc2NyZWVuLWVsZW1lbnQnKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgdGhpcy5kdC5zdGF0ZS5saW1pdCA9IE1hdGgucm91bmQodGhpcy5jYWxjdWxhdGVMaW1pdCgpKTtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuc3RhdGUpO1xuXG4gICAgICAgIC8vIG9uY2UgbG9hZGVkIHNldCBiYWNrIGNvcnJlY3QgcGFnZSBzaXplIHdlIHVzZSB3aGVuIGxvYWRpbmcgZGF0YVxuICAgICAgICB0aGlzLmR0LnN0YXRlLmxpbWl0ID0gdGhpcy5kdC5wYWdlU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBzYW1lIGxpa2UgYWJvdmUgbWV0aG9kIChvcGVuRnVsbFNjcmVlbikgYnV0IGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZUZ1bGxTY3JlZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaXNGdWxsU2NyZWVuTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2hvd05vbkZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIHRoaXMucnVuQ29sbGFwc2VFZmZlY3QoKTtcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuT25EVChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmxpbWl0ID0gdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmRpc3BsYXlMaW1pdDtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc2V0IG9mIHNldCBvZiBjc3MgcHJvcGVydGllcyB0byBtYWtlIHRoZSBEVCBtYWluIGNvbXBvbmVudCBvbiB0aGUgcGFnZSBleHBhbmQgdG9cbiAgICAgKiBmdWxsIHBhZ2UgbW9kZSBhbmQgYmFja1xuICAgICAqXG4gICAgICogV2Ugd2FudCB0byBtYWtlIGl0IHdpdGggbGl0dGxlIGRlbGF5IHRvIGxldCBvdGhlciBhbmltYXRpb24gZmluaXNoXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbk9uRFQoZnVsbFNjcmVlbjogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ICs9ICdkdC1mdWxsLXNjcmVlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ID0gdGhpcy5kdC5jbGFzc0xpc3QucmVwbGFjZSgnZHQtZnVsbC1zY3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBpbmZpbml0ZSBzY3JvbGwgZXZlbnQgYW5kIHJlcXVlc3QgbmV3IGRhdGEgZnJvbSBkYXRhIHNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgb25MYXp5TG9hZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGV2ZW50LmlzTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5kdC5zdGF0ZS5vZmZzZXQgPSBldmVudC5vZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmV0Y2godGhpcy5kdC5zdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YVByb3ZpZGVyID0gdGhpcy5kdC5kYXRhU291cmNlLmRhdGFQcm92aWRlcjtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChkYXRhLnNsaWNlKDAsIGV2ZW50Lm9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmltYXRpb24gZWZmZWN0IHRvIG1ha2UgaXQgZmVlbCBsaWtlIHRoZSBlbGVtZW50IChpbiB0aGlzIGNhc2UgRFQpIGlzIGV4cGFuZGluZ1xuICAgICAqIGZyb20gdGhlIG1pZGRsZSB0byB0aGUgZnVsbCBwYWdlIG1vZGUuXG4gICAgICpcbiAgICAgKiBXZSB0YWtlIHRoZSBkaW1lbnNpb24gb2YgdGhlIHRhYmxlIHRoZW4gaXQgaXMgc2NhbGVkIHNsb3dseSB0byB0aGUgZnVsbCBwYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5FeHBhbmRFZmZlY3QoKVxuICAgIHtcbiAgICAgICAgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvckZyb207XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24odHJ1ZSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmV4cGFuZENvbG9yVG87XG4gICAgICAgIH0sIDMwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIHNjYWxlIHRoZSBoZWxwZXIgZGl2IChvdmVybGF5KSBkb3duIHRvIG1ha2UgaXQgbG9vayBsaWtlXG4gICAgICogaXQgY29sbGFwc2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5Db2xsYXBzZUVmZmVjdCgpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKGZhbHNlKTtcblxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCwgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsIDAsXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogREZTICAtIHRvIGdvIHRocnUgYWxsIHRoZSBlbGVtZW50IHVuZGVyIEJPRFkgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChwYXJlbnRFbGVtZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUgPT09IHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZFRyYXZlcnNlRG93bihlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHQtZnVsbC1zY3JlZW4nKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndS1mcy1lbGVtZW50LW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHV0IGFsbCB0aGUgZWxlbWVudCB0aGF0IHdlcmUgcHJldmlvdXNseSByZW1vdmVkIGJ5IGhpZGVOb25GdWxsU2NyZWVuRWxlbWVudCgpIGJhY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIHNob3dOb25GdWxsU2NyZWVuRWxlbWVudCgpOiB2b2lkXG4gICAge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy51LWZzLWVsZW1lbnQtb3V0JykpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZWxlbTogYW55KSA9PiBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3UtZnMtZWxlbWVudC1vdXQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG5lZWRUcmF2ZXJzZURvd24oZWxlbWVudDogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlbGVtZW50KSAmJiBlbGVtZW50LnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygndS1mdWxsLXNjcmVlbi1lbGVtZW50JykgJiZcbiAgICAgICAgICAgICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHQtZnVsbC1zY3JlZW4nKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZW50ZXIgZnVsbCBzY3JlZW4gL3BhZ2UgbW9kZSB3aGVuIG5lZWQgdG8gY2FsY3VsYXRlIGhvdyBtYW55IHJvd3MgdG8gbG9hZCBpbml0aWFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlTGltaXQoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgYnJvd3NlckggPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBsZXQgcm93SCA9IHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keSB0cjpmaXJzdC1jaGlsZCcpLm9mZnNldEhlaWdodDtcblxuICAgICAgICByZXR1cm4gKGlzUHJlc2VudChyb3dIKSAmJiByb3dIID4gMCkgPyAoYnJvd3NlckggLyByb3dIKSArIDIwIDogNTA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUVsZW1lbnQobDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0OiBudW1iZXIgPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdzogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbCArICdweCc7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IHQgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBASW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgYXBwbHlUcmFuc2Zvcm1hdGlvbihleHBhbmQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgeCwgeSwgdHgsIHR5O1xuICAgICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgICAgICB4ID0gd2luZG93LmlubmVyV2lkdGggLyB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICAgICAgICAgICAgeSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgdHggPSAod2luZG93LmlubmVyV2lkdGggLyAyIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCAvIDJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCkgLyB4O1xuICAgICAgICAgICAgdHkgPSAod2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IC8gMlxuICAgICAgICAgICAgICAgIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3ApIC8geTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IDE7XG4gICAgICAgICAgICB5ID0gMTtcbiAgICAgICAgICAgIHR4ID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgdHkgPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICAgICAgICAnc2NhbGVYKCcgKyB4ICsgJykgc2NhbGVZKCcgKyB5ICsgJykgdHJhbnNsYXRlM2QoJyArICh0eCkgKyAncHgsICcgKyAodHkpICsgJ3B4LCAwcHgpJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIElORklOSVRFIFNDUk9MTElORyBNRVRIT0RTXG4gICAgICovXG5cbiAgICBwcml2YXRlIGluaXRGdWxsU2NyZWVuKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0RnVsbFNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbG9hZGluZyBpcyBmaW5pc2hlZCBtYXJrIGxvYWRpbmcgaWNvbiBpcyBkb25lIHNvIHdlIGNhbiBoaWRlIGl0LiBJIGFtIHVzaW5nIGxpdHRsZVxuICAgICAqIGRlbGF5IHRvIG1ha2UgdGhlIGFuaW1hdGlvbiB2aXNpYmxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkaW5nRmluaXNoZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmluZmluaXRlU2Nyb2xsKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluZmluaXRlU2Nyb2xsLmNvbXBsZXRlKCksIDIwMCk7XG5cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25Jbml0LCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGFuZCBzZXR0aW5nIHRoZSB3aWRlc3QgY29udGVudCB3aWR0aCBvbnRvXG4gKiBDb2x1bW4gY29tcG9uZW50IGFzIHRoZSB3aWRlc3RDZWxsIHByb3BlcnR5LlxuICpcbiAqIFdlIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbnNpZGUgZHQtY29sdW1uLmNvbXBvbmVudCB0byBzdG9yZSBhIGN1cnJlbnQgd2lkdGggZm9yIGVhY2ggdGQsdGhcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tkdE1heFdpZHRoXSdcbn0pXG5leHBvcnQgY2xhc3MgU2V0Q2VsbE1heFdpZHRoRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0XG57XG5cbiAgICBASW5wdXQoKVxuICAgIGR0TWF4V2lkdGg6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGQ6IERUQ29sdW1uMkNvbXBvbmVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDZWxsIE1heCBXaWR0aDogJyArIHRoaXMuZHRNYXhXaWR0aCwgdGhpcy5kdE1heFdpZHRoID4gMCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdE1heFdpZHRoKSAmJiB0aGlzLmR0TWF4V2lkdGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5saW5lRGF0YSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1jb2wtY2VsbC1kYXRhJyk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGlubGluZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGlubGluZURhdGEub2Zmc2V0V2lkdGg7IC8vIHRkXG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJblRocmVzSG9sZChjZWxsV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKz0gdGhpcy50ZFBhZGRpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFdpZHRoID4gdGhpcy50ZC53aWR0aFB4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsV2lkdGggPCB0aGlzLmR0TWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9IGNlbGxXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbCA/IGNlbGxXaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbFdpZHRoID49IHRoaXMuZHRNYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsID0gKHRoaXMuZHRNYXhXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZHRNYXhXaWR0aCA6IHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhlIG5ldyB3aWR0aCB0aGUgc2FtZSBhcyB0aGUgb25lIGFscmVhZHkgc2V0IG9uIHRoZSBjb2x1bW4/IElmIHllcyB0aGVuIHByb2JhYmx5XG4gICAgICogbmV3IGNvbnRlbnQgZG9lcyBub3QgZGlmZmVyIHRoYXQgbXVjaC4gV2Ugc3RpbGwga2VlcCBjZXJ0YWluIHRocmVzaG9sZCBhcyB0aGUgbmV3IGNvbnRlbnRcbiAgICAgKiB3aWR0aCBtaWdodCBkaWZmZXIgMSBvciAyIHBpeGVzIGRlcGVuZGluZyBob3cgc2V0IHRoZSBjc3MuXG4gICAgICpcbiAgICAgKiBUbyBtYWtlIHN1cmUgd2UgcmVzaXplIGNvbHVtbiBvbmx5IGlmIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IGNvdWxkIGJlIG9yaWdpbmFsIHNpemVcbiAgICAgKiBpcyA0MDBweCBidXQgdGhlIG5ldyBvbmUgaXMgNDAxcHggc2luY2Ugc29tZXdoZXJlIGFkZCBzb21lIGV4dHJhIGJvcmRlciB3ZSBoYXZlIHRoaXNcbiAgICAgKiBzYWZlIHRocmVzaG9sZFxuICAgICAqXG4gICAgICovXG4gICAgaXNJblRocmVzSG9sZChuZXdXaWR0aDogbnVtYmVyKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudGQud2lkZXN0Q2VsbCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnRkLndpZGVzdENlbGwgLSBuZXdXaWR0aCkgPiAzICYmIG5ld1dpZHRoID4gdGhpcy50ZC53aWRlc3RDZWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSB0ZFBhZGRpbmcoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBsZXQgY2VsbCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuXG4gICAgICAgIC8vIHBsdXMgZ2l2ZSBpdCBzb21lIGxpdHRsZSBzcGFjZSBhcm91bmQgdGhlIHRleHQgc28gaXQgbm90cyBweCB0byBweCBpbm5lciB3aWR0aCBvZiB0aGUgdGRcbiAgICAgICAgLy8gY3V6IGl0IGNvdWxkIHdyYXBcbiAgICAgICAgY2VsbCArPSA1O1xuXG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5pbXBvcnQge1xuICAgIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksXG4gICAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RyYWdEaXJlY3Rpb24sIERyYWdFdmVudHMsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqIERpcmVjdGl2ZSB1c2VkIGluc2lkZSBEVCBpbiBvcmRlciB0byBzdXBwb3J0IHRhYmxlIHJvd3MgcmUtb3JkZXJpbmcuIFRoaXMgbWFuYWdlcyBhbGwgdGhlXG4gKiBEJkQgbmVjZXNzYXJ5IGxvZ2ljIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogW2R0RHJhZ2dhYmxlUm93XSBpcyB1c2VkIGluc2lkZSB0aGUgYHJvd1RlbXBsYXRlYCBsaWtlIHRoaXM6XG4gKlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiA8bmctdGVtcGxhdGUgI3Jvd1RlbXBsYXRlIGxldC1yb3dEYXRhIGxldC1ldmVuPSdldmVudFwiIGxldC1vZGQ9XCJvZGRcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICAgICAgbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1jb2xzVG9SZW5kZXI9XCJjb2xzVG9SZW5kZXJcIj5cbiAqXG4gKiAgICAgPHRyICNyb3dFbGVtZW50IGR0RHJhZ2dhYmxlUm93IFtkbmRSb3dJbmRleF09XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICBjbGFzcz1cImR0LWJvZHktcm93XCJcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIHdoaWNoIGVuYWJsZWQgb3IgZGlzYWJsZXMgYmFzZWQgb24gdGhlIHVzZWQgRFQgYmluZGluZyBbZG5kUm93RW5hYmxlZF0uIEJ5IGRlZmF1bHQgaXRzIGRpc2FibGVkLlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tkdERyYWdnYWJsZVJvd10nXG59KVxuZXhwb3J0IGNsYXNzIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3lcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgdGhlIGRpcmVjdGl2ZSBpZiB3ZSBlbmFibGUgbWlkZGxlIHJvdyB6b25lIHRvIGNyZWF0ZSBhbiBlZmZlY3QgdGhhdCB3ZSBhcmUgZHJvcHBpbmdcbiAgICAgKiBpbnRvIHRoZSByb3cuIFVzZWQgZm9yIG91dGxpbmUgRFQgbWFpbmx5LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkcm9wSW50b0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgVFIgaW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRuZFJvd0luZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgb3VyIGRyYWdnaW5nIGRpcmVjdGlvbiBVUCBhbmQgRE9XTiBpbiBvcmRlciB0byBhc3NpZ24gY29ycmVjdCBzdHlsZVxuICAgICAqIHRoYXQgaGlnaGxpZ2h0cyB0aGUgcm93IGF0IHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRyYWdEaXI6IERyYWdEaXJlY3Rpb24gPSBEcmFnRGlyZWN0aW9uLk5vbmU7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB3ZSBkcmFnZ2VkIG91ciByb3cgYW5kIHN0b3BwZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgb3RoZXIgcm93XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluTWlkZGxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEN1cnJlbnQgZHJhZyBZIGNvb3JkaW5hdGVzIHdoaWNoIGlzIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgZHJhZ0RpciB3aGVuIGFzc2luZ2luZyBkcmFnZ2luZ1xuICAgICAqIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ1k6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBsaXN0ZW5lcnMgaGFuZGxlcnMgaGVyZSAtIHRoZSByZXR1cm4gZnJvbSAuYmluZCh0aGlzKS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGV2ZW50SGFuZGxlcnM6IHsgW25hbWU6IHN0cmluZ106IGFueSB9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhdGFibGUyQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcml2YXRlIGR0OiBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZG9tVXRpbHM6IERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lKVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmR0LmRuZFJvd0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5kbmRSb3dFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIGxpc3RlbmVycyBhbmQgcmV0dXJucyBoYW5kbGUgdG8gdGhlbSBzbyB3ZSBjYW4gbGF0ZXIgb24gdW5zdWJzY3JpYmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydtb3VzZWRvd24nXSA9IHRoaXMub25Nb3VzZURvd25FdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ21vdXNlZG93biddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnc3RhcnQnXSA9IHRoaXMub25EcmFnU3RhcnRFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdzdGFydCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnb3ZlciddID0gdGhpcy5vbkRyYWdPdmVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdvdmVyJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdsZWF2ZSddID0gdGhpcy5vbkRyYWdMZWF2ZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2xlYXZlJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2Ryb3AnXSA9IHRoaXMub25Ecm9wRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJvcCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnZW5kJ10gPSB0aGlzLm9uRHJhZ0VuZEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdlbmQnXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBjcmVhdGVkIGxpc3RlbmVycyBpbnNpZGUgZGVzdHJveSgpIGNhbGxiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgRHJhZ0V2ZW50cy5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25hbWUnLCB0aGlzLmV2ZW50SGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBpcyBmaXJzdCBldmVudCB3aGVyZSB3ZTpcbiAgICAgKlxuICAgICAqICAtIE1hcmsgZWxlbWVudCBkcmFnZ2FibGUgdG8gZW5hYmxlIEQmRFxuICAgICAqICAtIFNldCBjbGljayBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgbWlkZGxlIG9mIHRoZSBjdXJyZW50IHJvd1xuICAgICAqICAgICAgVGhpcyBpcyBtYWlubHkgbmVlZGVkIHdoZW4gd2UgYXJlIHRyeWluZyB0byBjYWxjdWxhdGUgc29tZXRoaW5nIGZvclxuICAgICAqICAgICAgZHJvcEludG8gcm93IChvdXRsaW5lKVxuICAgICAqXG4gICAgICogZXZlbnQudGFyZ2V0IHVzdWFsbHkgY29udGFpbnMgcmVmZXJlbmNlIHRvIFREIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uTW91c2VEb3duRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChldmVudC5hbHRLZXkgJiYgdGhpcy5kb21VdGlscy5oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCAnLmR0LXJvdy1kcmFnZ2FibGUnKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBlbFRvQmVEcmFnZ2VkID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScsIChlbFRvQmVEcmFnZ2VkLmhlaWdodCAvIDIpIC0gZXZlbnQub2Zmc2V0WSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNlY29uZCB0cmlnZ2VyZWQgZXZlbnQgd2hlbiB0aGUgYWN0dWFsIGRyYWdnaW5nIHN0YXJ0cy4gSGVyZSB3ZSBuZWVkIHRvIGRpc2FibGVcbiAgICAgKiBkcmFnZ2VkIHJvdyBhbmQgc2F2ZSBpbmZvcm1hdGlvbiB0aGF0IGFyZSBjb21tb24gdG8gYSB0YWJsZS5cbiAgICAgKlxuICAgICAqIE1hcmtpbmcgcm93IGRpc2FibGVkIHdpdGggdGhlIHN0eWxlIC5kdC1yb3ctZHJhZ2dpbmcgdXNpbmcgc2V0VGltZW91dCBpcyBuZWVkZWQgYXNcbiAgICAgKiBpZiB3ZSB3b3VsZCBnbyB3aXRob3V0IGl0IHRoZW4gRCZEIGZyYW1ld29yayB3b3VsZCBjcmVhdGUgYSBjb3B5IG9mIHJvdyBpbiBkaXNhYmxlZCBzdGF0ZS5cbiAgICAgKiBOb3cgd2UgZ3JhYiBhIHJvdyB3aXRoIGFjdGl2ZSBzdGF0ZSBhbmQgYWZ0ZXIgYSAyMDBtcyBkZWxheSB3ZSBkaXNhYmxlIHRoZSBvcmlnaW5hbCByb3cuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ1N0YXJ0RXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChldmVudC50YXJnZXQuY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnaXNEcmFnZ2luZycsIHRydWUpO1xuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnZG5kSWQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZXZlbnRzIGhhcHBlbnMgYW55dGltZSBhcyB3ZSBkcmFnIG92ZXIgcm93cy4gVGhpcyBldmVudCB0cmlnZ2VyZWQgYWZ0ZXIgY2VydGFpblxuICAgICAqIGRlbGF5LiBJbiBoZXJlIHdlIGNhbGN1bGF0ZSB0aGUgbW91c2UgbW92ZW1lbnQgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIGdvaW5nIFVQIG9yIERPV04uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG1haW5seSBuZWVkZWQgdG8gbWFyayBhIHJvdyB3aXRoIHRoZSBjb3JyZWN0IGxpbmUgb24gVE9QIG9yIEJPVFRPTSB0byB2aXN1YWxseVxuICAgICAqIHNob3cgYSB1c2VyIHdoZXJlIHdlIGFyZS5cbiAgICAgKlxuICAgICAqIE9uY2Ugd2Uga25vdyB0aGUgZGlyZWN0aW9uIGFuZCB0aGUgZHJvcCB0YXJnZXQgaXMgdmFsaWQgd2UgbWFyayB0aGUgcm93IHdpdGggY29ycmVjdCBjbGFzc1xuICAgICAqIHRoYXQgZG9lcyB0aGUgdHJpY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ092ZXJFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gICAgICAgIGlmICh0aGlzLmRyYWdZIDwgZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uRG93bjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdZID4gZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uVXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBzZXQgYWdhaW4gdW5sZXNzIGl0cyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1kgIT09IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRHJvcFRhcmdldChldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gdGVzdCB0aGlzIHByZXZlbnREZWZhdWx0KCkgc28gaXQgZG9lcyBub3QgY3JlYXRlIHNvbWUgc2lkZWVmZmVjdFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubWFya1Jvd1dpdGhDbGFzcyhldmVudCwgdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBmaW5pc2hpbmcgZXZlbnQganVzdCBiZWZvcmUgRCZEIGlzIGRvbmUuIEl0IHRha2VzIGN1cnJlbnQgaW5mb3JtYXRpb24gYW5kXG4gICAgICogYnJvYWRjYXN0IHRoZW0gdG8gdGhlIERUIHNvIERUIGNhbiBkbyBuZWNlc3Nhcnkgcm93IHJlb3JkZXJpbmdcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyb3BFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jbGVhckNsYXNzZXMoZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCBvcmlnSW5keCA9IHRoaXMuZHQuZW52LmdldFZhbHVlKCdkbmRJZCcpO1xuICAgICAgICBsZXQgZHJvcFBvczogRHJvcFBvc2l0aW9uID0gdGhpcy5pbk1pZGRsZSA/IERyb3BQb3NpdGlvbi5JbnRvIDogKFxuICAgICAgICAgICAgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLlVwID8gRHJvcFBvc2l0aW9uLkJlZm9yZSA6IERyb3BQb3NpdGlvbi5BZnRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLmR0Lm9uRG5EUm93RHJvcChvcmlnSW5keCwgdGhpcy5kbmRSb3dJbmRleCwgZHJvcFBvcyk7XG5cbiAgICAgICAgdGhpcy5pbk1pZGRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdZID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSB0aW1lIHdlIGRyYWcgb3ZlciB0aGUgZWxlbWVudCB3ZSBhcHBseSBzb21lIGNsYXNzZXMgdG8gdGhlIGl0LiB0aGlzIG1ldGhvZCBkb2VzIHRoZVxuICAgICAqIG9wcG9zaXRlIHdoaWNoIGlzIHRvIHJlbW92ZSBldmVyeXRoaW5nIHNvIHdlIGFyZSByZWFkeSBmb3IgdGhlIG5leHQgcm93XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnTGVhdmVFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHRyID0gdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKHRyKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kT25Ib2xkSW5kZXgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbGFzdCBldmVudCB3aXRoaW4gRCZEIGZsb3cuIE1haW5seSB1c2VkIHRvIGNsZWFuIHVwIGFsbCB0aGUgcmVzb3VyY2UgdGhhdCBoYXMgbm90XG4gICAgICogYmVlbiBjbGVhbiB1cCBhbHJlYWR5IGluc2lkZSBvbkRyb3BFdmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnRW5kRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnaXNEcmFnZ2luZycpO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIENTUyBjbGFzc2VzIHRvIHRoZSByb3cgdG8gY3JlYXRlIGFuIGhpZ2hsaWdodGluZyBlZmZlY3QgdG8gY2FwdHVyZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICogZm9yIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQmFzZWQgb24gdGhlIERyYWcgZGlyZWN0aW9uIHdlIGVpdGhlciBhcHBseVxuICAgICAqIGNzcyBjbGFzcyB0aGF0IGNyZWF0ZXMgYSBsaW5lIG9uIHRvcCBvciBib3R0b20uICBPbmx5IGZvciB0aGUgZHJvcEludG8gZnVuY3Rpb25hbGl0eSB3ZVxuICAgICAqIG5lZWQgdG8gY2FsY3VsYXRlIHNvbWUgbW9yZSB0byBpZGVudGlmeSBpZiB3ZSBhcmUgcmVhbGx5IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqIERyb3BJbnRvOlxuICAgICAqIC0tLS0tLS0tLVxuICAgICAqXG4gICAgICogSW5pdGlhbGx5IHdlIGNhcHR1cmVkIGEgcG9zaXRpb24gKGluIG1vdXNlZG93bikgdGhlIGRpc3RhbmNlIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHJvdyBhbmRcbiAgICAgKiB0aGlzIHdlIGFyZSB1c2luZyBoZXJlIHdpdGggc29tZSB0aHJlc2hvbGQgb2YgMiBwaXhlcyBzbyB3ZSBkb250IGhhdmUgdG8gYmUgZXhhY3RseSBvbiBwaXhlbFxuICAgICAqIHBlcmZlY3QuXG4gICAgICpcbiAgICAgKiAtIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgKiAgICAgIFJlYWQgY2VudGVyIG9mIGN1cnJlbnQgcm93XG4gICAgICpcbiAgICAgKiAtIGxldCBkcmFnZ2VkVHJDZW50ZXIgPSBldmVudC5vZmZzZXRZICsgdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgICAqICAgICAgUmVhZCBtb3VzZSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjdXJyZW50IHJvdy90ZCBhbmQgYWRkIHRvIGl0IG91ciBkZXZpYXRpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgbWFya1Jvd1dpdGhDbGFzcyhldmVudDogYW55LCBhY3RpdmVSb3c6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgdGhpcy5jbGVhckNsYXNzZXMoYWN0aXZlUm93KTtcblxuICAgICAgICAvLyBDaGVjayBpZiBkcmFnIGl0ZW0gaXMgaW4gdGhlIG1pZGRsZSBvZiBvdGhlciByb3dcbiAgICAgICAgbGV0IGN1cnJlbnRUckNlbnRlciA9IHRoaXMuZG9tVXRpbHMuZWxlbWVudERpbWVuc2lvbnMoYWN0aXZlUm93KS5oZWlnaHQgLyAyO1xuICAgICAgICBsZXQgZHJhZ2dlZFRyQ2VudGVyID0gZXZlbnQub2Zmc2V0WSArIHRoaXMuZHQuZW52LmdldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcblxuICAgICAgICBpZiAodGhpcy5kcm9wSW50b0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NaWRkbGUgPSBNYXRoLmFicyhjdXJyZW50VHJDZW50ZXIgLSBkcmFnZ2VkVHJDZW50ZXIpIDwgMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluTWlkZGxlKSB7XG4gICAgICAgICAgICBhY3RpdmVSb3cuY2xhc3NMaXN0LmFkZChEcmFnRGlyZWN0aW9uLk1pZGRsZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZVJvdy5jbGFzc0xpc3QuYWRkKHRoaXMuZHJhZ0Rpcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERyb3AgdGFyZ2V0IG11c3QgYmUgb25seSBhbm90aGVyIFRSIGFuZCBpdCBjYW5ub3QgYmUgdGhlIGVsZW1lbnQgaXRzZWxmIHRoZSBvbmUgd2UgYXJlXG4gICAgICogZHJhZ2dpbmcgYW5kIGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gYWxsb3cgdG8gZHJvcCB0byB0aGUgc2FtZSBwb3NpdGlvbiB3ZSBzdGFydGVkIGZyb21cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNWYWxpZERyb3BUYXJnZXQoZXZlbnQ6IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBvcmlnSW54ID0gdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIGxldCBzaWJsaW5nUm93ID0gdGhpcy5kbmRSb3dJbmRleCAtIG9yaWdJbng7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdUUicgJiYgdGhpcy5kbmRSb3dJbmRleCAhPT0gb3JpZ0lueCAmJlxuICAgICAgICAgICAgIShzaWJsaW5nUm93ID09PSAxICYmIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCkgJiZcbiAgICAgICAgICAgICEoc2libGluZ1JvdyA9PT0gLTEgJiYgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLkRvd24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2xlYXJDbGFzc2VzKHRyOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy10b3AnKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctYm90dG9tJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdGgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyVG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ0Rpcikge1xuICAgICAgICAgICAgY2FzZSBEcmFnRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnVXAnO1xuICAgICAgICAgICAgY2FzZSBEcmFnRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgcmV0dXJuICdEb3duJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOb3QgU3VyZSc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0FXT3V0bGluZUZvck1vZHVsZX0gZnJvbSAnLi4vb3V0bGluZS9vdXRsaW5lLWZvci5tb2R1bGUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RFRXcmFwcGVyfSBmcm9tICcuL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0lucHV0RmllbGRNb2R1bGV9IGZyb20gJy4uL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLm1vZHVsZSc7XG5pbXBvcnQge0RUSGVhZGVyQ29tcG9uZW50Mn0gZnJvbSAnLi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7XG4gICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vc2luZ2xlLXNlbGVjdC9kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge1NldENlbGxNYXhXaWR0aERpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R0LWNlbGwtZGlyZWN0aXZlcyc7XG5pbXBvcnQge0RURHJhZ2dhYmxlUm93RGlyZWN0aXZlfSBmcm9tICcuL2RpcmVjdGl2ZXMvZHQtZHJhZ2dhYmxlLXJvdy5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgIERUV3JhcHBlcixcbiAgICAgICAgRFRDb2x1bW4yQ29tcG9uZW50LFxuICAgICAgICBEVEhlYWRlckNvbXBvbmVudDIsXG4gICAgICAgIERURGV0YWlsUm93Q29tcG9uZW50LFxuICAgICAgICBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50LFxuICAgICAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFREcmFnZ2FibGVSb3dEaXJlY3RpdmUsXG4gICAgICAgIFNldENlbGxNYXhXaWR0aERpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCxcbiAgICAgICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgRFRDb2x1bW4yQ29tcG9uZW50LFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIERUSGVhZGVyQ29tcG9uZW50MixcbiAgICAgICAgRFREZXRhaWxSb3dDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEYXRhdGFibGUyTW9kdWxlXG57XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBjb25maXJtYXRpb24gaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBDb25maXJtYXRpb25Db21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbi1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGNvbmZpcm1hdGlvbiBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIENvbmZpcm1hdGlvbkNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY29uZmlybWF0aW9uLWZvb3RlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWZvb3Rlci5jb21wb25lbnQnO1xuXG4vKipcbiAqIENvbmZpcm1hdGlvbiBDb21wb25lbnQgaXMgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIHRoZSBkaWFsb2cgd2hlcmUgaXQgc3VwcG9ydHMgY29uZmlybSBhbmQgY2FuY2VsXG4gKiBmdW5jdGlvbmFsaXR5LiBJdCBiZWhhdmVzIGxpa2UgYSBkaWFsb2csIGlzIG1vZGFsLCBhbmQgbm90IGNsb3NhYmxlIGJ5IGRlZmF1bHQuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxDb25maXJtYXRpb25Db21wb25lbnQ+KSwgc2VydmljZS5jbG9zZSgpXG4gKlxuICogVXNhZ2U6XG4gKiAgICAxLiAgVXNpbmcgTW9kYWxTZXJ2aWNlIGRpcmVjdGx5IHRvIGRpc3BsYXkgYSBtb2RhbCBwb3B1cC4gVGhpcyB1c2FnZSBpcyBhIHF1aWNrIHdheSB0byBzaG93XG4gKiAgICAgICAgYSBjb25maXJtYXRpb24gdG8gdGhlIHVzZXIuXG4gKlxuICogICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxDb25maXJtYXRpb25Db21wb25lbnQ+KENvbmZpcm1hdGlvbkNvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbmZpcm1hdGlvbicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGAgQXJlIHlvdSBzdXJlID8gYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDMwMCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb25Db25maXJtOiAoKSA9PiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbigpO1xuICogICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogKCkgPT4ge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbigpO1xuICogICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctY29uZmlybWF0aW9uIFt0aXRsZV09XCInQ29uZmlybWF0aW9uJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyh2aXNpYmxlKV09XCJkaXNwbGF5XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNvbmZpcm0pPVwiY29uZmlybUFjdGlvbigpXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ2FuY2VsKT1cImNhbmNlbEFjdGlvbigpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwic2FwLWljb24gaWNvbi1hbGVydFwiPjwvaT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB5b3VyIGhhcmQgZHJpdmU/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWNvbmZpcm1hdGlvbj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm9wZW4oKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGVuIENvbmZpcm1hdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYm9vbGVhbiA9IGZhbHNlO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uZmlybUFjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uZmlybUFjdGlvbigpICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbiA9IFwiY29uZmlybWVkXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBmYWxzZTtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uID0gXCJjYW5jZWxlZFwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgIH1cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbicsXG4gICAgdGVtcGxhdGU6IGA8YXctZGlhbG9nIFt0aXRsZV09XCJ0aXRsZVwiIFsodmlzaWJsZSldPVwidmlzaWJsZVwiXG4gICAgICAgICAgIFttb2RhbF09XCJ0cnVlXCIgW2Nsb3NhYmxlXT1cImNsb3NhYmxlXCIgW3dpZHRoXT1cIndpZHRoXCIgW2hlaWdodF09XCJoZWlnaHRcIlxuICAgICAgICAgICBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW2FwcGVuZFRvXT1cImFwcGVuZFRvXCIgKG9uT3Blbik9XCJvcGVuKClcIiAob25DbG9zZSk9XCJjbG9zZSgpXCI+XG5cbiAgICA8YXctZGlhbG9nLWhlYWRlciAqbmdJZj1cImhhc0hlYWRlcigpXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNvbmZpcm1hdGlvbi1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9hdy1kaWFsb2ctaGVhZGVyPlxuXG4gICAge3tib2R5fX1cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cblxuICAgIDxhdy1kaWFsb2ctZm9vdGVyICpuZ0lmPVwiaGFzRm9vdGVyKCk7IGVsc2UgZGVmYXVsdEZvb3RlclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jb25maXJtYXRpb24tZm9vdGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvYXctZGlhbG9nLWZvb3Rlcj5cblxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdEZvb3Rlcj5cbiAgICAgICAgPGF3LWRpYWxvZy1mb290ZXI+XG4gICAgICAgICAgICA8YXctYnV0dG9uIG5hbWU9XCJjb25maXJtXCIgW3N0eWxlXT1cIidwcmltYXJ5J1wiIChhY3Rpb24pPVwiY29uZmlybSgpXCI+XG4gICAgICAgICAgICAgICAge3tjb25maXJtQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gbmFtZT1cImNhbmNlbFwiIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiIChhY3Rpb24pPVwiY2FuY2VsKClcIj5cbiAgICAgICAgICAgICAgICB7e2NhbmNlbEFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgIDwvYXctZGlhbG9nLWZvb3Rlcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG48L2F3LWRpYWxvZz5cbmAsXG4gICAgc3R5bGVzOiBbYC5jb25maXJtYXRpb24tZm9vdGVyLXNlcGFyYXRvcntib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3O2hlaWdodDoxNHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbkNvbXBvbmVudCBleHRlbmRzIE1vZGFsQ29udGFpbmVyXG57XG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIHRoZSBEaWFsb2cuICBpZiB0aXRsZSBhbmQgJ1RpdGxlVGVtcGxhdGUnIGFyZSBib3RoIHNldCwgdGl0bGVUZW1wbGF0ZSB0YWtlc1xuICAgICAqIHByZWNlZGVuY2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQm9keSBzZWN0aW9uIGZvciBEaWFsb2cuIENhbGxlciBzaG91bGQgdXNlIGVpdGhlciB0aGUgYm9keSBzdHJpbmcsIG9yIGNvbnRlbnQgcHJvamVjdGlvblxuICAgICAqIHRvIGFkZCB2YWx1ZXMgdG8gdGhlIGRpYWxvZy4gSWYgYm90aCBhcmUgdXNlZCwgdGhleSB3aWxsIGJvdGggc2hvdyB1cC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIE9LIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29uZmlybUFjdGlvbkxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBDYW5jZWwgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjYW5jZWxBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBzdXBwb3J0IHR3byB3YXkgZGF0YSBiaW5kaW5nIG9uIHZpc2libGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZXJlJ3MgYW4geCBhdCB0aGUgdG9wIHJpZ2h0IHRoYXQgbWFrZXMgdGhlIGRpYWxvZyBjbG9zYWJsZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNsb3NhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgZWxlbWVudCB0byBhdHRhY2ggdGhlIGRpYWxvZy4gXCJib2R5XCIgb3IgbG9jYWwgbmctdGVtcGxhdGUgdmFyaWFibGUgYXJlIHZhbGlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gZGlhbG9nIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGRpYWxvZyBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdXNlciBjbGlja2VkIG9uIGNvbmZpcm0gYnV0dG9uLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ29uZmlybTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHVzZXIgY2xpY2tlZCBvbiBjYW5jZWwgYnV0dG9uLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEhlYWRlciBjb21wb25lbnQuIFVzdWFsbHkgY29udGFpbnMgdGhlIHRpdGxlLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50KSBoZWFkZXI6IENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIERpYWxvZyBmb290ZXIuIFVzdWFsbHkgY29udGFpbnMgYnV0dG9uc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50KSBmb290ZXI6IENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudDtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSA0MDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAvLyBUb2RvOiBpbnRlcm5hdGlvbmFsaXplLlxuICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb25MYWJlbCA9ICdDb25maXJtJztcbiAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb25MYWJlbCA9ICdDYW5jZWwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9wZW4gY29uZmlybWF0aW9uLlxuICAgICAqL1xuICAgIG9wZW4oKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsb3NlIGNvbmZpcm1hdGlvbi5cbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoKTtcblxuICAgICAgICAvLyBJbXBvcnRhbnQgdG8gbWFrZSBzdXJlIGNoYW5nZSBpcyBzZXQgb24gcGFyZW50IGJpbmRpbmcuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHZhcmlhYmxlIGFuZCBkaWFsb2cgb3Blbi9jbG9zZSBzdGF0ZSBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIHN5bmMgYW5kIHdlIHdvdWxkbid0IHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGNvbmZpcm1hdGlvbiBoYXZlIGhlYWRlciBjb250ZW50P1xuICAgICAqL1xuICAgIGhhc0hlYWRlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuaGVhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBjb25maXJtYXRpb24gaGF2ZSBmb290ZXIgY29udGVudD9cbiAgICAgKi9cbiAgICBoYXNGb290ZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZvb3Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlybSBhY3Rpb24uXG4gICAgICovXG4gICAgY29uZmlybSgpXG4gICAge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMub25Db25maXJtLmVtaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYWN0aW9uLlxuICAgICAqL1xuICAgIGNhbmNlbCgpXG4gICAge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMub25DYW5jZWwuZW1pdCgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7Q29uZmlybWF0aW9uQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWZvb3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXRGlhbG9nTW9kdWxlfSBmcm9tICcuLi9kaWFsb2cvZGlhbG9nLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENvbmZpcm1hdGlvbkNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXRGlhbG9nTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENvbmZpcm1hdGlvbkNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDb25maXJtYXRpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogQ29udGFpbmVyIHBhbmVsIHByb3ZpZGluZyBzY3JvbGxpbmcgZnVuY3Rpb25hbGl0eSBmb3IgaXRzIGNoaWxkcmVuLiBZb3UgY2FuIGNvbmZpZ3VyZSB0aGlzXG4gKiBjb250YWluZXIgdG8gbGV0IGl0IHRvIHNjcm9sbCBpdHMgY29udGVudCBlaXRoZXIgaG9yaXpvbnRhbGx5LCB2ZXJ0aWNhbGx5IG9yIGxldCB0aGUgY29udGVudFxuICogd3JhcC5cbiAqXG4gKlxuICogVXNhZ2UgaXMgcHJldHR5IHNpbXBsZTpcbiAqXG4gKiAgIyMjIEV4YW1wbGUgdXNpbmcgaG9yaXpvbnRhbCBzY3JvbGwgKGRlZmF1bHQgYmVoYXZpb3IpOlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LXNjcm9sbGFibGU+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICpcbiAqICBgYGBcbiAqXG4gKiAgIyMjIEV4YW1wbGUgdXNpbmcgdmVydGljYWwgc2Nyb2xsOlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LXNjcm9sbGFibGUgW2RpcmVjdGlvbl09XCIndmVydGljYWwnXCIgW2hlaWdodF09XCInNDB2aCdcIj5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKlxuICogYGBgXG4gKlxuICogICMjIyBFeGFtcGxlIHNjcm9sbGluZyBpcyBkaXNhYmxlZCBhbmQgY29udGVudCB3cmFwcyBhbmQgY2VudGVyczpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlIFtkaXJlY3Rpb25dPVwiJ25vbmUnXCIgW2FsaWdubWVudF09XCInY2VudGVyJ1wiPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqICBgYGBcbiAqXG4gKiAjIyMgSGVpZ2h0IHByb3BlcnR5OlxuICpcbiAqIFdoZW4gdXNpbmcgXCJob3Jpem9udGFsIHNjcm9sbGluZ1wiIGl0IHNldCBcImZsZXhib3gtZGlyZWN0aW9uXCIgdG8gXCJyb3dcIiB3aGVyZSBoZWlnaHRcbiAqIGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBjb250ZW50LiBUaGUgaGVpZ2h0IHNob3VsZCBiZSBhbHdheXMgMTAwJSB3aGVuIHVzaW5nXG4gKiB0aGlzIGluIHBhcmVudCBjb250YWluZXIuXG4gKlxuICogSWYgXCJ2ZXJ0aWNhbCBzY3JvbGxpbmdcIiBpcyB1c2VkIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0OlxuICogICAtIHlvdXIgcGFyZW50IGNvbnRhaW5lciBzZXRzIHRoZSBib3VuZGFyaWVzIHdpdGggY29ycmVjdGx5IHNldCB3aWR0aCBhbmQgaGVpZ2h0XG4gKiAgIG90aGVyd2lzZSBpdCB3aWxsIHVzZSAxMDAlIG9mIHRoZSB2aWV3cG9ydFxuICogICAtIGlmIHVzZWQgYXMgc3RhbmRhbG9uZSB5b3UgbmVlZCB0byBsaW1pdCB0aGUgaGVpZ2h0IG90aGVyd2lzZSBpdCB3aWxsIGV4cGFuZCB0byAxMDAlIG9mXG4gKiAgIHRoZSBkb2N1bWVudFxuICpcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zY3JvbGxhYmxlJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LXNjcm9sbGFibGVcIiBbbmdDbGFzc109XCJsYXlvdXRDbGFzc1wiIFtzdHlsZS53aWR0aF09XCJ3aWR0aFwiXG4gICAgIFtzdHlsZS5oZWlnaHRdPVwiaGVpZ2h0XCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2Audy1zY3JvbGxhYmxle2Rpc3BsYXk6ZmxleDtkaXNwbGF5Oi13ZWJraXQtZmxleDtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO3dpbGwtY2hhbmdlOm92ZXJmbG93fS53LXNjcm9sbGFibGUgL2RlZXAvPip7ZmxleDowIDAgYXV0bzstd2Via2l0LWZsZXg6MCAwIGF1dG87LW1zLWZsZXg6MCAwIGF1dG87bWFyZ2luOjEwcHh9LnUtc2Nyb2xsYWJsZS1maHtmbGV4LWZsb3c6cm93IG5vd3JhcDtvdmVyZmxvdy14OmF1dG87b3ZlcmZsb3cteTpoaWRkZW59LnUtc2Nyb2xsYWJsZS1mdntmbGV4LWZsb3c6Y29sdW1uIG5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG99LnUtc2Nyb2xsYWJsZS1mYntmbGV4LWZsb3c6cm93IG5vd3JhcDtvdmVyZmxvdy14OmF1dG87b3ZlcmZsb3cteTphdXRvfS51LXNjcm9sbGFibGUtZnYtcm93e2ZsZXgtZmxvdzpyb3cgd3JhcDtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG99LnUtc2Nyb2xsYWJsZS1mbntmbGV4LWZsb3c6cm93IHdyYXB9LnUtc2Nyb2xsYWJsZS1hbHtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0fS51LXNjcm9sbGFibGUtYXJ7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS51LXNjcm9sbGFibGUtYWN7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWp1c3RpZnktY29udGVudDpjZW50ZXJ9LnUtc2Nyb2xsYWJsZS1haiwudS1zY3JvbGxhYmxlLWFqLWFyb3VuZHtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufWBdXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmVyIG1lYW5pbmcgdGVsbHMgd2hpY2ggb3ZlcmZsb3cgYXhpZXMgd2lsbCBiZVxuICAgICAqIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFwiaG9yaXpvbnRhbFwiOiBIZXJlIHdlIGxvY2sgb3ZlcmZsb3cteSBhbmQgb3ZlcmZsb3cteCBzZXQgdG8gYXV0by5cbiAgICAgKlxuICAgICAqIFdoZW4gc2Nyb2xsaW5nIGRpcmVjdGlvbiBpcyBcInZlcnRpY2FsXCIgcGxlYXNlIG1ha2Ugc3VyZSB5b3UgbWFpbnRhaW4gY29ycmVjdCBoZWlnaHQgYW5kXG4gICAgICogd2lkdGguXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpcmVjdGlvbjogU2Nyb2xsaW5nRGlyZWN0aW9uID0gJ2hvcml6b250YWwnO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgZmxleGJveCBjb250YWluZXIgaXRlbXMgc2hvdWxkIGJlIGFsaWduZWQuIERlZmF1bHQgYmVoYXZpb3IgaXMgTEVGVFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbm1lbnQ6IENvbnRhaW5lckl0ZW1zQWxpZ25tZW50ID0gJ2xlZnQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwcm9wZXJ0aWVzIGZvciBjYWxjdWxhdGVkIGNsYXNzIGxpc3RcbiAgICAgKi9cblxuICAgIGxheW91dENsYXNzOiBzdHJpbmc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHdlIHJlLWluaXRpYWxpemUgZGVmYXVsdCB3aGVuIElucHV0IEJpbmRpbmdzIGNoYW5nZXNcbiAgICAgKlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmluaXREZWZhdWx0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGRlZmF1bHQgdmFsdWVzIGFuZCBDYWxjdWxhdGVzIGxheW91dCBhbmQgYWxpZ25tZW50IGNsYXNzLiBUaGUgcmVhc29uIGZvciB1c2luZ1xuICAgICAqIHRoZXNlIHV0aWxpdHkgY2xhc3NlcyBpcyB0aGF0IHdlIGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yIGFueXRpbWUgYXMgY29tcGFyZWQgdG8gdXNpbmdcbiAgICAgKiBkaXJlY3RseSBbc3R5bGUueHh4XSBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqICMjIyBEaXJlY3Rpb24gZmxvdyBjbGFzczpcbiAgICAgKiAgLSB1LXNjcm9sbGFibGUtZjxkaXJlY3Rpb24+XG4gICAgICpcbiAgICAgKiAjIyMgQWxpZ25tZW50IGNsYXNzOlxuICAgICAqICAtIHUtc2Nyb2xsYWJsZS1hPGFsaWdubWVudD5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdERlZmF1bHQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZmgnO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZ2JztcblxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsLXJvdycpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZ2LXJvdyc7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mYic7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mbic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheW91dENsYXNzICs9ICcgdS1zY3JvbGxhYmxlLWEnICsgdGhpcy5hbGlnbm1lbnQuc3Vic3RyaW5nKDAsIDEpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdHlsZUNsYXNzKSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyArPSBgICR7dGhpcy5zdHlsZUNsYXNzfWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHNvbWUgdmFsdWUgaW4gY2FzZSBzb21lYm9keSBwYXNzZXMgbnVsbFxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLndpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNIb3Jpem9udGFsU2Nyb2xsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBzY3JvbGxDb250YWluZXIgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1zY3JvbGxhYmxlJyk7XG4gICAgICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGggPiBzY3JvbGxDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1ZlcnRpY2FsU2Nyb2xsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBzY3JvbGxDb250YWluZXIgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1zY3JvbGxhYmxlJyk7XG4gICAgICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsQ29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB9XG59XG5cbi8qKlxuICogU2Nyb2xsaW5nRGlyZWN0aW9uIGlzIGEgbmV3IHR5cGUgdGhhdCBkcml2ZXMgc2Nyb2xsaW5nIGJlaGF2aW9yOlxuICogIC0gaG9yaXpvbnRhbCA9PiBvdmVyZmxvdy14OiBhdXRvLCBvdmVyZmxvdy15OmhpZGRlblxuICogIC0gdmVydGljYWwgPT4gb3ZlcmZsb3cteDogaGlkZGVuLCBvdmVyZmxvdy15OmF1dG9cbiAqICAtIHZlcnRpY2FsLXJvdyA9PiBvdmVyZmxvdy14OiBoaWRkZW4sIG92ZXJmbG93LXk6YXV0bzsgZmxvdzogcm93IHdyYXBcbiAqICAtIGJvdGggPT4gb3ZlcmZsb3cteDogYXV0bywgb3ZlcmZsb3cteTphdXRvXG4gKiAgLSBub25lID0+IHNldHMgZmxvdy1mbG93IHRvIHJvdyB3cmFwXG4gKi9cbmV4cG9ydCB0eXBlIFNjcm9sbGluZ0RpcmVjdGlvbiA9ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgfCAndmVydGljYWwtcm93JyB8ICdib3RoJyB8ICdub25lJztcblxuXG4vKipcbiAqXG4gKiBDb250cm9scyB0aGUganVzdGlmeS1jb250ZW50IHByb3BlcnR5OlxuICpcbiAqIC0gbGVmdCA9PiBmbGV4LXN0YXJ0XG4gKiAtIHJpZ2h0ID0+IGZsZXgtZW5kXG4gKiAtIGNlbnRlciA9PiBjZW50ZXJcbiAqIC0ganVzdGlmeSA9PiBzcGFjZS1iZXR3ZWVuXG4gKlxuICovXG5leHBvcnQgdHlwZSBDb250YWluZXJJdGVtc0FsaWdubWVudCA9ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50fSBmcm9tICcuL3Njcm9sbGFibGUtY29udGFpbmVyLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtMaXN0Ym94LCBTZWxlY3RJdGVtfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtDaGVja2JveENvbXBvbmVudH0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50JztcblxuXG5leHBvcnQgY29uc3QgTEJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqXG4gKiBUaGUgTGlzdCBjb21wb25lbnQgcmVwcmVzZW50IGEgc3RydWN0dXJlIHdoaWNoIGNvbnRhaW5zIGEgbGlzdCBvZiBzZWxlY3RhYmxlIGl0ZW1zLiBJdGVtc1xuICogc2VsZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIGluIHNpbmdsZS1zZWxlY3Rpb24sIG11bHRpLXNlbGVjdGlvbiBvciBtdWx0aS1zZWxlY3Rpb24gd2l0aCB2aXNpYmxlXG4gKiBjaGVja2JveGVzIG1vZGUuXG4gKiBJbiBhZGRpdGlvbiBpdCBjYW4gZGlzcGxheSBkYXRhIGluc2lkZSAzIHpvbmVzIExFRlQsIE1JRERMRSBhbmQgUklHSFQgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICogZWFzeSB3YXkgZm9yIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBsYXlvdXQgaXRzIG93biBjdXN0b20gY29udGVudCBvciBldmVuIGNoYW5nZSBvdXQgb2YgYm94XG4gKiBiZWhhdmlvci5cbiAqXG4gKlxuICogICMjIyBFeGFtcGxlc1xuICpcbiAqICAxLiBSZW5kZXIgc2ltcGxlIHNpbmdsZSBzZWxlY3Rpb24gbGlzdFxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICAgICA8YXctbGlzdCBbbGlzdF09XCJsaXN0XCI+PC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqICAyLiBSZW5kZXIgbGlzdCAtIG11bHRpIHNlbGVjdGlvbiB3aXRoIGN1c3RvbSBSSUdIVCBjb250ZW50IHRvIHNob3cgYSBDaGVja01hcmsgd2hlbiBpdGVtXG4gKiAgaXMgc2VsZWN0ZWRcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgPGF3LWxpc3QgI2F3bGlzdCBbbGlzdF09XCJsaXN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9XCIxNTBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIyNTBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbk1vZGVdPVwiJ211bHRpJ1wiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNyaWdodCBsZXQtaXRlbT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNhcC1pY29uXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnaWNvbi1hY2NlcHQnOiBhd2xpc3QucExpc3RCb3guaXNTZWxlY3RlZChpdGVtKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnOiAhYXdsaXN0LnBMaXN0Qm94LmlzU2VsZWN0ZWQoaXRlbSl9XCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICA8L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICpcbiAqIDMuIFJlbmRlciBsaXN0IC0gbXVsdGkgc2VsZWN0aW9uIHdpdGggdmlzaWJsZSBjaGVja2JveGVzIGFuZCBjdXN0b20gTUlERExFIGNvbnRlbnQgdG8gY2hhbmdlXG4gKiAgdGhlIHdheSBpdGVtIG5hbWUgaXMgcmVuZGVyZWRcbiAqXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICA8YXctbGlzdCBbbGlzdF09XCJsaXN0XCIgaGVpZ2h0PVwiMTgwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMjAwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0aW9uXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uTW9kZV09XCInbXVsdGlXaXRoQ2hlY2tib3gnXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI21pZGRsZSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgICAgICAgICAgIFhYLXt7aXRlbS52YWx1ZX19XG4gKiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICA8L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPHAtbGlzdGJveCAjbGlzdGJveCBbb3B0aW9uc109XCJpbnRlcm5hbExpc3RcIiBbbXVsdGlwbGVdPVwiaXNNdWx0aXBsZVwiIFtjaGVja2JveF09XCJzaG93Q2hlY2tib3hcIlxuICAgICAgICAgICBbKG5nTW9kZWwpXT1cInNlbGVjdGlvblwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiIFtzdHlsZV09XCJsaXN0U3R5bGVcIiBbc2hvd1RvZ2dsZUFsbF09XCJmYWxzZVwiXG4gICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkl0ZW1TZWxlY3RlZCgkZXZlbnQpXCIgKG9uRGJsQ2xpY2spPVwiYWN0aW9uLmVtaXQoJGV2ZW50LnZhbHVlKVwiXG4gICAgICAgICAgIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIj5cblxuXG4gICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtIHBUZW1wbGF0ZT1cIml0ZW1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInctbGktd3JhcHBlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctbGktbGVmdFwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImhhc0xlZnRUZW1wbCgpOyBlbHNlIGRlZmF1bHRMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibFpvbmVUZW1wbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpdGVtfVwiPjwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdExlZnQ+XG4gICAgICAgICAgICAgICAgICAgIDxhdy1jaGVja2JveCAjY2hlY2sgKm5nSWY9XCJpc011bHRpcGxlICYmIHNob3dDaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJsaXN0Ym94LmlzU2VsZWN0ZWQoaXRlbSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIml0ZW1DbGlja2VkKCRldmVudCwgaXRlbSwgY2hlY2spXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvYXctY2hlY2tib3g+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy1saS1taWRkbGVcIiAoY2xpY2spPVwiaXRlbUNsaWNrZWQoJGV2ZW50LCBpdGVtLCBudWxsKVwiPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGFzTWlkZGxlVGVtcGwoKTsgZWxzZSBkZWZhdWx0TWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibVpvbmVUZW1wbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpdGVtfVwiPjwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRNaWRkbGU+XG4gICAgICAgICAgICAgICAgICAgIHt7aXRlbS5sYWJlbH19XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLXJpZ2h0XCIgKm5nSWY9XCJoYXNSaWdodFRlbXBsKClcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiclpvbmVUZW1wbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpdGVtfVwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9wLWxpc3Rib3g+XG5gLFxuICAgIHN0eWxlczogW2A6Om5nLWRlZXAgLnVpLWxpc3Rib3gtaXRlbT4udWktY2hrYm94e2Rpc3BsYXk6bm9uZX06Om5nLWRlZXAgLnVpLWxpc3Rib3gtaXRlbSAudWktY2hrYm94e21hcmdpbi1yaWdodDoxZW19LnctbGktd3JhcHBlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6ZmxleC1zdGFydH0udy1saS13cmFwcGVyIC53LWxpLWxlZnQsLnctbGktd3JhcHBlciAudy1saS1yaWdodHtmbGV4OjAgMSBhdXRvfS53LWxpLXdyYXBwZXIgLnctbGktbWlkZGxle2ZsZXg6MSAxIGF1dG99YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIExCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGlzdENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBMaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb3B0aW9uIHRoYXQgd2lsbCBzaG93IGluIHRoZSBsaXN0LiBQbGVhc2Ugbm90IHRoYXQgdGhpcyBsaXN0IGlzIGN1cnJlbnQgdXNlZCB0b1xuICAgICAqIHNob3cgbGltaXRlZCBudW1iZXIgb2YgaXRlbXMuIEl0IGRvZXMgbm90IGhhdmUgYW55IHNjcm9sbGluZyBmZWF0dXJlIGFuZCBsYXp5IGxvYWRpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBJdGVtcyB3aGljaCB3YXMgc2VsZWN0ZWQgYXMgYSBkZWZhdWx0IHZhbHVlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgcmVjb2duaXplcyAzIG1vZGVzOiBzaW5nbGUsIG11bHRpLCBtdWx0aSB3aXRoIHZpc2libGUgY2hlY2tib3hlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZSA9ICdzaW5nbGUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdXNlZCB0byBmb3JtYXQgZWFjaCBzZWxlY3Rpb24gZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlVHJhbnNmb3JtZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHdoZW4gZGVhbGluZyB3aXRoIG9iamVjdCB0byBpZGVudGlmeSBzcGVjaWZpYyBmaWVsZCBvbiB0aGUgb2JqZWN0IGZvcmNvbXBhcmlzb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpZWxkOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIERvbid0IHJlbmRlciBMaXN0Ym94IGJvcmRlci4gVXNlZCBmb3IgZW1iZWRkaW5nIHRoaXMgaW5zaWRlIG90aGVyIGNvbXBvbmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9yZGVybGVzczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gd2UgZG91YmxlIGNsaWNrIG9uIHRoZSBsaXN0IEl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIHdhbnQgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvciBvciBMZWZ0IHpvbmUuIFdlIGV4cG9zZSB0aGlzIGxpc3RCb3ggaW4gb3JkZXIgdG9cbiAgICAgKiBoYXZlIGFjY2VzcyBwcmltZU5nIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbGlzdGJveCcpXG4gICAgcExpc3RCb3g6IExpc3Rib3g7XG5cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB0ZW1wbGF0ZXMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvci4gVGhlIGxpc3QgaXRlbSBpcyBkaXZpZGVkIGludG8gMyB6b25lc1xuICAgICAqXG4gICAgICpcbiAgICAgKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICB8ICAgTCAgIHwgICAgICAgICAgICAgTSAgICAgICAgICAgICAgICAgICAgIHwgICBSICAgIHxcbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbGVmdCcpXG4gICAgbFpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGQoJ21pZGRsZScpXG4gICAgbVpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGQoJ3JpZ2h0JylcbiAgICByWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKi9cbiAgICBpbnRlcm5hbExpc3Q6IFNlbGVjdEl0ZW1bXTtcblxuICAgIGxpc3RTdHlsZToge1tuYW1lOiBzdHJpbmddOiBhbnl9ID0ge307XG5cbiAgICBpc011bHRpcGxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgc2hvd0NoZWNrYm94OiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLmlzTXVsdGlwbGUgPSB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScgfHxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpV2l0aENoZWNrYm94JztcbiAgICAgICAgdGhpcy5zaG93Q2hlY2tib3ggPSB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aVdpdGhDaGVja2JveCc7XG5cbiAgICAgICAgLy8gY2Fubm90IGhhdmUgYm90aCBlaXRoZXIgd2UgdXNlIGZpZWxkIHRvIGdldCBkaXNwbGF5IHZhbHVlIG9yIHZhbHVlVHJhbnNmb3JtZXJcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZpZWxkKSAmJiBpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIGhhdmUgZWl0aGVyIFtmaWVsZF0gb3IgW3ZhbHVlVHJhbnNmb3JtZXJdLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRMaXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgW2xpc3RdIGJpbmRpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHNvIGFkZCBvdmVyZmxvd1kgdG8gbWFrZSBzdXJlIGl0IGNhbiBzY3JvbGwgYW5kIGRvZXMgbm90IGV4cGFuZCBiYXNlZCBvbiBpdHMgY29udGVudFxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ2hlaWdodCddID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnb3ZlcmZsb3cteSddID0gJ2F1dG8nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLndpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ3dpZHRoJ10gPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYm9yZGVybGVzcykge1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ2JvcmRlci1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaW5jZSB3ZSBhcmUgdXNpbmcgPGF3LWNoZWNrYm94PiB3ZSBuZWVkIHRvIGhhdmUgY3VzdG9tIGhhbmRsaW5nIGJvdGggd2hlbiBjbGlja2luZyBvbiB0aGVcbiAgICAgKiBjaGVja2JveCBhcyB3ZWxsIGFzIGl0ZW0gdGV4dC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaXRlbUNsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55LCBjaGVja2JveDogQ2hlY2tib3hDb21wb25lbnQpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoZWNrYm94KSkge1xuICAgICAgICAgICAgdGhpcy5wTGlzdEJveC5vbkNoZWNrYm94Q2xpY2soZXZlbnQsIGl0ZW0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMucExpc3RCb3gpKSB7XG4gICAgICAgICAgICB0aGlzLnBMaXN0Qm94Lm9uT3B0aW9uQ2xpY2soZXZlbnQsIGl0ZW0pO1xuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbFxuICAgICAqXG4gICAgICovXG4gICAgaGFzUmlnaHRUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuclpvbmVUZW1wbCk7XG4gICAgfVxuXG4gICAgaGFzTGVmdFRlbXBsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5sWm9uZVRlbXBsKTtcbiAgICB9XG5cblxuICAgIGhhc01pZGRsZVRlbXBsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5tWm9uZVRlbXBsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRyaWdnZXJlZCBieSBwLWxpc3Rib3ggY29tcG9uZW50IHdoZW4gaXRlbSBpcyBzZWxlY3RlZC4gV2hlbiBzdGF0ZSBpcyBtYW5hZ2VkIGludGVybmFsbHlcbiAgICAgKiB3ZSBhbHNvIHVwZGF0ZSBGb3JtQ29udHJvbCBtb2RlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSXRlbVNlbGVjdGVkKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhldmVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdChldmVudC52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZShldmVudC52YWx1ZSwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQoZXZlbnQudmFsdWUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghZXF1YWxzKHZhbHVlLCB0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZXh0ZXJuYWwgZm9ybSBvZiB0aGUgbGlzdCBpbnRvIFByaW1lTkcgZXhwZWN0ZWQgZm9ybWF0IHdoZXJlIGl0IHVzZXNcbiAgICAgKiBTZWxlY3Rpb25JdGVtIGludGVyZmFjZVxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdExpc3QoKVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IHRoaXMubGlzdC5tYXAoKGl0ZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiB0aGlzLmRpc3BsYXlWYWx1ZShpdGVtKSwgdmFsdWU6IGl0ZW19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBHZW5lcmF0ZXMgbGFiZWwgdmFsdWUgZm9yIHRoZSBsaXN0IGJveC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZGlzcGxheVZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2YWwgPSBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWVsZCkpIHtcbiAgICAgICAgICAgIHZhbCA9IGl0ZW1bdGhpcy5maWVsZF07XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgdmFsID0gdGhpcy52YWx1ZVRyYW5zZm9ybWVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3Qgc3VwcG9ydCB0aGVzZSB0aHJlZSBzZWxlY3Rpb24gbW9kZXNcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIFNlbGVjdGlvbk1vZGUgPSAnc2luZ2xlJyB8ICdtdWx0aScgfCAnbXVsdGlXaXRoQ2hlY2tib3gnO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtMaXN0Ym94TW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtMaXN0Q29tcG9uZW50fSBmcm9tICcuL2xpc3QuY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBMaXN0Ym94TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIExpc3RDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXTGlzdE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIEBhdXRob3IgYW1hbnVsLmNob3dkaHVyeVxuICogQ29weXJpZ2h0IDIwMTggU0FQIEFyaWJhXG4gKlxuICogV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnQgY2FuIGJlIHVzZWQgYXMgYSBzdGVwIHByb2dyZXNzXG4gKiBpbiBhIHBhZ2UgdGhhdCBoYXMgbXVsdGlwbGUgc3RlcHNcbiAqIGA8YXctd2l6YXJkLXByb2dyZXNzXG4gKiAgW3N0ZXBzXT1cInN0ZXBzXCJcbiAqICBbY3VycmVudFN0ZXBdPVwiY3VycmVudFN0ZXBcIlxuICogIChzdGVwQ2hhbmdlZCk9XCJvblN0ZXBDaGFuZ2VkKCRldmVudClcIj5cbiAqIDwvYXctd2l6YXJkLXByb2dyZXNzPmBcbiAqL1xuXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBTdGVwXG57XG4gICAgY29tcGxldGU6IGJvb2xlYW47XG4gICAgY3VycmVudDogYm9vbGVhbjtcbiAgICB0aXRsZT86IHN0cmluZztcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy13aXphcmQtcHJvZ3Jlc3MnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInN0ZXAtaW5kaWNhdG9yXCI+e3tjdXJyZW50U3RlcCArIDF9fS97e3RvdGFsU3RlcHN9fTwvZGl2PlxuPGRpdiBjbGFzcz1cImF3LXN0ZXAtcHJvZ3Jlc3NcIj5cbiAgICA8ZGl2IGNsYXNzPVwiYXctc3RlcC1wcm9ncmVzc19faXRlbVwiICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzOyBsZXQgaSA9IGluZGV4O1wiXG4gICAgICAgICBbbmdDbGFzc109XCJ7ICdhdy1zdGVwLXByb2dyZXNzX19pdGVtLS1pcy1hY3RpdmUnOiBzdGVwLmN1cnJlbnQgPT09IHRydWUgfVwiXG4gICAgICAgICAoY2xpY2spPVwiZ29Ub1N0ZXAoaSk7XCI+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYDpob3N0e2Rpc3BsYXk6YmxvY2t9LnN0ZXAtaW5kaWNhdG9ye3dpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NjAwO3BhZGRpbmctYm90dG9tOi4zcmVtfS5hdy1zdGVwLXByb2dyZXNze2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzouMnJlbTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5hdy1zdGVwLXByb2dyZXNzX19pdGVte2N1cnNvcjpwb2ludGVyO2xpc3Qtc3R5bGU6bm9uZTt3aWR0aDoxLjJyZW07bWFyZ2luOjAgLjJyZW07Ym9yZGVyLXJhZGl1czouM3JlbTtoZWlnaHQ6LjRyZW07YmFja2dyb3VuZC1jb2xvcjojZWFlYWVhfS5hdy1zdGVwLXByb2dyZXNzX19pdGVtOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0OjB9LmF3LXN0ZXAtcHJvZ3Jlc3NfX2l0ZW06Zmlyc3QtY2hpbGR7bWFyZ2luLWxlZnQ6MH0uYXctc3RlcC1wcm9ncmVzc19faXRlbS0taXMtYWN0aXZle2JhY2tncm91bmQtY29sb3I6IzA5YTdhZn1gXVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxue1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcHM6IEFycmF5PFN0ZXA+O1xuXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMDtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN0ZXBDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgdG90YWxTdGVwczogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5zdGVwcy5maWx0ZXIoc3RlcCA9PiBzdGVwLmN1cnJlbnQpWzBdKTtcbiAgICAgICAgICAgIHRoaXMudG90YWxTdGVwcyA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RlcCh+Y3VycmVudEluZGV4ID8gY3VycmVudEluZGV4IDogMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDdXJyZW50U3RlcChpbmRleDogbnVtYmVyID0gMClcbiAgICB7XG4gICAgICAgIHRoaXMuc3RlcHNbaW5kZXhdLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RlcENoYW5nZWQuZW1pdCh7Y3VycmVudDogdGhpcy5jdXJyZW50U3RlcH0pO1xuICAgIH1cblxuICAgIGdvVG9TdGVwKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc3RlcHNbaW5kZXhdLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuc3RlcHMuZmlsdGVyKHN0ZXAgPT4gc3RlcC5jdXJyZW50KVswXSk7XG4gICAgICAgIHRoaXMuc3RlcHNbY3VycmVudEluZGV4XS5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RlcChpbmRleCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V2l6YXJkUHJvZ3Jlc3NDb21wb25lbnR9IGZyb20gJy4vd2l6YXJkLXByb2dyZXNzLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRQcm9ncmVzc01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFJlbmRlcnMgYSBUb2dnbGUgU3dpdGNoXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnbXlUb2dnbGVTZWN0aW9uJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogJzxhdy10b2dnbGUgW21vZGVsXT1cImlucHV0VmFsdWVcIiBbbGFiZWxUZXh0XT1cImxhYmVsVGV4dFwiID5cbiAqICAgICAgICAgICAgICA8L2F3LXRvZ2dsZT4nXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBNeU5vdGVDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgaW5wdXRWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuICogICAgICAgICAgbGFiZWxUZXh0OiBzdHJpbmcgPSAnbXkgbGFiZWwnO1xuICogICAgICB9XG4gKlxuICogYGBgXG4gKi9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10b2dnbGUnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctdG9nZ2xlXCI+XG4gICAgPGxhYmVsIGNsYXNzPVwidy10b2dnbGVfX2xhYmVsXCIgKm5nSWY9XCJsYWJlbFRleHRcIj5cbiAgICAgICAge3sgbGFiZWxUZXh0IH19XG4gICAgPC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwic2xpZGVyXCIgKGNsaWNrKT1cImNoYW5nZUhhbmRsZXIoKVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2xpZGVyX19idXR0b25cIiBbbmdDbGFzc109XCJ7ICdzbGlkZXJfX2J1dHRvbi0taXMtYWN0aXZlJzogbW9kZWwgPT09IHRydWUgfVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2A6aG9zdHtkaXNwbGF5OmJsb2NrfS53LXRvZ2dsZSBpbnB1dHtkaXNwbGF5Om5vbmV9LnctdG9nZ2xlX19sYWJlbHtjb2xvcjojOTk5O21hcmdpbi1yaWdodDouMnJlbX0udy10b2dnbGUgLnNsaWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6LjZyZW07d2lkdGg6MS41cmVtO2JhY2tncm91bmQtY29sb3I6I2Q4ZDhkODtib3JkZXItcmFkaXVzOi45cmVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JvcmRlci10b3A6MXB4IHNvbGlkICM3ZTdlN2U7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNiNWI1YjU7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjYjViNWI1fS53LXRvZ2dsZSAuc2xpZGVyX19idXR0b257bGVmdDotLjFyZW07dHJhbnNpdGlvbjpsZWZ0IC4xcyBlYXNlLW91dDtjdXJzb3I6cG9pbnRlcjtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MXJlbTt3aWR0aDoxcmVtO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2VhZWFlYTt0b3A6LS4ycmVtfS53LXRvZ2dsZSAuc2xpZGVyX19idXR0b24tLWlzLWFjdGl2ZXtsZWZ0OmNhbGMoMTAwJSAtIC44cmVtKTtiYWNrZ3JvdW5kLWNvbG9yOiMwOWE3YWZ9YF1cbn0pXG5cbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIG1vZGVsXG4gICAgICovXG4gICAgQElucHV0KCkgbW9kZWw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBsYWJlbCB0ZXh0XG4gICAgICovXG4gICAgQElucHV0KCkgbGFiZWxUZXh0OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xpY2sgaGFuZGxlciBmb3IgdG9nZ2xlXG4gICAgICovXG4gICAgY2hhbmdlSGFuZGxlcigpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGVsID0gIXRoaXMubW9kZWw7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1RvZ2dsZVN3aXRjaENvbXBvbmVudH0gZnJvbSAnLi90b2dnbGUtc3dpdGNoLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBUb2dnbGVTd2l0Y2hDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgVG9nZ2xlU3dpdGNoQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFRvZ2dsZVN3aXRjaENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtPdmVybGF5UGFuZWx9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBPdmVybGF5IENvbXBvbmVudCBpcyBhIHNpbXBsZSB2ZXJzaW9uIG9mIHRoZSBkaWFsb2cgd2hlcmUgdGhlcmUncyBvbmx5IGNvbnRlbnQuXG4gKiBPdmVybGF5IHdpbGwgYXBwZWFyIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYWN0aW9uIHBlcmZvcm1lZCB0cmlnZ2VyIGFuIG92ZXJsYXkuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxPdmVybGF5Q29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoZSB1c2FnZSBpcyBhIGxpdHRsZSB0cmlja3lcbiAqICAgICAgICBiZWNhdXNlIGFuZ3VsYXIgY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCBkeW5hbWljIGNvbnRlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiAgICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48T3ZlcmxheUNvbXBvbmVudD4oT3ZlcmxheUNvbXBvbmVudCwge30pO1xuICpcbiAqICAgICAgICAgICAgLy8gQWRkIGNvbnRlbnQuIFRoZXJlJ3Mgbm90IHN1cHBvcnQgZm9yIGR5bmFtaWMgY29udGVudCBwcm9qZWN0aW9uIHlldC5cbiAqICAgICAgICAgICAgLy8gU28gaGF2ZSBhZGQgY29udGVudCBkaXJlY3RseS5cbiAqICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3Qgd2F5LlxuICogICAgICAgICAgb3ZlcmxheS5pbnN0YW5jZS5vdmVybGF5LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi51aS1vdmVybGF5cGFuZWwtY29udGVudFwiKVxuICogICAgICAgICAgICAgICAuaW5uZXJIVE1MID0gYDxpbWcgc3R5bGU9J3dpZHRoOjMwMHB4Oycgc3JjPVwic2FsZXMucG5nXCIgYWx0PVwiU2FsZXMgQ2hhcnRcIiAvPmA7XG4gKlxuICogICAgICAgICAgLy8gZGVsYXkgdGhlIG9wZW5pbmcgYWZ0ZXIgbmcgbGlmZWN5Y2xlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IG92ZXJsYXkuaW5zdGFuY2Uub3BlbihldmVudCk7IH0sIDEpO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctb3ZlcmxheSAjb3ZlcmxheSAob25PcGVuKT1cIm92ZXJsYXlBY3Rpb249J29wZW4nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25DbG9zZSk9XCJvdmVybGF5QWN0aW9uPSdjbG9zZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cInNhbGVzLnBuZ1wiIGFsdD1cIkNoYXJ0XCIvPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctb3ZlcmxheT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm92ZXJsYXkub3BlbigkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wZW4gT3ZlcmxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUFjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb3ZlcmxheScsXG4gICAgdGVtcGxhdGU6IGA8cC1vdmVybGF5UGFuZWwgW2Rpc21pc3NhYmxlXT1cImRpc21pc3NhYmxlXCIgW3Nob3dDbG9zZUljb25dPVwic2hvd0Nsb3NlSWNvblwiXG4gICAgICAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFthcHBlbmRUb109XCJhcHBlbmRUb1wiXG4gICAgICAgICAgICAgICAgKG9uQWZ0ZXJIaWRlKT1cIm9uQ2xvc2VkKCRldmVudClcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L3Atb3ZlcmxheVBhbmVsPlxuYCxcbiAgICBzdHlsZXM6IFtgOjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWx7Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3O2JveC1zaGFkb3c6MCAycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY29udGVudHtwYWRkaW5nOjJlbSAzLjRlbSAuNmVtIDEuNDNlbX06Om5nLWRlZXAgLnVpLW92ZXJsYXlwYW5lbC1jbG9zZXtib3JkZXItcmFkaXVzOjA7dG9wOi41ZW07cmlnaHQ6LjVlbX06Om5nLWRlZXAgLnVpLW92ZXJsYXlwYW5lbC1jbG9zZS51aS1zdGF0ZS1kZWZhdWx0e2JvcmRlcjpub25lfWBdXG59KVxuZXhwb3J0IGNsYXNzIE92ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lciBpbXBsZW1lbnRzIE9uSW5pdFxue1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgaGlkZSBvdmVybGF5IHdoZW4gb3V0c2lkZSBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzbWlzc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGNsb3NlIGljb24gJ3gnIGF0IHRvcCBvZiByaWdodCBjb3JuZXIuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Q2xvc2VJY29uOiBib29sZWFuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBvdmVybGF5LiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBvdmVybGF5IGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgb3ZlcmxheSBwYW5lbC5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKE92ZXJsYXlQYW5lbClcbiAgICBvdmVybGF5OiBPdmVybGF5UGFuZWw7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIE92ZXJsYXlcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvcGVuKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkuc2hvdyhldmVudCk7XG4gICAgICAgIHRoaXMub25PcGVuZWQobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgT3ZlcmxheVxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5oaWRlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgb3BlbiBhbmQgY2xvc2UuXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgdG9nZ2xlKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkudG9nZ2xlKGV2ZW50KTtcbiAgICB9XG5cblxuICAgIG9uT3BlbmVkKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBvbkNsb3NlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoZXZlbnQpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogRGVmaW5lcyB3aGVyZSB0aGUgQ2FyZCBpcyBwb3NpdGlvbmVkLiBJdCBjYW4gYmUgZWl0aGVyOlxuICogICAgLSBhYm92ZSB0aGUgdHJpZ2dlcmluZyBsaW5rXG4gKiAgICAtIHVuZGVyIHRoZSB0cmlnZ2VyaW5nIGxpbmtcbiAqICAgIC0gY29tcGxldGVseSBvbiB0b3Agb2YgaXQgLSBjb3ZlcmluZyBpdC4gRm9yIHRoaXMgY2FzZSB0aGVyZSBpcyBub25lIGFzIG5vIHN0eWxlIGlzIGFwcGxpZWRcbiAqL1xuZXhwb3J0IGVudW0gSENDYXJkUG9zaXRpb24ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbm9uZVxufVxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZCBieSBkZWZhdWx0LiBNZWFuaW5nIHdoZXJlIHByaW1lTkcgY29kZSBwdXQgaXQuXG4gKlxuICogV2hlbiB0aGVyZSBpcyBhbGxvdCBvZiBzcGFjZSBvbiB0aGUgc2lkZXMgPj0gIChMZWZ0IG9yIFJpZ2h0KSBpcyB1c2VkXG4gKiAocGFkZGVkTGVmdCwgcGFkZGVkUmlnaHQpIG90aGVyd2lzZS4gV2hlbiB0aGVyZSBpcyBub3QgbXVjaCBzcGFjZSBhbmQgY2FyZCBjb250YWluZXJcbiAqICBpcyBub3QgYWxpZ25lZCAobGVmdCwgcmlnaHQpIHdpdGggdGhlIHRyaWdlcmluZyBpY29uIGJ1dCBpdCBpcyBzaGlmdGVkIHRvIGZpdCBpbnRvIHRoZSBzY3JlZW5cbiAqL1xuZW51bSBIQ0NhcmRBbGlnbm1lbnQge1xuICAgIGxlZnQsXG4gICAgcGFkZGVkTGVmdCxcbiAgICByaWdodCxcbiAgICBwYWRkZWRSaWdodCxcbiAgICBkZWZhdWx0XG59XG5cbi8qKlxuICogTWFwcyBwb3NpdGlvbiB0byBzdHlsZXMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgQ2FyZCBjb250YWluZXIuIFRoaXMgaXMganVzdCB0byBtYWtlIGl0IGVhc2llclxuICogYXMgd2UgYXJlIHdvcmtpbmcgd2l0aCBlbnVtZXJhdGlvbnMgYW5kIGhhdmUgYWxyZWFkeSBlbnVtIHR5cGUuXG4gKlxuICogdS1oYy1hcnJvdy1iOiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgYm90dG9tXG4gKiB1LWhjLWFycm93LXQ6IEFycm93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqXG4gKiB1LWhjLXNoYWRvdy10OiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqIHUtaGMtc2hhZG93LWI6IEJvcmRlciBzaGFkb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICovXG5jb25zdCBQb3NpdGlvblRvU3R5bGUgPSB7XG4gICAgdG9wOiAnIHctaGMtcGFuZWwtYXJyb3cgdS1oYy1hcnJvdy1iIHUtaGMtc2hhZG93LXQnLFxuICAgIGJvdHRvbTogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctdCB1LWhjLXNoYWRvdy1iJyxcbiAgICBub25lOiAnJ1xufTtcblxuXG4vKipcbiAqXG4gKiBNYXBzIGFsaWduZWQgQ2FyZCBjb250YWluZXIgdG8gY3VzdG9tIHN0eWxlcyBpbiBvcmRlciB0byBhcHBseSBjb3JyZWN0IGFycm93XG4gKlxuICogLWxsOiBTdGFuZHMgZm9yIExhcmdlIExlZnQgKGxhcmdlOiB0aGVyZSBpcyBwbGVudHkgb2Ygc3BhY2UgYXJvdW5kIClcbiAqIC1scjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICogLXNsOiBTdGFuZHMgZm9yIFNtYWxsIGxlZnQgKFNtYWxsIGFuZCByZXNpemVkIHNjcmVlbiB3aGVyZSB3ZSB0cnkgdG8gZml0IGNhcmQgY29udGFpbmVyXG4gKiBzb21ld2hlcmUgaW4gYmV0d2VlbilcbiAqIC1zcjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICpcbiAqL1xuY29uc3QgQWxpZ25tZW50VG9TdHlsZSA9IHtcbiAgICBsZWZ0OiAnIHUtaGMtYXJyb3ctbGwnLFxuICAgIHJpZ2h0OiAnIHUtaGMtYXJyb3ctbHInLFxuICAgIHBhZGRlZExlZnQ6ICcgdS1oYy1hcnJvdy1zbCcsXG4gICAgcGFkZGVkUmlnaHQ6ICcgdS1oYy1hcnJvdy1zcicsXG4gICAgZGVmYXVsdDogJyB1LWhjLWFycm93LWxsJyxcbn07XG5cbi8qKlxuICogVGhlIEhvdmVyQ2FyZCBjb21wb25lbnRzIGFkZHMgaG92ZXIgYmVoYXZpb3IgdG8gdGV4dCwgdGhlIHNwZWNpZmllZCBjb250ZW50IGlzIGxvYWRlZFxuICogb24gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUb2RvOiBleHRlbmRzIHNvIHdlIGNhbiB3cmFwIGFueSBlbGVtZW50IGFuZCBhbnkgZWxlbWVudCBjYW4gYmUgdHJpZ2dlcmluZyB0aGlzLiBOb3Qgb25seVxuICogbGlua1RpdGxlXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICpcbiAqICAgPGF3LWhvdmVyLWNhcmQgW2xpbmtUaXRsZV09XCInRnJhbmsga29sYXInXCI+XG4gKiAgICAgICA8aDM+TXkgQ2FyZCBUaXRsZTwvaDM+XG4gKiAgICAgICA8ZGl2PlxuICpcbiAqICAgICAgICAgICBUaGlzIGlzIG15IGNvbnRlbnRzXG4gKlxuICogICAgICAgPC9kaXY+XG4gKlxuICpcbiAqICAgIDwvYXctaG92ZXItY2FyZD5cbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlcmUgaXMgW2ZvcmNlQ2xvc2VdPXRydWUgd2hpY2ggZm9yY2VzIHRoZSB1c2VyIHRvIHVzZSBYIGNsb3NlIGljb25cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ob3Zlci1jYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidy1oY1wiPlxuICAgIDxzcGFuIGNsYXNzPVwidy1oYy10aXRsZVwiPlxuICAgICAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJsaW5rVGl0bGVcIj48L2F3LXN0cmluZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzYXAtaWNvbiBpY29uLXNsaW0tYXJyb3ctZG93blwiIChtb3VzZW92ZXIpPVwib3BlbkNhcmQoJGV2ZW50KVwiPjwvc3Bhbj5cbiAgICA8L3NwYW4+XG5cbiAgICA8ZGl2IGNsYXNzPVwidy1oYy1ib2R5XCI+XG5cbiAgICAgICAgIDxhdy1vdmVybGF5ICNvdmVybGF5IFtzaG93Q2xvc2VJY29uXT1cImZvcmNlQ2xvc2VcIiBbZGlzbWlzc2FibGVdPVwiIWZvcmNlQ2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgICBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIlxuICAgICAgICAgICAgICAgICAgICAgKG9uT3Blbik9XCJjYXJkT3BlbmVkKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+XG5cbiAgICAgICAgPCEtLSB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuXG4gICAgICAgIHJlZmVyIHRvIHRoaXMgbmctY29udGVudC4gQW5ndWxhciBkb2VzIG5vdCBoYXZlIGFueSB3YXkgcmlnaHQgbm93IHRvIHRyYWNrIHRoaXNcbiAgICAgICAgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3NwYW4+XG5cbiAgICA8L2F3LW92ZXJsYXk+XG5cbiAgICA8L2Rpdj5cbjwvc3Bhbj5cblxuXG48IS0tPG5nLXRlbXBsYXRlICNjb250ZW50VG9Cb2R5Pi0tPlxuICAgIDwhLS08YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVthcHBlbmRUb109XCJhcHBlbmRUb1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+LS0+XG5cbiAgICAgICAgPCEtLSZsdDshJm5kYXNoOyB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuLS0+XG4gICAgICAgIDwhLS1yZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzLS0+XG4gICAgICAgIDwhLS0mbmRhc2g7Jmd0Oy0tPlxuICAgICAgICA8IS0tPHNwYW4gY2xhc3M9XCJ1LW5nY29udGVudFwiPi0tPlxuICAgICAgICAgICAgICAgIDwhLS08bmctY29udGVudD48L25nLWNvbnRlbnQ+LS0+XG4gICAgICAgICAgICA8IS0tPC9zcGFuPi0tPlxuXG4gICAgPCEtLTwvYXctb3ZlcmxheT4tLT5cblxuPCEtLTwvbmctdGVtcGxhdGU+LS0+XG5cblxuPCEtLTxuZy10ZW1wbGF0ZSAjY29udGVudFRvT3ZlcmxheT4tLT5cblxuICAgIDwhLS08YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+LS0+XG5cbiAgICAgICAgPCEtLSZsdDshJm5kYXNoOyB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuLS0+XG4gICAgICAgIDwhLS1yZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzLS0+XG4gICAgICAgIDwhLS0mbmRhc2g7Jmd0Oy0tPlxuICAgICAgICA8IS0tPHNwYW4gY2xhc3M9XCJ1LW5nY29udGVudFwiPi0tPlxuICAgICAgICAgICAgICAgIDwhLS08bmctY29udGVudD48L25nLWNvbnRlbnQ+LS0+XG4gICAgICAgICAgICA8IS0tPC9zcGFuPi0tPlxuXG4gICAgPCEtLTwvYXctb3ZlcmxheT4tLT5cbjwhLS08L25nLXRlbXBsYXRlPi0tPlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWhjLXRpdGxle3BhZGRpbmctcmlnaHQ6MS40ZW07cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwfS53LWhjLXRpdGxlIC5zYXAtaWNvbntmb250LXNpemU6MWVtO2NvbG9yOiMwMDY3OWU7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZy10b3A6LjJlbTtyaWdodDowfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdy51LWhjLXNoYWRvdy1ie2JveC1zaGFkb3c6MCAycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93LnUtaGMtc2hhZG93LXR7Ym94LXNoYWRvdzowIC0ycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93OmFmdGVyLDo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzpiZWZvcmV7bGVmdDoyNSU7Ym9yZGVyOnNvbGlkIHRyYW5zcGFyZW50O2NvbnRlbnQ6XCIgXCI7aGVpZ2h0OjA7d2lkdGg6MDtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzphZnRlcntib3JkZXItY29sb3I6cmdiYSgxMzYsMTgzLDIxMywwKTtib3JkZXItd2lkdGg6LjdlbTttYXJnaW4tbGVmdDotLjdlbX06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YmVmb3Jle2JvcmRlci1jb2xvcjpyZ2JhKDI1NSwxMzYsNTYsMCk7Ym9yZGVyLXdpZHRoOi44ZW07bWFyZ2luLWxlZnQ6LS44ZW19OjpuZy1kZWVwIC51LWhjLWFycm93LWxsOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1sbDpiZWZvcmV7bGVmdDoyNSV9OjpuZy1kZWVwIC51LWhjLWFycm93LWxyOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1scjpiZWZvcmV7bGVmdDo3NSV9OjpuZy1kZWVwIC51LWhjLWFycm93LXNsOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1zbDpiZWZvcmV7bGVmdDoxMCV9OjpuZy1kZWVwIC51LWhjLWFycm93LXNyOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1zcjpiZWZvcmV7bGVmdDo5MCV9OjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YWZ0ZXIsOjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YmVmb3Jle2JvdHRvbToxMDAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy10OmFmdGVye2JvcmRlci1ib3R0b20tY29sb3I6I2ZmZn06Om5nLWRlZXAgLnUtaGMtYXJyb3ctdDpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZDdkN2Q3fTo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmJlZm9yZXt0b3A6MTAwJX06Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjphZnRlcntib3JkZXItdG9wLWNvbG9yOiNmZmZ9OjpuZy1kZWVwIC51LWhjLWFycm93LWI6YmVmb3Jle2JvcmRlci10b3AtY29sb3I6I2Q3ZDdkN31gXVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckNhcmRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCB7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBhZGRpbmcgcmVwcmVzZW50aW5nIGEgaGVpZ2h0IG9mIHRoZSBBcnJvdyBmb3Igd2hpY2ggd2UgbmVlZCB0byB2ZXJ0aWNhbGx5IGFkanVzdFxuICAgICAqIENhcmQgY29udGFpbmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFycm93UGFkID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHNhZmUgdGhyZXNob2xkIHdoZXJlIHRoZXJlIG1pZ2h0IG5vdCBiZSBlbm91Z2ggc3BhY2UgYXJvdW5kIG9yIENhcmQgaXMgYWxpZ25lZCB3aXRoXG4gICAgICogdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQgZm9yIHdoaWNoIHdlIG5lZWQgdG8gcG9zaXRpb24gdGhlIEFycm93IGNsb3NlciB0byB0aGVcbiAgICAgKiBzaWRlIG9mIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNwYWNpbmdMaW1pdCA9IDUwO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGxpbmtUaXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHdlIGtlZXAgdGhlIGhvdmVyIGNhcmQgb3BlbiBhbmQgZm9yY2UgdXNlciB0byBtYW51YWxseSBjbG9zZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JjZUNsb3NlOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGN1cnJlbnQgd29ya2Fyb3VuZCB1bnRpbCB3ZSBmaW5kIGJldHRlciBzb2x1dGlvbi4gUHJpbWVORyBvdmVybGF5cyBvcGVyYXRlcyB3aXRoaW5cbiAgICAgKiBpdHMgcmVsYXRpdmUgZWxlbWVudCBzbyBpZiB0aGUgb3ZlcmxheSBpcyB3cmFwcGVkIGluc2lkZSBzb21lIG90aGVyIHJlbGF0aXZlIGNvbnRhaW5lclxuICAgICAqIHRoZSBvdmVybGF5IGNvbnRlbnQgaXMgY3JvcGVkIGJ5IGl0cyBwYXJlbnQgYW5kIGNvbnRlbnQgaXMgbm90IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBUaGV5IGhhdmUgW2FwcGVuZFRvXSBiaW5kaW5nIHdoaWNoIHdlIG5lZWQgdG8gdXNlIGZvciB0aGlzIHB1cnBvc2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kQ29udGVudFRvQm9keTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gT3ZlcmxheUNvbXBvbmVudCB0byBjYW4gYWNjZXNzIFByaW1lTkcgY29tcG9uZW50IGFzIHdlbGxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JylcbiAgICBhd092ZXJsYXk6IE92ZXJsYXlDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJuYWwgc3R5bGUgY2xhc3MgdG8gdXNlIHRvIGFwcGx5IGFkZGl0aW9uYWwgc3R5bGVzIHdoZW4gaXQgbmVlZHMgdG8gc2hvdyBhIEFycm93IG9uIHRoZVxuICAgICAqIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIGFycm93Q2xhc3M6IHN0cmluZyA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwcm9wZXJ0aWVzIHRvIHJlZmVyZW5jZXMgdGVtcGxhdGUgZWxlbWVudHMgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHRpdGxlQXJlYVJlY3Q6IGFueTtcbiAgICB0cmlnUmVjdDogYW55O1xuICAgIHRyaWdJY29uTWlkZGxlOiBhbnk7XG5cbiAgICBvcGVuaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBhcHBlbmRUbzogJ2JvZHknO1xuXG4gICAgY3VycnJlbnRQb3NpdGlvbjogSENDYXJkUG9zaXRpb24gPSBIQ0NhcmRQb3NpdGlvbi5ub25lO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbTogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMubGlua1RpdGxlKSwgJ1lvdSBtdXN0IHByb3ZpZGUgW2xpbmtUaXRsZV0gYmluZGluZyAhJyk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIG9wZW4gSEMgd2hlbiB3ZSBzdGFydCBuZXcgY29tcG9uZW50XG4gICAgICAgIHRoaXMuZW52LmRlbGV0ZVZhbHVlKCdoYy1vcGVuJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFwcGVuZENvbnRlbnRUb0JvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBcyBvZiBBbmd1bGFyIDUgd2UgaGF2ZSB0byBpbnRyb2R1Y2UgdGhpcyBWaWV3Q2hlY2tlZCBhcyBQcmltZU5HIGRvZXMgZmluYWwgY2FsY3VsYXRpb25cbiAgICAgKiBkdXJpbmcgdGhpcyBwaGFzZS5cbiAgICAgKlxuICAgICAqIFNvIG5vdyBpdHMgYnJva2VuIGRvd24gaW50byB0d28gcGFydHM6XG4gICAgICogICAtIEFwcGx5IGNsYXNzIHN0eWxlc1xuICAgICAqICAgLSBQb3NpdGlvbiBpdC5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm9wZW5pbmcpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgbGV0IGNudFJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJycmVudFBvc2l0aW9uICE9PSBIQ0NhcmRQb3NpdGlvbi5ub25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RDYXJkKGNvbnRhaW5lciwgY250UmVjdCwgdGhpcy5hd092ZXJsYXkub3ZlcmxheSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvd0NsYXNzID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3BlbmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0IGVsZW1lbnRzIEJvdW5kaW5nQ2xpZW50UmVjdCB0aGF0IHdlIHVzZSBmb3IgY2FsY3VsYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRFbGVtZW50cygpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRpdGxlRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LWhjLXRpdGxlJyk7XG4gICAgICAgIGxldCB0cmlnZ2VyRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zYXAtaWNvbicpO1xuICAgICAgICB0aGlzLnRpdGxlQXJlYVJlY3QgPSB0aXRsZUVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ1JlY3QgPSB0cmlnZ2VyRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy50cmlnSWNvbk1pZGRsZSA9IHRoaXMudHJpZ1JlY3Qud2lkdGggLyAyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyB3aGVuIHVzZXIgbW91c2Ugb3ZlciB0aGUgdHJpZ2dlcmluZyBpY29uIGFuZCBvcGVucyB1cCBvdmVybGF5IGNvbXBvbmVudC4gVG8gbWFrZSBzdXJlXG4gICAgICogb25seSBvbmUgQ2FyZCBpcyBvcGVuZWQgYXQgdGhlIHRpbWUgaXQgdXNlcyBFbnZpcm9ubWVudCB0byBzYXZlIGV4dHJhIGluZm9ybWF0aW9uIGZvciBpdFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuQ2FyZChldmVudDogYW55KTogYW55IHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF3T3ZlcmxheSkgJiYgIXRoaXMuZW52Lmhhc1ZhbHVlKCdoYy1vcGVuJykpIHtcbiAgICAgICAgICAgIHRoaXMuYXdPdmVybGF5Lm9wZW4oZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmVudi5zZXRWYWx1ZSgnaGMtb3BlbicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIG9wZW5pbmcgY3ljbGUgd2hlbiBhbGwgaXMgaW5pdGlhbGl6ZWQgYW5kIHRoZSBjYXJkIGlzIGFib3V0IHRvXG4gICAgICogZmFkZSBpbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGZpcnN0IHNpbXVsYXRlcyBkaXNwbGF5aW5nIGNhcmQgYnkgc2V0dGluZyBkaXNwbGF5OmJsb2NrIGFuZFxuICAgICAqIGRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbiBzbyB3ZSBjYW4gcmVhZCBkaW1lbnNpb25zIGFuZCB0aGVuIGxhdGVyIG9uIHBvc2l0aW9uIHRoZSBjYXJkXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKi9cbiAgICBjYXJkT3BlbmVkKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkuY29udGFpbmVyO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS50YXJnZXQ7XG4gICAgICAgIHRoaXMub3BlbkZvckFkanVzdG1lbnRzKGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gcHJlLXJ1biBwb3NpdGlvbmluZyBzbyB3ZSBjYW4gY2FsY3VsYXRlIG5ldyBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmN1cnJyZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9yQ2FyZChjb250YWluZXIsIGNudFJlY3QpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZUNsYXNzKGNvbnRhaW5lciwgY250UmVjdCwgdGhpcy5hd092ZXJsYXkub3ZlcmxheSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMub3BlbmluZyA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gY2FyZCBpcyBjbG9zZWQgd2UgbmVlZCB0byByZWxlYXNlIGl0IGFuZCBkZWxldGUgYWxsIHRoZSByZWZlcmVuY2VzIGZyb20gRW52aXJvbm1lbnRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgY2FyZENsb3NlZChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW52LmRlbGV0ZVZhbHVlKCdoYy1vcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIHN0eWxlLlRPUCBhbmQgc3R5bGUuTEVGVCB0byB0aGUgY29udGFpbmVyIGluIG9yZGVyIHRvIHJlcG9zaXRpb24gaXQgYW5kIGFkZFxuICAgICAqIGV4dHJhIGFycm93LlxuICAgICAqXG4gICAgICogRmlyc3QgYmFzZWQgb24gdGhlIGluaXRpYWwgcG9zaXRpb24gd2UgYXBwbHkgc3R5bGUuVE9QIGFuZCBkZXBlbmRpbmcgaWYgaXRzIG9uIHRoZVxuICAgICAqIHRvcCBvciBib3R0b20gd2UgYXBwbHkgZWl0aGVyIC1Ib3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgb3IgK0hvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZC5cbiAgICAgKlxuICAgICAqIFRoZW4gZm9yIHBvc2l0aW9uaW5nIGhvcml6b250YWxseSB3ZSB1c2UgdHdvIHR5cGVzLlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgYWxsb3Qgb2Ygc3BhY2UgdGhlIGFycm93IGlzIDI1JSBmcm9tIHRoZSBlZGdlXG4gICAgICpcbiAgICAgKiAgICAtLS0tLV4tLS0tLS0tLS0tLS0gICBvciAgICAgICAtLS0tLS0tLS0tLV4tLS0tXG4gICAgICpcbiAgICAgKlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgbGVzcyBvciBub25lIHNwYWNlIHdlIGhhdmUgb25seSAxMCUgZmFyIGF3YXkgZm9ybSB0aGUgZWRnZVxuICAgICAqXG4gICAgICogICAgLS1eLS0tLS0tLS0tLS0tICAgb3IgICAgICAgLS0tLS0tLS0tLS1eLS1cbiAgICAgKlxuICAgICAqICBPbmNlIHdlIHBpY2sgdGhlIGNvcnJlY3QgcG9zaXRpb25pbmcgKDI1JSwgMTAlKSB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGFuZCBzaGlmdCB0aGUgY2FyZFxuICAgICAqICBlaXRoZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGp1c3RDYXJkKGNvbnRhaW5lcjogYW55LCBjb250YWluZXJSZWN0OiBhbnksIG1vZGFsQ29udGFpbmVyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGRpZmYgPSAodGhpcy5jdXJycmVudFBvc2l0aW9uID09PSBIQ0NhcmRQb3NpdGlvbi5ib3R0b20pID8gMSA6IC0xO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gbW9kYWxDb250YWluZXIuZG9tSGFuZGxlci5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgbGV0IHBvc1dpdGhTY3JvbGwgPSBjb250YWluZXJSZWN0LnRvcCArIHNjcm9sbFRvcDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IChwb3NXaXRoU2Nyb2xsICsgKEhvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZCAqIGRpZmYpKSArICdweCc7XG5cbiAgICAgICAgbGV0IGFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50Rm9yQ2FyZChjb250YWluZXJSZWN0LCBtb2RhbENvbnRhaW5lcik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gdGhpcy5jYWxjTGVmdEZvckFsaWdubWVudChjb250YWluZXJSZWN0LCBhbGlnbm1lbnQpICsgJ3B4JztcbiAgICB9XG5cblxuICAgIGFwcGx5U3R5bGVDbGFzcyhjb250YWluZXI6IGFueSwgY29udGFpbmVyUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50Rm9yQ2FyZChjb250YWluZXJSZWN0LCBtb2RhbENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICg8YW55PlBvc2l0aW9uVG9TdHlsZSlbKDxhbnk+SENDYXJkUG9zaXRpb24pW3RoaXMuY3VycnJlbnRQb3NpdGlvbl1dO1xuICAgICAgICAgICAgdGhpcy5hcnJvd0NsYXNzICs9ICg8YW55PkFsaWdubWVudFRvU3R5bGUpWyg8YW55PkhDQ2FyZEFsaWdubWVudClbYWxpZ25tZW50XV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXRlY3RzIGlmIHRoZSBjYXJkIGlzIGdvaW5nIHRvIGJlIHNob3duIG9uIHRoZSB0b3Agb2YgdGhlIExpbmsgbGFiZWwgb3IgdW5kZXIuIE9yIGlmXG4gICAgICogaXRzIGNvdmVyaW5nIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9zaXRpb25Gb3JDYXJkKGNvbnRhaW5lcjogYW55LCBib3VuZGluZ1JlY3Q6IGFueSk6IEhDQ2FyZFBvc2l0aW9uIHtcbiAgICAgICAgLy8gc2VjdXJlIHRoaXMgaW4gY2FzZSBvZiBJRSByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgICAgIGxldCBib3JkZXJXaWR0aCA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5ib3JkZXJXaWR0aDtcbiAgICAgICAgbGV0IGNudFdpZHRoID0gcGFyc2VGbG9hdChib3JkZXJXaWR0aCB8fCAnMCcpO1xuICAgICAgICBsZXQgcG9zID0gSENDYXJkUG9zaXRpb24ubm9uZTtcblxuICAgICAgICBpZiAodGhpcy50cmlnUmVjdC5ib3R0b20gPCBib3VuZGluZ1JlY3QudG9wKSB7XG4gICAgICAgICAgICBwb3MgPSBIQ0NhcmRQb3NpdGlvbi5ib3R0b207XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC50b3AgPiAoYm91bmRpbmdSZWN0LmJvdHRvbSAtIGNudFdpZHRoKSkge1xuICAgICAgICAgICAgcG9zID0gSENDYXJkUG9zaXRpb24udG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0IGhvcml6b250YWwgYWxpZ25tZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBhbGlnbm1lbnRGb3JDYXJkKGJvdW5kaW5nUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogSENDYXJkQWxpZ25tZW50IHtcbiAgICAgICAgbGV0IGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5sZWZ0O1xuICAgICAgICBsZXQgdmlld1BvcnQgPSBtb2RhbENvbnRhaW5lci5kb21IYW5kbGVyLmdldFZpZXdwb3J0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ1JlY3QubGVmdC50b0ZpeGVkKDApID09PSBib3VuZGluZ1JlY3QubGVmdC50b0ZpeGVkKDApICYmXG4gICAgICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5sZWZ0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRpbmdSZWN0LmxlZnQgPCBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkTGVmdDtcblxuICAgICAgICB9IGVsc2UgaWYgKCh2aWV3UG9ydC53aWR0aCAtIGJvdW5kaW5nUmVjdC5yaWdodCkgPCBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkUmlnaHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyaWdSZWN0LnJpZ2h0LnRvRml4ZWQoMCkgPT09IGJvdW5kaW5nUmVjdC5yaWdodC50b0ZpeGVkKDApIHx8XG4gICAgICAgICAgICAodmlld1BvcnQud2lkdGggLSBib3VuZGluZ1JlY3QucmlnaHQpID4gSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnJpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxpZ25tZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHVybiBvbiB0ZW1wb3JhcnkgZGlzcGxheSB0byBCTE9DSyBzbyB3ZSBjYW4gcmVhZCBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuRm9yQWRqdXN0bWVudHMoY29udGFpbmVyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnRzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb2ZmIGRpc3BsYXkgYmFjayBOT05FXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAvLyBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsY3VsYXRlcyBwb3NpdGlvbmluZyBmb3Igc3R5bGUuTEVGVC4gQXMgYWxyZWFkeSBzYWlkIHRoZXkgYXJlIHR3byB0eXBlcyBvZiB0cmlhbmdsZXMgdGhhdFxuICAgICAqIGFyZSBhcHBsaWVzIGZvciB0aGVzZSBjYXNlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBhKSBMYXJnZSBsZWZ0LCBMYXJnZSByaWdodFxuICAgICAqXG4gICAgICogIFByaW1lTkcgYWxpZ25zIHRoZSBjYXJkIHdpdGggZWl0aGVyIHRoZSByaWdodCBzaWRlIG9yIGxlZnQgc2lkZSBvZiB0aGUgdHJpZ2dlcmluZyBpY29uXG4gICAgICpcbiAgICAgKlxuICAgICAqICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbiAgICAgKiAgLi4uLi4uXi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvciAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5eLi4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgYikgU21hbGwgbGVmdCAsIHNtYWxsIHJpZ2h0XG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhbmQgUHJpbWVORyBwb3NpdGlvbiB0aGUgY2FyZCBvZmYgdG8gdGhlXG4gICAgICogIHRyaWdnZXJpbmcgaWNvbnMsIHNvIGV2ZW4gcHJpbWVOZyBkb2VzIG5vdCBoYXZlIHNwYWNlIHRvIGFsaWduIGl0IHdpdGggdGhlIFZcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogIC4uLi5eLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9yICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLl4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqIGMpQWxpZ25lZCB3aXRoIHRoZSBlZGdlIG9mIGJyb3dzZXJcbiAgICAgKlxuICAgICAqIE9uIHRoZSByaWdodCBzaWRlIHRoaXMgaXMgcHJvYmxlbSBhcyB3ZSBjYW5ub3QgY2FsY3VsYXRlIGZ1bGwgZnV0dXJlIHdpZHRoIG9mIHRoZSBjYXJkLlxuICAgICAqIGJ1dCB3ZSBhcHBsbHkgZm9yIHRoaXMgY2FzZSAjYiAoYXJyb3cgMTAlIClcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGNMZWZ0Rm9yQWxpZ25tZW50KGJvdW5kaW5nUmVjdDogYW55LCBhbGlnbm1lbnQ6IEhDQ2FyZEFsaWdubWVudCk6IG51bWJlciB7XG4gICAgICAgIC8vIHdpZHRoIGZvciB3aGljaCB3ZSBuZWVkIHRvIHNoaWZ0IGNhcmQuIDI1JSBvciAxMCUgb2YgdGhlIGNvbnRhaW5lciB3aWR0aFxuICAgICAgICBsZXQgd0xhcmdlVHJpYW5nbGUgPSBib3VuZGluZ1JlY3Qud2lkdGggKiAwLjI1O1xuICAgICAgICBsZXQgd1NtYWxsVHJpYW5nbGUgPSBib3VuZGluZ1JlY3Qud2lkdGggKiAwLjEwO1xuXG4gICAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5yaWdodDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRSaWdodCA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgd0xhcmdlVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgbGV0IHRyaWdSaWdodCA9IHRoaXMudHJpZ1JlY3QucmlnaHQgLSB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdFJpZ2h0IC0gKGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyaWdSaWdodCk7XG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnBhZGRlZFJpZ2h0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdFJpZ2h0UyA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgd1NtYWxsVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgbGV0IHRyaWdSaWdodFMgPSB0aGlzLnRyaWdSZWN0LnJpZ2h0IC0gdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRSaWdodFMgLSAoYm91bmRpbmdSZWN0LnJpZ2h0IC0gdHJpZ1JpZ2h0Uyk7XG5cblxuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkTGVmdDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRMZWZ0UGFkID0gYm91bmRpbmdSZWN0LmxlZnQgLSB3U21hbGxUcmlhbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRMZWZ0UGFkICsgdGhpcy50cmlnSWNvbk1pZGRsZTtcblxuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQubGVmdDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0TGVmdCA9IGJvdW5kaW5nUmVjdC5sZWZ0IC0gd0xhcmdlVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0TGVmdCArIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRG9DaGVjayxcbiAgICBFbGVtZW50UmVmLFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFNpbXBsZUNoYW5nZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50LCBwcmludH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTcHkgbGlmZWN5Y2xlIGRpcmVjdGl2ZSBpcyB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgdG8gdHJhY2sgbGlmZWN5Y2xlIGNhbGxiYWNrXG4gKlxuICogIyMjVXNhZ2VcbiAqXG4gKiBgYGBcbiAqICAgPG15LWRpcmVjdGl2ZSBzcHlob29rcz48bXktZGlyZWN0aXZlPlxuICpcbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tzcHlIb29rc10nfSlcbmV4cG9ydCBjbGFzcyBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0LCBEb0NoZWNrLCBPbkNoYW5nZXMsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZFxue1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ29uSW5pdCcpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ29uRGVzdHJveScpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczoge1sgcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZX0pXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ09uQ2hhbmdlcyA9ICcgKyBjaGFuZ2VzKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdEb0NoZWNrJyk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJDb250ZW50SW5pdCcpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpXG4gICAge1xuXG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJDb250ZW50Q2hlY2tlZCcpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyVmlld0luaXQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlclZpZXdDaGVja2VkJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2dJdChtc2c6IHN0cmluZylcbiAgICB7XG4gICAgICAgIGxldCBsZXZlbCA9IDA7XG4gICAgICAgIGxldCBtZSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBsZXQgdGFnQm9keSA9IG1lO1xuXG4gICAgICAgIHdoaWxlICgodGFnQm9keSA9IHRhZ0JvZHkucGFyZW50Tm9kZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIGlmICh0YWdCb2R5LnRhZ05hbWUgPT09ICdBUFAtUk9PVCcgfHwgbGV2ZWwgPT09IDYpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZW50ID0gJyc7XG4gICAgICAgIGxldCBpbmRlbnROdW1iZXIgPSBsZXZlbDtcbiAgICAgICAgd2hpbGUgKGxldmVsID4gMCkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICdcXHQnO1xuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHBhcmFtcyA9ICcnO1xuICAgICAgICBpZiAoaXNQcmVzZW50KG1lLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYXR0cjogQXR0ciA9IG1lLmF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZ25vcmUoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgcGFyYW1zICs9ICcoJyArIGF0dHIubmFtZSArICc9JyArIGF0dHIudmFsdWUgKyAnKSwgICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnQoaW5kZW50ICsgbWUudGFnTmFtZSArICcoJyArIGluZGVudE51bWJlciArICcpOiAnICsgbXNnICsgJyA9PiAnICsgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlnbm9yZShuYW1lOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gbmFtZS5pbmRleE9mKCdfbmcnKSA+IC0xIHx8XG4gICAgICAgICAgICBuYW1lLmluZGV4T2YoJ25nLScpID4gLTEgfHxcbiAgICAgICAgICAgIG5hbWUuaW5kZXhPZignc3B5aG9va3MnKSA+IC0xO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7T3ZlcmxheUNvbXBvbmVudH0gZnJvbSAnLi9vdmVybGF5LmNvbXBvbmVudCc7XG5pbXBvcnQge092ZXJsYXlQYW5lbE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPdmVybGF5Q29tcG9uZW50LFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdPdmVybGF5TW9kdWxlXG57XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0hvdmVyQ2FyZENvbXBvbmVudH0gZnJvbSAnLi9ob3Zlci1jYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXT3ZlcmxheU1vZHVsZX0gZnJvbSAnLi4vb3ZlcmxheS9vdmVybGF5Lm1vZHVsZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBIb3ZlckNhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBIb3ZlckNhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSG92ZXJDYXJkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FQUF9JTklUSUFMSVpFUiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgQnV0dG9uTW9kdWxlLFxuICAgIENhbGVuZGFyTW9kdWxlLFxuICAgIENoZWNrYm94LFxuICAgIENoZWNrYm94TW9kdWxlLFxuICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICBEaWFsb2csXG4gICAgRGlhbG9nTW9kdWxlLFxuICAgIERyb3Bkb3duTW9kdWxlLFxuICAgIEVkaXRvck1vZHVsZSxcbiAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICBNZW51TW9kdWxlLFxuICAgIE92ZXJsYXlQYW5lbE1vZHVsZSxcbiAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgUGFuZWxNb2R1bGUsXG4gICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgU2hhcmVkTW9kdWxlLFxuICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgVG9vbGJhck1vZHVsZSxcbiAgICBUcmVlTW9kdWxlXG59IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FyaWJhQ29yZU1vZHVsZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1NweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlfSBmcm9tICcuL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7RW1iZWRkZWRJdGVtRGlyZWN0aXZlfSBmcm9tICcuL2NvcmUvZW1iZWRkZWQtaXRlbSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50cyBmcm9tICcuL2VudHJ5LWNvbXBvbmVudHMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0FXQmFzaWNOYXZpZ2F0b3JNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9iYXNpYy1uYXZpZ2F0b3IvYmFzaWMtbmF2aWdhdG9yLm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hlY2tCb3hMaXN0TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hlY2stYm94LWxpc3QvY2hlY2stYm94LWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Nob29zZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlJztcbmltcG9ydCB7QVdDb25maXJtYXRpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jb25maXJtYXRpb24vY29uZmlybWF0aW9uLm1vZHVsZSc7XG5pbXBvcnQge0FXQ3VycmVuY3lNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jdXJyZW5jeS9jdXJyZW5jeS5tb2R1bGUnO1xuaW1wb3J0IHtBV0RhdGVBbmRUaW1lTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRhLWFuZC10aW1lLm1vZHVsZSc7XG5pbXBvcnQge0FXRGlhbG9nTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZGlhbG9nL2RpYWxvZy5tb2R1bGUnO1xuaW1wb3J0IHtBV0Ryb3Bkb3duTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7QVdHZW5lcmljQ2hvb3Nlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2dlbmVyaWMtY2hvb3Nlci9nZW5lcmljLWNob29zZXIubW9kdWxlJztcbmltcG9ydCB7QVdIeXBlcmxpbmtNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLm1vZHVsZSc7XG5pbXBvcnQge0FXSW5wdXRGaWVsZE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLm1vZHVsZSc7XG5pbXBvcnQge0FXT3V0bGluZUZvck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL291dGxpbmUvb3V0bGluZS1mb3IubW9kdWxlJztcbmltcG9ydCB7QVdPdmVybGF5TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZSc7XG5pbXBvcnQge0FXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLm1vZHVsZSc7XG5pbXBvcnQge0FXUGFnZVdyYXBwZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS13cmFwcGVyLm1vZHVsZSc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25MaXN0TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdSaWNoVGV4dEFyZWFNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9yaWNoLXRleHQtYXJlYS9yaWNoLXRleHQtYXJlYS5tb2R1bGUnO1xuaW1wb3J0IHtBV0hvdmVyQ2FyZE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUnO1xuaW1wb3J0IHtcbiAgICBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGVcbn0gZnJvbSAnLi93aWRnZXRzL3Njcm9sbGFibGUtY29udGFpbmVyL3Njcm9sbGFibGUtY29udGFpbmVyLm1vZHVsZSc7XG5pbXBvcnQge0FXU2VjdGlvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0ZXBwZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zdGVwcGVyL3N0ZXBwZXIubW9kdWxlJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QVdUZXh0QXJlYU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEubW9kdWxlJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge0FXRm9ybVRhYmxlTW9kdWxlfSBmcm9tICcuL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZSc7XG5pbXBvcnQge0FXTGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2xpc3QvbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0NhcmRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jYXJkL2NhcmQubW9kdWxlJztcbmltcG9ydCB7QVdEYXRhdGFibGUyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZSc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC5zZXJ2aWNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQge0F3TmFtZVN0b3JlfSBmcm9tICcuL2NvcmUvYXctbmFtZS9hdy1uYW1lLnN0b3JlJztcbmltcG9ydCB7RGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7V2l6YXJkUHJvZ3Jlc3NNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy93aXphcmQtcHJvZ3Jlc3Mvd2l6YXJkLXByb2dyZXNzLm1vZHVsZSc7XG5pbXBvcnQge1RvZ2dsZVN3aXRjaE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3RvZ2dsZS1zd2l0Y2gvdG9nZ2xlLXN3aXRjaC5tb2R1bGUnO1xuXG4vKipcbiAqIENvbXBvbmVudCBtb2R1bGUgaXMgY29yZSBtb2R1bGUgZm9yIHRoZSBjb21tb24gbGF5b3V0cyBhbmQgd2lkZ2V0cyBsaWJyYXJpZXMuXG4gKlxuICogdG9kbzogVGhlcmUgYXJlIHNvbWUgdGhpbmdzIHRoYXQgSSBzdGlsbCBuZWVkIHRvIHJlc29sdmUgLSBwbGVhc2Ugc2VlIGFuZCBub3RpY2VzIEBEdXBsaWNhdGVzXG4gKiBqc2RvYyBJIHdhbnQgdG8ga2VlcCB0aGlzIHRoZXJlIHRvIHJlbWluZCBtZSB0aGF0IEkgbmVlZCB0byByZWZhY3RvciB0aGlzIGFzIG9mIG5vdyB0aGVyZSBhcmVcbiAqIG5vdCBtdWNoIG9wdGlvbiB3aXRoIGFuZ3VsYXIuXG4gKlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQXJpYmFDb3JlTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdCYXNpY05hdmlnYXRvck1vZHVsZSxcbiAgICAgICAgQVdDYXJkTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TGlzdE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZSxcbiAgICAgICAgQVdDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0NvbmZpcm1hdGlvbk1vZHVsZSxcbiAgICAgICAgQVdDdXJyZW5jeU1vZHVsZSxcbiAgICAgICAgQVdEYXRlQW5kVGltZU1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXR2VuZXJpY0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0lucHV0RmllbGRNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXUGFnZVdyYXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlLFxuICAgICAgICBBV1JpY2hUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlLFxuICAgICAgICBBV1NlY3Rpb25Nb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdGb3JtVGFibGVNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0hvdmVyQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdMaXN0TW9kdWxlLFxuICAgICAgICBBV0RhdGF0YWJsZTJNb2R1bGUsXG4gICAgICAgIFdpemFyZFByb2dyZXNzTW9kdWxlLFxuICAgICAgICBUb2dnbGVTd2l0Y2hNb2R1bGUsXG5cbiAgICAgICAgLy8gUHJpbWVORyByZW1vdmUgd2hlbiBhbGwgQVcgYXJlIGltcG9ydGVkXG4gICAgICAgIFBhbmVsTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlLFxuICAgICAgICBSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgU2hhcmVkTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIE1lbnVNb2R1bGUsXG4gICAgICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgICAgIFBhZ2luYXRvck1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlLFxuICAgICAgICBUcmVlTW9kdWxlXG5cbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSxcbiAgICAgICAgLy8gM3RoIHBhcnR5IGRlY2xhcmF0aW9uXG4gICAgXSxcbiAgICBib290c3RyYXA6IFtdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuXG4gICAgICAgIC8vIFByaW1lTkdcbiAgICAgICAgQ2hlY2tib3gsXG4gICAgICAgIERpYWxvZ1xuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdCYXNpY05hdmlnYXRvck1vZHVsZSxcbiAgICAgICAgQVdDYXJkTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TGlzdE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZSxcbiAgICAgICAgQVdDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0NvbmZpcm1hdGlvbk1vZHVsZSxcbiAgICAgICAgQVdDdXJyZW5jeU1vZHVsZSxcbiAgICAgICAgQVdEYXRlQW5kVGltZU1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXR2VuZXJpY0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0lucHV0RmllbGRNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXUGFnZVdyYXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlLFxuICAgICAgICBBV1JpY2hUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlLFxuICAgICAgICBBV1NlY3Rpb25Nb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdGb3JtVGFibGVNb2R1bGUsXG4gICAgICAgIEVtYmVkZGVkSXRlbURpcmVjdGl2ZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSG92ZXJDYXJkTW9kdWxlLFxuICAgICAgICBBV0xpc3RNb2R1bGUsXG4gICAgICAgIEFXRGF0YXRhYmxlMk1vZHVsZSxcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NNb2R1bGUsXG4gICAgICAgIFRvZ2dsZVN3aXRjaE1vZHVsZSxcblxuICAgICAgICAvLyBQcmltZU5HXG4gICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgUGFuZWxNb2R1bGUsXG4gICAgICAgIEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgVG9vbGJhck1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIE1lbnVNb2R1bGUsXG4gICAgICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgRGF0YVRhYmxlTW9kdWxlLFxuICAgICAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQXJpYmFDb21wb25lbnRzTW9kdWxlXG57XG5cblxuICAgIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnNcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQXJpYmFDb21wb25lbnRzTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTW9kYWxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIEVycm9yTWFuYWdlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBEYXRhUHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIERhdGFGaW5kZXJzLFxuICAgICAgICAgICAgICAgIEF3TmFtZVN0b3JlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiByZWdpc3RlckNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IFtDb21wb25lbnRSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMoY29tcFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSk6IEZ1bmN0aW9uXG57XG4gICAgcmV0dXJuIGNvbXBSZWdpc3RyeS5pbml0aWFsaXplLmJpbmQoY29tcFJlZ2lzdHJ5LCBjb21wb25lbnRzKTtcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QVBQX0lOSVRJQUxJWkVSLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50cyBmcm9tICcuL2VudHJ5LWNvbXBvbmVudHMnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwuc2VydmljZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Vycm9yTWFuYWdlclNlcnZpY2V9IGZyb20gJy4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHtBd05hbWVTdG9yZX0gZnJvbSAnLi9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZSc7XG5pbXBvcnQge0RhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5cblxuLyoqXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgdXNlZCBtYWlubHkgZm9yIHRlc3RzIGFzIGltcG9ydGluZyBhIG1vZHVsZSB3aXRoIGFsbCB0aGUgY29tcG9uZW50cyBhbmQgeW91XG4gKiB1c2Ugb25seSAxIG9yIHR3byBoYXMgYSBiaWcgaW1wYWN0IG9uIHRoZSBwZXJmb3JtYW5jZSBleGVjdXRpb24uIGUuZy4gZnJvbSBleGVjdXRpbmcgY291cGxlXG4gKiB0ZXN0cyB1bmRlciAxIHNlYyBjYW4gZ28gdXAgdG8gMTBzZWMgaWYgeW91IGltcG9ydCBhbGwgdGhlIHRoaW5ncyB0aGF0IHlvdSBhcmUgbm90IHVzaW5nLlxuICpcbiAqIEkgaGF2ZW50IG5vdGljZWQgYW55dGhpbmcgc2ltaWxhciBpbiBhcHBsaWNhdGlvbiBpdHMgb25seSBqYXNtaW5lL2thcm1hIHRoYXQgbmVlZHMgdG8gaW5pdFxuICogY29tcG9uZW50cyBmb3IgZXZlcnkgdGVzdC5cbiAqXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW11cbn0pXG5leHBvcnQgY2xhc3MgQXJpYmFDb21wb25lbnRzVGVzdFByb3ZpZGVyTW9kdWxlIHtcblxuXG4gICAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQXJpYmFDb21wb25lbnRzVGVzdFByb3ZpZGVyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTW9kYWxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIEVycm9yTWFuYWdlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBEYXRhUHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIERhdGFGaW5kZXJzLFxuICAgICAgICAgICAgICAgIEF3TmFtZVN0b3JlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiByZWdpc3RlckNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IFtDb21wb25lbnRSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMoY29tcFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm4gY29tcFJlZ2lzdHJ5LmluaXRpYWxpemUuYmluZChjb21wUmVnaXN0cnksIGNvbXBvbmVudHMpO1xufVxuXG5cbiJdLCJuYW1lcyI6WyJpc1ByZXNlbnQiLCJEaXJlY3RpdmUiLCJWaWV3Q29udGFpbmVyUmVmIiwiSW5wdXQiLCJpc0JsYW5rIiwiTWFwV3JhcHBlciIsIkNvbXBvbmVudCIsIlJlbmRlcmVyMiIsIkVsZW1lbnRSZWYiLCJBcHBDb25maWciLCJ0c2xpYl8xLl9fZXh0ZW5kcyIsIm5vb3AiLCJGb3JtR3JvdXAiLCJ1dWlkIiwiRm9ybUNvbnRyb2wiLCJFbnZpcm9ubWVudCIsIkluamVjdCIsIlNraXBTZWxmIiwiT3B0aW9uYWwiLCJmb3J3YXJkUmVmIiwiRG9tU2FuaXRpemVyIiwiaXNTdHJpbmdNYXAiLCJJbmplY3RhYmxlIiwiYXNzZXJ0IiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiQ2hhbmdlRGV0ZWN0b3JSZWYiLCJTdHJpbmdXcmFwcGVyIiwiVmlld0NoaWxkIiwiUGlwZSIsIkN1cnJlbmN5UGlwZSIsIkV2ZW50RW1pdHRlciIsIk91dHB1dCIsIk5nWm9uZSIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIiwiaXNUeXBlIiwib2JqZWN0VG9OYW1lIiwiQmVoYXZpb3JTdWJqZWN0Iiwib2JzZXJ2YWJsZU9mIiwiRmllbGRQYXRoIiwiaXNBcnJheSIsImlzU3RyaW5nIiwidW5pbXBsZW1lbnRlZCIsImlzRnVuY3Rpb24iLCJpc0pzT2JqZWN0Iiwib2JqZWN0VmFsdWVzIiwiSW5qZWN0aW9uVG9rZW4iLCJIb3N0QmluZGluZyIsIlZhbGlkYXRvcnMiLCJMaXN0V3JhcHBlciIsIkNvbnRlbnRDaGlsZCIsIkNvbnRlbnRDaGlsZHJlbiIsIkZvcm1zTW9kdWxlIiwiUmVhY3RpdmVGb3Jtc01vZHVsZSIsIklucHV0VGV4dE1vZHVsZSIsIk5HX1ZBTFVFX0FDQ0VTU09SIiwiRGVjaW1hbFBpcGUiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIkJ1dHRvbk1vZHVsZSIsIlRvb2xiYXJNb2R1bGUiLCJpc0Jvb2xlYW4iLCJDaGVja2JveE1vZHVsZSIsImVxdWFscyIsIkF1dG9Db21wbGV0ZU1vZHVsZSIsIkRyb3Bkb3duTW9kdWxlIiwiaXNEYXRlIiwiQ2FsZW5kYXJNb2R1bGUiLCJEaWFsb2dNb2R1bGUiLCJSYWRpb0J1dHRvbk1vZHVsZSIsImlzRW50aXR5IiwidHJpZ2dlciIsInN0YXRlIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwiYW5pbWF0ZSIsIkFuaW1hdGlvbkJ1aWxkZXIiLCJJbnB1dFRleHRhcmVhTW9kdWxlIiwiU3ViamVjdCIsIlJvdXRpbmdTZXJ2aWNlIiwiUm91dGVyTW9kdWxlIiwiRWRpdG9yTW9kdWxlIiwiQWNjb3JkaW9uTW9kdWxlIiwiQXJpYmFDb3JlTW9kdWxlIiwiU2hhcmVkTW9kdWxlIiwiQm9vbGVhbldyYXBwZXIiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIkRvbUhhbmRsZXIiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiT2JqZWN0VXRpbHMiLCJDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSIsIkluamVjdG9yIiwiZGVib3VuY2VUaW1lIiwic3dpdGNoTWFwIiwib2YiLCJpc1BsYXRmb3JtQnJvd3NlciIsIlBMQVRGT1JNX0lEIiwiTGlzdGJveE1vZHVsZSIsIk92ZXJsYXlQYW5lbCIsInByaW50IiwiT3ZlcmxheVBhbmVsTW9kdWxlIiwiQVBQX0lOSVRJQUxJWkVSIiwiUGFuZWxNb2R1bGUiLCJNZW51TW9kdWxlIiwiVGFiTWVudU1vZHVsZSIsIkRhdGFUYWJsZU1vZHVsZSIsIlBhZ2luYXRvck1vZHVsZSIsIlRyZWVNb2R1bGUiLCJDaGVja2JveCIsIkRpYWxvZyIsInJlZ2lzdGVyQ29tcG9uZW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWtGSSwrQkFBb0IsY0FBZ0M7WUFBaEMsbUJBQWMsR0FBZCxjQUFjLENBQWtCO1NBRW5EO1FBWkQsc0JBQ0ksdUNBQUk7Ozs7Z0JBRFIsVUFDUyxJQUFTO2dCQUVkLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO2FBQzlCOzs7V0FBQTs7Ozs7Ozs7O1FBYUQsMkNBQVc7Ozs7O1lBQVgsVUFBWSxPQUFzQjtnQkFFOUIsSUFBSUEsZ0JBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2lCQUMxRTtnQkFFRCxJQUFJQSxnQkFBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFDOUIscUJBQUksT0FBTyxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDbkQsSUFBSSxDQUFDLFFB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